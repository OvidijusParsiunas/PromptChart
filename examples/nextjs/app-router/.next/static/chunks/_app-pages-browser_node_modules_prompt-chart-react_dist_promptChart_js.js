"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_prompt-chart-react_dist_promptChart_js"],{

/***/ "(app-pages-browser)/./node_modules/@lit/react/development/create-component.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lit/react/development/create-component.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createComponent: function() { return /* binding */ createComponent; }\n/* harmony export */ });\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst NODE_MODE = false;\nconst DEV_MODE = true;\nconst reservedReactProperties = new Set([\n    'children',\n    'localName',\n    'ref',\n    'style',\n    'className',\n]);\nconst listenedEvents = new WeakMap();\n/**\n * Adds an event listener for the specified event to the given node. In the\n * React setup, there should only ever be one event listener. Thus, for\n * efficiency only one listener is added and the handler for that listener is\n * updated to point to the given listener function.\n */\nconst addOrUpdateEventListener = (node, event, listener) => {\n    let events = listenedEvents.get(node);\n    if (events === undefined) {\n        listenedEvents.set(node, (events = new Map()));\n    }\n    let handler = events.get(event);\n    if (listener !== undefined) {\n        // If necessary, add listener and track handler\n        if (handler === undefined) {\n            events.set(event, (handler = { handleEvent: listener }));\n            node.addEventListener(event, handler);\n            // Otherwise just update the listener with new value\n        }\n        else {\n            handler.handleEvent = listener;\n        }\n        // Remove listener if one exists and value is undefined\n    }\n    else if (handler !== undefined) {\n        events.delete(event);\n        node.removeEventListener(event, handler);\n    }\n};\n/**\n * Sets properties and events on custom elements. These properties and events\n * have been pre-filtered so we know they should apply to the custom element.\n */\nconst setProperty = (node, name, value, old, events) => {\n    const event = events?.[name];\n    // Dirty check event value.\n    if (event !== undefined) {\n        if (value !== old) {\n            addOrUpdateEventListener(node, event, value);\n        }\n        return;\n    }\n    // But don't dirty check properties; elements are assumed to do this.\n    node[name] = value;\n    // This block is to replicate React's behavior for attributes of native\n    // elements where `undefined` or `null` values result in attributes being\n    // removed.\n    // https://github.com/facebook/react/blob/899cb95f52cc83ab5ca1eb1e268c909d3f0961e7/packages/react-dom-bindings/src/client/DOMPropertyOperations.js#L107-L141\n    //\n    // It's only needed here for native HTMLElement properties that reflect\n    // attributes of the same name but don't have that behavior like \"id\" or\n    // \"draggable\".\n    if ((value === undefined || value === null) &&\n        name in HTMLElement.prototype) {\n        node.removeAttribute(name);\n    }\n};\n/**\n * Creates a React component for a custom element. Properties are distinguished\n * from attributes automatically, and events can be configured so they are added\n * to the custom element as event listeners.\n *\n * @param options An options bag containing the parameters needed to generate a\n * wrapped web component.\n *\n * @param options.react The React module, typically imported from the `react`\n * npm package.\n * @param options.tagName The custom element tag name registered via\n * `customElements.define`.\n * @param options.elementClass The custom element class registered via\n * `customElements.define`.\n * @param options.events An object listing events to which the component can\n * listen. The object keys are the event property names passed in via React\n * props and the object values are the names of the corresponding events\n * generated by the custom element. For example, given `{onactivate:\n * 'activate'}` an event function may be passed via the component's `onactivate`\n * prop and will be called when the custom element fires its `activate` event.\n * @param options.displayName A React component display name, used in debugging\n * messages. Default value is inferred from the name of custom element class\n * registered via `customElements.define`.\n */\nconst createComponent = ({ react: React, tagName, elementClass, events, displayName, }) => {\n    const eventProps = new Set(Object.keys(events ?? {}));\n    if (DEV_MODE && !NODE_MODE) {\n        for (const p of reservedReactProperties) {\n            if (p in elementClass.prototype && !(p in HTMLElement.prototype)) {\n                // Note, this effectively warns only for `ref` since the other\n                // reserved props are on HTMLElement.prototype. To address this\n                // would require crawling down the prototype, which doesn't feel worth\n                // it since implementing these properties on an element is extremely\n                // rare.\n                console.warn(`${tagName} contains property ${p} which is a React reserved ` +\n                    `property. It will be used by React and not set on the element.`);\n            }\n        }\n    }\n    const ReactComponent = React.forwardRef((props, ref) => {\n        const prevElemPropsRef = React.useRef(new Map());\n        const elementRef = React.useRef(null);\n        // Props to be passed to React.createElement\n        const reactProps = {};\n        // Props to be set on element with setProperty\n        const elementProps = {};\n        for (const [k, v] of Object.entries(props)) {\n            if (reservedReactProperties.has(k)) {\n                // React does *not* handle `className` for custom elements so\n                // coerce it to `class` so it's handled correctly.\n                reactProps[k === 'className' ? 'class' : k] = v;\n                continue;\n            }\n            if (eventProps.has(k) || k in elementClass.prototype) {\n                elementProps[k] = v;\n                continue;\n            }\n            reactProps[k] = v;\n        }\n        // useLayoutEffect produces warnings during server rendering.\n        if (!NODE_MODE) {\n            // This one has no dependency array so it'll run on every re-render.\n            React.useLayoutEffect(() => {\n                if (elementRef.current === null) {\n                    return;\n                }\n                const newElemProps = new Map();\n                for (const key in elementProps) {\n                    setProperty(elementRef.current, key, props[key], prevElemPropsRef.current.get(key), events);\n                    prevElemPropsRef.current.delete(key);\n                    newElemProps.set(key, props[key]);\n                }\n                // \"Unset\" any props from previous render that no longer exist.\n                // Setting to `undefined` seems like the correct thing to \"unset\"\n                // but currently React will set it as `null`.\n                // See https://github.com/facebook/react/issues/28203\n                for (const [key, value] of prevElemPropsRef.current) {\n                    setProperty(elementRef.current, key, undefined, value, events);\n                }\n                prevElemPropsRef.current = newElemProps;\n            });\n            // Empty dependency array so this will only run once after first render.\n            React.useLayoutEffect(() => {\n                elementRef.current?.removeAttribute('defer-hydration');\n            }, []);\n        }\n        if (NODE_MODE) {\n            // If component is to be server rendered with `@lit/ssr-react`, pass\n            // element properties in a special bag to be set by the server-side\n            // element renderer.\n            if ((React.createElement.name === 'litPatchedCreateElement' ||\n                globalThis.litSsrReactEnabled) &&\n                Object.keys(elementProps).length) {\n                // This property needs to remain unminified.\n                reactProps['_$litProps$'] = elementProps;\n            }\n        }\n        else {\n            // Suppress hydration warning for server-rendered attributes.\n            // This property needs to remain unminified.\n            reactProps['suppressHydrationWarning'] = true;\n        }\n        return React.createElement(tagName, {\n            ...reactProps,\n            ref: React.useCallback((node) => {\n                elementRef.current = node;\n                if (typeof ref === 'function') {\n                    ref(node);\n                }\n                else if (ref !== null) {\n                    ref.current = node;\n                }\n            }, [ref]),\n        });\n    });\n    ReactComponent.displayName = displayName ?? elementClass.name;\n    return ReactComponent;\n};\n//# sourceMappingURL=create-component.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl0L3JlYWN0L2RldmVsb3BtZW50L2NyZWF0ZS1jb21wb25lbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1QkFBdUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQiwyREFBMkQ7QUFDN0YsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUyxvQkFBb0IsR0FBRztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGl0L3JlYWN0L2RldmVsb3BtZW50L2NyZWF0ZS1jb21wb25lbnQuanM/NTJiMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cbmNvbnN0IE5PREVfTU9ERSA9IGZhbHNlO1xuY29uc3QgREVWX01PREUgPSB0cnVlO1xuY29uc3QgcmVzZXJ2ZWRSZWFjdFByb3BlcnRpZXMgPSBuZXcgU2V0KFtcbiAgICAnY2hpbGRyZW4nLFxuICAgICdsb2NhbE5hbWUnLFxuICAgICdyZWYnLFxuICAgICdzdHlsZScsXG4gICAgJ2NsYXNzTmFtZScsXG5dKTtcbmNvbnN0IGxpc3RlbmVkRXZlbnRzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudCB0byB0aGUgZ2l2ZW4gbm9kZS4gSW4gdGhlXG4gKiBSZWFjdCBzZXR1cCwgdGhlcmUgc2hvdWxkIG9ubHkgZXZlciBiZSBvbmUgZXZlbnQgbGlzdGVuZXIuIFRodXMsIGZvclxuICogZWZmaWNpZW5jeSBvbmx5IG9uZSBsaXN0ZW5lciBpcyBhZGRlZCBhbmQgdGhlIGhhbmRsZXIgZm9yIHRoYXQgbGlzdGVuZXIgaXNcbiAqIHVwZGF0ZWQgdG8gcG9pbnQgdG8gdGhlIGdpdmVuIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICovXG5jb25zdCBhZGRPclVwZGF0ZUV2ZW50TGlzdGVuZXIgPSAobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSA9PiB7XG4gICAgbGV0IGV2ZW50cyA9IGxpc3RlbmVkRXZlbnRzLmdldChub2RlKTtcbiAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGlzdGVuZWRFdmVudHMuc2V0KG5vZGUsIChldmVudHMgPSBuZXcgTWFwKCkpKTtcbiAgICB9XG4gICAgbGV0IGhhbmRsZXIgPSBldmVudHMuZ2V0KGV2ZW50KTtcbiAgICBpZiAobGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBJZiBuZWNlc3NhcnksIGFkZCBsaXN0ZW5lciBhbmQgdHJhY2sgaGFuZGxlclxuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBldmVudHMuc2V0KGV2ZW50LCAoaGFuZGxlciA9IHsgaGFuZGxlRXZlbnQ6IGxpc3RlbmVyIH0pKTtcbiAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcik7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UganVzdCB1cGRhdGUgdGhlIGxpc3RlbmVyIHdpdGggbmV3IHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVyLmhhbmRsZUV2ZW50ID0gbGlzdGVuZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGxpc3RlbmVyIGlmIG9uZSBleGlzdHMgYW5kIHZhbHVlIGlzIHVuZGVmaW5lZFxuICAgIH1cbiAgICBlbHNlIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXZlbnRzLmRlbGV0ZShldmVudCk7XG4gICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcik7XG4gICAgfVxufTtcbi8qKlxuICogU2V0cyBwcm9wZXJ0aWVzIGFuZCBldmVudHMgb24gY3VzdG9tIGVsZW1lbnRzLiBUaGVzZSBwcm9wZXJ0aWVzIGFuZCBldmVudHNcbiAqIGhhdmUgYmVlbiBwcmUtZmlsdGVyZWQgc28gd2Uga25vdyB0aGV5IHNob3VsZCBhcHBseSB0byB0aGUgY3VzdG9tIGVsZW1lbnQuXG4gKi9cbmNvbnN0IHNldFByb3BlcnR5ID0gKG5vZGUsIG5hbWUsIHZhbHVlLCBvbGQsIGV2ZW50cykgPT4ge1xuICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzPy5bbmFtZV07XG4gICAgLy8gRGlydHkgY2hlY2sgZXZlbnQgdmFsdWUuXG4gICAgaWYgKGV2ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBvbGQpIHtcbiAgICAgICAgICAgIGFkZE9yVXBkYXRlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQnV0IGRvbid0IGRpcnR5IGNoZWNrIHByb3BlcnRpZXM7IGVsZW1lbnRzIGFyZSBhc3N1bWVkIHRvIGRvIHRoaXMuXG4gICAgbm9kZVtuYW1lXSA9IHZhbHVlO1xuICAgIC8vIFRoaXMgYmxvY2sgaXMgdG8gcmVwbGljYXRlIFJlYWN0J3MgYmVoYXZpb3IgZm9yIGF0dHJpYnV0ZXMgb2YgbmF0aXZlXG4gICAgLy8gZWxlbWVudHMgd2hlcmUgYHVuZGVmaW5lZGAgb3IgYG51bGxgIHZhbHVlcyByZXN1bHQgaW4gYXR0cmlidXRlcyBiZWluZ1xuICAgIC8vIHJlbW92ZWQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvODk5Y2I5NWY1MmNjODNhYjVjYTFlYjFlMjY4YzkwOWQzZjA5NjFlNy9wYWNrYWdlcy9yZWFjdC1kb20tYmluZGluZ3Mvc3JjL2NsaWVudC9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanMjTDEwNy1MMTQxXG4gICAgLy9cbiAgICAvLyBJdCdzIG9ubHkgbmVlZGVkIGhlcmUgZm9yIG5hdGl2ZSBIVE1MRWxlbWVudCBwcm9wZXJ0aWVzIHRoYXQgcmVmbGVjdFxuICAgIC8vIGF0dHJpYnV0ZXMgb2YgdGhlIHNhbWUgbmFtZSBidXQgZG9uJ3QgaGF2ZSB0aGF0IGJlaGF2aW9yIGxpa2UgXCJpZFwiIG9yXG4gICAgLy8gXCJkcmFnZ2FibGVcIi5cbiAgICBpZiAoKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpICYmXG4gICAgICAgIG5hbWUgaW4gSFRNTEVsZW1lbnQucHJvdG90eXBlKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbn07XG4vKipcbiAqIENyZWF0ZXMgYSBSZWFjdCBjb21wb25lbnQgZm9yIGEgY3VzdG9tIGVsZW1lbnQuIFByb3BlcnRpZXMgYXJlIGRpc3Rpbmd1aXNoZWRcbiAqIGZyb20gYXR0cmlidXRlcyBhdXRvbWF0aWNhbGx5LCBhbmQgZXZlbnRzIGNhbiBiZSBjb25maWd1cmVkIHNvIHRoZXkgYXJlIGFkZGVkXG4gKiB0byB0aGUgY3VzdG9tIGVsZW1lbnQgYXMgZXZlbnQgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIEFuIG9wdGlvbnMgYmFnIGNvbnRhaW5pbmcgdGhlIHBhcmFtZXRlcnMgbmVlZGVkIHRvIGdlbmVyYXRlIGFcbiAqIHdyYXBwZWQgd2ViIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucy5yZWFjdCBUaGUgUmVhY3QgbW9kdWxlLCB0eXBpY2FsbHkgaW1wb3J0ZWQgZnJvbSB0aGUgYHJlYWN0YFxuICogbnBtIHBhY2thZ2UuXG4gKiBAcGFyYW0gb3B0aW9ucy50YWdOYW1lIFRoZSBjdXN0b20gZWxlbWVudCB0YWcgbmFtZSByZWdpc3RlcmVkIHZpYVxuICogYGN1c3RvbUVsZW1lbnRzLmRlZmluZWAuXG4gKiBAcGFyYW0gb3B0aW9ucy5lbGVtZW50Q2xhc3MgVGhlIGN1c3RvbSBlbGVtZW50IGNsYXNzIHJlZ2lzdGVyZWQgdmlhXG4gKiBgY3VzdG9tRWxlbWVudHMuZGVmaW5lYC5cbiAqIEBwYXJhbSBvcHRpb25zLmV2ZW50cyBBbiBvYmplY3QgbGlzdGluZyBldmVudHMgdG8gd2hpY2ggdGhlIGNvbXBvbmVudCBjYW5cbiAqIGxpc3Rlbi4gVGhlIG9iamVjdCBrZXlzIGFyZSB0aGUgZXZlbnQgcHJvcGVydHkgbmFtZXMgcGFzc2VkIGluIHZpYSBSZWFjdFxuICogcHJvcHMgYW5kIHRoZSBvYmplY3QgdmFsdWVzIGFyZSB0aGUgbmFtZXMgb2YgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnRzXG4gKiBnZW5lcmF0ZWQgYnkgdGhlIGN1c3RvbSBlbGVtZW50LiBGb3IgZXhhbXBsZSwgZ2l2ZW4gYHtvbmFjdGl2YXRlOlxuICogJ2FjdGl2YXRlJ31gIGFuIGV2ZW50IGZ1bmN0aW9uIG1heSBiZSBwYXNzZWQgdmlhIHRoZSBjb21wb25lbnQncyBgb25hY3RpdmF0ZWBcbiAqIHByb3AgYW5kIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGN1c3RvbSBlbGVtZW50IGZpcmVzIGl0cyBgYWN0aXZhdGVgIGV2ZW50LlxuICogQHBhcmFtIG9wdGlvbnMuZGlzcGxheU5hbWUgQSBSZWFjdCBjb21wb25lbnQgZGlzcGxheSBuYW1lLCB1c2VkIGluIGRlYnVnZ2luZ1xuICogbWVzc2FnZXMuIERlZmF1bHQgdmFsdWUgaXMgaW5mZXJyZWQgZnJvbSB0aGUgbmFtZSBvZiBjdXN0b20gZWxlbWVudCBjbGFzc1xuICogcmVnaXN0ZXJlZCB2aWEgYGN1c3RvbUVsZW1lbnRzLmRlZmluZWAuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVDb21wb25lbnQgPSAoeyByZWFjdDogUmVhY3QsIHRhZ05hbWUsIGVsZW1lbnRDbGFzcywgZXZlbnRzLCBkaXNwbGF5TmFtZSwgfSkgPT4ge1xuICAgIGNvbnN0IGV2ZW50UHJvcHMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGV2ZW50cyA/PyB7fSkpO1xuICAgIGlmIChERVZfTU9ERSAmJiAhTk9ERV9NT0RFKSB7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiByZXNlcnZlZFJlYWN0UHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHAgaW4gZWxlbWVudENsYXNzLnByb3RvdHlwZSAmJiAhKHAgaW4gSFRNTEVsZW1lbnQucHJvdG90eXBlKSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGUsIHRoaXMgZWZmZWN0aXZlbHkgd2FybnMgb25seSBmb3IgYHJlZmAgc2luY2UgdGhlIG90aGVyXG4gICAgICAgICAgICAgICAgLy8gcmVzZXJ2ZWQgcHJvcHMgYXJlIG9uIEhUTUxFbGVtZW50LnByb3RvdHlwZS4gVG8gYWRkcmVzcyB0aGlzXG4gICAgICAgICAgICAgICAgLy8gd291bGQgcmVxdWlyZSBjcmF3bGluZyBkb3duIHRoZSBwcm90b3R5cGUsIHdoaWNoIGRvZXNuJ3QgZmVlbCB3b3J0aFxuICAgICAgICAgICAgICAgIC8vIGl0IHNpbmNlIGltcGxlbWVudGluZyB0aGVzZSBwcm9wZXJ0aWVzIG9uIGFuIGVsZW1lbnQgaXMgZXh0cmVtZWx5XG4gICAgICAgICAgICAgICAgLy8gcmFyZS5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7dGFnTmFtZX0gY29udGFpbnMgcHJvcGVydHkgJHtwfSB3aGljaCBpcyBhIFJlYWN0IHJlc2VydmVkIGAgK1xuICAgICAgICAgICAgICAgICAgICBgcHJvcGVydHkuIEl0IHdpbGwgYmUgdXNlZCBieSBSZWFjdCBhbmQgbm90IHNldCBvbiB0aGUgZWxlbWVudC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBSZWFjdENvbXBvbmVudCA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgICAgICAgY29uc3QgcHJldkVsZW1Qcm9wc1JlZiA9IFJlYWN0LnVzZVJlZihuZXcgTWFwKCkpO1xuICAgICAgICBjb25zdCBlbGVtZW50UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgICAgICAvLyBQcm9wcyB0byBiZSBwYXNzZWQgdG8gUmVhY3QuY3JlYXRlRWxlbWVudFxuICAgICAgICBjb25zdCByZWFjdFByb3BzID0ge307XG4gICAgICAgIC8vIFByb3BzIHRvIGJlIHNldCBvbiBlbGVtZW50IHdpdGggc2V0UHJvcGVydHlcbiAgICAgICAgY29uc3QgZWxlbWVudFByb3BzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkge1xuICAgICAgICAgICAgaWYgKHJlc2VydmVkUmVhY3RQcm9wZXJ0aWVzLmhhcyhrKSkge1xuICAgICAgICAgICAgICAgIC8vIFJlYWN0IGRvZXMgKm5vdCogaGFuZGxlIGBjbGFzc05hbWVgIGZvciBjdXN0b20gZWxlbWVudHMgc29cbiAgICAgICAgICAgICAgICAvLyBjb2VyY2UgaXQgdG8gYGNsYXNzYCBzbyBpdCdzIGhhbmRsZWQgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHJlYWN0UHJvcHNbayA9PT0gJ2NsYXNzTmFtZScgPyAnY2xhc3MnIDoga10gPSB2O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50UHJvcHMuaGFzKGspIHx8IGsgaW4gZWxlbWVudENsYXNzLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRQcm9wc1trXSA9IHY7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFjdFByb3BzW2tdID0gdjtcbiAgICAgICAgfVxuICAgICAgICAvLyB1c2VMYXlvdXRFZmZlY3QgcHJvZHVjZXMgd2FybmluZ3MgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuXG4gICAgICAgIGlmICghTk9ERV9NT0RFKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG9uZSBoYXMgbm8gZGVwZW5kZW5jeSBhcnJheSBzbyBpdCdsbCBydW4gb24gZXZlcnkgcmUtcmVuZGVyLlxuICAgICAgICAgICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RWxlbVByb3BzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGVsZW1lbnRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICBzZXRQcm9wZXJ0eShlbGVtZW50UmVmLmN1cnJlbnQsIGtleSwgcHJvcHNba2V5XSwgcHJldkVsZW1Qcm9wc1JlZi5jdXJyZW50LmdldChrZXkpLCBldmVudHMpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2RWxlbVByb3BzUmVmLmN1cnJlbnQuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0VsZW1Qcm9wcy5zZXQoa2V5LCBwcm9wc1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gXCJVbnNldFwiIGFueSBwcm9wcyBmcm9tIHByZXZpb3VzIHJlbmRlciB0aGF0IG5vIGxvbmdlciBleGlzdC5cbiAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIHRvIGB1bmRlZmluZWRgIHNlZW1zIGxpa2UgdGhlIGNvcnJlY3QgdGhpbmcgdG8gXCJ1bnNldFwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IGN1cnJlbnRseSBSZWFjdCB3aWxsIHNldCBpdCBhcyBgbnVsbGAuXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjgyMDNcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBwcmV2RWxlbVByb3BzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0UHJvcGVydHkoZWxlbWVudFJlZi5jdXJyZW50LCBrZXksIHVuZGVmaW5lZCwgdmFsdWUsIGV2ZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZFbGVtUHJvcHNSZWYuY3VycmVudCA9IG5ld0VsZW1Qcm9wcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gRW1wdHkgZGVwZW5kZW5jeSBhcnJheSBzbyB0aGlzIHdpbGwgb25seSBydW4gb25jZSBhZnRlciBmaXJzdCByZW5kZXIuXG4gICAgICAgICAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRSZWYuY3VycmVudD8ucmVtb3ZlQXR0cmlidXRlKCdkZWZlci1oeWRyYXRpb24nKTtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTk9ERV9NT0RFKSB7XG4gICAgICAgICAgICAvLyBJZiBjb21wb25lbnQgaXMgdG8gYmUgc2VydmVyIHJlbmRlcmVkIHdpdGggYEBsaXQvc3NyLXJlYWN0YCwgcGFzc1xuICAgICAgICAgICAgLy8gZWxlbWVudCBwcm9wZXJ0aWVzIGluIGEgc3BlY2lhbCBiYWcgdG8gYmUgc2V0IGJ5IHRoZSBzZXJ2ZXItc2lkZVxuICAgICAgICAgICAgLy8gZWxlbWVudCByZW5kZXJlci5cbiAgICAgICAgICAgIGlmICgoUmVhY3QuY3JlYXRlRWxlbWVudC5uYW1lID09PSAnbGl0UGF0Y2hlZENyZWF0ZUVsZW1lbnQnIHx8XG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5saXRTc3JSZWFjdEVuYWJsZWQpICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZWxlbWVudFByb3BzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHByb3BlcnR5IG5lZWRzIHRvIHJlbWFpbiB1bm1pbmlmaWVkLlxuICAgICAgICAgICAgICAgIHJlYWN0UHJvcHNbJ18kbGl0UHJvcHMkJ10gPSBlbGVtZW50UHJvcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTdXBwcmVzcyBoeWRyYXRpb24gd2FybmluZyBmb3Igc2VydmVyLXJlbmRlcmVkIGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICAvLyBUaGlzIHByb3BlcnR5IG5lZWRzIHRvIHJlbWFpbiB1bm1pbmlmaWVkLlxuICAgICAgICAgICAgcmVhY3RQcm9wc1snc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJ10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHRhZ05hbWUsIHtcbiAgICAgICAgICAgIC4uLnJlYWN0UHJvcHMsXG4gICAgICAgICAgICByZWY6IFJlYWN0LnVzZUNhbGxiYWNrKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZWYobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW3JlZl0pLFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBSZWFjdENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lID8/IGVsZW1lbnRDbGFzcy5uYW1lO1xuICAgIHJldHVybiBSZWFjdENvbXBvbmVudDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGUtY29tcG9uZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lit/react/development/create-component.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lit/react/development/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@lit/react/development/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createComponent: function() { return /* reexport safe */ _create_component_js__WEBPACK_IMPORTED_MODULE_0__.createComponent; }\n/* harmony export */ });\n/* harmony import */ var _create_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create-component.js */ \"(app-pages-browser)/./node_modules/@lit/react/development/create-component.js\");\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl0L3JlYWN0L2RldmVsb3BtZW50L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzQztBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdC9kZXZlbG9wbWVudC9pbmRleC5qcz9lZDdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0ICogZnJvbSAnLi9jcmVhdGUtY29tcG9uZW50LmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lit/react/development/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prompt-chart-react/dist/promptChart.js":
/*!*************************************************************!*\
  !*** ./node_modules/prompt-chart-react/dist/promptChart.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("var react__WEBPACK_IMPORTED_MODULE_2___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PromptChart: function() { return /* binding */ PromptChart; }\n/* harmony export */ });\n/* harmony import */ var prompt_chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prompt-chart */ \"(app-pages-browser)/./node_modules/prompt-chart/dist/promptChart.js\");\n/* harmony import */ var _lit_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lit/react */ \"(app-pages-browser)/./node_modules/@lit/react/development/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\n\nconst PromptChart = (0,_lit_react__WEBPACK_IMPORTED_MODULE_1__.createComponent)({\n    tagName: 'prompt-chart',\n    elementClass: prompt_chart__WEBPACK_IMPORTED_MODULE_0__.PromptChart,\n    react: /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_2__, 2))),\n    events: {\n        onactivate: 'activate',\n        onchange: 'change',\n    },\n});\n//# sourceMappingURL=promptChart.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9tcHQtY2hhcnQtcmVhY3QvZGlzdC9wcm9tcHRDaGFydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE4RDtBQUNqQjtBQUNkO0FBQ3hCLG9CQUFvQiwyREFBZTtBQUMxQztBQUNBLGtCQUFrQixxREFBZTtBQUNqQyxXQUFXLHlMQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb21wdC1jaGFydC1yZWFjdC9kaXN0L3Byb21wdENoYXJ0LmpzPzY1OGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHJvbXB0Q2hhcnQgYXMgUHJvbXB0Q2hhcnRDb3JlIH0gZnJvbSAncHJvbXB0LWNoYXJ0JztcbmltcG9ydCB7IGNyZWF0ZUNvbXBvbmVudCB9IGZyb20gJ0BsaXQvcmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuZXhwb3J0IGNvbnN0IFByb21wdENoYXJ0ID0gY3JlYXRlQ29tcG9uZW50KHtcbiAgICB0YWdOYW1lOiAncHJvbXB0LWNoYXJ0JyxcbiAgICBlbGVtZW50Q2xhc3M6IFByb21wdENoYXJ0Q29yZSxcbiAgICByZWFjdDogUmVhY3QsXG4gICAgZXZlbnRzOiB7XG4gICAgICAgIG9uYWN0aXZhdGU6ICdhY3RpdmF0ZScsXG4gICAgICAgIG9uY2hhbmdlOiAnY2hhbmdlJyxcbiAgICB9LFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9tcHRDaGFydC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prompt-chart-react/dist/promptChart.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prompt-chart/dist/promptChart.js":
/*!*******************************************************!*\
  !*** ./node_modules/prompt-chart/dist/promptChart.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChartRenderer: function() { return /* binding */ fn; },\n/* harmony export */   PromptChart: function() { return /* binding */ nt; }\n/* harmony export */ });\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2)); }, _regeneratorDefine2(e, r, n, t); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n5 = 0, F = function F() {}; return { s: F, n: function n() { return _n5 >= r.length ? { done: !0 } : { done: !1, value: r[_n5++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _wrapNativeSuper(t) { var r = \"function\" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }\nfunction _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf(\"[native code]\"); } catch (n) { return \"function\" == typeof t; } }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar ao = Object.defineProperty;\nvar lo = function lo(i, t, e) {\n  return t in i ? ao(i, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : i[t] = e;\n};\nvar w = function w(i, t, e) {\n  return lo(i, _typeof(t) != \"symbol\" ? t + \"\" : t, e);\n};\nvar Lt = /*#__PURE__*/function () {\n  function Lt() {\n    _classCallCheck(this, Lt);\n  }\n  return _createClass(Lt, null, [{\n    key: \"attemptAppendStyleSheetToHead\",\n    value: function attemptAppendStyleSheetToHead(t) {\n      if (t.fontFamily && t.fontFamily !== Lt.DEFAULT_FONT_FAMILY) return;\n      var e = document.getElementsByTagName(\"head\")[0];\n      if (!Array.from(e.getElementsByTagName(\"link\")).some(function (n) {\n        return n.getAttribute(\"href\") === Lt.FONT_URL;\n      })) {\n        var n = document.createElement(\"link\");\n        n.rel = \"stylesheet\", n.href = Lt.FONT_URL, e.appendChild(n);\n      }\n    }\n  }]);\n}();\nLt.FONT_URL = \"https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap\", Lt.DEFAULT_FONT_FAMILY = \"'Inter', sans-serif, Avenir, Helvetica, Arial\";\nvar Ne = Lt;\nvar $t = /*#__PURE__*/function () {\n  function $t() {\n    _classCallCheck(this, $t);\n  }\n  return _createClass($t, null, [{\n    key: \"applyToStyleIfNotDefined\",\n    value: function applyToStyleIfNotDefined(t, e) {\n      for (var s in e) {\n        var n = s,\n          o = e[n];\n        t[n] === \"\" && o && (t[n] = o);\n      }\n    }\n  }, {\n    key: \"applyDefaultStyleToComponent\",\n    value: function applyDefaultStyleToComponent(t, e) {\n      e && $t.applyToStyleIfNotDefined(t, e), $t.applyToStyleIfNotDefined(t, $t.DEFAULT_COMPONENT_STYLE);\n    }\n  }]);\n}();\n$t.DEFAULT_COMPONENT_STYLE = {\n  height: \"350px\",\n  width: \"100%\",\n  fontFamily: Ne.DEFAULT_FONT_FAMILY,\n  fontSize: \"0.9rem\",\n  backgroundColor: \"white\",\n  position: \"relative\",\n  overflow: \"hidden\"\n};\nvar bi = $t;\nvar Ve = /*#__PURE__*/function () {\n  function Ve() {\n    _classCallCheck(this, Ve);\n  }\n  return _createClass(Ve, null, [{\n    key: \"waitForPropertiesToBeUpdatedBeforeRender\",\n    value: function waitForPropertiesToBeUpdatedBeforeRender(t) {\n      t._propUpdated_ = !1, setTimeout(function () {\n        t._propUpdated_ ? Ve.waitForPropertiesToBeUpdatedBeforeRender(t) : (t._waitingToRender_ = !1, t.onRender());\n      });\n    }\n  }, {\n    key: \"attemptRender\",\n    value: function attemptRender(t) {\n      t._propUpdated_ = !0, t._waitingToRender_ || (t._waitingToRender_ = !0, Ve.waitForPropertiesToBeUpdatedBeforeRender(t));\n    }\n  }]);\n}();\nvar gt = /*#__PURE__*/function (_HTMLElement) {\n  // If this is not working, try using propertyName directly\n  function gt() {\n    var _this;\n    _classCallCheck(this, gt);\n    _this = _callSuper(this, gt), _this._waitingToRender_ = !1, _this._propUpdated_ = !1, Object.keys(gt._attributeToProperty_).forEach(function (t) {\n      var e = gt._attributeToProperty_[t];\n      _this.constructPropertyAccessors(e), _this.hasOwnProperty(t) || _this.constructPropertyAccessors(e, t);\n    });\n    return _this;\n  }\n  _inherits(gt, _HTMLElement);\n  return _createClass(gt, [{\n    key: \"constructPropertyAccessors\",\n    value:\n    // need to be called here as accessors need to be set for the class instance\n    function constructPropertyAccessors(t, e) {\n      var s;\n      Object.defineProperty(this, e || t, {\n        get: function get() {\n          return s;\n        },\n        set: function set(r) {\n          s = r, e ? this[t] = r : Ve.attemptRender(this);\n        }\n      });\n    }\n  }, {\n    key: \"attributeChangedCallback\",\n    value: function attributeChangedCallback(t, e, s) {\n      if (e === s) return;\n      var n = gt._attributes_[t](s),\n        o = gt._attributeToProperty_[t];\n      this[o] = n;\n    }\n  }, {\n    key: \"onRender\",\n    value: function onRender() {}\n  }], [{\n    key: \"observedAttributes\",\n    get: function get() {\n      return Object.keys(gt._attributes_) || [];\n    }\n  }]);\n}(/*#__PURE__*/_wrapNativeSuper(HTMLElement));\ngt._attributes_ = {}, gt._attributeToProperty_ = {};\nvar _i = gt;\nvar co = /*#__PURE__*/function () {\n  function co() {\n    _classCallCheck(this, co);\n  }\n  return _createClass(co, [{\n    key: \"generate\",\n    value: function generate(t) {\n      var e = t.toLowerCase(),\n        s = this.detectChartType(e),\n        n = t.charAt(0).toUpperCase() + t.slice(1),\n        _this$generateDataset = this.generateDataset(e),\n        o = _this$generateDataset.labels,\n        r = _this$generateDataset.datasets,\n        a = _this$generateDataset.dataset;\n      return {\n        chartSpec: {\n          type: s,\n          title: n,\n          xAxis: {\n            label: \"Category\"\n          },\n          yAxis: {\n            label: \"Value\"\n          },\n          legend: {\n            display: r.length > 1 || s === \"pie\" || s === \"doughnut\",\n            position: \"top\"\n          }\n        },\n        data: {\n          labels: o,\n          datasets: r\n        },\n        metadata: {\n          generatedAt: (/* @__PURE__ */new Date()).toISOString(),\n          dataset: a,\n          recordCount: o.length\n        }\n      };\n    }\n  }, {\n    key: \"detectChartType\",\n    value: function detectChartType(t) {\n      return t.includes(\"pie\") ? \"pie\" : t.includes(\"doughnut\") || t.includes(\"donut\") ? \"doughnut\" : t.includes(\"line\") || t.includes(\"trend\") ? \"line\" : t.includes(\"area\") ? \"area\" : t.includes(\"scatter\") ? \"scatter\" : \"bar\";\n    }\n  }, {\n    key: \"generateDataset\",\n    value: function generateDataset(t) {\n      return t.includes(\"month\") || t.includes(\"year\") ? this.generateMonthlyData(t) : t.includes(\"product\") || t.includes(\"revenue\") ? this.generateProductRevenueData() : t.includes(\"status\") || t.includes(\"order\") ? this.generateOrderStatusData() : t.includes(\"signup\") || t.includes(\"user\") ? this.generateUserSignupData() : t.includes(\"profit\") || t.includes(\"top\") ? this.generateProfitData() : this.generateDefaultData();\n    }\n  }, {\n    key: \"generateMonthlyData\",\n    value: function generateMonthlyData(t) {\n      var e = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n      return t.includes(\"region\") ? {\n        labels: e,\n        datasets: [{\n          label: \"North\",\n          data: [65, 78, 90, 81, 96, 105, 110, 102, 95, 88, 92, 108],\n          backgroundColor: \"#3b82f6\",\n          borderColor: \"#3b82f6\"\n        }, {\n          label: \"South\",\n          data: [45, 52, 60, 55, 70, 82, 88, 80, 72, 65, 70, 85],\n          backgroundColor: \"#10b981\",\n          borderColor: \"#10b981\"\n        }, {\n          label: \"East\",\n          data: [35, 40, 48, 45, 55, 62, 68, 60, 55, 50, 52, 65],\n          backgroundColor: \"#f59e0b\",\n          borderColor: \"#f59e0b\"\n        }],\n        dataset: \"sales_by_region\"\n      } : {\n        labels: e,\n        datasets: [{\n          label: \"Value\",\n          data: [65, 78, 90, 81, 96, 105, 110, 102, 95, 88, 92, 108],\n          backgroundColor: \"#3b82f6\",\n          borderColor: \"#3b82f6\"\n        }],\n        dataset: \"monthly_data\"\n      };\n    }\n  }, {\n    key: \"generateProductRevenueData\",\n    value: function generateProductRevenueData() {\n      var t = [\"Product A\", \"Product B\", \"Product C\", \"Product D\", \"Product E\"],\n        e = [\"#3b82f6\", \"#10b981\", \"#f59e0b\", \"#ef4444\", \"#8b5cf6\"];\n      return {\n        labels: t,\n        datasets: [{\n          label: \"Revenue\",\n          data: [42e3, 35e3, 28e3, 21e3, 15e3],\n          backgroundColor: e,\n          borderColor: e\n        }],\n        dataset: \"product_revenue\"\n      };\n    }\n  }, {\n    key: \"generateOrderStatusData\",\n    value: function generateOrderStatusData() {\n      var t = [\"Completed\", \"Pending\", \"Processing\", \"Cancelled\"],\n        e = [\"#10b981\", \"#f59e0b\", \"#3b82f6\", \"#ef4444\"];\n      return {\n        labels: t,\n        datasets: [{\n          label: \"Orders\",\n          data: [245, 89, 56, 23],\n          backgroundColor: e,\n          borderColor: e\n        }],\n        dataset: \"order_status\"\n      };\n    }\n  }, {\n    key: \"generateUserSignupData\",\n    value: function generateUserSignupData() {\n      return {\n        labels: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n        datasets: [{\n          label: \"Signups\",\n          data: [120, 145, 180, 220, 290, 350, 420, 480, 520, 580, 650, 720],\n          backgroundColor: \"#8b5cf6\",\n          borderColor: \"#8b5cf6\"\n        }],\n        dataset: \"user_signups\"\n      };\n    }\n  }, {\n    key: \"generateProfitData\",\n    value: function generateProfitData() {\n      var t = [\"Widget Pro\", \"Gadget X\", \"Tool Master\", \"Device Plus\", \"Smart Kit\"],\n        e = [\"#3b82f6\", \"#10b981\", \"#f59e0b\", \"#ef4444\", \"#8b5cf6\"];\n      return {\n        labels: t,\n        datasets: [{\n          label: \"Profit\",\n          data: [18500, 15200, 12800, 9500, 7200],\n          backgroundColor: e,\n          borderColor: e\n        }],\n        dataset: \"product_profit\"\n      };\n    }\n  }, {\n    key: \"generateDefaultData\",\n    value: function generateDefaultData() {\n      var t = [\"Category A\", \"Category B\", \"Category C\", \"Category D\", \"Category E\"],\n        e = [\"#3b82f6\", \"#10b981\", \"#f59e0b\", \"#ef4444\", \"#8b5cf6\"];\n      return {\n        labels: t,\n        datasets: [{\n          label: \"Value\",\n          data: [42, 35, 28, 21, 15],\n          backgroundColor: e,\n          borderColor: e\n        }],\n        dataset: \"demo_data\"\n      };\n    }\n  }]);\n}();\nvar Xi = /*#__PURE__*/_createClass(function Xi() {\n  _classCallCheck(this, Xi);\n});\nXi.attibutes = {\n  string: function string(t) {\n    return t;\n  },\n  number: function number(t) {\n    return parseFloat(t);\n  },\n  \"boolean\": function boolean(t) {\n    return t === \"true\";\n  },\n  object: function object(t) {\n    return JSON.parse(t);\n  },\n  array: function array(t) {\n    return JSON.parse(t);\n  },\n  \"function\": function _function(t) {\n    return new Function(\"return \".concat(t))();\n  }\n};\nvar xi = Xi;\nfunction ct(i) {\n  return function (t, e) {\n    Object.defineProperty(t, e, {});\n    var s = t.constructor,\n      n = e.toLocaleLowerCase();\n    s._attributes_[n] = xi.attibutes[i], s._attributeToProperty_[n] = e;\n  };\n}\n/*!\n * @kurkle/color v0.3.4\n * https://github.com/kurkle/color#readme\n * (c) 2024 Jukka Kurkela\n * Released under the MIT License\n */\nfunction xe(i) {\n  return i + 0.5 | 0;\n}\nvar xt = function xt(i, t, e) {\n  return Math.max(Math.min(i, e), t);\n};\nfunction ne(i) {\n  return xt(xe(i * 2.55), 0, 255);\n}\nfunction St(i) {\n  return xt(xe(i * 255), 0, 255);\n}\nfunction pt(i) {\n  return xt(xe(i / 2.55) / 100, 0, 1);\n}\nfunction qi(i) {\n  return xt(xe(i * 100), 0, 100);\n}\nvar Q = {\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 4,\n    5: 5,\n    6: 6,\n    7: 7,\n    8: 8,\n    9: 9,\n    A: 10,\n    B: 11,\n    C: 12,\n    D: 13,\n    E: 14,\n    F: 15,\n    a: 10,\n    b: 11,\n    c: 12,\n    d: 13,\n    e: 14,\n    f: 15\n  },\n  yi = _toConsumableArray(\"0123456789ABCDEF\"),\n  ho = function ho(i) {\n    return yi[i & 15];\n  },\n  uo = function uo(i) {\n    return yi[(i & 240) >> 4] + yi[i & 15];\n  },\n  ve = function ve(i) {\n    return (i & 240) >> 4 === (i & 15);\n  },\n  fo = function fo(i) {\n    return ve(i.r) && ve(i.g) && ve(i.b) && ve(i.a);\n  };\nfunction go(i) {\n  var t = i.length,\n    e;\n  return i[0] === \"#\" && (t === 4 || t === 5 ? e = {\n    r: 255 & Q[i[1]] * 17,\n    g: 255 & Q[i[2]] * 17,\n    b: 255 & Q[i[3]] * 17,\n    a: t === 5 ? Q[i[4]] * 17 : 255\n  } : (t === 7 || t === 9) && (e = {\n    r: Q[i[1]] << 4 | Q[i[2]],\n    g: Q[i[3]] << 4 | Q[i[4]],\n    b: Q[i[5]] << 4 | Q[i[6]],\n    a: t === 9 ? Q[i[7]] << 4 | Q[i[8]] : 255\n  })), e;\n}\nvar po = function po(i, t) {\n  return i < 255 ? t(i) : \"\";\n};\nfunction mo(i) {\n  var t = fo(i) ? ho : uo;\n  return i ? \"#\" + t(i.r) + t(i.g) + t(i.b) + po(i.a, t) : void 0;\n}\nvar bo = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction gn(i, t, e) {\n  var s = t * Math.min(e, 1 - e),\n    n = function n(o) {\n      var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (o + i / 30) % 12;\n      return e - s * Math.max(Math.min(r - 3, 9 - r, 1), -1);\n    };\n  return [n(0), n(8), n(4)];\n}\nfunction _o(i, t, e) {\n  var s = function s(n) {\n    var o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n + i / 60) % 6;\n    return e - e * t * Math.max(Math.min(o, 4 - o, 1), 0);\n  };\n  return [s(5), s(3), s(1)];\n}\nfunction xo(i, t, e) {\n  var s = gn(i, 1, 0.5);\n  var n;\n  for (t + e > 1 && (n = 1 / (t + e), t *= n, e *= n), n = 0; n < 3; n++) s[n] *= 1 - t - e, s[n] += t;\n  return s;\n}\nfunction yo(i, t, e, s, n) {\n  return i === n ? (t - e) / s + (t < e ? 6 : 0) : t === n ? (e - i) / s + 2 : (i - t) / s + 4;\n}\nfunction Ri(i) {\n  var e = i.r / 255,\n    s = i.g / 255,\n    n = i.b / 255,\n    o = Math.max(e, s, n),\n    r = Math.min(e, s, n),\n    a = (o + r) / 2;\n  var l, c, h;\n  return o !== r && (h = o - r, c = a > 0.5 ? h / (2 - o - r) : h / (o + r), l = yo(e, s, n, h, o), l = l * 60 + 0.5), [l | 0, c || 0, a];\n}\nfunction Li(i, t, e, s) {\n  return (Array.isArray(t) ? i(t[0], t[1], t[2]) : i(t, e, s)).map(St);\n}\nfunction Ei(i, t, e) {\n  return Li(gn, i, t, e);\n}\nfunction vo(i, t, e) {\n  return Li(xo, i, t, e);\n}\nfunction Mo(i, t, e) {\n  return Li(_o, i, t, e);\n}\nfunction pn(i) {\n  return (i % 360 + 360) % 360;\n}\nfunction So(i) {\n  var t = bo.exec(i);\n  var e = 255,\n    s;\n  if (!t) return;\n  t[5] !== s && (e = t[6] ? ne(+t[5]) : St(+t[5]));\n  var n = pn(+t[2]),\n    o = +t[3] / 100,\n    r = +t[4] / 100;\n  return t[1] === \"hwb\" ? s = vo(n, o, r) : t[1] === \"hsv\" ? s = Mo(n, o, r) : s = Ei(n, o, r), {\n    r: s[0],\n    g: s[1],\n    b: s[2],\n    a: e\n  };\n}\nfunction ko(i, t) {\n  var e = Ri(i);\n  e[0] = pn(e[0] + t), e = Ei(e), i.r = e[0], i.g = e[1], i.b = e[2];\n}\nfunction wo(i) {\n  if (!i) return;\n  var t = Ri(i),\n    e = t[0],\n    s = qi(t[1]),\n    n = qi(t[2]);\n  return i.a < 255 ? \"hsla(\".concat(e, \", \").concat(s, \"%, \").concat(n, \"%, \").concat(pt(i.a), \")\") : \"hsl(\".concat(e, \", \").concat(s, \"%, \").concat(n, \"%)\");\n}\nvar Ki = {\n    x: \"dark\",\n    Z: \"light\",\n    Y: \"re\",\n    X: \"blu\",\n    W: \"gr\",\n    V: \"medium\",\n    U: \"slate\",\n    A: \"ee\",\n    T: \"ol\",\n    S: \"or\",\n    B: \"ra\",\n    C: \"lateg\",\n    D: \"ights\",\n    R: \"in\",\n    Q: \"turquois\",\n    E: \"hi\",\n    P: \"ro\",\n    O: \"al\",\n    N: \"le\",\n    M: \"de\",\n    L: \"yello\",\n    F: \"en\",\n    K: \"ch\",\n    G: \"arks\",\n    H: \"ea\",\n    I: \"ightg\",\n    J: \"wh\"\n  },\n  Gi = {\n    OiceXe: \"f0f8ff\",\n    antiquewEte: \"faebd7\",\n    aqua: \"ffff\",\n    aquamarRe: \"7fffd4\",\n    azuY: \"f0ffff\",\n    beige: \"f5f5dc\",\n    bisque: \"ffe4c4\",\n    black: \"0\",\n    blanKedOmond: \"ffebcd\",\n    Xe: \"ff\",\n    XeviTet: \"8a2be2\",\n    bPwn: \"a52a2a\",\n    burlywood: \"deb887\",\n    caMtXe: \"5f9ea0\",\n    KartYuse: \"7fff00\",\n    KocTate: \"d2691e\",\n    cSO: \"ff7f50\",\n    cSnflowerXe: \"6495ed\",\n    cSnsilk: \"fff8dc\",\n    crimson: \"dc143c\",\n    cyan: \"ffff\",\n    xXe: \"8b\",\n    xcyan: \"8b8b\",\n    xgTMnPd: \"b8860b\",\n    xWay: \"a9a9a9\",\n    xgYF: \"6400\",\n    xgYy: \"a9a9a9\",\n    xkhaki: \"bdb76b\",\n    xmagFta: \"8b008b\",\n    xTivegYF: \"556b2f\",\n    xSange: \"ff8c00\",\n    xScEd: \"9932cc\",\n    xYd: \"8b0000\",\n    xsOmon: \"e9967a\",\n    xsHgYF: \"8fbc8f\",\n    xUXe: \"483d8b\",\n    xUWay: \"2f4f4f\",\n    xUgYy: \"2f4f4f\",\n    xQe: \"ced1\",\n    xviTet: \"9400d3\",\n    dAppRk: \"ff1493\",\n    dApskyXe: \"bfff\",\n    dimWay: \"696969\",\n    dimgYy: \"696969\",\n    dodgerXe: \"1e90ff\",\n    fiYbrick: \"b22222\",\n    flSOwEte: \"fffaf0\",\n    foYstWAn: \"228b22\",\n    fuKsia: \"ff00ff\",\n    gaRsbSo: \"dcdcdc\",\n    ghostwEte: \"f8f8ff\",\n    gTd: \"ffd700\",\n    gTMnPd: \"daa520\",\n    Way: \"808080\",\n    gYF: \"8000\",\n    gYFLw: \"adff2f\",\n    gYy: \"808080\",\n    honeyMw: \"f0fff0\",\n    hotpRk: \"ff69b4\",\n    RdianYd: \"cd5c5c\",\n    Rdigo: \"4b0082\",\n    ivSy: \"fffff0\",\n    khaki: \"f0e68c\",\n    lavFMr: \"e6e6fa\",\n    lavFMrXsh: \"fff0f5\",\n    lawngYF: \"7cfc00\",\n    NmoncEffon: \"fffacd\",\n    ZXe: \"add8e6\",\n    ZcSO: \"f08080\",\n    Zcyan: \"e0ffff\",\n    ZgTMnPdLw: \"fafad2\",\n    ZWay: \"d3d3d3\",\n    ZgYF: \"90ee90\",\n    ZgYy: \"d3d3d3\",\n    ZpRk: \"ffb6c1\",\n    ZsOmon: \"ffa07a\",\n    ZsHgYF: \"20b2aa\",\n    ZskyXe: \"87cefa\",\n    ZUWay: \"778899\",\n    ZUgYy: \"778899\",\n    ZstAlXe: \"b0c4de\",\n    ZLw: \"ffffe0\",\n    lime: \"ff00\",\n    limegYF: \"32cd32\",\n    lRF: \"faf0e6\",\n    magFta: \"ff00ff\",\n    maPon: \"800000\",\n    VaquamarRe: \"66cdaa\",\n    VXe: \"cd\",\n    VScEd: \"ba55d3\",\n    VpurpN: \"9370db\",\n    VsHgYF: \"3cb371\",\n    VUXe: \"7b68ee\",\n    VsprRggYF: \"fa9a\",\n    VQe: \"48d1cc\",\n    VviTetYd: \"c71585\",\n    midnightXe: \"191970\",\n    mRtcYam: \"f5fffa\",\n    mistyPse: \"ffe4e1\",\n    moccasR: \"ffe4b5\",\n    navajowEte: \"ffdead\",\n    navy: \"80\",\n    Tdlace: \"fdf5e6\",\n    Tive: \"808000\",\n    TivedBb: \"6b8e23\",\n    Sange: \"ffa500\",\n    SangeYd: \"ff4500\",\n    ScEd: \"da70d6\",\n    pOegTMnPd: \"eee8aa\",\n    pOegYF: \"98fb98\",\n    pOeQe: \"afeeee\",\n    pOeviTetYd: \"db7093\",\n    papayawEp: \"ffefd5\",\n    pHKpuff: \"ffdab9\",\n    peru: \"cd853f\",\n    pRk: \"ffc0cb\",\n    plum: \"dda0dd\",\n    powMrXe: \"b0e0e6\",\n    purpN: \"800080\",\n    YbeccapurpN: \"663399\",\n    Yd: \"ff0000\",\n    Psybrown: \"bc8f8f\",\n    PyOXe: \"4169e1\",\n    saddNbPwn: \"8b4513\",\n    sOmon: \"fa8072\",\n    sandybPwn: \"f4a460\",\n    sHgYF: \"2e8b57\",\n    sHshell: \"fff5ee\",\n    siFna: \"a0522d\",\n    silver: \"c0c0c0\",\n    skyXe: \"87ceeb\",\n    UXe: \"6a5acd\",\n    UWay: \"708090\",\n    UgYy: \"708090\",\n    snow: \"fffafa\",\n    sprRggYF: \"ff7f\",\n    stAlXe: \"4682b4\",\n    tan: \"d2b48c\",\n    teO: \"8080\",\n    tEstN: \"d8bfd8\",\n    tomato: \"ff6347\",\n    Qe: \"40e0d0\",\n    viTet: \"ee82ee\",\n    JHt: \"f5deb3\",\n    wEte: \"ffffff\",\n    wEtesmoke: \"f5f5f5\",\n    Lw: \"ffff00\",\n    LwgYF: \"9acd32\"\n  };\nfunction Po() {\n  var i = {},\n    t = Object.keys(Gi),\n    e = Object.keys(Ki);\n  var s, n, o, r, a;\n  for (s = 0; s < t.length; s++) {\n    for (r = a = t[s], n = 0; n < e.length; n++) o = e[n], a = a.replace(o, Ki[o]);\n    o = parseInt(Gi[r], 16), i[a] = [o >> 16 & 255, o >> 8 & 255, o & 255];\n  }\n  return i;\n}\nvar Me;\nfunction Do(i) {\n  Me || (Me = Po(), Me.transparent = [0, 0, 0, 0]);\n  var t = Me[i.toLowerCase()];\n  return t && {\n    r: t[0],\n    g: t[1],\n    b: t[2],\n    a: t.length === 4 ? t[3] : 255\n  };\n}\nvar Co = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction Oo(i) {\n  var t = Co.exec(i);\n  var e = 255,\n    s,\n    n,\n    o;\n  if (t) {\n    if (t[7] !== s) {\n      var r = +t[7];\n      e = t[8] ? ne(r) : xt(r * 255, 0, 255);\n    }\n    return s = +t[1], n = +t[3], o = +t[5], s = 255 & (t[2] ? ne(s) : xt(s, 0, 255)), n = 255 & (t[4] ? ne(n) : xt(n, 0, 255)), o = 255 & (t[6] ? ne(o) : xt(o, 0, 255)), {\n      r: s,\n      g: n,\n      b: o,\n      a: e\n    };\n  }\n}\nfunction To(i) {\n  return i && (i.a < 255 ? \"rgba(\".concat(i.r, \", \").concat(i.g, \", \").concat(i.b, \", \").concat(pt(i.a), \")\") : \"rgb(\".concat(i.r, \", \").concat(i.g, \", \").concat(i.b, \")\"));\n}\nvar si = function si(i) {\n    return i <= 31308e-7 ? i * 12.92 : Math.pow(i, 1 / 2.4) * 1.055 - 0.055;\n  },\n  Nt = function Nt(i) {\n    return i <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);\n  };\nfunction Ao(i, t, e) {\n  var s = Nt(pt(i.r)),\n    n = Nt(pt(i.g)),\n    o = Nt(pt(i.b));\n  return {\n    r: St(si(s + e * (Nt(pt(t.r)) - s))),\n    g: St(si(n + e * (Nt(pt(t.g)) - n))),\n    b: St(si(o + e * (Nt(pt(t.b)) - o))),\n    a: i.a + e * (t.a - i.a)\n  };\n}\nfunction Se(i, t, e) {\n  if (i) {\n    var s = Ri(i);\n    s[t] = Math.max(0, Math.min(s[t] + s[t] * e, t === 0 ? 360 : 1)), s = Ei(s), i.r = s[0], i.g = s[1], i.b = s[2];\n  }\n}\nfunction mn(i, t) {\n  return i && Object.assign(t || {}, i);\n}\nfunction Ji(i) {\n  var t = {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 255\n  };\n  return Array.isArray(i) ? i.length >= 3 && (t = {\n    r: i[0],\n    g: i[1],\n    b: i[2],\n    a: 255\n  }, i.length > 3 && (t.a = St(i[3]))) : (t = mn(i, {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 1\n  }), t.a = St(t.a)), t;\n}\nfunction Ro(i) {\n  return i.charAt(0) === \"r\" ? Oo(i) : So(i);\n}\nvar ue = /*#__PURE__*/function () {\n  function ue(t) {\n    _classCallCheck(this, ue);\n    if (t instanceof ue) return t;\n    var e = _typeof(t);\n    var s;\n    e === \"object\" ? s = Ji(t) : e === \"string\" && (s = go(t) || Do(t) || Ro(t)), this._rgb = s, this._valid = !!s;\n  }\n  return _createClass(ue, [{\n    key: \"valid\",\n    get: function get() {\n      return this._valid;\n    }\n  }, {\n    key: \"rgb\",\n    get: function get() {\n      var t = mn(this._rgb);\n      return t && (t.a = pt(t.a)), t;\n    },\n    set: function set(t) {\n      this._rgb = Ji(t);\n    }\n  }, {\n    key: \"rgbString\",\n    value: function rgbString() {\n      return this._valid ? To(this._rgb) : void 0;\n    }\n  }, {\n    key: \"hexString\",\n    value: function hexString() {\n      return this._valid ? mo(this._rgb) : void 0;\n    }\n  }, {\n    key: \"hslString\",\n    value: function hslString() {\n      return this._valid ? wo(this._rgb) : void 0;\n    }\n  }, {\n    key: \"mix\",\n    value: function mix(t, e) {\n      if (t) {\n        var s = this.rgb,\n          n = t.rgb;\n        var o;\n        var r = e === o ? 0.5 : e,\n          a = 2 * r - 1,\n          l = s.a - n.a,\n          c = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2;\n        o = 1 - c, s.r = 255 & c * s.r + o * n.r + 0.5, s.g = 255 & c * s.g + o * n.g + 0.5, s.b = 255 & c * s.b + o * n.b + 0.5, s.a = r * s.a + (1 - r) * n.a, this.rgb = s;\n      }\n      return this;\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(t, e) {\n      return t && (this._rgb = Ao(this._rgb, t._rgb, e)), this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new ue(this.rgb);\n    }\n  }, {\n    key: \"alpha\",\n    value: function alpha(t) {\n      return this._rgb.a = St(t), this;\n    }\n  }, {\n    key: \"clearer\",\n    value: function clearer(t) {\n      var e = this._rgb;\n      return e.a *= 1 - t, this;\n    }\n  }, {\n    key: \"greyscale\",\n    value: function greyscale() {\n      var t = this._rgb,\n        e = xe(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);\n      return t.r = t.g = t.b = e, this;\n    }\n  }, {\n    key: \"opaquer\",\n    value: function opaquer(t) {\n      var e = this._rgb;\n      return e.a *= 1 + t, this;\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      var t = this._rgb;\n      return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;\n    }\n  }, {\n    key: \"lighten\",\n    value: function lighten(t) {\n      return Se(this._rgb, 2, t), this;\n    }\n  }, {\n    key: \"darken\",\n    value: function darken(t) {\n      return Se(this._rgb, 2, -t), this;\n    }\n  }, {\n    key: \"saturate\",\n    value: function saturate(t) {\n      return Se(this._rgb, 1, t), this;\n    }\n  }, {\n    key: \"desaturate\",\n    value: function desaturate(t) {\n      return Se(this._rgb, 1, -t), this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(t) {\n      return ko(this._rgb, t), this;\n    }\n  }]);\n}();\n/*!\n * Chart.js v4.5.1\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */\nfunction dt() {}\nvar Lo = /* @__PURE__ */function () {\n  var i = 0;\n  return function () {\n    return i++;\n  };\n}();\nfunction R(i) {\n  return i == null;\n}\nfunction N(i) {\n  if (Array.isArray && Array.isArray(i)) return !0;\n  var t = Object.prototype.toString.call(i);\n  return t.slice(0, 7) === \"[object\" && t.slice(-6) === \"Array]\";\n}\nfunction T(i) {\n  return i !== null && Object.prototype.toString.call(i) === \"[object Object]\";\n}\nfunction q(i) {\n  return (typeof i == \"number\" || i instanceof Number) && isFinite(+i);\n}\nfunction ot(i, t) {\n  return q(i) ? i : t;\n}\nfunction D(i, t) {\n  return _typeof(i) > \"u\" ? t : i;\n}\nvar Eo = function Eo(i, t) {\n    return typeof i == \"string\" && i.endsWith(\"%\") ? parseFloat(i) / 100 : +i / t;\n  },\n  bn = function bn(i, t) {\n    return typeof i == \"string\" && i.endsWith(\"%\") ? parseFloat(i) / 100 * t : +i;\n  };\nfunction I(i, t, e) {\n  if (i && typeof i.call == \"function\") return i.apply(e, t);\n}\nfunction L(i, t, e, s) {\n  var n, o, r;\n  if (N(i)) for (o = i.length, n = 0; n < o; n++) t.call(e, i[n], n);else if (T(i)) for (r = Object.keys(i), o = r.length, n = 0; n < o; n++) t.call(e, i[r[n]], r[n]);\n}\nfunction je(i, t) {\n  var e, s, n, o;\n  if (!i || !t || i.length !== t.length) return !1;\n  for (e = 0, s = i.length; e < s; ++e) if (n = i[e], o = t[e], n.datasetIndex !== o.datasetIndex || n.index !== o.index) return !1;\n  return !0;\n}\nfunction $e(i) {\n  if (N(i)) return i.map($e);\n  if (T(i)) {\n    var t = /* @__PURE__ */Object.create(null),\n      e = Object.keys(i),\n      s = e.length;\n    var n = 0;\n    for (; n < s; ++n) t[e[n]] = $e(i[e[n]]);\n    return t;\n  }\n  return i;\n}\nfunction _n(i) {\n  return [\"__proto__\", \"prototype\", \"constructor\"].indexOf(i) === -1;\n}\nfunction Fo(i, t, e, s) {\n  if (!_n(i)) return;\n  var n = t[i],\n    o = e[i];\n  T(n) && T(o) ? fe(n, o, s) : t[i] = $e(o);\n}\nfunction fe(i, t, e) {\n  var s = N(t) ? t : [t],\n    n = s.length;\n  if (!T(i)) return i;\n  e = e || {};\n  var o = e.merger || Fo;\n  var r;\n  for (var a = 0; a < n; ++a) {\n    if (r = s[a], !T(r)) continue;\n    var l = Object.keys(r);\n    for (var c = 0, h = l.length; c < h; ++c) o(l[c], i, r, e);\n  }\n  return i;\n}\nfunction le(i, t) {\n  return fe(i, t, {\n    merger: Io\n  });\n}\nfunction Io(i, t, e) {\n  if (!_n(i)) return;\n  var s = t[i],\n    n = e[i];\n  T(s) && T(n) ? le(s, n) : Object.prototype.hasOwnProperty.call(t, i) || (t[i] = $e(n));\n}\nvar Zi = {\n  // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n  \"\": function _(i) {\n    return i;\n  },\n  // default resolvers\n  x: function x(i) {\n    return i.x;\n  },\n  y: function y(i) {\n    return i.y;\n  }\n};\nfunction zo(i) {\n  var t = i.split(\".\"),\n    e = [];\n  var s = \"\";\n  var _iterator = _createForOfIteratorHelper(t),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var n = _step.value;\n      s += n, s.endsWith(\"\\\\\") ? s = s.slice(0, -1) + \".\" : (e.push(s), s = \"\");\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return e;\n}\nfunction Bo(i) {\n  var t = zo(i);\n  return function (e) {\n    var _iterator2 = _createForOfIteratorHelper(t),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var s = _step2.value;\n        if (s === \"\") break;\n        e = e && e[s];\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return e;\n  };\n}\nfunction It(i, t) {\n  return (Zi[t] || (Zi[t] = Bo(t)))(i);\n}\nfunction Fi(i) {\n  return i.charAt(0).toUpperCase() + i.slice(1);\n}\nvar ge = function ge(i) {\n    return _typeof(i) < \"u\";\n  },\n  wt = function wt(i) {\n    return typeof i == \"function\";\n  },\n  Qi = function Qi(i, t) {\n    if (i.size !== t.size) return !1;\n    var _iterator3 = _createForOfIteratorHelper(i),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var e = _step3.value;\n        if (!t.has(e)) return !1;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return !0;\n  };\nfunction Ho(i) {\n  return i.type === \"mouseup\" || i.type === \"click\" || i.type === \"contextmenu\";\n}\nvar E = Math.PI,\n  B = 2 * E,\n  Wo = B + E,\n  Ye = Number.POSITIVE_INFINITY,\n  No = E / 180,\n  V = E / 2,\n  Ct = E / 4,\n  ts = E * 2 / 3,\n  xn = Math.log10,\n  lt = Math.sign;\nfunction ce(i, t, e) {\n  return Math.abs(i - t) < e;\n}\nfunction es(i) {\n  var t = Math.round(i);\n  i = ce(i, t, i / 1e3) ? t : i;\n  var e = Math.pow(10, Math.floor(xn(i))),\n    s = i / e;\n  return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * e;\n}\nfunction Vo(i) {\n  var t = [],\n    e = Math.sqrt(i);\n  var s;\n  for (s = 1; s < e; s++) i % s === 0 && (t.push(s), t.push(i / s));\n  return e === (e | 0) && t.push(e), t.sort(function (n, o) {\n    return n - o;\n  }).pop(), t;\n}\nfunction jo(i) {\n  return _typeof(i) == \"symbol\" || _typeof(i) == \"object\" && i !== null && !(Symbol.toPrimitive in i || \"toString\" in i || \"valueOf\" in i);\n}\nfunction Xt(i) {\n  return !jo(i) && !isNaN(parseFloat(i)) && isFinite(i);\n}\nfunction $o(i, t) {\n  var e = Math.round(i);\n  return e - t <= i && e + t >= i;\n}\nfunction Yo(i, t, e) {\n  var s, n, o;\n  for (s = 0, n = i.length; s < n; s++) o = i[s][e], isNaN(o) || (t.min = Math.min(t.min, o), t.max = Math.max(t.max, o));\n}\nfunction bt(i) {\n  return i * (E / 180);\n}\nfunction Uo(i) {\n  return i * (180 / E);\n}\nfunction is(i) {\n  if (!q(i)) return;\n  var t = 1,\n    e = 0;\n  for (; Math.round(i * t) / t !== i;) t *= 10, e++;\n  return e;\n}\nfunction yn(i, t) {\n  var e = t.x - i.x,\n    s = t.y - i.y,\n    n = Math.sqrt(e * e + s * s);\n  var o = Math.atan2(s, e);\n  return o < -0.5 * E && (o += B), {\n    angle: o,\n    distance: n\n  };\n}\nfunction vi(i, t) {\n  return Math.sqrt(Math.pow(t.x - i.x, 2) + Math.pow(t.y - i.y, 2));\n}\nfunction Xo(i, t) {\n  return (i - t + Wo) % B - E;\n}\nfunction Z(i) {\n  return (i % B + B) % B;\n}\nfunction pe(i, t, e, s) {\n  var n = Z(i),\n    o = Z(t),\n    r = Z(e),\n    a = Z(o - n),\n    l = Z(r - n),\n    c = Z(n - o),\n    h = Z(n - r);\n  return n === o || n === r || s && o === r || a > l && c < h;\n}\nfunction U(i, t, e) {\n  return Math.max(t, Math.min(e, i));\n}\nfunction qo(i) {\n  return U(i, -32768, 32767);\n}\nfunction _t(i, t, e) {\n  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-6;\n  return i >= Math.min(t, e) - s && i <= Math.max(t, e) + s;\n}\nfunction Ii(i, t, e) {\n  e = e || function (r) {\n    return i[r] < t;\n  };\n  var s = i.length - 1,\n    n = 0,\n    o;\n  for (; s - n > 1;) o = n + s >> 1, e(o) ? n = o : s = o;\n  return {\n    lo: n,\n    hi: s\n  };\n}\nvar Et = function Et(i, t, e, s) {\n    return Ii(i, e, s ? function (n) {\n      var o = i[n][t];\n      return o < e || o === e && i[n + 1][t] === e;\n    } : function (n) {\n      return i[n][t] < e;\n    });\n  },\n  Ko = function Ko(i, t, e) {\n    return Ii(i, e, function (s) {\n      return i[s][t] >= e;\n    });\n  };\nfunction Go(i, t, e) {\n  var s = 0,\n    n = i.length;\n  for (; s < n && i[s] < t;) s++;\n  for (; n > s && i[n - 1] > e;) n--;\n  return s > 0 || n < i.length ? i.slice(s, n) : i;\n}\nvar vn = [\"push\", \"pop\", \"shift\", \"splice\", \"unshift\"];\nfunction Jo(i, t) {\n  if (i._chartjs) {\n    i._chartjs.listeners.push(t);\n    return;\n  }\n  Object.defineProperty(i, \"_chartjs\", {\n    configurable: !0,\n    enumerable: !1,\n    value: {\n      listeners: [t]\n    }\n  }), vn.forEach(function (e) {\n    var s = \"_onData\" + Fi(e),\n      n = i[e];\n    Object.defineProperty(i, e, {\n      configurable: !0,\n      enumerable: !1,\n      value: function value() {\n        for (var _len = arguments.length, o = new Array(_len), _key = 0; _key < _len; _key++) {\n          o[_key] = arguments[_key];\n        }\n        var r = n.apply(this, o);\n        return i._chartjs.listeners.forEach(function (a) {\n          typeof a[s] == \"function\" && a[s].apply(a, o);\n        }), r;\n      }\n    });\n  });\n}\nfunction ss(i, t) {\n  var e = i._chartjs;\n  if (!e) return;\n  var s = e.listeners,\n    n = s.indexOf(t);\n  n !== -1 && s.splice(n, 1), !(s.length > 0) && (vn.forEach(function (o) {\n    delete i[o];\n  }), delete i._chartjs);\n}\nfunction Mn(i) {\n  var t = new Set(i);\n  return t.size === i.length ? i : Array.from(t);\n}\nvar Sn = function () {\n  return (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) > \"u\" ? function (i) {\n    return i();\n  } : window.requestAnimationFrame;\n}();\nfunction kn(i, t) {\n  var e = [],\n    s = !1;\n  return function () {\n    for (var _len2 = arguments.length, n = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      n[_key2] = arguments[_key2];\n    }\n    e = n, s || (s = !0, Sn.call(window, function () {\n      s = !1, i.apply(t, e);\n    }));\n  };\n}\nfunction Zo(i, t) {\n  var e;\n  return function () {\n    for (var _len3 = arguments.length, s = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      s[_key3] = arguments[_key3];\n    }\n    return t ? (clearTimeout(e), e = setTimeout(i, t, s)) : i.apply(this, s), t;\n  };\n}\nvar zi = function zi(i) {\n    return i === \"start\" ? \"left\" : i === \"end\" ? \"right\" : \"center\";\n  },\n  Y = function Y(i, t, e) {\n    return i === \"start\" ? t : i === \"end\" ? e : (t + e) / 2;\n  },\n  Qo = function Qo(i, t, e, s) {\n    return i === (s ? \"left\" : \"right\") ? e : i === \"center\" ? (t + e) / 2 : t;\n  };\nfunction wn(i, t, e) {\n  var s = t.length;\n  var n = 0,\n    o = s;\n  if (i._sorted) {\n    var r = i.iScale,\n      a = i.vScale,\n      l = i._parsed,\n      c = i.dataset && i.dataset.options ? i.dataset.options.spanGaps : null,\n      h = r.axis,\n      _r$getUserBounds = r.getUserBounds(),\n      d = _r$getUserBounds.min,\n      u = _r$getUserBounds.max,\n      f = _r$getUserBounds.minDefined,\n      p = _r$getUserBounds.maxDefined;\n    if (f) {\n      if (n = Math.min(\n      // @ts-expect-error Need to type _parsed\n      Et(l, h, d).lo,\n      // @ts-expect-error Need to fix types on _lookupByKey\n      e ? s : Et(t, h, r.getPixelForValue(d)).lo), c) {\n        var g = l.slice(0, n + 1).reverse().findIndex(function (m) {\n          return !R(m[a.axis]);\n        });\n        n -= Math.max(0, g);\n      }\n      n = U(n, 0, s - 1);\n    }\n    if (p) {\n      var _g = Math.max(\n      // @ts-expect-error Need to type _parsed\n      Et(l, r.axis, u, !0).hi + 1,\n      // @ts-expect-error Need to fix types on _lookupByKey\n      e ? 0 : Et(t, h, r.getPixelForValue(u), !0).hi + 1);\n      if (c) {\n        var m = l.slice(_g - 1).findIndex(function (b) {\n          return !R(b[a.axis]);\n        });\n        _g += Math.max(0, m);\n      }\n      o = U(_g, n, s) - n;\n    } else o = s - n;\n  }\n  return {\n    start: n,\n    count: o\n  };\n}\nfunction Pn(i) {\n  var t = i.xScale,\n    e = i.yScale,\n    s = i._scaleRanges,\n    n = {\n      xmin: t.min,\n      xmax: t.max,\n      ymin: e.min,\n      ymax: e.max\n    };\n  if (!s) return i._scaleRanges = n, !0;\n  var o = s.xmin !== t.min || s.xmax !== t.max || s.ymin !== e.min || s.ymax !== e.max;\n  return Object.assign(s, n), o;\n}\nvar ke = function ke(i) {\n    return i === 0 || i === 1;\n  },\n  ns = function ns(i, t, e) {\n    return -(Math.pow(2, 10 * (i -= 1)) * Math.sin((i - t) * B / e));\n  },\n  os = function os(i, t, e) {\n    return Math.pow(2, -10 * i) * Math.sin((i - t) * B / e) + 1;\n  },\n  he = {\n    linear: function linear(i) {\n      return i;\n    },\n    easeInQuad: function easeInQuad(i) {\n      return i * i;\n    },\n    easeOutQuad: function easeOutQuad(i) {\n      return -i * (i - 2);\n    },\n    easeInOutQuad: function easeInOutQuad(i) {\n      return (i /= 0.5) < 1 ? 0.5 * i * i : -0.5 * (--i * (i - 2) - 1);\n    },\n    easeInCubic: function easeInCubic(i) {\n      return i * i * i;\n    },\n    easeOutCubic: function easeOutCubic(i) {\n      return (i -= 1) * i * i + 1;\n    },\n    easeInOutCubic: function easeInOutCubic(i) {\n      return (i /= 0.5) < 1 ? 0.5 * i * i * i : 0.5 * ((i -= 2) * i * i + 2);\n    },\n    easeInQuart: function easeInQuart(i) {\n      return i * i * i * i;\n    },\n    easeOutQuart: function easeOutQuart(i) {\n      return -((i -= 1) * i * i * i - 1);\n    },\n    easeInOutQuart: function easeInOutQuart(i) {\n      return (i /= 0.5) < 1 ? 0.5 * i * i * i * i : -0.5 * ((i -= 2) * i * i * i - 2);\n    },\n    easeInQuint: function easeInQuint(i) {\n      return i * i * i * i * i;\n    },\n    easeOutQuint: function easeOutQuint(i) {\n      return (i -= 1) * i * i * i * i + 1;\n    },\n    easeInOutQuint: function easeInOutQuint(i) {\n      return (i /= 0.5) < 1 ? 0.5 * i * i * i * i * i : 0.5 * ((i -= 2) * i * i * i * i + 2);\n    },\n    easeInSine: function easeInSine(i) {\n      return -Math.cos(i * V) + 1;\n    },\n    easeOutSine: function easeOutSine(i) {\n      return Math.sin(i * V);\n    },\n    easeInOutSine: function easeInOutSine(i) {\n      return -0.5 * (Math.cos(E * i) - 1);\n    },\n    easeInExpo: function easeInExpo(i) {\n      return i === 0 ? 0 : Math.pow(2, 10 * (i - 1));\n    },\n    easeOutExpo: function easeOutExpo(i) {\n      return i === 1 ? 1 : -Math.pow(2, -10 * i) + 1;\n    },\n    easeInOutExpo: function easeInOutExpo(i) {\n      return ke(i) ? i : i < 0.5 ? 0.5 * Math.pow(2, 10 * (i * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (i * 2 - 1)) + 2);\n    },\n    easeInCirc: function easeInCirc(i) {\n      return i >= 1 ? i : -(Math.sqrt(1 - i * i) - 1);\n    },\n    easeOutCirc: function easeOutCirc(i) {\n      return Math.sqrt(1 - (i -= 1) * i);\n    },\n    easeInOutCirc: function easeInOutCirc(i) {\n      return (i /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - i * i) - 1) : 0.5 * (Math.sqrt(1 - (i -= 2) * i) + 1);\n    },\n    easeInElastic: function easeInElastic(i) {\n      return ke(i) ? i : ns(i, 0.075, 0.3);\n    },\n    easeOutElastic: function easeOutElastic(i) {\n      return ke(i) ? i : os(i, 0.075, 0.3);\n    },\n    easeInOutElastic: function easeInOutElastic(i) {\n      return ke(i) ? i : i < 0.5 ? 0.5 * ns(i * 2, 0.1125, 0.45) : 0.5 + 0.5 * os(i * 2 - 1, 0.1125, 0.45);\n    },\n    easeInBack: function easeInBack(i) {\n      return i * i * ((1.70158 + 1) * i - 1.70158);\n    },\n    easeOutBack: function easeOutBack(i) {\n      return (i -= 1) * i * ((1.70158 + 1) * i + 1.70158) + 1;\n    },\n    easeInOutBack: function easeInOutBack(i) {\n      var t = 1.70158;\n      return (i /= 0.5) < 1 ? 0.5 * (i * i * (((t *= 1.525) + 1) * i - t)) : 0.5 * ((i -= 2) * i * (((t *= 1.525) + 1) * i + t) + 2);\n    },\n    easeInBounce: function easeInBounce(i) {\n      return 1 - he.easeOutBounce(1 - i);\n    },\n    easeOutBounce: function easeOutBounce(i) {\n      return i < 1 / 2.75 ? 7.5625 * i * i : i < 2 / 2.75 ? 7.5625 * (i -= 1.5 / 2.75) * i + 0.75 : i < 2.5 / 2.75 ? 7.5625 * (i -= 2.25 / 2.75) * i + 0.9375 : 7.5625 * (i -= 2.625 / 2.75) * i + 0.984375;\n    },\n    easeInOutBounce: function easeInOutBounce(i) {\n      return i < 0.5 ? he.easeInBounce(i * 2) * 0.5 : he.easeOutBounce(i * 2 - 1) * 0.5 + 0.5;\n    }\n  };\nfunction Bi(i) {\n  if (i && _typeof(i) == \"object\") {\n    var t = i.toString();\n    return t === \"[object CanvasPattern]\" || t === \"[object CanvasGradient]\";\n  }\n  return !1;\n}\nfunction rs(i) {\n  return Bi(i) ? i : new ue(i);\n}\nfunction ni(i) {\n  return Bi(i) ? i : new ue(i).saturate(0.5).darken(0.1).hexString();\n}\nvar tr = [\"x\", \"y\", \"borderWidth\", \"radius\", \"tension\"],\n  er = [\"color\", \"borderColor\", \"backgroundColor\"];\nfunction ir(i) {\n  i.set(\"animation\", {\n    delay: void 0,\n    duration: 1e3,\n    easing: \"easeOutQuart\",\n    fn: void 0,\n    from: void 0,\n    loop: void 0,\n    to: void 0,\n    type: void 0\n  }), i.describe(\"animation\", {\n    _fallback: !1,\n    _indexable: !1,\n    _scriptable: function _scriptable(t) {\n      return t !== \"onProgress\" && t !== \"onComplete\" && t !== \"fn\";\n    }\n  }), i.set(\"animations\", {\n    colors: {\n      type: \"color\",\n      properties: er\n    },\n    numbers: {\n      type: \"number\",\n      properties: tr\n    }\n  }), i.describe(\"animations\", {\n    _fallback: \"animation\"\n  }), i.set(\"transitions\", {\n    active: {\n      animation: {\n        duration: 400\n      }\n    },\n    resize: {\n      animation: {\n        duration: 0\n      }\n    },\n    show: {\n      animations: {\n        colors: {\n          from: \"transparent\"\n        },\n        visible: {\n          type: \"boolean\",\n          duration: 0\n        }\n      }\n    },\n    hide: {\n      animations: {\n        colors: {\n          to: \"transparent\"\n        },\n        visible: {\n          type: \"boolean\",\n          easing: \"linear\",\n          fn: function fn(t) {\n            return t | 0;\n          }\n        }\n      }\n    }\n  });\n}\nfunction sr(i) {\n  i.set(\"layout\", {\n    autoPadding: !0,\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  });\n}\nvar as = /* @__PURE__ */new Map();\nfunction nr(i, t) {\n  t = t || {};\n  var e = i + JSON.stringify(t);\n  var s = as.get(e);\n  return s || (s = new Intl.NumberFormat(i, t), as.set(e, s)), s;\n}\nfunction Hi(i, t, e) {\n  return nr(t, e).format(i);\n}\nvar or = {\n  values: function values(i) {\n    return N(i) ? i : \"\" + i;\n  },\n  numeric: function numeric(i, t, e) {\n    if (i === 0) return \"0\";\n    var s = this.chart.options.locale;\n    var n,\n      o = i;\n    if (e.length > 1) {\n      var c = Math.max(Math.abs(e[0].value), Math.abs(e[e.length - 1].value));\n      (c < 1e-4 || c > 1e15) && (n = \"scientific\"), o = rr(i, e);\n    }\n    var r = xn(Math.abs(o)),\n      a = isNaN(r) ? 1 : Math.max(Math.min(-1 * Math.floor(r), 20), 0),\n      l = {\n        notation: n,\n        minimumFractionDigits: a,\n        maximumFractionDigits: a\n      };\n    return Object.assign(l, this.options.ticks.format), Hi(i, s, l);\n  }\n};\nfunction rr(i, t) {\n  var e = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;\n  return Math.abs(e) >= 1 && i !== Math.floor(i) && (e = i - Math.floor(i)), e;\n}\nvar Dn = {\n  formatters: or\n};\nfunction ar(i) {\n  i.set(\"scale\", {\n    display: !0,\n    offset: !1,\n    reverse: !1,\n    beginAtZero: !1,\n    bounds: \"ticks\",\n    clip: !0,\n    grace: 0,\n    grid: {\n      display: !0,\n      lineWidth: 1,\n      drawOnChartArea: !0,\n      drawTicks: !0,\n      tickLength: 8,\n      tickWidth: function tickWidth(t, e) {\n        return e.lineWidth;\n      },\n      tickColor: function tickColor(t, e) {\n        return e.color;\n      },\n      offset: !1\n    },\n    border: {\n      display: !0,\n      dash: [],\n      dashOffset: 0,\n      width: 1\n    },\n    title: {\n      display: !1,\n      text: \"\",\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n    ticks: {\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: !1,\n      textStrokeWidth: 0,\n      textStrokeColor: \"\",\n      padding: 3,\n      display: !0,\n      autoSkip: !0,\n      autoSkipPadding: 3,\n      labelOffset: 0,\n      callback: Dn.formatters.values,\n      minor: {},\n      major: {},\n      align: \"center\",\n      crossAlign: \"near\",\n      showLabelBackdrop: !1,\n      backdropColor: \"rgba(255, 255, 255, 0.75)\",\n      backdropPadding: 2\n    }\n  }), i.route(\"scale.ticks\", \"color\", \"\", \"color\"), i.route(\"scale.grid\", \"color\", \"\", \"borderColor\"), i.route(\"scale.border\", \"color\", \"\", \"borderColor\"), i.route(\"scale.title\", \"color\", \"\", \"color\"), i.describe(\"scale\", {\n    _fallback: !1,\n    _scriptable: function _scriptable(t) {\n      return !t.startsWith(\"before\") && !t.startsWith(\"after\") && t !== \"callback\" && t !== \"parser\";\n    },\n    _indexable: function _indexable(t) {\n      return t !== \"borderDash\" && t !== \"tickBorderDash\" && t !== \"dash\";\n    }\n  }), i.describe(\"scales\", {\n    _fallback: \"scale\"\n  }), i.describe(\"scale.ticks\", {\n    _scriptable: function _scriptable(t) {\n      return t !== \"backdropPadding\" && t !== \"callback\";\n    },\n    _indexable: function _indexable(t) {\n      return t !== \"backdropPadding\";\n    }\n  });\n}\nvar zt = /* @__PURE__ */Object.create(null),\n  Mi = /* @__PURE__ */Object.create(null);\nfunction de(i, t) {\n  if (!t) return i;\n  var e = t.split(\".\");\n  for (var s = 0, n = e.length; s < n; ++s) {\n    var o = e[s];\n    i = i[o] || (i[o] = /* @__PURE__ */Object.create(null));\n  }\n  return i;\n}\nfunction oi(i, t, e) {\n  return typeof t == \"string\" ? fe(de(i, t), e) : fe(de(i, \"\"), t);\n}\nvar lr = /*#__PURE__*/function () {\n  function lr(t, e) {\n    _classCallCheck(this, lr);\n    this.animation = void 0, this.backgroundColor = \"rgba(0,0,0,0.1)\", this.borderColor = \"rgba(0,0,0,0.1)\", this.color = \"#666\", this.datasets = {}, this.devicePixelRatio = function (s) {\n      return s.chart.platform.getDevicePixelRatio();\n    }, this.elements = {}, this.events = [\"mousemove\", \"mouseout\", \"click\", \"touchstart\", \"touchmove\"], this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: \"normal\",\n      lineHeight: 1.2,\n      weight: null\n    }, this.hover = {}, this.hoverBackgroundColor = function (s, n) {\n      return ni(n.backgroundColor);\n    }, this.hoverBorderColor = function (s, n) {\n      return ni(n.borderColor);\n    }, this.hoverColor = function (s, n) {\n      return ni(n.color);\n    }, this.indexAxis = \"x\", this.interaction = {\n      mode: \"nearest\",\n      intersect: !0,\n      includeInvisible: !1\n    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(e);\n  }\n  return _createClass(lr, [{\n    key: \"set\",\n    value: function set(t, e) {\n      return oi(this, t, e);\n    }\n  }, {\n    key: \"get\",\n    value: function get(t) {\n      return de(this, t);\n    }\n  }, {\n    key: \"describe\",\n    value: function describe(t, e) {\n      return oi(Mi, t, e);\n    }\n  }, {\n    key: \"override\",\n    value: function override(t, e) {\n      return oi(zt, t, e);\n    }\n  }, {\n    key: \"route\",\n    value: function route(t, e, s, n) {\n      var o = de(this, t),\n        r = de(this, s),\n        a = \"_\" + e;\n      Object.defineProperties(o, _defineProperty(_defineProperty({}, a, {\n        value: o[e],\n        writable: !0\n      }), e, {\n        enumerable: !0,\n        get: function get() {\n          var l = this[a],\n            c = r[n];\n          return T(l) ? Object.assign({}, c, l) : D(l, c);\n        },\n        set: function set(l) {\n          this[a] = l;\n        }\n      }));\n    }\n  }, {\n    key: \"apply\",\n    value: function apply(t) {\n      var _this2 = this;\n      t.forEach(function (e) {\n        return e(_this2);\n      });\n    }\n  }]);\n}();\nvar W = /* @__PURE__ */new lr({\n  _scriptable: function _scriptable(i) {\n    return !i.startsWith(\"on\");\n  },\n  _indexable: function _indexable(i) {\n    return i !== \"events\";\n  },\n  hover: {\n    _fallback: \"interaction\"\n  },\n  interaction: {\n    _scriptable: !1,\n    _indexable: !1\n  }\n}, [ir, sr, ar]);\nfunction cr(i) {\n  return !i || R(i.size) || R(i.family) ? null : (i.style ? i.style + \" \" : \"\") + (i.weight ? i.weight + \" \" : \"\") + i.size + \"px \" + i.family;\n}\nfunction ls(i, t, e, s, n) {\n  var o = t[n];\n  return o || (o = t[n] = i.measureText(n).width, e.push(n)), o > s && (s = o), s;\n}\nfunction Ot(i, t, e) {\n  var s = i.currentDevicePixelRatio,\n    n = e !== 0 ? Math.max(e / 2, 0.5) : 0;\n  return Math.round((t - n) * s) / s + n;\n}\nfunction cs(i, t) {\n  !t && !i || (t = t || i.getContext(\"2d\"), t.save(), t.resetTransform(), t.clearRect(0, 0, i.width, i.height), t.restore());\n}\nfunction Si(i, t, e, s) {\n  Cn(i, t, e, s, null);\n}\nfunction Cn(i, t, e, s, n) {\n  var o, r, a, l, c, h, d, u;\n  var f = t.pointStyle,\n    p = t.rotation,\n    g = t.radius;\n  var m = (p || 0) * No;\n  if (f && _typeof(f) == \"object\" && (o = f.toString(), o === \"[object HTMLImageElement]\" || o === \"[object HTMLCanvasElement]\")) {\n    i.save(), i.translate(e, s), i.rotate(m), i.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), i.restore();\n    return;\n  }\n  if (!(isNaN(g) || g <= 0)) {\n    switch (i.beginPath(), f) {\n      // Default includes circle\n      default:\n        n ? i.ellipse(e, s, n / 2, g, 0, 0, B) : i.arc(e, s, g, 0, B), i.closePath();\n        break;\n      case \"triangle\":\n        h = n ? n / 2 : g, i.moveTo(e + Math.sin(m) * h, s - Math.cos(m) * g), m += ts, i.lineTo(e + Math.sin(m) * h, s - Math.cos(m) * g), m += ts, i.lineTo(e + Math.sin(m) * h, s - Math.cos(m) * g), i.closePath();\n        break;\n      case \"rectRounded\":\n        c = g * 0.516, l = g - c, r = Math.cos(m + Ct) * l, d = Math.cos(m + Ct) * (n ? n / 2 - c : l), a = Math.sin(m + Ct) * l, u = Math.sin(m + Ct) * (n ? n / 2 - c : l), i.arc(e - d, s - a, c, m - E, m - V), i.arc(e + u, s - r, c, m - V, m), i.arc(e + d, s + a, c, m, m + V), i.arc(e - u, s + r, c, m + V, m + E), i.closePath();\n        break;\n      case \"rect\":\n        if (!p) {\n          l = Math.SQRT1_2 * g, h = n ? n / 2 : l, i.rect(e - h, s - l, 2 * h, 2 * l);\n          break;\n        }\n        m += Ct;\n      /* falls through */\n      case \"rectRot\":\n        d = Math.cos(m) * (n ? n / 2 : g), r = Math.cos(m) * g, a = Math.sin(m) * g, u = Math.sin(m) * (n ? n / 2 : g), i.moveTo(e - d, s - a), i.lineTo(e + u, s - r), i.lineTo(e + d, s + a), i.lineTo(e - u, s + r), i.closePath();\n        break;\n      case \"crossRot\":\n        m += Ct;\n      /* falls through */\n      case \"cross\":\n        d = Math.cos(m) * (n ? n / 2 : g), r = Math.cos(m) * g, a = Math.sin(m) * g, u = Math.sin(m) * (n ? n / 2 : g), i.moveTo(e - d, s - a), i.lineTo(e + d, s + a), i.moveTo(e + u, s - r), i.lineTo(e - u, s + r);\n        break;\n      case \"star\":\n        d = Math.cos(m) * (n ? n / 2 : g), r = Math.cos(m) * g, a = Math.sin(m) * g, u = Math.sin(m) * (n ? n / 2 : g), i.moveTo(e - d, s - a), i.lineTo(e + d, s + a), i.moveTo(e + u, s - r), i.lineTo(e - u, s + r), m += Ct, d = Math.cos(m) * (n ? n / 2 : g), r = Math.cos(m) * g, a = Math.sin(m) * g, u = Math.sin(m) * (n ? n / 2 : g), i.moveTo(e - d, s - a), i.lineTo(e + d, s + a), i.moveTo(e + u, s - r), i.lineTo(e - u, s + r);\n        break;\n      case \"line\":\n        r = n ? n / 2 : Math.cos(m) * g, a = Math.sin(m) * g, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a);\n        break;\n      case \"dash\":\n        i.moveTo(e, s), i.lineTo(e + Math.cos(m) * (n ? n / 2 : g), s + Math.sin(m) * g);\n        break;\n      case !1:\n        i.closePath();\n        break;\n    }\n    i.fill(), t.borderWidth > 0 && i.stroke();\n  }\n}\nfunction me(i, t, e) {\n  return e = e || 0.5, !t || i && i.x > t.left - e && i.x < t.right + e && i.y > t.top - e && i.y < t.bottom + e;\n}\nfunction Je(i, t) {\n  i.save(), i.beginPath(), i.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), i.clip();\n}\nfunction Ze(i) {\n  i.restore();\n}\nfunction hr(i, t, e, s, n) {\n  if (!t) return i.lineTo(e.x, e.y);\n  if (n === \"middle\") {\n    var o = (t.x + e.x) / 2;\n    i.lineTo(o, t.y), i.lineTo(o, e.y);\n  } else n === \"after\" != !!s ? i.lineTo(t.x, e.y) : i.lineTo(e.x, t.y);\n  i.lineTo(e.x, e.y);\n}\nfunction dr(i, t, e, s) {\n  if (!t) return i.lineTo(e.x, e.y);\n  i.bezierCurveTo(s ? t.cp1x : t.cp2x, s ? t.cp1y : t.cp2y, s ? e.cp2x : e.cp1x, s ? e.cp2y : e.cp1y, e.x, e.y);\n}\nfunction ur(i, t) {\n  t.translation && i.translate(t.translation[0], t.translation[1]), R(t.rotation) || i.rotate(t.rotation), t.color && (i.fillStyle = t.color), t.textAlign && (i.textAlign = t.textAlign), t.textBaseline && (i.textBaseline = t.textBaseline);\n}\nfunction fr(i, t, e, s, n) {\n  if (n.strikethrough || n.underline) {\n    var o = i.measureText(s),\n      r = t - o.actualBoundingBoxLeft,\n      a = t + o.actualBoundingBoxRight,\n      l = e - o.actualBoundingBoxAscent,\n      c = e + o.actualBoundingBoxDescent,\n      h = n.strikethrough ? (l + c) / 2 : c;\n    i.strokeStyle = i.fillStyle, i.beginPath(), i.lineWidth = n.decorationWidth || 2, i.moveTo(r, h), i.lineTo(a, h), i.stroke();\n  }\n}\nfunction gr(i, t) {\n  var e = i.fillStyle;\n  i.fillStyle = t.color, i.fillRect(t.left, t.top, t.width, t.height), i.fillStyle = e;\n}\nfunction be(i, t, e, s, n) {\n  var o = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n  var r = N(t) ? t : [t],\n    a = o.strokeWidth > 0 && o.strokeColor !== \"\";\n  var l, c;\n  for (i.save(), i.font = n.string, ur(i, o), l = 0; l < r.length; ++l) c = r[l], o.backdrop && gr(i, o.backdrop), a && (o.strokeColor && (i.strokeStyle = o.strokeColor), R(o.strokeWidth) || (i.lineWidth = o.strokeWidth), i.strokeText(c, e, s, o.maxWidth)), i.fillText(c, e, s, o.maxWidth), fr(i, e, s, c, o), s += Number(n.lineHeight);\n  i.restore();\n}\nfunction Ue(i, t) {\n  var e = t.x,\n    s = t.y,\n    n = t.w,\n    o = t.h,\n    r = t.radius;\n  i.arc(e + r.topLeft, s + r.topLeft, r.topLeft, 1.5 * E, E, !0), i.lineTo(e, s + o - r.bottomLeft), i.arc(e + r.bottomLeft, s + o - r.bottomLeft, r.bottomLeft, E, V, !0), i.lineTo(e + n - r.bottomRight, s + o), i.arc(e + n - r.bottomRight, s + o - r.bottomRight, r.bottomRight, V, 0, !0), i.lineTo(e + n, s + r.topRight), i.arc(e + n - r.topRight, s + r.topRight, r.topRight, 0, -V, !0), i.lineTo(e + r.topLeft, s);\n}\nvar pr = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/,\n  mr = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\nfunction br(i, t) {\n  var e = (\"\" + i).match(pr);\n  if (!e || e[1] === \"normal\") return t * 1.2;\n  switch (i = +e[2], e[3]) {\n    case \"px\":\n      return i;\n    case \"%\":\n      i /= 100;\n      break;\n  }\n  return t * i;\n}\nvar _r = function _r(i) {\n  return +i || 0;\n};\nfunction Wi(i, t) {\n  var e = {},\n    s = T(t),\n    n = s ? Object.keys(t) : t,\n    o = T(i) ? s ? function (r) {\n      return D(i[r], i[t[r]]);\n    } : function (r) {\n      return i[r];\n    } : function () {\n      return i;\n    };\n  var _iterator4 = _createForOfIteratorHelper(n),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var r = _step4.value;\n      e[r] = _r(o(r));\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return e;\n}\nfunction On(i) {\n  return Wi(i, {\n    top: \"y\",\n    right: \"x\",\n    bottom: \"y\",\n    left: \"x\"\n  });\n}\nfunction Yt(i) {\n  return Wi(i, [\"topLeft\", \"topRight\", \"bottomLeft\", \"bottomRight\"]);\n}\nfunction et(i) {\n  var t = On(i);\n  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;\n}\nfunction X(i, t) {\n  i = i || {}, t = t || W.font;\n  var e = D(i.size, t.size);\n  typeof e == \"string\" && (e = parseInt(e, 10));\n  var s = D(i.style, t.style);\n  s && !(\"\" + s).match(mr) && (console.warn('Invalid font style specified: \"' + s + '\"'), s = void 0);\n  var n = {\n    family: D(i.family, t.family),\n    lineHeight: br(D(i.lineHeight, t.lineHeight), e),\n    size: e,\n    style: s,\n    weight: D(i.weight, t.weight),\n    string: \"\"\n  };\n  return n.string = cr(n), n;\n}\nfunction we(i, t, e, s) {\n  var n, o, r;\n  for (n = 0, o = i.length; n < o; ++n) if (r = i[n], r !== void 0 && r !== void 0) return r;\n}\nfunction xr(i, t, e) {\n  var s = i.min,\n    n = i.max,\n    o = bn(t, (n - s) / 2),\n    r = function r(a, l) {\n      return e && a === 0 ? 0 : a + l;\n    };\n  return {\n    min: r(s, -Math.abs(o)),\n    max: r(n, o)\n  };\n}\nfunction Bt(i, t) {\n  return Object.assign(Object.create(i), t);\n}\nfunction Ni(i) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [\"\"];\n  var e = arguments.length > 2 ? arguments[2] : undefined;\n  var s = arguments.length > 3 ? arguments[3] : undefined;\n  var n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {\n    return i[0];\n  };\n  var o = e || i;\n  _typeof(s) > \"u\" && (s = Ln(\"_fallback\", i));\n  var r = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, Symbol.toStringTag, \"Object\"), \"_cacheable\", !0), \"_scopes\", i), \"_rootScopes\", o), \"_fallback\", s), \"_getTarget\", n), \"override\", function override(a) {\n    return Ni([a].concat(_toConsumableArray(i)), t, o, s);\n  });\n  return new Proxy(r, {\n    /**\n    * A trap for the delete operator.\n    */\n    deleteProperty: function deleteProperty(a, l) {\n      return delete a[l], delete a._keys, delete i[0][l], !0;\n    },\n    /**\n    * A trap for getting property values.\n    */\n    get: function get(a, l) {\n      return An(a, l, function () {\n        return Dr(l, t, i, a);\n      });\n    },\n    /**\n    * A trap for Object.getOwnPropertyDescriptor.\n    * Also used by Object.hasOwnProperty.\n    */\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(a, l) {\n      return Reflect.getOwnPropertyDescriptor(a._scopes[0], l);\n    },\n    /**\n    * A trap for Object.getPrototypeOf.\n    */\n    getPrototypeOf: function getPrototypeOf() {\n      return Reflect.getPrototypeOf(i[0]);\n    },\n    /**\n    * A trap for the in operator.\n    */\n    has: function has(a, l) {\n      return ds(a).includes(l);\n    },\n    /**\n    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n    */\n    ownKeys: function ownKeys(a) {\n      return ds(a);\n    },\n    /**\n    * A trap for setting property values.\n    */\n    set: function set(a, l, c) {\n      var h = a._storage || (a._storage = n());\n      return a[l] = h[l] = c, delete a._keys, !0;\n    }\n  });\n}\nfunction qt(i, t, e, s) {\n  var n = {\n    _cacheable: !1,\n    _proxy: i,\n    _context: t,\n    _subProxy: e,\n    _stack: /* @__PURE__ */new Set(),\n    _descriptors: Tn(i, s),\n    setContext: function setContext(o) {\n      return qt(i, o, e, s);\n    },\n    override: function override(o) {\n      return qt(i.override(o), t, e, s);\n    }\n  };\n  return new Proxy(n, {\n    /**\n    * A trap for the delete operator.\n    */\n    deleteProperty: function deleteProperty(o, r) {\n      return delete o[r], delete i[r], !0;\n    },\n    /**\n    * A trap for getting property values.\n    */\n    get: function get(o, r, a) {\n      return An(o, r, function () {\n        return vr(o, r, a);\n      });\n    },\n    /**\n    * A trap for Object.getOwnPropertyDescriptor.\n    * Also used by Object.hasOwnProperty.\n    */\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(o, r) {\n      return o._descriptors.allKeys ? Reflect.has(i, r) ? {\n        enumerable: !0,\n        configurable: !0\n      } : void 0 : Reflect.getOwnPropertyDescriptor(i, r);\n    },\n    /**\n    * A trap for Object.getPrototypeOf.\n    */\n    getPrototypeOf: function getPrototypeOf() {\n      return Reflect.getPrototypeOf(i);\n    },\n    /**\n    * A trap for the in operator.\n    */\n    has: function has(o, r) {\n      return Reflect.has(i, r);\n    },\n    /**\n    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n    */\n    ownKeys: function ownKeys() {\n      return Reflect.ownKeys(i);\n    },\n    /**\n    * A trap for setting property values.\n    */\n    set: function set(o, r, a) {\n      return i[r] = a, delete o[r], !0;\n    }\n  });\n}\nfunction Tn(i) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    scriptable: !0,\n    indexable: !0\n  };\n  var _i$_scriptable = i._scriptable,\n    e = _i$_scriptable === void 0 ? t.scriptable : _i$_scriptable,\n    _i$_indexable = i._indexable,\n    s = _i$_indexable === void 0 ? t.indexable : _i$_indexable,\n    _i$_allKeys = i._allKeys,\n    n = _i$_allKeys === void 0 ? t.allKeys : _i$_allKeys;\n  return {\n    allKeys: n,\n    scriptable: e,\n    indexable: s,\n    isScriptable: wt(e) ? e : function () {\n      return e;\n    },\n    isIndexable: wt(s) ? s : function () {\n      return s;\n    }\n  };\n}\nvar yr = function yr(i, t) {\n    return i ? i + Fi(t) : t;\n  },\n  Vi = function Vi(i, t) {\n    return T(t) && i !== \"adapters\" && (Object.getPrototypeOf(t) === null || t.constructor === Object);\n  };\nfunction An(i, t, e) {\n  if (Object.prototype.hasOwnProperty.call(i, t) || t === \"constructor\") return i[t];\n  var s = e();\n  return i[t] = s, s;\n}\nfunction vr(i, t, e) {\n  var s = i._proxy,\n    n = i._context,\n    o = i._subProxy,\n    r = i._descriptors;\n  var a = s[t];\n  return wt(a) && r.isScriptable(t) && (a = Mr(t, a, i, e)), N(a) && a.length && (a = Sr(t, a, i, r.isIndexable)), Vi(t, a) && (a = qt(a, n, o && o[t], r)), a;\n}\nfunction Mr(i, t, e, s) {\n  var n = e._proxy,\n    o = e._context,\n    r = e._subProxy,\n    a = e._stack;\n  if (a.has(i)) throw new Error(\"Recursion detected: \" + Array.from(a).join(\"->\") + \"->\" + i);\n  a.add(i);\n  var l = t(o, r || s);\n  return a[\"delete\"](i), Vi(i, l) && (l = ji(n._scopes, n, i, l)), l;\n}\nfunction Sr(i, t, e, s) {\n  var n = e._proxy,\n    o = e._context,\n    r = e._subProxy,\n    a = e._descriptors;\n  if (_typeof(o.index) < \"u\" && s(i)) return t[o.index % t.length];\n  if (T(t[0])) {\n    var l = t,\n      c = n._scopes.filter(function (h) {\n        return h !== l;\n      });\n    t = [];\n    var _iterator5 = _createForOfIteratorHelper(l),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var h = _step5.value;\n        var d = ji(c, n, i, h);\n        t.push(qt(d, o, r && r[i], a));\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  }\n  return t;\n}\nfunction Rn(i, t, e) {\n  return wt(i) ? i(t, e) : i;\n}\nvar kr = function kr(i, t) {\n  return i === !0 ? t : typeof i == \"string\" ? It(t, i) : void 0;\n};\nfunction wr(i, t, e, s, n) {\n  var _iterator6 = _createForOfIteratorHelper(t),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var o = _step6.value;\n      var r = kr(e, o);\n      if (r) {\n        i.add(r);\n        var a = Rn(r._fallback, e, n);\n        if (_typeof(a) < \"u\" && a !== e && a !== s) return a;\n      } else if (r === !1 && _typeof(s) < \"u\" && e !== s) return null;\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  return !1;\n}\nfunction ji(i, t, e, s) {\n  var n = t._rootScopes,\n    o = Rn(t._fallback, e, s),\n    r = [].concat(_toConsumableArray(i), _toConsumableArray(n)),\n    a = /* @__PURE__ */new Set();\n  a.add(s);\n  var l = hs(a, r, e, o || e, s);\n  return l === null || _typeof(o) < \"u\" && o !== e && (l = hs(a, r, o, l, s), l === null) ? !1 : Ni(Array.from(a), [\"\"], n, o, function () {\n    return Pr(t, e, s);\n  });\n}\nfunction hs(i, t, e, s, n) {\n  for (; e;) e = wr(i, t, e, s, n);\n  return e;\n}\nfunction Pr(i, t, e) {\n  var s = i._getTarget();\n  t in s || (s[t] = {});\n  var n = s[t];\n  return N(n) && T(e) ? e : n || {};\n}\nfunction Dr(i, t, e, s) {\n  var n;\n  var _iterator7 = _createForOfIteratorHelper(t),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var o = _step7.value;\n      if (n = Ln(yr(o, i), e), _typeof(n) < \"u\") return Vi(i, n) ? ji(e, s, i, n) : n;\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n}\nfunction Ln(i, t) {\n  var _iterator8 = _createForOfIteratorHelper(t),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var e = _step8.value;\n      if (!e) continue;\n      var s = e[i];\n      if (_typeof(s) < \"u\") return s;\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n}\nfunction ds(i) {\n  var t = i._keys;\n  return t || (t = i._keys = Cr(i._scopes)), t;\n}\nfunction Cr(i) {\n  var t = /* @__PURE__ */new Set();\n  var _iterator9 = _createForOfIteratorHelper(i),\n    _step9;\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var e = _step9.value;\n      var _iterator0 = _createForOfIteratorHelper(Object.keys(e).filter(function (n) {\n          return !n.startsWith(\"_\");\n        })),\n        _step0;\n      try {\n        for (_iterator0.s(); !(_step0 = _iterator0.n()).done;) {\n          var s = _step0.value;\n          t.add(s);\n        }\n      } catch (err) {\n        _iterator0.e(err);\n      } finally {\n        _iterator0.f();\n      }\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n  return Array.from(t);\n}\nvar Or = Number.EPSILON || 1e-14,\n  Kt = function Kt(i, t) {\n    return t < i.length && !i[t].skip && i[t];\n  },\n  En = function En(i) {\n    return i === \"x\" ? \"y\" : \"x\";\n  };\nfunction Tr(i, t, e, s) {\n  var n = i.skip ? t : i,\n    o = t,\n    r = e.skip ? t : e,\n    a = vi(o, n),\n    l = vi(r, o);\n  var c = a / (a + l),\n    h = l / (a + l);\n  c = isNaN(c) ? 0 : c, h = isNaN(h) ? 0 : h;\n  var d = s * c,\n    u = s * h;\n  return {\n    previous: {\n      x: o.x - d * (r.x - n.x),\n      y: o.y - d * (r.y - n.y)\n    },\n    next: {\n      x: o.x + u * (r.x - n.x),\n      y: o.y + u * (r.y - n.y)\n    }\n  };\n}\nfunction Ar(i, t, e) {\n  var s = i.length;\n  var n,\n    o,\n    r,\n    a,\n    l,\n    c = Kt(i, 0);\n  for (var h = 0; h < s - 1; ++h) if (l = c, c = Kt(i, h + 1), !(!l || !c)) {\n    if (ce(t[h], 0, Or)) {\n      e[h] = e[h + 1] = 0;\n      continue;\n    }\n    n = e[h] / t[h], o = e[h + 1] / t[h], a = Math.pow(n, 2) + Math.pow(o, 2), !(a <= 9) && (r = 3 / Math.sqrt(a), e[h] = n * r * t[h], e[h + 1] = o * r * t[h]);\n  }\n}\nfunction Rr(i, t) {\n  var e = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"x\";\n  var s = En(e),\n    n = i.length;\n  var o,\n    r,\n    a,\n    l = Kt(i, 0);\n  for (var c = 0; c < n; ++c) {\n    if (r = a, a = l, l = Kt(i, c + 1), !a) continue;\n    var h = a[e],\n      d = a[s];\n    r && (o = (h - r[e]) / 3, a[\"cp1\".concat(e)] = h - o, a[\"cp1\".concat(s)] = d - o * t[c]), l && (o = (l[e] - h) / 3, a[\"cp2\".concat(e)] = h + o, a[\"cp2\".concat(s)] = d + o * t[c]);\n  }\n}\nfunction Lr(i) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"x\";\n  var e = En(t),\n    s = i.length,\n    n = Array(s).fill(0),\n    o = Array(s);\n  var r,\n    a,\n    l,\n    c = Kt(i, 0);\n  for (r = 0; r < s; ++r) if (a = l, l = c, c = Kt(i, r + 1), !!l) {\n    if (c) {\n      var h = c[t] - l[t];\n      n[r] = h !== 0 ? (c[e] - l[e]) / h : 0;\n    }\n    o[r] = a ? c ? lt(n[r - 1]) !== lt(n[r]) ? 0 : (n[r - 1] + n[r]) / 2 : n[r - 1] : n[r];\n  }\n  Ar(i, n, o), Rr(i, o, t);\n}\nfunction Pe(i, t, e) {\n  return Math.max(Math.min(i, e), t);\n}\nfunction Er(i, t) {\n  var e,\n    s,\n    n,\n    o,\n    r,\n    a = me(i[0], t);\n  for (e = 0, s = i.length; e < s; ++e) r = o, o = a, a = e < s - 1 && me(i[e + 1], t), o && (n = i[e], r && (n.cp1x = Pe(n.cp1x, t.left, t.right), n.cp1y = Pe(n.cp1y, t.top, t.bottom)), a && (n.cp2x = Pe(n.cp2x, t.left, t.right), n.cp2y = Pe(n.cp2y, t.top, t.bottom)));\n}\nfunction Fr(i, t, e, s, n) {\n  var o, r, a, l;\n  if (t.spanGaps && (i = i.filter(function (c) {\n    return !c.skip;\n  })), t.cubicInterpolationMode === \"monotone\") Lr(i, n);else {\n    var c = s ? i[i.length - 1] : i[0];\n    for (o = 0, r = i.length; o < r; ++o) a = i[o], l = Tr(c, a, i[Math.min(o + 1, r - (s ? 0 : 1)) % r], t.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, c = a;\n  }\n  t.capBezierPoints && Er(i, e);\n}\nfunction $i() {\n  return (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) < \"u\" && (typeof document === \"undefined\" ? \"undefined\" : _typeof(document)) < \"u\";\n}\nfunction Yi(i) {\n  var t = i.parentNode;\n  return t && t.toString() === \"[object ShadowRoot]\" && (t = t.host), t;\n}\nfunction Xe(i, t, e) {\n  var s;\n  return typeof i == \"string\" ? (s = parseInt(i, 10), i.indexOf(\"%\") !== -1 && (s = s / 100 * t.parentNode[e])) : s = i, s;\n}\nvar Qe = function Qe(i) {\n  return i.ownerDocument.defaultView.getComputedStyle(i, null);\n};\nfunction Ir(i, t) {\n  return Qe(i).getPropertyValue(t);\n}\nvar zr = [\"top\", \"right\", \"bottom\", \"left\"];\nfunction Ft(i, t, e) {\n  var s = {};\n  e = e ? \"-\" + e : \"\";\n  for (var n = 0; n < 4; n++) {\n    var o = zr[n];\n    s[o] = parseFloat(i[t + \"-\" + o + e]) || 0;\n  }\n  return s.width = s.left + s.right, s.height = s.top + s.bottom, s;\n}\nvar Br = function Br(i, t, e) {\n  return (i > 0 || t > 0) && (!e || !e.shadowRoot);\n};\nfunction Hr(i, t) {\n  var e = i.touches,\n    s = e && e.length ? e[0] : i,\n    n = s.offsetX,\n    o = s.offsetY;\n  var r = !1,\n    a,\n    l;\n  if (Br(n, o, i.target)) a = n, l = o;else {\n    var c = t.getBoundingClientRect();\n    a = s.clientX - c.left, l = s.clientY - c.top, r = !0;\n  }\n  return {\n    x: a,\n    y: l,\n    box: r\n  };\n}\nfunction At(i, t) {\n  if (\"native\" in i) return i;\n  var e = t.canvas,\n    s = t.currentDevicePixelRatio,\n    n = Qe(e),\n    o = n.boxSizing === \"border-box\",\n    r = Ft(n, \"padding\"),\n    a = Ft(n, \"border\", \"width\"),\n    _Hr = Hr(i, e),\n    l = _Hr.x,\n    c = _Hr.y,\n    h = _Hr.box,\n    d = r.left + (h && a.left),\n    u = r.top + (h && a.top);\n  var f = t.width,\n    p = t.height;\n  return o && (f -= r.width + a.width, p -= r.height + a.height), {\n    x: Math.round((l - d) / f * e.width / s),\n    y: Math.round((c - u) / p * e.height / s)\n  };\n}\nfunction Wr(i, t, e) {\n  var s, n;\n  if (t === void 0 || e === void 0) {\n    var o = i && Yi(i);\n    if (!o) t = i.clientWidth, e = i.clientHeight;else {\n      var r = o.getBoundingClientRect(),\n        a = Qe(o),\n        l = Ft(a, \"border\", \"width\"),\n        c = Ft(a, \"padding\");\n      t = r.width - c.width - l.width, e = r.height - c.height - l.height, s = Xe(a.maxWidth, o, \"clientWidth\"), n = Xe(a.maxHeight, o, \"clientHeight\");\n    }\n  }\n  return {\n    width: t,\n    height: e,\n    maxWidth: s || Ye,\n    maxHeight: n || Ye\n  };\n}\nvar yt = function yt(i) {\n  return Math.round(i * 10) / 10;\n};\nfunction Nr(i, t, e, s) {\n  var n = Qe(i),\n    o = Ft(n, \"margin\"),\n    r = Xe(n.maxWidth, i, \"clientWidth\") || Ye,\n    a = Xe(n.maxHeight, i, \"clientHeight\") || Ye,\n    l = Wr(i, t, e);\n  var c = l.width,\n    h = l.height;\n  if (n.boxSizing === \"content-box\") {\n    var u = Ft(n, \"border\", \"width\"),\n      f = Ft(n, \"padding\");\n    c -= f.width + u.width, h -= f.height + u.height;\n  }\n  return c = Math.max(0, c - o.width), h = Math.max(0, s ? c / s : h - o.height), c = yt(Math.min(c, r, l.maxWidth)), h = yt(Math.min(h, a, l.maxHeight)), c && !h && (h = yt(c / 2)), (t !== void 0 || e !== void 0) && s && l.height && h > l.height && (h = l.height, c = yt(Math.floor(h * s))), {\n    width: c,\n    height: h\n  };\n}\nfunction us(i, t, e) {\n  var s = t || 1,\n    n = yt(i.height * s),\n    o = yt(i.width * s);\n  i.height = yt(i.height), i.width = yt(i.width);\n  var r = i.canvas;\n  return r.style && (e || !r.style.height && !r.style.width) && (r.style.height = \"\".concat(i.height, \"px\"), r.style.width = \"\".concat(i.width, \"px\")), i.currentDevicePixelRatio !== s || r.height !== n || r.width !== o ? (i.currentDevicePixelRatio = s, r.height = n, r.width = o, i.ctx.setTransform(s, 0, 0, s, 0, 0), !0) : !1;\n}\nvar Vr = function () {\n  var i = !1;\n  try {\n    var t = {\n      get passive() {\n        return i = !0, !1;\n      }\n    };\n    $i() && (window.addEventListener(\"test\", null, t), window.removeEventListener(\"test\", null, t));\n  } catch (_unused) {}\n  return i;\n}();\nfunction fs(i, t) {\n  var e = Ir(i, t),\n    s = e && e.match(/^(\\d+)(\\.\\d+)?px$/);\n  return s ? +s[1] : void 0;\n}\nfunction Rt(i, t, e, s) {\n  return {\n    x: i.x + e * (t.x - i.x),\n    y: i.y + e * (t.y - i.y)\n  };\n}\nfunction jr(i, t, e, s) {\n  return {\n    x: i.x + e * (t.x - i.x),\n    y: s === \"middle\" ? e < 0.5 ? i.y : t.y : s === \"after\" ? e < 1 ? i.y : t.y : e > 0 ? t.y : i.y\n  };\n}\nfunction $r(i, t, e, s) {\n  var n = {\n      x: i.cp2x,\n      y: i.cp2y\n    },\n    o = {\n      x: t.cp1x,\n      y: t.cp1y\n    },\n    r = Rt(i, n, e),\n    a = Rt(n, o, e),\n    l = Rt(o, t, e),\n    c = Rt(r, a, e),\n    h = Rt(a, l, e);\n  return Rt(c, h, e);\n}\nvar Yr = function Yr(i, t) {\n    return {\n      x: function x(e) {\n        return i + i + t - e;\n      },\n      setWidth: function setWidth(e) {\n        t = e;\n      },\n      textAlign: function textAlign(e) {\n        return e === \"center\" ? e : e === \"right\" ? \"left\" : \"right\";\n      },\n      xPlus: function xPlus(e, s) {\n        return e - s;\n      },\n      leftForLtr: function leftForLtr(e, s) {\n        return e - s;\n      }\n    };\n  },\n  Ur = function Ur() {\n    return {\n      x: function x(i) {\n        return i;\n      },\n      setWidth: function setWidth(i) {},\n      textAlign: function textAlign(i) {\n        return i;\n      },\n      xPlus: function xPlus(i, t) {\n        return i + t;\n      },\n      leftForLtr: function leftForLtr(i, t) {\n        return i;\n      }\n    };\n  };\nfunction Ut(i, t, e) {\n  return i ? Yr(t, e) : Ur();\n}\nfunction Fn(i, t) {\n  var e, s;\n  (t === \"ltr\" || t === \"rtl\") && (e = i.canvas.style, s = [e.getPropertyValue(\"direction\"), e.getPropertyPriority(\"direction\")], e.setProperty(\"direction\", t, \"important\"), i.prevTextDirection = s);\n}\nfunction In(i, t) {\n  t !== void 0 && (delete i.prevTextDirection, i.canvas.style.setProperty(\"direction\", t[0], t[1]));\n}\nfunction zn(i) {\n  return i === \"angle\" ? {\n    between: pe,\n    compare: Xo,\n    normalize: Z\n  } : {\n    between: _t,\n    compare: function compare(t, e) {\n      return t - e;\n    },\n    normalize: function normalize(t) {\n      return t;\n    }\n  };\n}\nfunction gs(_ref) {\n  var i = _ref.start,\n    t = _ref.end,\n    e = _ref.count,\n    s = _ref.loop,\n    n = _ref.style;\n  return {\n    start: i % e,\n    end: t % e,\n    loop: s && (t - i + 1) % e === 0,\n    style: n\n  };\n}\nfunction Xr(i, t, e) {\n  var s = e.property,\n    n = e.start,\n    o = e.end,\n    _zn = zn(s),\n    r = _zn.between,\n    a = _zn.normalize,\n    l = t.length;\n  var c = i.start,\n    h = i.end,\n    d = i.loop,\n    u,\n    f;\n  if (d) {\n    for (c += l, h += l, u = 0, f = l; u < f && r(a(t[c % l][s]), n, o); ++u) c--, h--;\n    c %= l, h %= l;\n  }\n  return h < c && (h += l), {\n    start: c,\n    end: h,\n    loop: d,\n    style: i.style\n  };\n}\nfunction Bn(i, t, e) {\n  if (!e) return [i];\n  var s = e.property,\n    n = e.start,\n    o = e.end,\n    r = t.length,\n    _zn2 = zn(s),\n    a = _zn2.compare,\n    l = _zn2.between,\n    c = _zn2.normalize,\n    _Xr = Xr(i, t, e),\n    h = _Xr.start,\n    d = _Xr.end,\n    u = _Xr.loop,\n    f = _Xr.style,\n    p = [];\n  var g = !1,\n    m = null,\n    b,\n    _,\n    v;\n  var y = function y() {\n      return l(n, v, b) && a(n, v) !== 0;\n    },\n    x = function x() {\n      return a(o, b) === 0 || l(o, v, b);\n    },\n    M = function M() {\n      return g || y();\n    },\n    S = function S() {\n      return !g || x();\n    };\n  for (var k = h, P = h; k <= d; ++k) _ = t[k % r], !_.skip && (b = c(_[s]), b !== v && (g = l(b, n, o), m === null && M() && (m = a(b, n) === 0 ? k : P), m !== null && S() && (p.push(gs({\n    start: m,\n    end: k,\n    loop: u,\n    count: r,\n    style: f\n  })), m = null), P = k, v = b));\n  return m !== null && p.push(gs({\n    start: m,\n    end: d,\n    loop: u,\n    count: r,\n    style: f\n  })), p;\n}\nfunction Hn(i, t) {\n  var e = [],\n    s = i.segments;\n  for (var n = 0; n < s.length; n++) {\n    var o = Bn(s[n], i.points, t);\n    o.length && e.push.apply(e, _toConsumableArray(o));\n  }\n  return e;\n}\nfunction qr(i, t, e, s) {\n  var n = 0,\n    o = t - 1;\n  if (e && !s) for (; n < t && !i[n].skip;) n++;\n  for (; n < t && i[n].skip;) n++;\n  for (n %= t, e && (o += n); o > n && i[o % t].skip;) o--;\n  return o %= t, {\n    start: n,\n    end: o\n  };\n}\nfunction Kr(i, t, e, s) {\n  var n = i.length,\n    o = [];\n  var r = t,\n    a = i[t],\n    l;\n  for (l = t + 1; l <= e; ++l) {\n    var c = i[l % n];\n    c.skip || c.stop ? a.skip || (s = !1, o.push({\n      start: t % n,\n      end: (l - 1) % n,\n      loop: s\n    }), t = r = c.stop ? l : null) : (r = l, a.skip && (t = l)), a = c;\n  }\n  return r !== null && o.push({\n    start: t % n,\n    end: r % n,\n    loop: s\n  }), o;\n}\nfunction Gr(i, t) {\n  var e = i.points,\n    s = i.options.spanGaps,\n    n = e.length;\n  if (!n) return [];\n  var o = !!i._loop,\n    _qr = qr(e, n, o, s),\n    r = _qr.start,\n    a = _qr.end;\n  if (s === !0) return ps(i, [{\n    start: r,\n    end: a,\n    loop: o\n  }], e, t);\n  var l = a < r ? a + n : a,\n    c = !!i._fullLoop && r === 0 && a === n - 1;\n  return ps(i, Kr(e, r, l, c), e, t);\n}\nfunction ps(i, t, e, s) {\n  return !s || !s.setContext || !e ? t : Jr(i, t, e, s);\n}\nfunction Jr(i, t, e, s) {\n  var n = i._chart.getContext(),\n    o = ms(i.options),\n    r = i._datasetIndex,\n    a = i.options.spanGaps,\n    l = e.length,\n    c = [];\n  var h = o,\n    d = t[0].start,\n    u = d;\n  function f(p, g, m, b) {\n    var _ = a ? -1 : 1;\n    if (p !== g) {\n      for (p += l; e[p % l].skip;) p -= _;\n      for (; e[g % l].skip;) g += _;\n      p % l !== g % l && (c.push({\n        start: p % l,\n        end: g % l,\n        loop: m,\n        style: b\n      }), h = b, d = g % l);\n    }\n  }\n  var _iterator1 = _createForOfIteratorHelper(t),\n    _step1;\n  try {\n    for (_iterator1.s(); !(_step1 = _iterator1.n()).done;) {\n      var p = _step1.value;\n      d = a ? d : p.start;\n      var g = e[d % l],\n        m = void 0;\n      for (u = d + 1; u <= p.end; u++) {\n        var b = e[u % l];\n        m = ms(s.setContext(Bt(n, {\n          type: \"segment\",\n          p0: g,\n          p1: b,\n          p0DataIndex: (u - 1) % l,\n          p1DataIndex: u % l,\n          datasetIndex: r\n        }))), Zr(m, h) && f(d, u - 1, p.loop, h), g = b, h = m;\n      }\n      d < u - 1 && f(d, u - 1, p.loop, h);\n    }\n  } catch (err) {\n    _iterator1.e(err);\n  } finally {\n    _iterator1.f();\n  }\n  return c;\n}\nfunction ms(i) {\n  return {\n    backgroundColor: i.backgroundColor,\n    borderCapStyle: i.borderCapStyle,\n    borderDash: i.borderDash,\n    borderDashOffset: i.borderDashOffset,\n    borderJoinStyle: i.borderJoinStyle,\n    borderWidth: i.borderWidth,\n    borderColor: i.borderColor\n  };\n}\nfunction Zr(i, t) {\n  if (!t) return !1;\n  var e = [],\n    s = function s(n, o) {\n      return Bi(o) ? (e.includes(o) || e.push(o), e.indexOf(o)) : o;\n    };\n  return JSON.stringify(i, s) !== JSON.stringify(t, s);\n}\nfunction De(i, t, e) {\n  return i.options.clip ? i[e] : t[e];\n}\nfunction Qr(i, t) {\n  var e = i.xScale,\n    s = i.yScale;\n  return e && s ? {\n    left: De(e, t, \"left\"),\n    right: De(e, t, \"right\"),\n    top: De(s, t, \"top\"),\n    bottom: De(s, t, \"bottom\")\n  } : t;\n}\nfunction Wn(i, t) {\n  var e = t._clip;\n  if (e.disabled) return !1;\n  var s = Qr(t, i.chartArea);\n  return {\n    left: e.left === !1 ? 0 : s.left - (e.left === !0 ? 0 : e.left),\n    right: e.right === !1 ? i.width : s.right + (e.right === !0 ? 0 : e.right),\n    top: e.top === !1 ? 0 : s.top - (e.top === !0 ? 0 : e.top),\n    bottom: e.bottom === !1 ? i.height : s.bottom + (e.bottom === !0 ? 0 : e.bottom)\n  };\n}\n/*!\n * Chart.js v4.5.1\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */\nvar ta = /*#__PURE__*/function () {\n  function ta() {\n    _classCallCheck(this, ta);\n    this._request = null, this._charts = /* @__PURE__ */new Map(), this._running = !1, this._lastDate = void 0;\n  }\n  return _createClass(ta, [{\n    key: \"_notify\",\n    value: function _notify(t, e, s, n) {\n      var o = e.listeners[n],\n        r = e.duration;\n      o.forEach(function (a) {\n        return a({\n          chart: t,\n          initial: e.initial,\n          numSteps: r,\n          currentStep: Math.min(s - e.start, r)\n        });\n      });\n    }\n  }, {\n    key: \"_refresh\",\n    value: function _refresh() {\n      var _this3 = this;\n      this._request || (this._running = !0, this._request = Sn.call(window, function () {\n        _this3._update(), _this3._request = null, _this3._running && _this3._refresh();\n      }));\n    }\n  }, {\n    key: \"_update\",\n    value: function _update() {\n      var _this4 = this;\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Date.now();\n      var e = 0;\n      this._charts.forEach(function (s, n) {\n        if (!s.running || !s.items.length) return;\n        var o = s.items;\n        var r = o.length - 1,\n          a = !1,\n          l;\n        for (; r >= 0; --r) l = o[r], l._active ? (l._total > s.duration && (s.duration = l._total), l.tick(t), a = !0) : (o[r] = o[o.length - 1], o.pop());\n        a && (n.draw(), _this4._notify(n, s, t, \"progress\")), o.length || (s.running = !1, _this4._notify(n, s, t, \"complete\"), s.initial = !1), e += o.length;\n      }), this._lastDate = t, e === 0 && (this._running = !1);\n    }\n  }, {\n    key: \"_getAnims\",\n    value: function _getAnims(t) {\n      var e = this._charts;\n      var s = e.get(t);\n      return s || (s = {\n        running: !1,\n        initial: !0,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      }, e.set(t, s)), s;\n    }\n  }, {\n    key: \"listen\",\n    value: function listen(t, e, s) {\n      this._getAnims(t).listeners[e].push(s);\n    }\n  }, {\n    key: \"add\",\n    value: function add(t, e) {\n      var _this$_getAnims$items;\n      !e || !e.length || (_this$_getAnims$items = this._getAnims(t).items).push.apply(_this$_getAnims$items, _toConsumableArray(e));\n    }\n  }, {\n    key: \"has\",\n    value: function has(t) {\n      return this._getAnims(t).items.length > 0;\n    }\n  }, {\n    key: \"start\",\n    value: function start(t) {\n      var e = this._charts.get(t);\n      e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(function (s, n) {\n        return Math.max(s, n._duration);\n      }, 0), this._refresh());\n    }\n  }, {\n    key: \"running\",\n    value: function running(t) {\n      if (!this._running) return !1;\n      var e = this._charts.get(t);\n      return !(!e || !e.running || !e.items.length);\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(t) {\n      var e = this._charts.get(t);\n      if (!e || !e.items.length) return;\n      var s = e.items;\n      var n = s.length - 1;\n      for (; n >= 0; --n) s[n].cancel();\n      e.items = [], this._notify(t, e, Date.now(), \"complete\");\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(t) {\n      return this._charts[\"delete\"](t);\n    }\n  }]);\n}();\nvar ut = /* @__PURE__ */new ta();\nvar bs = \"transparent\",\n  ea = {\n    \"boolean\": function boolean(i, t, e) {\n      return e > 0.5 ? t : i;\n    },\n    color: function color(i, t, e) {\n      var s = rs(i || bs),\n        n = s.valid && rs(t || bs);\n      return n && n.valid ? n.mix(s, e).hexString() : t;\n    },\n    number: function number(i, t, e) {\n      return i + (t - i) * e;\n    }\n  };\nvar ia = /*#__PURE__*/function () {\n  function ia(t, e, s, n) {\n    _classCallCheck(this, ia);\n    var o = e[s];\n    n = we([t.to, n, o, t.from]);\n    var r = we([t.from, o, n]);\n    this._active = !0, this._fn = t.fn || ea[t.type || _typeof(r)], this._easing = he[t.easing] || he.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = s, this._from = r, this._to = n, this._promises = void 0;\n  }\n  return _createClass(ia, [{\n    key: \"active\",\n    value: function active() {\n      return this._active;\n    }\n  }, {\n    key: \"update\",\n    value: function update(t, e, s) {\n      if (this._active) {\n        this._notify(!1);\n        var n = this._target[this._prop],\n          o = s - this._start,\n          r = this._duration - o;\n        this._start = s, this._duration = Math.floor(Math.max(r, t.duration)), this._total += o, this._loop = !!t.loop, this._to = we([t.to, e, n, t.from]), this._from = we([t.from, n, e]);\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));\n    }\n  }, {\n    key: \"tick\",\n    value: function tick(t) {\n      var e = t - this._start,\n        s = this._duration,\n        n = this._prop,\n        o = this._from,\n        r = this._loop,\n        a = this._to;\n      var l;\n      if (this._active = o !== a && (r || e < s), !this._active) {\n        this._target[n] = a, this._notify(!0);\n        return;\n      }\n      if (e < 0) {\n        this._target[n] = o;\n        return;\n      }\n      l = e / s % 2, l = r && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[n] = this._fn(o, a, l);\n    }\n  }, {\n    key: \"wait\",\n    value: function wait() {\n      var t = this._promises || (this._promises = []);\n      return new Promise(function (e, s) {\n        t.push({\n          res: e,\n          rej: s\n        });\n      });\n    }\n  }, {\n    key: \"_notify\",\n    value: function _notify(t) {\n      var e = t ? \"res\" : \"rej\",\n        s = this._promises || [];\n      for (var n = 0; n < s.length; n++) s[n][e]();\n    }\n  }]);\n}();\nvar Nn = /*#__PURE__*/function () {\n  function Nn(t, e) {\n    _classCallCheck(this, Nn);\n    this._chart = t, this._properties = /* @__PURE__ */new Map(), this.configure(e);\n  }\n  return _createClass(Nn, [{\n    key: \"configure\",\n    value: function configure(t) {\n      if (!T(t)) return;\n      var e = Object.keys(W.animation),\n        s = this._properties;\n      Object.getOwnPropertyNames(t).forEach(function (n) {\n        var o = t[n];\n        if (!T(o)) return;\n        var r = {};\n        for (var _i2 = 0, _e2 = e; _i2 < _e2.length; _i2++) {\n          var a = _e2[_i2];\n          r[a] = o[a];\n        }\n        (N(o.properties) && o.properties || [n]).forEach(function (a) {\n          (a === n || !s.has(a)) && s.set(a, r);\n        });\n      });\n    }\n  }, {\n    key: \"_animateOptions\",\n    value: function _animateOptions(t, e) {\n      var s = e.options,\n        n = na(t, s);\n      if (!n) return [];\n      var o = this._createAnimations(n, s);\n      return s.$shared && sa(t.options.$animations, s).then(function () {\n        t.options = s;\n      }, function () {}), o;\n    }\n  }, {\n    key: \"_createAnimations\",\n    value: function _createAnimations(t, e) {\n      var s = this._properties,\n        n = [],\n        o = t.$animations || (t.$animations = {}),\n        r = Object.keys(e),\n        a = Date.now();\n      var l;\n      for (l = r.length - 1; l >= 0; --l) {\n        var c = r[l];\n        if (c.charAt(0) === \"$\") continue;\n        if (c === \"options\") {\n          n.push.apply(n, _toConsumableArray(this._animateOptions(t, e)));\n          continue;\n        }\n        var h = e[c];\n        var d = o[c];\n        var u = s.get(c);\n        if (d) if (u && d.active()) {\n          d.update(u, h, a);\n          continue;\n        } else d.cancel();\n        if (!u || !u.duration) {\n          t[c] = h;\n          continue;\n        }\n        o[c] = d = new ia(u, t, c, h), n.push(d);\n      }\n      return n;\n    }\n  }, {\n    key: \"update\",\n    value: function update(t, e) {\n      if (this._properties.size === 0) {\n        Object.assign(t, e);\n        return;\n      }\n      var s = this._createAnimations(t, e);\n      if (s.length) return ut.add(this._chart, s), !0;\n    }\n  }]);\n}();\nfunction sa(i, t) {\n  var e = [],\n    s = Object.keys(t);\n  for (var n = 0; n < s.length; n++) {\n    var o = i[s[n]];\n    o && o.active() && e.push(o.wait());\n  }\n  return Promise.all(e);\n}\nfunction na(i, t) {\n  if (!t) return;\n  var e = i.options;\n  if (!e) {\n    i.options = t;\n    return;\n  }\n  return e.$shared && (i.options = e = Object.assign({}, e, {\n    $shared: !1,\n    $animations: {}\n  })), e;\n}\nfunction _s(i, t) {\n  var e = i && i.options || {},\n    s = e.reverse,\n    n = e.min === void 0 ? t : 0,\n    o = e.max === void 0 ? t : 0;\n  return {\n    start: s ? o : n,\n    end: s ? n : o\n  };\n}\nfunction oa(i, t, e) {\n  if (e === !1) return !1;\n  var s = _s(i, e),\n    n = _s(t, e);\n  return {\n    top: n.end,\n    right: s.end,\n    bottom: n.start,\n    left: s.start\n  };\n}\nfunction ra(i) {\n  var t, e, s, n;\n  return T(i) ? (t = i.top, e = i.right, s = i.bottom, n = i.left) : t = e = s = n = i, {\n    top: t,\n    right: e,\n    bottom: s,\n    left: n,\n    disabled: i === !1\n  };\n}\nfunction Vn(i, t) {\n  var e = [],\n    s = i._getSortedDatasetMetas(t);\n  var n, o;\n  for (n = 0, o = s.length; n < o; ++n) e.push(s[n].index);\n  return e;\n}\nfunction xs(i, t, e) {\n  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var n = i.keys,\n    o = s.mode === \"single\";\n  var r, a, l, c;\n  if (t === null) return;\n  var h = !1;\n  for (r = 0, a = n.length; r < a; ++r) {\n    if (l = +n[r], l === e) {\n      if (h = !0, s.all) continue;\n      break;\n    }\n    c = i.values[l], q(c) && (o || t === 0 || lt(t) === lt(c)) && (t += c);\n  }\n  return !h && !s.all ? 0 : t;\n}\nfunction aa(i, t) {\n  var e = t.iScale,\n    s = t.vScale,\n    n = e.axis === \"x\" ? \"x\" : \"y\",\n    o = s.axis === \"x\" ? \"x\" : \"y\",\n    r = Object.keys(i),\n    a = new Array(r.length);\n  var l, c, h;\n  for (l = 0, c = r.length; l < c; ++l) h = r[l], a[l] = _defineProperty(_defineProperty({}, n, h), o, i[h]);\n  return a;\n}\nfunction ri(i, t) {\n  var e = i && i.options.stacked;\n  return e || e === void 0 && t.stack !== void 0;\n}\nfunction la(i, t, e) {\n  return \"\".concat(i.id, \".\").concat(t.id, \".\").concat(e.stack || e.type);\n}\nfunction ca(i) {\n  var _i$getUserBounds = i.getUserBounds(),\n    t = _i$getUserBounds.min,\n    e = _i$getUserBounds.max,\n    s = _i$getUserBounds.minDefined,\n    n = _i$getUserBounds.maxDefined;\n  return {\n    min: s ? t : Number.NEGATIVE_INFINITY,\n    max: n ? e : Number.POSITIVE_INFINITY\n  };\n}\nfunction ha(i, t, e) {\n  var s = i[t] || (i[t] = {});\n  return s[e] || (s[e] = {});\n}\nfunction ys(i, t, e, s) {\n  var _iterator10 = _createForOfIteratorHelper(t.getMatchingVisibleMetas(s).reverse()),\n    _step10;\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var n = _step10.value;\n      var o = i[n.index];\n      if (e && o > 0 || !e && o < 0) return n.index;\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n  return null;\n}\nfunction vs(i, t) {\n  var e = i.chart,\n    s = i._cachedMeta,\n    n = e._stacks || (e._stacks = {}),\n    o = s.iScale,\n    r = s.vScale,\n    a = s.index,\n    l = o.axis,\n    c = r.axis,\n    h = la(o, r, s),\n    d = t.length;\n  var u;\n  for (var f = 0; f < d; ++f) {\n    var p = t[f],\n      g = p[l],\n      m = p[c],\n      b = p._stacks || (p._stacks = {});\n    u = b[c] = ha(n, h, g), u[a] = m, u._top = ys(u, r, !0, s.type), u._bottom = ys(u, r, !1, s.type);\n    var _ = u._visualValues || (u._visualValues = {});\n    _[a] = m;\n  }\n}\nfunction ai(i, t) {\n  var e = i.scales;\n  return Object.keys(e).filter(function (s) {\n    return e[s].axis === t;\n  }).shift();\n}\nfunction da(i, t) {\n  return Bt(i, {\n    active: !1,\n    dataset: void 0,\n    datasetIndex: t,\n    index: t,\n    mode: \"default\",\n    type: \"dataset\"\n  });\n}\nfunction ua(i, t, e) {\n  return Bt(i, {\n    active: !1,\n    dataIndex: t,\n    parsed: void 0,\n    raw: void 0,\n    element: e,\n    index: t,\n    mode: \"default\",\n    type: \"data\"\n  });\n}\nfunction Qt(i, t) {\n  var e = i.controller.index,\n    s = i.vScale && i.vScale.axis;\n  if (s) {\n    t = t || i._parsed;\n    var _iterator11 = _createForOfIteratorHelper(t),\n      _step11;\n    try {\n      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n        var n = _step11.value;\n        var o = n._stacks;\n        if (!o || o[s] === void 0 || o[s][e] === void 0) return;\n        delete o[s][e], o[s]._visualValues !== void 0 && o[s]._visualValues[e] !== void 0 && delete o[s]._visualValues[e];\n      }\n    } catch (err) {\n      _iterator11.e(err);\n    } finally {\n      _iterator11.f();\n    }\n  }\n}\nvar li = function li(i) {\n    return i === \"reset\" || i === \"none\";\n  },\n  Ms = function Ms(i, t) {\n    return t ? i : Object.assign({}, i);\n  },\n  fa = function fa(i, t, e) {\n    return i && !t.hidden && t._stacked && {\n      keys: Vn(e, !0),\n      values: null\n    };\n  };\nvar kt = /*#__PURE__*/function () {\n  function kt(t, e) {\n    _classCallCheck(this, kt);\n    this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = (this instanceof kt ? this.constructor : void 0).datasetElementType, this.dataElementType = (this instanceof kt ? this.constructor : void 0).dataElementType, this.initialize();\n  }\n  return _createClass(kt, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var t = this._cachedMeta;\n      this.configure(), this.linkScales(), t._stacked = ri(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled(\"filler\") && console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n    }\n  }, {\n    key: \"updateIndex\",\n    value: function updateIndex(t) {\n      this.index !== t && Qt(this._cachedMeta), this.index = t;\n    }\n  }, {\n    key: \"linkScales\",\n    value: function linkScales() {\n      var t = this.chart,\n        e = this._cachedMeta,\n        s = this.getDataset(),\n        n = function n(d, u, f, p) {\n          return d === \"x\" ? u : d === \"r\" ? p : f;\n        },\n        o = e.xAxisID = D(s.xAxisID, ai(t, \"x\")),\n        r = e.yAxisID = D(s.yAxisID, ai(t, \"y\")),\n        a = e.rAxisID = D(s.rAxisID, ai(t, \"r\")),\n        l = e.indexAxis,\n        c = e.iAxisID = n(l, o, r, a),\n        h = e.vAxisID = n(l, r, o, a);\n      e.xScale = this.getScaleForId(o), e.yScale = this.getScaleForId(r), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(c), e.vScale = this.getScaleForId(h);\n    }\n  }, {\n    key: \"getDataset\",\n    value: function getDataset() {\n      return this.chart.data.datasets[this.index];\n    }\n  }, {\n    key: \"getMeta\",\n    value: function getMeta() {\n      return this.chart.getDatasetMeta(this.index);\n    }\n  }, {\n    key: \"getScaleForId\",\n    value: function getScaleForId(t) {\n      return this.chart.scales[t];\n    }\n  }, {\n    key: \"_getOtherScale\",\n    value: function _getOtherScale(t) {\n      var e = this._cachedMeta;\n      return t === e.iScale ? e.vScale : e.iScale;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._update(\"reset\");\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      var t = this._cachedMeta;\n      this._data && ss(this._data, this), t._stacked && Qt(t);\n    }\n  }, {\n    key: \"_dataCheck\",\n    value: function _dataCheck() {\n      var t = this.getDataset(),\n        e = t.data || (t.data = []),\n        s = this._data;\n      if (T(e)) {\n        var n = this._cachedMeta;\n        this._data = aa(e, n);\n      } else if (s !== e) {\n        if (s) {\n          ss(s, this);\n          var _n2 = this._cachedMeta;\n          Qt(_n2), _n2._parsed = [];\n        }\n        e && Object.isExtensible(e) && Jo(e, this), this._syncList = [], this._data = e;\n      }\n    }\n  }, {\n    key: \"addElements\",\n    value: function addElements() {\n      var t = this._cachedMeta;\n      this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());\n    }\n  }, {\n    key: \"buildOrUpdateElements\",\n    value: function buildOrUpdateElements(t) {\n      var e = this._cachedMeta,\n        s = this.getDataset();\n      var n = !1;\n      this._dataCheck();\n      var o = e._stacked;\n      e._stacked = ri(e.vScale, e), e.stack !== s.stack && (n = !0, Qt(e), e.stack = s.stack), this._resyncElements(t), (n || o !== e._stacked) && (vs(this, e._parsed), e._stacked = ri(e.vScale, e));\n    }\n  }, {\n    key: \"configure\",\n    value: function configure() {\n      var t = this.chart.config,\n        e = t.datasetScopeKeys(this._type),\n        s = t.getOptionScopes(this.getDataset(), e, !0);\n      this.options = t.createResolver(s, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(t, e) {\n      var s = this._cachedMeta,\n        n = this._data,\n        o = s.iScale,\n        r = s._stacked,\n        a = o.axis;\n      var l = t === 0 && e === n.length ? !0 : s._sorted,\n        c = t > 0 && s._parsed[t - 1],\n        h,\n        d,\n        u;\n      if (this._parsing === !1) s._parsed = n, s._sorted = !0, u = n;else {\n        N(n[t]) ? u = this.parseArrayData(s, n, t, e) : T(n[t]) ? u = this.parseObjectData(s, n, t, e) : u = this.parsePrimitiveData(s, n, t, e);\n        var f = function f() {\n          return d[a] === null || c && d[a] < c[a];\n        };\n        for (h = 0; h < e; ++h) s._parsed[h + t] = d = u[h], l && (f() && (l = !1), c = d);\n        s._sorted = l;\n      }\n      r && vs(this, u);\n    }\n  }, {\n    key: \"parsePrimitiveData\",\n    value: function parsePrimitiveData(t, e, s, n) {\n      var o = t.iScale,\n        r = t.vScale,\n        a = o.axis,\n        l = r.axis,\n        c = o.getLabels(),\n        h = o === r,\n        d = new Array(n);\n      var u, f, p;\n      for (u = 0, f = n; u < f; ++u) p = u + s, d[u] = _defineProperty(_defineProperty({}, a, h || o.parse(c[p], p)), l, r.parse(e[p], p));\n      return d;\n    }\n  }, {\n    key: \"parseArrayData\",\n    value: function parseArrayData(t, e, s, n) {\n      var o = t.xScale,\n        r = t.yScale,\n        a = new Array(n);\n      var l, c, h, d;\n      for (l = 0, c = n; l < c; ++l) h = l + s, d = e[h], a[l] = {\n        x: o.parse(d[0], h),\n        y: r.parse(d[1], h)\n      };\n      return a;\n    }\n  }, {\n    key: \"parseObjectData\",\n    value: function parseObjectData(t, e, s, n) {\n      var o = t.xScale,\n        r = t.yScale,\n        _this$_parsing = this._parsing,\n        _this$_parsing$xAxisK = _this$_parsing.xAxisKey,\n        a = _this$_parsing$xAxisK === void 0 ? \"x\" : _this$_parsing$xAxisK,\n        _this$_parsing$yAxisK = _this$_parsing.yAxisKey,\n        l = _this$_parsing$yAxisK === void 0 ? \"y\" : _this$_parsing$yAxisK,\n        c = new Array(n);\n      var h, d, u, f;\n      for (h = 0, d = n; h < d; ++h) u = h + s, f = e[u], c[h] = {\n        x: o.parse(It(f, a), u),\n        y: r.parse(It(f, l), u)\n      };\n      return c;\n    }\n  }, {\n    key: \"getParsed\",\n    value: function getParsed(t) {\n      return this._cachedMeta._parsed[t];\n    }\n  }, {\n    key: \"getDataElement\",\n    value: function getDataElement(t) {\n      return this._cachedMeta.data[t];\n    }\n  }, {\n    key: \"applyStack\",\n    value: function applyStack(t, e, s) {\n      var n = this.chart,\n        o = this._cachedMeta,\n        r = e[t.axis],\n        a = {\n          keys: Vn(n, !0),\n          values: e._stacks[t.axis]._visualValues\n        };\n      return xs(a, r, o.index, {\n        mode: s\n      });\n    }\n  }, {\n    key: \"updateRangeFromParsed\",\n    value: function updateRangeFromParsed(t, e, s, n) {\n      var o = s[e.axis];\n      var r = o === null ? NaN : o;\n      var a = n && s._stacks[e.axis];\n      n && a && (n.values = a, r = xs(n, o, this._cachedMeta.index)), t.min = Math.min(t.min, r), t.max = Math.max(t.max, r);\n    }\n  }, {\n    key: \"getMinMax\",\n    value: function getMinMax(t, e) {\n      var s = this._cachedMeta,\n        n = s._parsed,\n        o = s._sorted && t === s.iScale,\n        r = n.length,\n        a = this._getOtherScale(t),\n        l = fa(e, s, this.chart),\n        c = {\n          min: Number.POSITIVE_INFINITY,\n          max: Number.NEGATIVE_INFINITY\n        },\n        _ca = ca(a),\n        h = _ca.min,\n        d = _ca.max;\n      var u, f;\n      function p() {\n        f = n[u];\n        var g = f[a.axis];\n        return !q(f[t.axis]) || h > g || d < g;\n      }\n      for (u = 0; u < r && !(!p() && (this.updateRangeFromParsed(c, t, f, l), o)); ++u);\n      if (o) {\n        for (u = r - 1; u >= 0; --u) if (!p()) {\n          this.updateRangeFromParsed(c, t, f, l);\n          break;\n        }\n      }\n      return c;\n    }\n  }, {\n    key: \"getAllParsedValues\",\n    value: function getAllParsedValues(t) {\n      var e = this._cachedMeta._parsed,\n        s = [];\n      var n, o, r;\n      for (n = 0, o = e.length; n < o; ++n) r = e[n][t.axis], q(r) && s.push(r);\n      return s;\n    }\n  }, {\n    key: \"getMaxOverflow\",\n    value: function getMaxOverflow() {\n      return !1;\n    }\n  }, {\n    key: \"getLabelAndValue\",\n    value: function getLabelAndValue(t) {\n      var e = this._cachedMeta,\n        s = e.iScale,\n        n = e.vScale,\n        o = this.getParsed(t);\n      return {\n        label: s ? \"\" + s.getLabelForValue(o[s.axis]) : \"\",\n        value: n ? \"\" + n.getLabelForValue(o[n.axis]) : \"\"\n      };\n    }\n  }, {\n    key: \"_update\",\n    value: function _update(t) {\n      var e = this._cachedMeta;\n      this.update(t || \"default\"), e._clip = ra(D(this.options.clip, oa(e.xScale, e.yScale, this.getMaxOverflow())));\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {}\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var t = this._ctx,\n        e = this.chart,\n        s = this._cachedMeta,\n        n = s.data || [],\n        o = e.chartArea,\n        r = [],\n        a = this._drawStart || 0,\n        l = this._drawCount || n.length - a,\n        c = this.options.drawActiveElementsOnTop;\n      var h;\n      for (s.dataset && s.dataset.draw(t, o, a, l), h = a; h < a + l; ++h) {\n        var d = n[h];\n        d.hidden || (d.active && c ? r.push(d) : d.draw(t, o));\n      }\n      for (h = 0; h < r.length; ++h) r[h].draw(t, o);\n    }\n  }, {\n    key: \"getStyle\",\n    value: function getStyle(t, e) {\n      var s = e ? \"active\" : \"default\";\n      return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(s) : this.resolveDataElementOptions(t || 0, s);\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext(t, e, s) {\n      var n = this.getDataset();\n      var o;\n      if (t >= 0 && t < this._cachedMeta.data.length) {\n        var r = this._cachedMeta.data[t];\n        o = r.$context || (r.$context = ua(this.getContext(), t, r)), o.parsed = this.getParsed(t), o.raw = n.data[t], o.index = o.dataIndex = t;\n      } else o = this.$context || (this.$context = da(this.chart.getContext(), this.index)), o.dataset = n, o.index = o.datasetIndex = this.index;\n      return o.active = !!e, o.mode = s, o;\n    }\n  }, {\n    key: \"resolveDatasetElementOptions\",\n    value: function resolveDatasetElementOptions(t) {\n      return this._resolveElementOptions(this.datasetElementType.id, t);\n    }\n  }, {\n    key: \"resolveDataElementOptions\",\n    value: function resolveDataElementOptions(t, e) {\n      return this._resolveElementOptions(this.dataElementType.id, e, t);\n    }\n  }, {\n    key: \"_resolveElementOptions\",\n    value: function _resolveElementOptions(t) {\n      var _this5 = this;\n      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"default\";\n      var s = arguments.length > 2 ? arguments[2] : undefined;\n      var n = e === \"active\",\n        o = this._cachedDataOpts,\n        r = t + \"-\" + e,\n        a = o[r],\n        l = this.enableOptionSharing && ge(s);\n      if (a) return Ms(a, l);\n      var c = this.chart.config,\n        h = c.datasetElementScopeKeys(this._type, t),\n        d = n ? [\"\".concat(t, \"Hover\"), \"hover\", t, \"\"] : [t, \"\"],\n        u = c.getOptionScopes(this.getDataset(), h),\n        f = Object.keys(W.elements[t]),\n        p = function p() {\n          return _this5.getContext(s, n, e);\n        },\n        g = c.resolveNamedOptions(u, f, p, d);\n      return g.$shared && (g.$shared = l, o[r] = Object.freeze(Ms(g, l))), g;\n    }\n  }, {\n    key: \"_resolveAnimations\",\n    value: function _resolveAnimations(t, e, s) {\n      var n = this.chart,\n        o = this._cachedDataOpts,\n        r = \"animation-\".concat(e),\n        a = o[r];\n      if (a) return a;\n      var l;\n      if (n.options.animation !== !1) {\n        var h = this.chart.config,\n          d = h.datasetAnimationScopeKeys(this._type, e),\n          u = h.getOptionScopes(this.getDataset(), d);\n        l = h.createResolver(u, this.getContext(t, s, e));\n      }\n      var c = new Nn(n, l && l.animations);\n      return l && l._cacheable && (o[r] = Object.freeze(c)), c;\n    }\n  }, {\n    key: \"getSharedOptions\",\n    value: function getSharedOptions(t) {\n      if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));\n    }\n  }, {\n    key: \"includeOptions\",\n    value: function includeOptions(t, e) {\n      return !e || li(t) || this.chart._animationsDisabled;\n    }\n  }, {\n    key: \"_getSharedOptions\",\n    value: function _getSharedOptions(t, e) {\n      var s = this.resolveDataElementOptions(t, e),\n        n = this._sharedOptions,\n        o = this.getSharedOptions(s),\n        r = this.includeOptions(e, o) || o !== n;\n      return this.updateSharedOptions(o, e, s), {\n        sharedOptions: o,\n        includeOptions: r\n      };\n    }\n  }, {\n    key: \"updateElement\",\n    value: function updateElement(t, e, s, n) {\n      li(n) ? Object.assign(t, s) : this._resolveAnimations(e, n).update(t, s);\n    }\n  }, {\n    key: \"updateSharedOptions\",\n    value: function updateSharedOptions(t, e, s) {\n      t && !li(e) && this._resolveAnimations(void 0, e).update(t, s);\n    }\n  }, {\n    key: \"_setStyle\",\n    value: function _setStyle(t, e, s, n) {\n      t.active = n;\n      var o = this.getStyle(e, n);\n      this._resolveAnimations(e, s, n).update(t, {\n        options: !n && this.getSharedOptions(o) || o\n      });\n    }\n  }, {\n    key: \"removeHoverStyle\",\n    value: function removeHoverStyle(t, e, s) {\n      this._setStyle(t, s, \"active\", !1);\n    }\n  }, {\n    key: \"setHoverStyle\",\n    value: function setHoverStyle(t, e, s) {\n      this._setStyle(t, s, \"active\", !0);\n    }\n  }, {\n    key: \"_removeDatasetHoverStyle\",\n    value: function _removeDatasetHoverStyle() {\n      var t = this._cachedMeta.dataset;\n      t && this._setStyle(t, void 0, \"active\", !1);\n    }\n  }, {\n    key: \"_setDatasetHoverStyle\",\n    value: function _setDatasetHoverStyle() {\n      var t = this._cachedMeta.dataset;\n      t && this._setStyle(t, void 0, \"active\", !0);\n    }\n  }, {\n    key: \"_resyncElements\",\n    value: function _resyncElements(t) {\n      var e = this._data,\n        s = this._cachedMeta.data;\n      var _iterator12 = _createForOfIteratorHelper(this._syncList),\n        _step12;\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var _step12$value = _slicedToArray(_step12.value, 3),\n            a = _step12$value[0],\n            l = _step12$value[1],\n            c = _step12$value[2];\n          this[a](l, c);\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n      this._syncList = [];\n      var n = s.length,\n        o = e.length,\n        r = Math.min(o, n);\n      r && this.parse(0, r), o > n ? this._insertElements(n, o - n, t) : o < n && this._removeElements(o, n - o);\n    }\n  }, {\n    key: \"_insertElements\",\n    value: function _insertElements(t, e) {\n      var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;\n      var n = this._cachedMeta,\n        o = n.data,\n        r = t + e;\n      var a;\n      var l = function l(c) {\n        for (c.length += e, a = c.length - 1; a >= r; a--) c[a] = c[a - e];\n      };\n      for (l(o), a = t; a < r; ++a) o[a] = new this.dataElementType();\n      this._parsing && l(n._parsed), this.parse(t, e), s && this.updateElements(o, t, e, \"reset\");\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {}\n  }, {\n    key: \"_removeElements\",\n    value: function _removeElements(t, e) {\n      var s = this._cachedMeta;\n      if (this._parsing) {\n        var n = s._parsed.splice(t, e);\n        s._stacked && Qt(s, n);\n      }\n      s.data.splice(t, e);\n    }\n  }, {\n    key: \"_sync\",\n    value: function _sync(t) {\n      if (this._parsing) this._syncList.push(t);else {\n        var _t2 = _slicedToArray(t, 3),\n          e = _t2[0],\n          s = _t2[1],\n          n = _t2[2];\n        this[e](s, n);\n      }\n      this.chart._dataChanges.push([this.index].concat(_toConsumableArray(t)));\n    }\n  }, {\n    key: \"_onDataPush\",\n    value: function _onDataPush() {\n      var t = arguments.length;\n      this._sync([\"_insertElements\", this.getDataset().data.length - t, t]);\n    }\n  }, {\n    key: \"_onDataPop\",\n    value: function _onDataPop() {\n      this._sync([\"_removeElements\", this._cachedMeta.data.length - 1, 1]);\n    }\n  }, {\n    key: \"_onDataShift\",\n    value: function _onDataShift() {\n      this._sync([\"_removeElements\", 0, 1]);\n    }\n  }, {\n    key: \"_onDataSplice\",\n    value: function _onDataSplice(t, e) {\n      e && this._sync([\"_removeElements\", t, e]);\n      var s = arguments.length - 2;\n      s && this._sync([\"_insertElements\", t, s]);\n    }\n  }, {\n    key: \"_onDataUnshift\",\n    value: function _onDataUnshift() {\n      this._sync([\"_insertElements\", 0, arguments.length]);\n    }\n  }]);\n}();\nw(kt, \"defaults\", {}), w(kt, \"datasetElementType\", null), w(kt, \"dataElementType\", null);\nfunction ga(i, t) {\n  if (!i._cache.$bar) {\n    var e = i.getMatchingVisibleMetas(t);\n    var s = [];\n    for (var n = 0, o = e.length; n < o; n++) s = s.concat(e[n].controller.getAllParsedValues(i));\n    i._cache.$bar = Mn(s.sort(function (n, o) {\n      return n - o;\n    }));\n  }\n  return i._cache.$bar;\n}\nfunction pa(i) {\n  var t = i.iScale,\n    e = ga(t, i.type);\n  var s = t._length,\n    n,\n    o,\n    r,\n    a;\n  var l = function l() {\n    r === 32767 || r === -32768 || (ge(a) && (s = Math.min(s, Math.abs(r - a) || s)), a = r);\n  };\n  for (n = 0, o = e.length; n < o; ++n) r = t.getPixelForValue(e[n]), l();\n  for (a = void 0, n = 0, o = t.ticks.length; n < o; ++n) r = t.getPixelForTick(n), l();\n  return s;\n}\nfunction ma(i, t, e, s) {\n  var n = e.barThickness;\n  var o, r;\n  return R(n) ? (o = t.min * e.categoryPercentage, r = e.barPercentage) : (o = n * s, r = 1), {\n    chunk: o / s,\n    ratio: r,\n    start: t.pixels[i] - o / 2\n  };\n}\nfunction ba(i, t, e, s) {\n  var n = t.pixels,\n    o = n[i];\n  var r = i > 0 ? n[i - 1] : null,\n    a = i < n.length - 1 ? n[i + 1] : null;\n  var l = e.categoryPercentage;\n  r === null && (r = o - (a === null ? t.end - t.start : a - o)), a === null && (a = o + o - r);\n  var c = o - (o - Math.min(r, a)) / 2 * l;\n  return {\n    chunk: Math.abs(a - r) / 2 * l / s,\n    ratio: e.barPercentage,\n    start: c\n  };\n}\nfunction _a(i, t, e, s) {\n  var n = e.parse(i[0], s),\n    o = e.parse(i[1], s),\n    r = Math.min(n, o),\n    a = Math.max(n, o);\n  var l = r,\n    c = a;\n  Math.abs(r) > Math.abs(a) && (l = a, c = r), t[e.axis] = c, t._custom = {\n    barStart: l,\n    barEnd: c,\n    start: n,\n    end: o,\n    min: r,\n    max: a\n  };\n}\nfunction jn(i, t, e, s) {\n  return N(i) ? _a(i, t, e, s) : t[e.axis] = e.parse(i, s), t;\n}\nfunction Ss(i, t, e, s) {\n  var n = i.iScale,\n    o = i.vScale,\n    r = n.getLabels(),\n    a = n === o,\n    l = [];\n  var c, h, d, u;\n  for (c = e, h = e + s; c < h; ++c) u = t[c], d = {}, d[n.axis] = a || n.parse(r[c], c), l.push(jn(u, d, o, c));\n  return l;\n}\nfunction ci(i) {\n  return i && i.barStart !== void 0 && i.barEnd !== void 0;\n}\nfunction xa(i, t, e) {\n  return i !== 0 ? lt(i) : (t.isHorizontal() ? 1 : -1) * (t.min >= e ? 1 : -1);\n}\nfunction ya(i) {\n  var t, e, s, n, o;\n  return i.horizontal ? (t = i.base > i.x, e = \"left\", s = \"right\") : (t = i.base < i.y, e = \"bottom\", s = \"top\"), t ? (n = \"end\", o = \"start\") : (n = \"start\", o = \"end\"), {\n    start: e,\n    end: s,\n    reverse: t,\n    top: n,\n    bottom: o\n  };\n}\nfunction va(i, t, e, s) {\n  var n = t.borderSkipped;\n  var o = {};\n  if (!n) {\n    i.borderSkipped = o;\n    return;\n  }\n  if (n === !0) {\n    i.borderSkipped = {\n      top: !0,\n      right: !0,\n      bottom: !0,\n      left: !0\n    };\n    return;\n  }\n  var _ya = ya(i),\n    r = _ya.start,\n    a = _ya.end,\n    l = _ya.reverse,\n    c = _ya.top,\n    h = _ya.bottom;\n  n === \"middle\" && e && (i.enableBorderRadius = !0, (e._top || 0) === s ? n = c : (e._bottom || 0) === s ? n = h : (o[ks(h, r, a, l)] = !0, n = c)), o[ks(n, r, a, l)] = !0, i.borderSkipped = o;\n}\nfunction ks(i, t, e, s) {\n  return s ? (i = Ma(i, t, e), i = ws(i, e, t)) : i = ws(i, t, e), i;\n}\nfunction Ma(i, t, e) {\n  return i === t ? e : i === e ? t : i;\n}\nfunction ws(i, t, e) {\n  return i === \"start\" ? t : i === \"end\" ? e : i;\n}\nfunction Sa(i, _ref2, e) {\n  var t = _ref2.inflateAmount;\n  i.inflateAmount = t === \"auto\" ? e === 1 ? 0.33 : 0 : t;\n}\nvar Ee = /*#__PURE__*/function (_kt) {\n  function Ee() {\n    _classCallCheck(this, Ee);\n    return _callSuper(this, Ee, arguments);\n  }\n  _inherits(Ee, _kt);\n  return _createClass(Ee, [{\n    key: \"parsePrimitiveData\",\n    value: function parsePrimitiveData(t, e, s, n) {\n      return Ss(t, e, s, n);\n    }\n  }, {\n    key: \"parseArrayData\",\n    value: function parseArrayData(t, e, s, n) {\n      return Ss(t, e, s, n);\n    }\n  }, {\n    key: \"parseObjectData\",\n    value: function parseObjectData(t, e, s, n) {\n      var o = t.iScale,\n        r = t.vScale,\n        _this$_parsing2 = this._parsing,\n        _this$_parsing2$xAxis = _this$_parsing2.xAxisKey,\n        a = _this$_parsing2$xAxis === void 0 ? \"x\" : _this$_parsing2$xAxis,\n        _this$_parsing2$yAxis = _this$_parsing2.yAxisKey,\n        l = _this$_parsing2$yAxis === void 0 ? \"y\" : _this$_parsing2$yAxis,\n        c = o.axis === \"x\" ? a : l,\n        h = r.axis === \"x\" ? a : l,\n        d = [];\n      var u, f, p, g;\n      for (u = s, f = s + n; u < f; ++u) g = e[u], p = {}, p[o.axis] = o.parse(It(g, c), u), d.push(jn(It(g, h), p, r, u));\n      return d;\n    }\n  }, {\n    key: \"updateRangeFromParsed\",\n    value: function updateRangeFromParsed(t, e, s, n) {\n      _superPropGet(Ee, \"updateRangeFromParsed\", this, 3)([t, e, s, n]);\n      var o = s._custom;\n      o && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, o.min), t.max = Math.max(t.max, o.max));\n    }\n  }, {\n    key: \"getMaxOverflow\",\n    value: function getMaxOverflow() {\n      return 0;\n    }\n  }, {\n    key: \"getLabelAndValue\",\n    value: function getLabelAndValue(t) {\n      var e = this._cachedMeta,\n        s = e.iScale,\n        n = e.vScale,\n        o = this.getParsed(t),\n        r = o._custom,\n        a = ci(r) ? \"[\" + r.start + \", \" + r.end + \"]\" : \"\" + n.getLabelForValue(o[n.axis]);\n      return {\n        label: \"\" + s.getLabelForValue(o[s.axis]),\n        value: a\n      };\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      this.enableOptionSharing = !0, _superPropGet(Ee, \"initialize\", this, 3)([]);\n      var t = this._cachedMeta;\n      t.stack = this.getDataset().stack;\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = this._cachedMeta;\n      this.updateElements(e.data, 0, e.data.length, t);\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {\n      var o = n === \"reset\",\n        r = this.index,\n        a = this._cachedMeta.vScale,\n        l = a.getBasePixel(),\n        c = a.isHorizontal(),\n        h = this._getRuler(),\n        _this$_getSharedOptio = this._getSharedOptions(e, n),\n        d = _this$_getSharedOptio.sharedOptions,\n        u = _this$_getSharedOptio.includeOptions;\n      for (var f = e; f < e + s; f++) {\n        var p = this.getParsed(f),\n          g = o || R(p[a.axis]) ? {\n            base: l,\n            head: l\n          } : this._calculateBarValuePixels(f),\n          m = this._calculateBarIndexPixels(f, h),\n          b = (p._stacks || {})[a.axis],\n          _ = {\n            horizontal: c,\n            base: g.base,\n            enableBorderRadius: !b || ci(p._custom) || r === b._top || r === b._bottom,\n            x: c ? g.head : m.center,\n            y: c ? m.center : g.head,\n            height: c ? m.size : Math.abs(g.size),\n            width: c ? Math.abs(g.size) : m.size\n          };\n        u && (_.options = d || this.resolveDataElementOptions(f, t[f].active ? \"active\" : n));\n        var v = _.options || t[f].options;\n        va(_, v, b, r), Sa(_, v, h.ratio), this.updateElement(t[f], f, _, n);\n      }\n    }\n  }, {\n    key: \"_getStacks\",\n    value: function _getStacks(t, e) {\n      var s = this._cachedMeta.iScale,\n        n = s.getMatchingVisibleMetas(this._type).filter(function (h) {\n          return h.controller.options.grouped;\n        }),\n        o = s.options.stacked,\n        r = [],\n        a = this._cachedMeta.controller.getParsed(e),\n        l = a && a[s.axis],\n        c = function c(h) {\n          var d = h._parsed.find(function (f) {\n              return f[s.axis] === l;\n            }),\n            u = d && d[h.vScale.axis];\n          if (R(u) || isNaN(u)) return !0;\n        };\n      var _iterator13 = _createForOfIteratorHelper(n),\n        _step13;\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var h = _step13.value;\n          if (!(e !== void 0 && c(h)) && ((o === !1 || r.indexOf(h.stack) === -1 || o === void 0 && h.stack === void 0) && r.push(h.stack), h.index === t)) break;\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n      return r.length || r.push(void 0), r;\n    }\n  }, {\n    key: \"_getStackCount\",\n    value: function _getStackCount(t) {\n      return this._getStacks(void 0, t).length;\n    }\n  }, {\n    key: \"_getAxisCount\",\n    value: function _getAxisCount() {\n      return this._getAxis().length;\n    }\n  }, {\n    key: \"getFirstScaleIdForIndexAxis\",\n    value: function getFirstScaleIdForIndexAxis() {\n      var t = this.chart.scales,\n        e = this.chart.options.indexAxis;\n      return Object.keys(t).filter(function (s) {\n        return t[s].axis === e;\n      }).shift();\n    }\n  }, {\n    key: \"_getAxis\",\n    value: function _getAxis() {\n      var t = {},\n        e = this.getFirstScaleIdForIndexAxis();\n      var _iterator14 = _createForOfIteratorHelper(this.chart.data.datasets),\n        _step14;\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var s = _step14.value;\n          t[D(this.chart.options.indexAxis === \"x\" ? s.xAxisID : s.yAxisID, e)] = !0;\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n      return Object.keys(t);\n    }\n  }, {\n    key: \"_getStackIndex\",\n    value: function _getStackIndex(t, e, s) {\n      var n = this._getStacks(t, s),\n        o = e !== void 0 ? n.indexOf(e) : -1;\n      return o === -1 ? n.length - 1 : o;\n    }\n  }, {\n    key: \"_getRuler\",\n    value: function _getRuler() {\n      var t = this.options,\n        e = this._cachedMeta,\n        s = e.iScale,\n        n = [];\n      var o, r;\n      for (o = 0, r = e.data.length; o < r; ++o) n.push(s.getPixelForValue(this.getParsed(o)[s.axis], o));\n      var a = t.barThickness;\n      return {\n        min: a || pa(e),\n        pixels: n,\n        start: s._startPixel,\n        end: s._endPixel,\n        stackCount: this._getStackCount(),\n        scale: s,\n        grouped: t.grouped,\n        ratio: a ? 1 : t.categoryPercentage * t.barPercentage\n      };\n    }\n  }, {\n    key: \"_calculateBarValuePixels\",\n    value: function _calculateBarValuePixels(t) {\n      var _this$_cachedMeta = this._cachedMeta,\n        e = _this$_cachedMeta.vScale,\n        s = _this$_cachedMeta._stacked,\n        n = _this$_cachedMeta.index,\n        _this$options = this.options,\n        o = _this$options.base,\n        r = _this$options.minBarLength,\n        a = o || 0,\n        l = this.getParsed(t),\n        c = l._custom,\n        h = ci(c);\n      var d = l[e.axis],\n        u = 0,\n        f = s ? this.applyStack(e, l, s) : d,\n        p,\n        g;\n      f !== d && (u = f - d, f = d), h && (d = c.barStart, f = c.barEnd - c.barStart, d !== 0 && lt(d) !== lt(c.barEnd) && (u = 0), u += d);\n      var m = !R(o) && !h ? o : u;\n      var b = e.getPixelForValue(m);\n      if (this.chart.getDataVisibility(t) ? p = e.getPixelForValue(u + f) : p = b, g = p - b, Math.abs(g) < r) {\n        g = xa(g, e, a) * r, d === a && (b -= g / 2);\n        var _ = e.getPixelForDecimal(0),\n          v = e.getPixelForDecimal(1),\n          y = Math.min(_, v),\n          x = Math.max(_, v);\n        b = Math.max(Math.min(b, x), y), p = b + g, s && !h && (l._stacks[e.axis]._visualValues[n] = e.getValueForPixel(p) - e.getValueForPixel(b));\n      }\n      if (b === e.getPixelForValue(a)) {\n        var _2 = lt(g) * e.getLineWidthForValue(a) / 2;\n        b += _2, g -= _2;\n      }\n      return {\n        size: g,\n        base: b,\n        head: p,\n        center: p + g / 2\n      };\n    }\n  }, {\n    key: \"_calculateBarIndexPixels\",\n    value: function _calculateBarIndexPixels(t, e) {\n      var s = e.scale,\n        n = this.options,\n        o = n.skipNull,\n        r = D(n.maxBarThickness, 1 / 0);\n      var a, l;\n      var c = this._getAxisCount();\n      if (e.grouped) {\n        var h = o ? this._getStackCount(t) : e.stackCount,\n          d = n.barThickness === \"flex\" ? ba(t, e, n, h * c) : ma(t, e, n, h * c),\n          u = this.chart.options.indexAxis === \"x\" ? this.getDataset().xAxisID : this.getDataset().yAxisID,\n          f = this._getAxis().indexOf(D(u, this.getFirstScaleIdForIndexAxis())),\n          p = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0) + f;\n        a = d.start + d.chunk * p + d.chunk / 2, l = Math.min(r, d.chunk * d.ratio);\n      } else a = s.getPixelForValue(this.getParsed(t)[s.axis], t), l = Math.min(r, e.min * e.ratio);\n      return {\n        base: a - l / 2,\n        head: a + l / 2,\n        center: a,\n        size: l\n      };\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var t = this._cachedMeta,\n        e = t.vScale,\n        s = t.data,\n        n = s.length;\n      var o = 0;\n      for (; o < n; ++o) this.getParsed(o)[e.axis] !== null && !s[o].hidden && s[o].draw(this._ctx);\n    }\n  }]);\n}(kt);\nw(Ee, \"id\", \"bar\"), w(Ee, \"defaults\", {\n  datasetElementType: !1,\n  dataElementType: \"bar\",\n  categoryPercentage: 0.8,\n  barPercentage: 0.9,\n  grouped: !0,\n  animations: {\n    numbers: {\n      type: \"number\",\n      properties: [\"x\", \"y\", \"base\", \"width\", \"height\"]\n    }\n  }\n}), w(Ee, \"overrides\", {\n  scales: {\n    _index_: {\n      type: \"category\",\n      offset: !0,\n      grid: {\n        offset: !0\n      }\n    },\n    _value_: {\n      type: \"linear\",\n      beginAtZero: !0\n    }\n  }\n});\nfunction ka(i, t, e) {\n  var s = 1,\n    n = 1,\n    o = 0,\n    r = 0;\n  if (t < B) {\n    var a = i,\n      l = a + t,\n      c = Math.cos(a),\n      h = Math.sin(a),\n      d = Math.cos(l),\n      u = Math.sin(l),\n      f = function f(v, y, x) {\n        return pe(v, a, l, !0) ? 1 : Math.max(y, y * e, x, x * e);\n      },\n      p = function p(v, y, x) {\n        return pe(v, a, l, !0) ? -1 : Math.min(y, y * e, x, x * e);\n      },\n      g = f(0, c, d),\n      m = f(V, h, u),\n      b = p(E, c, d),\n      _ = p(E + V, h, u);\n    s = (g - b) / 2, n = (m - _) / 2, o = -(g + b) / 2, r = -(m + _) / 2;\n  }\n  return {\n    ratioX: s,\n    ratioY: n,\n    offsetX: o,\n    offsetY: r\n  };\n}\nvar jt = /*#__PURE__*/function (_kt2) {\n  function jt(t, e) {\n    var _this6;\n    _classCallCheck(this, jt);\n    _this6 = _callSuper(this, jt, [t, e]), _this6.enableOptionSharing = !0, _this6.innerRadius = void 0, _this6.outerRadius = void 0, _this6.offsetX = void 0, _this6.offsetY = void 0;\n    return _this6;\n  }\n  _inherits(jt, _kt2);\n  return _createClass(jt, [{\n    key: \"linkScales\",\n    value: function linkScales() {}\n  }, {\n    key: \"parse\",\n    value: function parse(t, e) {\n      var s = this.getDataset().data,\n        n = this._cachedMeta;\n      if (this._parsing === !1) n._parsed = s;else {\n        var o = function o(l) {\n          return +s[l];\n        };\n        if (T(s[t])) {\n          var _this$_parsing$key = this._parsing.key,\n            l = _this$_parsing$key === void 0 ? \"value\" : _this$_parsing$key;\n          o = function o(c) {\n            return +It(s[c], l);\n          };\n        }\n        var r, a;\n        for (r = t, a = t + e; r < a; ++r) n._parsed[r] = o(r);\n      }\n    }\n  }, {\n    key: \"_getRotation\",\n    value: function _getRotation() {\n      return bt(this.options.rotation - 90);\n    }\n  }, {\n    key: \"_getCircumference\",\n    value: function _getCircumference() {\n      return bt(this.options.circumference);\n    }\n  }, {\n    key: \"_getRotationExtents\",\n    value: function _getRotationExtents() {\n      var t = B,\n        e = -B;\n      for (var s = 0; s < this.chart.data.datasets.length; ++s) if (this.chart.isDatasetVisible(s) && this.chart.getDatasetMeta(s).type === this._type) {\n        var n = this.chart.getDatasetMeta(s).controller,\n          o = n._getRotation(),\n          r = n._getCircumference();\n        t = Math.min(t, o), e = Math.max(e, o + r);\n      }\n      return {\n        rotation: t,\n        circumference: e - t\n      };\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = this.chart,\n        s = e.chartArea,\n        n = this._cachedMeta,\n        o = n.data,\n        r = this.getMaxBorderWidth() + this.getMaxOffset(o) + this.options.spacing,\n        a = Math.max((Math.min(s.width, s.height) - r) / 2, 0),\n        l = Math.min(Eo(this.options.cutout, a), 1),\n        c = this._getRingWeight(this.index),\n        _this$_getRotationExt = this._getRotationExtents(),\n        h = _this$_getRotationExt.circumference,\n        d = _this$_getRotationExt.rotation,\n        _ka = ka(d, h, l),\n        u = _ka.ratioX,\n        f = _ka.ratioY,\n        p = _ka.offsetX,\n        g = _ka.offsetY,\n        m = (s.width - r) / u,\n        b = (s.height - r) / f,\n        _ = Math.max(Math.min(m, b) / 2, 0),\n        v = bn(this.options.radius, _),\n        y = Math.max(v * l, 0),\n        x = (v - y) / this._getVisibleDatasetWeightTotal();\n      this.offsetX = p * v, this.offsetY = g * v, n.total = this.calculateTotal(), this.outerRadius = v - x * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - x * c, 0), this.updateElements(o, 0, o.length, t);\n    }\n  }, {\n    key: \"_circumference\",\n    value: function _circumference(t, e) {\n      var s = this.options,\n        n = this._cachedMeta,\n        o = this._getCircumference();\n      return e && s.animation.animateRotate || !this.chart.getDataVisibility(t) || n._parsed[t] === null || n.data[t].hidden ? 0 : this.calculateCircumference(n._parsed[t] * o / B);\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {\n      var o = n === \"reset\",\n        r = this.chart,\n        a = r.chartArea,\n        c = r.options.animation,\n        h = (a.left + a.right) / 2,\n        d = (a.top + a.bottom) / 2,\n        u = o && c.animateScale,\n        f = u ? 0 : this.innerRadius,\n        p = u ? 0 : this.outerRadius,\n        _this$_getSharedOptio2 = this._getSharedOptions(e, n),\n        g = _this$_getSharedOptio2.sharedOptions,\n        m = _this$_getSharedOptio2.includeOptions;\n      var b = this._getRotation(),\n        _;\n      for (_ = 0; _ < e; ++_) b += this._circumference(_, o);\n      for (_ = e; _ < e + s; ++_) {\n        var v = this._circumference(_, o),\n          y = t[_],\n          x = {\n            x: h + this.offsetX,\n            y: d + this.offsetY,\n            startAngle: b,\n            endAngle: b + v,\n            circumference: v,\n            outerRadius: p,\n            innerRadius: f\n          };\n        m && (x.options = g || this.resolveDataElementOptions(_, y.active ? \"active\" : n)), b += v, this.updateElement(y, _, x, n);\n      }\n    }\n  }, {\n    key: \"calculateTotal\",\n    value: function calculateTotal() {\n      var t = this._cachedMeta,\n        e = t.data;\n      var s = 0,\n        n;\n      for (n = 0; n < e.length; n++) {\n        var o = t._parsed[n];\n        o !== null && !isNaN(o) && this.chart.getDataVisibility(n) && !e[n].hidden && (s += Math.abs(o));\n      }\n      return s;\n    }\n  }, {\n    key: \"calculateCircumference\",\n    value: function calculateCircumference(t) {\n      var e = this._cachedMeta.total;\n      return e > 0 && !isNaN(t) ? B * (Math.abs(t) / e) : 0;\n    }\n  }, {\n    key: \"getLabelAndValue\",\n    value: function getLabelAndValue(t) {\n      var e = this._cachedMeta,\n        s = this.chart,\n        n = s.data.labels || [],\n        o = Hi(e._parsed[t], s.options.locale);\n      return {\n        label: n[t] || \"\",\n        value: o\n      };\n    }\n  }, {\n    key: \"getMaxBorderWidth\",\n    value: function getMaxBorderWidth(t) {\n      var e = 0;\n      var s = this.chart;\n      var n, o, r, a, l;\n      if (!t) {\n        for (n = 0, o = s.data.datasets.length; n < o; ++n) if (s.isDatasetVisible(n)) {\n          r = s.getDatasetMeta(n), t = r.data, a = r.controller;\n          break;\n        }\n      }\n      if (!t) return 0;\n      for (n = 0, o = t.length; n < o; ++n) l = a.resolveDataElementOptions(n), l.borderAlign !== \"inner\" && (e = Math.max(e, l.borderWidth || 0, l.hoverBorderWidth || 0));\n      return e;\n    }\n  }, {\n    key: \"getMaxOffset\",\n    value: function getMaxOffset(t) {\n      var e = 0;\n      for (var s = 0, n = t.length; s < n; ++s) {\n        var o = this.resolveDataElementOptions(s);\n        e = Math.max(e, o.offset || 0, o.hoverOffset || 0);\n      }\n      return e;\n    }\n  }, {\n    key: \"_getRingWeightOffset\",\n    value: function _getRingWeightOffset(t) {\n      var e = 0;\n      for (var s = 0; s < t; ++s) this.chart.isDatasetVisible(s) && (e += this._getRingWeight(s));\n      return e;\n    }\n  }, {\n    key: \"_getRingWeight\",\n    value: function _getRingWeight(t) {\n      return Math.max(D(this.chart.data.datasets[t].weight, 1), 0);\n    }\n  }, {\n    key: \"_getVisibleDatasetWeightTotal\",\n    value: function _getVisibleDatasetWeightTotal() {\n      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n    }\n  }]);\n}(kt);\nw(jt, \"id\", \"doughnut\"), w(jt, \"defaults\", {\n  datasetElementType: !1,\n  dataElementType: \"arc\",\n  animation: {\n    animateRotate: !0,\n    animateScale: !1\n  },\n  animations: {\n    numbers: {\n      type: \"number\",\n      properties: [\"circumference\", \"endAngle\", \"innerRadius\", \"outerRadius\", \"startAngle\", \"x\", \"y\", \"offset\", \"borderWidth\", \"spacing\"]\n    }\n  },\n  cutout: \"50%\",\n  rotation: 0,\n  circumference: 360,\n  radius: \"100%\",\n  spacing: 0,\n  indexAxis: \"r\"\n}), w(jt, \"descriptors\", {\n  _scriptable: function _scriptable(t) {\n    return t !== \"spacing\";\n  },\n  _indexable: function _indexable(t) {\n    return t !== \"spacing\" && !t.startsWith(\"borderDash\") && !t.startsWith(\"hoverBorderDash\");\n  }\n}), w(jt, \"overrides\", {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels: function generateLabels(t) {\n          var e = t.data,\n            _t$legend$options$lab = t.legend.options.labels,\n            s = _t$legend$options$lab.pointStyle,\n            n = _t$legend$options$lab.textAlign,\n            o = _t$legend$options$lab.color,\n            r = _t$legend$options$lab.useBorderRadius,\n            a = _t$legend$options$lab.borderRadius;\n          return e.labels.length && e.datasets.length ? e.labels.map(function (l, c) {\n            var d = t.getDatasetMeta(0).controller.getStyle(c);\n            return {\n              text: l,\n              fillStyle: d.backgroundColor,\n              fontColor: o,\n              hidden: !t.getDataVisibility(c),\n              lineDash: d.borderDash,\n              lineDashOffset: d.borderDashOffset,\n              lineJoin: d.borderJoinStyle,\n              lineWidth: d.borderWidth,\n              strokeStyle: d.borderColor,\n              textAlign: n,\n              pointStyle: s,\n              borderRadius: r && (a || d.borderRadius),\n              index: c\n            };\n          }) : [];\n        }\n      },\n      onClick: function onClick(t, e, s) {\n        s.chart.toggleDataVisibility(e.index), s.chart.update();\n      }\n    }\n  }\n});\nvar Fe = /*#__PURE__*/function (_kt3) {\n  function Fe() {\n    _classCallCheck(this, Fe);\n    return _callSuper(this, Fe, arguments);\n  }\n  _inherits(Fe, _kt3);\n  return _createClass(Fe, [{\n    key: \"initialize\",\n    value: function initialize() {\n      this.enableOptionSharing = !0, this.supportsDecimation = !0, _superPropGet(Fe, \"initialize\", this, 3)([]);\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = this._cachedMeta,\n        s = e.dataset,\n        _e$data = e.data,\n        n = _e$data === void 0 ? [] : _e$data,\n        o = e._dataset,\n        r = this.chart._animationsDisabled;\n      var _wn = wn(e, n, r),\n        a = _wn.start,\n        l = _wn.count;\n      this._drawStart = a, this._drawCount = l, Pn(e) && (a = 0, l = n.length), s._chart = this.chart, s._datasetIndex = this.index, s._decimated = !!o._decimated, s.points = n;\n      var c = this.resolveDatasetElementOptions(t);\n      this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(s, void 0, {\n        animated: !r,\n        options: c\n      }, t), this.updateElements(n, a, l, t);\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {\n      var o = n === \"reset\",\n        _this$_cachedMeta2 = this._cachedMeta,\n        r = _this$_cachedMeta2.iScale,\n        a = _this$_cachedMeta2.vScale,\n        l = _this$_cachedMeta2._stacked,\n        c = _this$_cachedMeta2._dataset,\n        _this$_getSharedOptio3 = this._getSharedOptions(e, n),\n        h = _this$_getSharedOptio3.sharedOptions,\n        d = _this$_getSharedOptio3.includeOptions,\n        u = r.axis,\n        f = a.axis,\n        _this$options2 = this.options,\n        p = _this$options2.spanGaps,\n        g = _this$options2.segment,\n        m = Xt(p) ? p : Number.POSITIVE_INFINITY,\n        b = this.chart._animationsDisabled || o || n === \"none\",\n        _ = e + s,\n        v = t.length;\n      var y = e > 0 && this.getParsed(e - 1);\n      for (var x = 0; x < v; ++x) {\n        var M = t[x],\n          S = b ? M : {};\n        if (x < e || x >= _) {\n          S.skip = !0;\n          continue;\n        }\n        var k = this.getParsed(x),\n          P = R(k[f]),\n          C = S[u] = r.getPixelForValue(k[u], x),\n          O = S[f] = o || P ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, k, l) : k[f], x);\n        S.skip = isNaN(C) || isNaN(O) || P, S.stop = x > 0 && Math.abs(k[u] - y[u]) > m, g && (S.parsed = k, S.raw = c.data[x]), d && (S.options = h || this.resolveDataElementOptions(x, M.active ? \"active\" : n)), b || this.updateElement(M, x, S, n), y = k;\n      }\n    }\n  }, {\n    key: \"getMaxOverflow\",\n    value: function getMaxOverflow() {\n      var t = this._cachedMeta,\n        e = t.dataset,\n        s = e.options && e.options.borderWidth || 0,\n        n = t.data || [];\n      if (!n.length) return s;\n      var o = n[0].size(this.resolveDataElementOptions(0)),\n        r = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1));\n      return Math.max(s, o, r) / 2;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var t = this._cachedMeta;\n      t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), _superPropGet(Fe, \"draw\", this, 3)([]);\n    }\n  }]);\n}(kt);\nw(Fe, \"id\", \"line\"), w(Fe, \"defaults\", {\n  datasetElementType: \"line\",\n  dataElementType: \"point\",\n  showLine: !0,\n  spanGaps: !1\n}), w(Fe, \"overrides\", {\n  scales: {\n    _index_: {\n      type: \"category\"\n    },\n    _value_: {\n      type: \"linear\"\n    }\n  }\n});\nvar ki = /*#__PURE__*/function (_jt) {\n  function ki() {\n    _classCallCheck(this, ki);\n    return _callSuper(this, ki, arguments);\n  }\n  _inherits(ki, _jt);\n  return _createClass(ki);\n}(jt);\nw(ki, \"id\", \"pie\"), w(ki, \"defaults\", {\n  cutout: 0,\n  rotation: 0,\n  circumference: 360,\n  radius: \"100%\"\n});\nvar Ie = /*#__PURE__*/function (_kt4) {\n  function Ie() {\n    _classCallCheck(this, Ie);\n    return _callSuper(this, Ie, arguments);\n  }\n  _inherits(Ie, _kt4);\n  return _createClass(Ie, [{\n    key: \"getLabelAndValue\",\n    value: function getLabelAndValue(t) {\n      var e = this._cachedMeta,\n        s = this.chart.data.labels || [],\n        n = e.xScale,\n        o = e.yScale,\n        r = this.getParsed(t),\n        a = n.getLabelForValue(r.x),\n        l = o.getLabelForValue(r.y);\n      return {\n        label: s[t] || \"\",\n        value: \"(\" + a + \", \" + l + \")\"\n      };\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = this._cachedMeta,\n        _e$data2 = e.data,\n        s = _e$data2 === void 0 ? [] : _e$data2,\n        n = this.chart._animationsDisabled;\n      var _wn2 = wn(e, s, n),\n        o = _wn2.start,\n        r = _wn2.count;\n      if (this._drawStart = o, this._drawCount = r, Pn(e) && (o = 0, r = s.length), this.options.showLine) {\n        this.datasetElementType || this.addElements();\n        var a = e.dataset,\n          l = e._dataset;\n        a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!l._decimated, a.points = s;\n        var c = this.resolveDatasetElementOptions(t);\n        c.segment = this.options.segment, this.updateElement(a, void 0, {\n          animated: !n,\n          options: c\n        }, t);\n      } else this.datasetElementType && (delete e.dataset, this.datasetElementType = !1);\n      this.updateElements(s, o, r, t);\n    }\n  }, {\n    key: \"addElements\",\n    value: function addElements() {\n      var t = this.options.showLine;\n      !this.datasetElementType && t && (this.datasetElementType = this.chart.registry.getElement(\"line\")), _superPropGet(Ie, \"addElements\", this, 3)([]);\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {\n      var o = n === \"reset\",\n        _this$_cachedMeta3 = this._cachedMeta,\n        r = _this$_cachedMeta3.iScale,\n        a = _this$_cachedMeta3.vScale,\n        l = _this$_cachedMeta3._stacked,\n        c = _this$_cachedMeta3._dataset,\n        h = this.resolveDataElementOptions(e, n),\n        d = this.getSharedOptions(h),\n        u = this.includeOptions(n, d),\n        f = r.axis,\n        p = a.axis,\n        _this$options3 = this.options,\n        g = _this$options3.spanGaps,\n        m = _this$options3.segment,\n        b = Xt(g) ? g : Number.POSITIVE_INFINITY,\n        _ = this.chart._animationsDisabled || o || n === \"none\";\n      var v = e > 0 && this.getParsed(e - 1);\n      for (var y = e; y < e + s; ++y) {\n        var x = t[y],\n          M = this.getParsed(y),\n          S = _ ? x : {},\n          k = R(M[p]),\n          P = S[f] = r.getPixelForValue(M[f], y),\n          C = S[p] = o || k ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, M, l) : M[p], y);\n        S.skip = isNaN(P) || isNaN(C) || k, S.stop = y > 0 && Math.abs(M[f] - v[f]) > b, m && (S.parsed = M, S.raw = c.data[y]), u && (S.options = d || this.resolveDataElementOptions(y, x.active ? \"active\" : n)), _ || this.updateElement(x, y, S, n), v = M;\n      }\n      this.updateSharedOptions(d, n, h);\n    }\n  }, {\n    key: \"getMaxOverflow\",\n    value: function getMaxOverflow() {\n      var t = this._cachedMeta,\n        e = t.data || [];\n      if (!this.options.showLine) {\n        var a = 0;\n        for (var l = e.length - 1; l >= 0; --l) a = Math.max(a, e[l].size(this.resolveDataElementOptions(l)) / 2);\n        return a > 0 && a;\n      }\n      var s = t.dataset,\n        n = s.options && s.options.borderWidth || 0;\n      if (!e.length) return n;\n      var o = e[0].size(this.resolveDataElementOptions(0)),\n        r = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));\n      return Math.max(n, o, r) / 2;\n    }\n  }]);\n}(kt);\nw(Ie, \"id\", \"scatter\"), w(Ie, \"defaults\", {\n  datasetElementType: !1,\n  dataElementType: \"point\",\n  showLine: !1,\n  fill: !1\n}), w(Ie, \"overrides\", {\n  interaction: {\n    mode: \"point\"\n  },\n  scales: {\n    x: {\n      type: \"linear\"\n    },\n    y: {\n      type: \"linear\"\n    }\n  }\n});\nfunction Tt() {\n  throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\");\n}\nvar Ui = /*#__PURE__*/function () {\n  function Ui(t) {\n    _classCallCheck(this, Ui);\n    w(this, \"options\");\n    this.options = t || {};\n  }\n  /**\n  * Override default date adapter methods.\n  * Accepts type parameter to define options type.\n  * @example\n  * Chart._adapters._date.override<{myAdapterOption: string}>({\n  *   init() {\n  *     console.log(this.options.myAdapterOption);\n  *   }\n  * })\n  */\n  return _createClass(Ui, [{\n    key: \"init\",\n    value:\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    function init() {}\n  }, {\n    key: \"formats\",\n    value: function formats() {\n      return Tt();\n    }\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      return Tt();\n    }\n  }, {\n    key: \"format\",\n    value: function format() {\n      return Tt();\n    }\n  }, {\n    key: \"add\",\n    value: function add() {\n      return Tt();\n    }\n  }, {\n    key: \"diff\",\n    value: function diff() {\n      return Tt();\n    }\n  }, {\n    key: \"startOf\",\n    value: function startOf() {\n      return Tt();\n    }\n  }, {\n    key: \"endOf\",\n    value: function endOf() {\n      return Tt();\n    }\n  }], [{\n    key: \"override\",\n    value: function override(t) {\n      Object.assign(Ui.prototype, t);\n    }\n  }]);\n}();\nvar wa = {\n  _date: Ui\n};\nfunction Pa(i, t, e, s) {\n  var n = i.controller,\n    o = i.data,\n    r = i._sorted,\n    a = n._cachedMeta.iScale,\n    l = i.dataset && i.dataset.options ? i.dataset.options.spanGaps : null;\n  if (a && t === a.axis && t !== \"r\" && r && o.length) {\n    var c = a._reversePixels ? Ko : Et;\n    if (s) {\n      if (n._sharedOptions) {\n        var h = o[0],\n          d = typeof h.getRange == \"function\" && h.getRange(t);\n        if (d) {\n          var u = c(o, t, e - d),\n            f = c(o, t, e + d);\n          return {\n            lo: u.lo,\n            hi: f.hi\n          };\n        }\n      }\n    } else {\n      var _h = c(o, t, e);\n      if (l) {\n        var _d = n._cachedMeta.vScale,\n          _u = i._parsed,\n          _f = _u.slice(0, _h.lo + 1).reverse().findIndex(function (g) {\n            return !R(g[_d.axis]);\n          });\n        _h.lo -= Math.max(0, _f);\n        var p = _u.slice(_h.hi).findIndex(function (g) {\n          return !R(g[_d.axis]);\n        });\n        _h.hi += Math.max(0, p);\n      }\n      return _h;\n    }\n  }\n  return {\n    lo: 0,\n    hi: o.length - 1\n  };\n}\nfunction ti(i, t, e, s, n) {\n  var o = i.getSortedVisibleDatasetMetas(),\n    r = e[t];\n  for (var a = 0, l = o.length; a < l; ++a) {\n    var _o$a = o[a],\n      c = _o$a.index,\n      h = _o$a.data,\n      _Pa = Pa(o[a], t, r, n),\n      d = _Pa.lo,\n      u = _Pa.hi;\n    for (var f = d; f <= u; ++f) {\n      var p = h[f];\n      p.skip || s(p, c, f);\n    }\n  }\n}\nfunction Da(i) {\n  var t = i.indexOf(\"x\") !== -1,\n    e = i.indexOf(\"y\") !== -1;\n  return function (s, n) {\n    var o = t ? Math.abs(s.x - n.x) : 0,\n      r = e ? Math.abs(s.y - n.y) : 0;\n    return Math.sqrt(Math.pow(o, 2) + Math.pow(r, 2));\n  };\n}\nfunction hi(i, t, e, s, n) {\n  var o = [];\n  return !n && !i.isPointInArea(t) || ti(i, e, t, function (a, l, c) {\n    !n && !me(a, i.chartArea, 0) || a.inRange(t.x, t.y, s) && o.push({\n      element: a,\n      datasetIndex: l,\n      index: c\n    });\n  }, !0), o;\n}\nfunction Ca(i, t, e, s) {\n  var n = [];\n  function o(r, a, l) {\n    var _r$getProps = r.getProps([\"startAngle\", \"endAngle\"], s),\n      c = _r$getProps.startAngle,\n      h = _r$getProps.endAngle,\n      _yn = yn(r, {\n        x: t.x,\n        y: t.y\n      }),\n      d = _yn.angle;\n    pe(d, c, h) && n.push({\n      element: r,\n      datasetIndex: a,\n      index: l\n    });\n  }\n  return ti(i, e, t, o), n;\n}\nfunction Oa(i, t, e, s, n, o) {\n  var r = [];\n  var a = Da(e);\n  var l = Number.POSITIVE_INFINITY;\n  function c(h, d, u) {\n    var f = h.inRange(t.x, t.y, n);\n    if (s && !f) return;\n    var p = h.getCenterPoint(n);\n    if (!(!!o || i.isPointInArea(p)) && !f) return;\n    var m = a(t, p);\n    m < l ? (r = [{\n      element: h,\n      datasetIndex: d,\n      index: u\n    }], l = m) : m === l && r.push({\n      element: h,\n      datasetIndex: d,\n      index: u\n    });\n  }\n  return ti(i, e, t, c), r;\n}\nfunction di(i, t, e, s, n, o) {\n  return !o && !i.isPointInArea(t) ? [] : e === \"r\" && !s ? Ca(i, t, e, n) : Oa(i, t, e, s, n, o);\n}\nfunction Ps(i, t, e, s, n) {\n  var o = [],\n    r = e === \"x\" ? \"inXRange\" : \"inYRange\";\n  var a = !1;\n  return ti(i, e, t, function (l, c, h) {\n    l[r] && l[r](t[e], n) && (o.push({\n      element: l,\n      datasetIndex: c,\n      index: h\n    }), a = a || l.inRange(t.x, t.y, n));\n  }), s && !a ? [] : o;\n}\nvar Ta = {\n  modes: {\n    index: function index(i, t, e, s) {\n      var n = At(t, i),\n        o = e.axis || \"x\",\n        r = e.includeInvisible || !1,\n        a = e.intersect ? hi(i, n, o, s, r) : di(i, n, o, !1, s, r),\n        l = [];\n      return a.length ? (i.getSortedVisibleDatasetMetas().forEach(function (c) {\n        var h = a[0].index,\n          d = c.data[h];\n        d && !d.skip && l.push({\n          element: d,\n          datasetIndex: c.index,\n          index: h\n        });\n      }), l) : [];\n    },\n    dataset: function dataset(i, t, e, s) {\n      var n = At(t, i),\n        o = e.axis || \"xy\",\n        r = e.includeInvisible || !1;\n      var a = e.intersect ? hi(i, n, o, s, r) : di(i, n, o, !1, s, r);\n      if (a.length > 0) {\n        var l = a[0].datasetIndex,\n          c = i.getDatasetMeta(l).data;\n        a = [];\n        for (var h = 0; h < c.length; ++h) a.push({\n          element: c[h],\n          datasetIndex: l,\n          index: h\n        });\n      }\n      return a;\n    },\n    point: function point(i, t, e, s) {\n      var n = At(t, i),\n        o = e.axis || \"xy\",\n        r = e.includeInvisible || !1;\n      return hi(i, n, o, s, r);\n    },\n    nearest: function nearest(i, t, e, s) {\n      var n = At(t, i),\n        o = e.axis || \"xy\",\n        r = e.includeInvisible || !1;\n      return di(i, n, o, e.intersect, s, r);\n    },\n    x: function x(i, t, e, s) {\n      var n = At(t, i);\n      return Ps(i, n, \"x\", e.intersect, s);\n    },\n    y: function y(i, t, e, s) {\n      var n = At(t, i);\n      return Ps(i, n, \"y\", e.intersect, s);\n    }\n  }\n};\nvar $n = [\"left\", \"top\", \"right\", \"bottom\"];\nfunction te(i, t) {\n  return i.filter(function (e) {\n    return e.pos === t;\n  });\n}\nfunction Ds(i, t) {\n  return i.filter(function (e) {\n    return $n.indexOf(e.pos) === -1 && e.box.axis === t;\n  });\n}\nfunction ee(i, t) {\n  return i.sort(function (e, s) {\n    var n = t ? s : e,\n      o = t ? e : s;\n    return n.weight === o.weight ? n.index - o.index : n.weight - o.weight;\n  });\n}\nfunction Aa(i) {\n  var t = [];\n  var e, s, n, o, r, a;\n  for (e = 0, s = (i || []).length; e < s; ++e) {\n    var _n3, _n3$options, _n3$options$stackWeig;\n    n = i[e], _n3 = n, o = _n3.position, _n3$options = _n3.options, r = _n3$options.stack, _n3$options$stackWeig = _n3$options.stackWeight, a = _n3$options$stackWeig === void 0 ? 1 : _n3$options$stackWeig, t.push({\n      index: e,\n      box: n,\n      pos: o,\n      horizontal: n.isHorizontal(),\n      weight: n.weight,\n      stack: r && o + r,\n      stackWeight: a\n    });\n  }\n  return t;\n}\nfunction Ra(i) {\n  var t = {};\n  var _iterator15 = _createForOfIteratorHelper(i),\n    _step15;\n  try {\n    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n      var e = _step15.value;\n      var s = e.stack,\n        n = e.pos,\n        o = e.stackWeight;\n      if (!s || !$n.includes(n)) continue;\n      var r = t[s] || (t[s] = {\n        count: 0,\n        placed: 0,\n        weight: 0,\n        size: 0\n      });\n      r.count++, r.weight += o;\n    }\n  } catch (err) {\n    _iterator15.e(err);\n  } finally {\n    _iterator15.f();\n  }\n  return t;\n}\nfunction La(i, t) {\n  var e = Ra(i),\n    s = t.vBoxMaxWidth,\n    n = t.hBoxMaxHeight;\n  var o, r, a;\n  for (o = 0, r = i.length; o < r; ++o) {\n    a = i[o];\n    var l = a.box.fullSize,\n      c = e[a.stack],\n      h = c && a.stackWeight / c.weight;\n    a.horizontal ? (a.width = h ? h * s : l && t.availableWidth, a.height = n) : (a.width = s, a.height = h ? h * n : l && t.availableHeight);\n  }\n  return e;\n}\nfunction Ea(i) {\n  var t = Aa(i),\n    e = ee(t.filter(function (c) {\n      return c.box.fullSize;\n    }), !0),\n    s = ee(te(t, \"left\"), !0),\n    n = ee(te(t, \"right\")),\n    o = ee(te(t, \"top\"), !0),\n    r = ee(te(t, \"bottom\")),\n    a = Ds(t, \"x\"),\n    l = Ds(t, \"y\");\n  return {\n    fullSize: e,\n    leftAndTop: s.concat(o),\n    rightAndBottom: n.concat(l).concat(r).concat(a),\n    chartArea: te(t, \"chartArea\"),\n    vertical: s.concat(n).concat(l),\n    horizontal: o.concat(r).concat(a)\n  };\n}\nfunction Cs(i, t, e, s) {\n  return Math.max(i[e], t[e]) + Math.max(i[s], t[s]);\n}\nfunction Yn(i, t) {\n  i.top = Math.max(i.top, t.top), i.left = Math.max(i.left, t.left), i.bottom = Math.max(i.bottom, t.bottom), i.right = Math.max(i.right, t.right);\n}\nfunction Fa(i, t, e, s) {\n  var n = e.pos,\n    o = e.box,\n    r = i.maxPadding;\n  if (!T(n)) {\n    e.size && (i[n] -= e.size);\n    var d = s[e.stack] || {\n      size: 0,\n      count: 1\n    };\n    d.size = Math.max(d.size, e.horizontal ? o.height : o.width), e.size = d.size / d.count, i[n] += e.size;\n  }\n  o.getPadding && Yn(r, o.getPadding());\n  var a = Math.max(0, t.outerWidth - Cs(r, i, \"left\", \"right\")),\n    l = Math.max(0, t.outerHeight - Cs(r, i, \"top\", \"bottom\")),\n    c = a !== i.w,\n    h = l !== i.h;\n  return i.w = a, i.h = l, e.horizontal ? {\n    same: c,\n    other: h\n  } : {\n    same: h,\n    other: c\n  };\n}\nfunction Ia(i) {\n  var t = i.maxPadding;\n  function e(s) {\n    var n = Math.max(t[s] - i[s], 0);\n    return i[s] += n, n;\n  }\n  i.y += e(\"top\"), i.x += e(\"left\"), e(\"right\"), e(\"bottom\");\n}\nfunction za(i, t) {\n  var e = t.maxPadding;\n  function s(n) {\n    var o = {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n    return n.forEach(function (r) {\n      o[r] = Math.max(t[r], e[r]);\n    }), o;\n  }\n  return s(i ? [\"left\", \"right\"] : [\"top\", \"bottom\"]);\n}\nfunction oe(i, t, e, s) {\n  var n = [];\n  var o, r, a, l, c, h;\n  for (o = 0, r = i.length, c = 0; o < r; ++o) {\n    a = i[o], l = a.box, l.update(a.width || t.w, a.height || t.h, za(a.horizontal, t));\n    var _Fa = Fa(t, e, a, s),\n      d = _Fa.same,\n      u = _Fa.other;\n    c |= d && n.length, h = h || u, l.fullSize || n.push(a);\n  }\n  return c && oe(n, t, e, s) || h;\n}\nfunction Ce(i, t, e, s, n) {\n  i.top = e, i.left = t, i.right = t + s, i.bottom = e + n, i.width = s, i.height = n;\n}\nfunction Os(i, t, e, s) {\n  var n = e.padding;\n  var o = t.x,\n    r = t.y;\n  var _iterator16 = _createForOfIteratorHelper(i),\n    _step16;\n  try {\n    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n      var a = _step16.value;\n      var l = a.box,\n        c = s[a.stack] || {\n          placed: 0,\n          weight: 1\n        },\n        h = a.stackWeight / c.weight || 1;\n      if (a.horizontal) {\n        var d = t.w * h,\n          u = c.size || l.height;\n        ge(c.start) && (r = c.start), l.fullSize ? Ce(l, n.left, r, e.outerWidth - n.right - n.left, u) : Ce(l, t.left + c.placed, r, d, u), c.start = r, c.placed += d, r = l.bottom;\n      } else {\n        var _d2 = t.h * h,\n          _u2 = c.size || l.width;\n        ge(c.start) && (o = c.start), l.fullSize ? Ce(l, o, n.top, _u2, e.outerHeight - n.bottom - n.top) : Ce(l, o, t.top + c.placed, _u2, _d2), c.start = o, c.placed += _d2, o = l.right;\n      }\n    }\n  } catch (err) {\n    _iterator16.e(err);\n  } finally {\n    _iterator16.f();\n  }\n  t.x = o, t.y = r;\n}\nvar tt = {\n  addBox: function addBox(i, t) {\n    i.boxes || (i.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || \"top\", t.weight = t.weight || 0, t._layers = t._layers || function () {\n      return [{\n        z: 0,\n        draw: function draw(e) {\n          t.draw(e);\n        }\n      }];\n    }, i.boxes.push(t);\n  },\n  removeBox: function removeBox(i, t) {\n    var e = i.boxes ? i.boxes.indexOf(t) : -1;\n    e !== -1 && i.boxes.splice(e, 1);\n  },\n  configure: function configure(i, t, e) {\n    t.fullSize = e.fullSize, t.position = e.position, t.weight = e.weight;\n  },\n  update: function update(i, t, e, s) {\n    if (!i) return;\n    var n = et(i.options.layout.padding),\n      o = Math.max(t - n.width, 0),\n      r = Math.max(e - n.height, 0),\n      a = Ea(i.boxes),\n      l = a.vertical,\n      c = a.horizontal;\n    L(i.boxes, function (g) {\n      typeof g.beforeLayout == \"function\" && g.beforeLayout();\n    });\n    var h = l.reduce(function (g, m) {\n        return m.box.options && m.box.options.display === !1 ? g : g + 1;\n      }, 0) || 1,\n      d = Object.freeze({\n        outerWidth: t,\n        outerHeight: e,\n        padding: n,\n        availableWidth: o,\n        availableHeight: r,\n        vBoxMaxWidth: o / 2 / h,\n        hBoxMaxHeight: r / 2\n      }),\n      u = Object.assign({}, n);\n    Yn(u, et(s));\n    var f = Object.assign({\n        maxPadding: u,\n        w: o,\n        h: r,\n        x: n.left,\n        y: n.top\n      }, n),\n      p = La(l.concat(c), d);\n    oe(a.fullSize, f, d, p), oe(l, f, d, p), oe(c, f, d, p) && oe(l, f, d, p), Ia(f), Os(a.leftAndTop, f, d, p), f.x += f.w, f.y += f.h, Os(a.rightAndBottom, f, d, p), i.chartArea = {\n      left: f.left,\n      top: f.top,\n      right: f.left + f.w,\n      bottom: f.top + f.h,\n      height: f.h,\n      width: f.w\n    }, L(a.chartArea, function (g) {\n      var m = g.box;\n      Object.assign(m, i.chartArea), m.update(f.w, f.h, {\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0\n      });\n    });\n  }\n};\nvar Un = /*#__PURE__*/function () {\n  function Un() {\n    _classCallCheck(this, Un);\n  }\n  return _createClass(Un, [{\n    key: \"acquireContext\",\n    value: function acquireContext(t, e) {}\n  }, {\n    key: \"releaseContext\",\n    value: function releaseContext(t) {\n      return !1;\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(t, e, s) {}\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(t, e, s) {}\n  }, {\n    key: \"getDevicePixelRatio\",\n    value: function getDevicePixelRatio() {\n      return 1;\n    }\n  }, {\n    key: \"getMaximumSize\",\n    value: function getMaximumSize(t, e, s, n) {\n      return e = Math.max(0, e || t.width), s = s || t.height, {\n        width: e,\n        height: Math.max(0, n ? Math.floor(e / n) : s)\n      };\n    }\n  }, {\n    key: \"isAttached\",\n    value: function isAttached(t) {\n      return !0;\n    }\n  }, {\n    key: \"updateConfig\",\n    value: function updateConfig(t) {}\n  }]);\n}();\nvar Ba = /*#__PURE__*/function (_Un) {\n  function Ba() {\n    _classCallCheck(this, Ba);\n    return _callSuper(this, Ba, arguments);\n  }\n  _inherits(Ba, _Un);\n  return _createClass(Ba, [{\n    key: \"acquireContext\",\n    value: function acquireContext(t) {\n      return t && t.getContext && t.getContext(\"2d\") || null;\n    }\n  }, {\n    key: \"updateConfig\",\n    value: function updateConfig(t) {\n      t.options.animation = !1;\n    }\n  }]);\n}(Un);\nvar ze = \"$chartjs\",\n  Ha = {\n    touchstart: \"mousedown\",\n    touchmove: \"mousemove\",\n    touchend: \"mouseup\",\n    pointerenter: \"mouseenter\",\n    pointerdown: \"mousedown\",\n    pointermove: \"mousemove\",\n    pointerup: \"mouseup\",\n    pointerleave: \"mouseout\",\n    pointerout: \"mouseout\"\n  },\n  Ts = function Ts(i) {\n    return i === null || i === \"\";\n  };\nfunction Wa(i, t) {\n  var e = i.style,\n    s = i.getAttribute(\"height\"),\n    n = i.getAttribute(\"width\");\n  if (i[ze] = {\n    initial: {\n      height: s,\n      width: n,\n      style: {\n        display: e.display,\n        height: e.height,\n        width: e.width\n      }\n    }\n  }, e.display = e.display || \"block\", e.boxSizing = e.boxSizing || \"border-box\", Ts(n)) {\n    var o = fs(i, \"width\");\n    o !== void 0 && (i.width = o);\n  }\n  if (Ts(s)) if (i.style.height === \"\") i.height = i.width / (t || 2);else {\n    var _o2 = fs(i, \"height\");\n    _o2 !== void 0 && (i.height = _o2);\n  }\n  return i;\n}\nvar Xn = Vr ? {\n  passive: !0\n} : !1;\nfunction Na(i, t, e) {\n  i && i.addEventListener(t, e, Xn);\n}\nfunction Va(i, t, e) {\n  i && i.canvas && i.canvas.removeEventListener(t, e, Xn);\n}\nfunction ja(i, t) {\n  var e = Ha[i.type] || i.type,\n    _At = At(i, t),\n    s = _At.x,\n    n = _At.y;\n  return {\n    type: e,\n    chart: t,\n    \"native\": i,\n    x: s !== void 0 ? s : null,\n    y: n !== void 0 ? n : null\n  };\n}\nfunction qe(i, t) {\n  var _iterator17 = _createForOfIteratorHelper(i),\n    _step17;\n  try {\n    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n      var e = _step17.value;\n      if (e === t || e.contains(t)) return !0;\n    }\n  } catch (err) {\n    _iterator17.e(err);\n  } finally {\n    _iterator17.f();\n  }\n}\nfunction $a(i, t, e) {\n  var s = i.canvas,\n    n = new MutationObserver(function (o) {\n      var r = !1;\n      var _iterator18 = _createForOfIteratorHelper(o),\n        _step18;\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var a = _step18.value;\n          r = r || qe(a.addedNodes, s), r = r && !qe(a.removedNodes, s);\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n      r && e();\n    });\n  return n.observe(document, {\n    childList: !0,\n    subtree: !0\n  }), n;\n}\nfunction Ya(i, t, e) {\n  var s = i.canvas,\n    n = new MutationObserver(function (o) {\n      var r = !1;\n      var _iterator19 = _createForOfIteratorHelper(o),\n        _step19;\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var a = _step19.value;\n          r = r || qe(a.removedNodes, s), r = r && !qe(a.addedNodes, s);\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n      r && e();\n    });\n  return n.observe(document, {\n    childList: !0,\n    subtree: !0\n  }), n;\n}\nvar _e = /* @__PURE__ */new Map();\nvar As = 0;\nfunction qn() {\n  var i = window.devicePixelRatio;\n  i !== As && (As = i, _e.forEach(function (t, e) {\n    e.currentDevicePixelRatio !== i && t();\n  }));\n}\nfunction Ua(i, t) {\n  _e.size || window.addEventListener(\"resize\", qn), _e.set(i, t);\n}\nfunction Xa(i) {\n  _e[\"delete\"](i), _e.size || window.removeEventListener(\"resize\", qn);\n}\nfunction qa(i, t, e) {\n  var s = i.canvas,\n    n = s && Yi(s);\n  if (!n) return;\n  var o = kn(function (a, l) {\n      var c = n.clientWidth;\n      e(a, l), c < n.clientWidth && e();\n    }, window),\n    r = new ResizeObserver(function (a) {\n      var l = a[0],\n        c = l.contentRect.width,\n        h = l.contentRect.height;\n      c === 0 && h === 0 || o(c, h);\n    });\n  return r.observe(n), Ua(i, o), r;\n}\nfunction ui(i, t, e) {\n  e && e.disconnect(), t === \"resize\" && Xa(i);\n}\nfunction Ka(i, t, e) {\n  var s = i.canvas,\n    n = kn(function (o) {\n      i.ctx !== null && e(ja(o, i));\n    }, i);\n  return Na(s, t, n), n;\n}\nvar Ga = /*#__PURE__*/function (_Un2) {\n  function Ga() {\n    _classCallCheck(this, Ga);\n    return _callSuper(this, Ga, arguments);\n  }\n  _inherits(Ga, _Un2);\n  return _createClass(Ga, [{\n    key: \"acquireContext\",\n    value: function acquireContext(t, e) {\n      var s = t && t.getContext && t.getContext(\"2d\");\n      return s && s.canvas === t ? (Wa(t, e), s) : null;\n    }\n  }, {\n    key: \"releaseContext\",\n    value: function releaseContext(t) {\n      var e = t.canvas;\n      if (!e[ze]) return !1;\n      var s = e[ze].initial;\n      [\"height\", \"width\"].forEach(function (o) {\n        var r = s[o];\n        R(r) ? e.removeAttribute(o) : e.setAttribute(o, r);\n      });\n      var n = s.style || {};\n      return Object.keys(n).forEach(function (o) {\n        e.style[o] = n[o];\n      }), e.width = e.width, delete e[ze], !0;\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(t, e, s) {\n      this.removeEventListener(t, e);\n      var n = t.$proxies || (t.$proxies = {}),\n        r = {\n          attach: $a,\n          detach: Ya,\n          resize: qa\n        }[e] || Ka;\n      n[e] = r(t, e, s);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(t, e) {\n      var s = t.$proxies || (t.$proxies = {}),\n        n = s[e];\n      if (!n) return;\n      ({\n        attach: ui,\n        detach: ui,\n        resize: ui\n      }[e] || Va)(t, e, n), s[e] = void 0;\n    }\n  }, {\n    key: \"getDevicePixelRatio\",\n    value: function getDevicePixelRatio() {\n      return window.devicePixelRatio;\n    }\n  }, {\n    key: \"getMaximumSize\",\n    value: function getMaximumSize(t, e, s, n) {\n      return Nr(t, e, s, n);\n    }\n  }, {\n    key: \"isAttached\",\n    value: function isAttached(t) {\n      var e = t && Yi(t);\n      return !!(e && e.isConnected);\n    }\n  }]);\n}(Un);\nfunction Ja(i) {\n  return !$i() || (typeof OffscreenCanvas === \"undefined\" ? \"undefined\" : _typeof(OffscreenCanvas)) < \"u\" && i instanceof OffscreenCanvas ? Ba : Ga;\n}\nvar st = /*#__PURE__*/function () {\n  function st() {\n    _classCallCheck(this, st);\n    w(this, \"x\");\n    w(this, \"y\");\n    w(this, \"active\", !1);\n    w(this, \"options\");\n    w(this, \"$animations\");\n  }\n  return _createClass(st, [{\n    key: \"tooltipPosition\",\n    value: function tooltipPosition(t) {\n      var _this$getProps = this.getProps([\"x\", \"y\"], t),\n        e = _this$getProps.x,\n        s = _this$getProps.y;\n      return {\n        x: e,\n        y: s\n      };\n    }\n  }, {\n    key: \"hasValue\",\n    value: function hasValue() {\n      return Xt(this.x) && Xt(this.y);\n    }\n  }, {\n    key: \"getProps\",\n    value: function getProps(t, e) {\n      var _this7 = this;\n      var s = this.$animations;\n      if (!e || !s) return this;\n      var n = {};\n      return t.forEach(function (o) {\n        n[o] = s[o] && s[o].active() ? s[o]._to : _this7[o];\n      }), n;\n    }\n  }]);\n}();\nw(st, \"defaults\", {}), w(st, \"defaultRoutes\");\nfunction Za(i, t) {\n  var e = i.options.ticks,\n    s = Qa(i),\n    n = Math.min(e.maxTicksLimit || s, s),\n    o = e.major.enabled ? el(t) : [],\n    r = o.length,\n    a = o[0],\n    l = o[r - 1],\n    c = [];\n  if (r > n) return il(t, c, o, r / n), c;\n  var h = tl(o, t, n);\n  if (r > 0) {\n    var d, u;\n    var f = r > 1 ? Math.round((l - a) / (r - 1)) : null;\n    for (Oe(t, c, h, R(f) ? 0 : a - f, a), d = 0, u = r - 1; d < u; d++) Oe(t, c, h, o[d], o[d + 1]);\n    return Oe(t, c, h, l, R(f) ? t.length : l + f), c;\n  }\n  return Oe(t, c, h), c;\n}\nfunction Qa(i) {\n  var t = i.options.offset,\n    e = i._tickSize(),\n    s = i._length / e + (t ? 0 : 1),\n    n = i._maxLength / e;\n  return Math.floor(Math.min(s, n));\n}\nfunction tl(i, t, e) {\n  var s = sl(i),\n    n = t.length / e;\n  if (!s) return Math.max(n, 1);\n  var o = Vo(s);\n  for (var r = 0, a = o.length - 1; r < a; r++) {\n    var l = o[r];\n    if (l > n) return l;\n  }\n  return Math.max(n, 1);\n}\nfunction el(i) {\n  var t = [];\n  var e, s;\n  for (e = 0, s = i.length; e < s; e++) i[e].major && t.push(e);\n  return t;\n}\nfunction il(i, t, e, s) {\n  var n = 0,\n    o = e[0],\n    r;\n  for (s = Math.ceil(s), r = 0; r < i.length; r++) r === o && (t.push(i[r]), n++, o = e[n * s]);\n}\nfunction Oe(i, t, e, s, n) {\n  var o = D(s, 0),\n    r = Math.min(D(n, i.length), i.length);\n  var a = 0,\n    l,\n    c,\n    h;\n  for (e = Math.ceil(e), n && (l = n - s, e = l / Math.floor(l / e)), h = o; h < 0;) a++, h = Math.round(o + a * e);\n  for (c = Math.max(o, 0); c < r; c++) c === h && (t.push(i[c]), a++, h = Math.round(o + a * e));\n}\nfunction sl(i) {\n  var t = i.length;\n  var e, s;\n  if (t < 2) return !1;\n  for (s = i[0], e = 1; e < t; ++e) if (i[e] - i[e - 1] !== s) return !1;\n  return s;\n}\nvar nl = function nl(i) {\n    return i === \"left\" ? \"right\" : i === \"right\" ? \"left\" : i;\n  },\n  Rs = function Rs(i, t, e) {\n    return t === \"top\" || t === \"left\" ? i[t] + e : i[t] - e;\n  },\n  Ls = function Ls(i, t) {\n    return Math.min(t || i, i);\n  };\nfunction Es(i, t) {\n  var e = [],\n    s = i.length / t,\n    n = i.length;\n  var o = 0;\n  for (; o < n; o += s) e.push(i[Math.floor(o)]);\n  return e;\n}\nfunction ol(i, t, e) {\n  var s = i.ticks.length,\n    n = Math.min(t, s - 1),\n    o = i._startPixel,\n    r = i._endPixel,\n    a = 1e-6;\n  var l = i.getPixelForTick(n),\n    c;\n  if (!(e && (s === 1 ? c = Math.max(l - o, r - l) : t === 0 ? c = (i.getPixelForTick(1) - l) / 2 : c = (l - i.getPixelForTick(n - 1)) / 2, l += n < t ? c : -c, l < o - a || l > r + a))) return l;\n}\nfunction rl(i, t) {\n  L(i, function (e) {\n    var s = e.gc,\n      n = s.length / 2;\n    var o;\n    if (n > t) {\n      for (o = 0; o < n; ++o) delete e.data[s[o]];\n      s.splice(0, n);\n    }\n  });\n}\nfunction ie(i) {\n  return i.drawTicks ? i.tickLength : 0;\n}\nfunction Fs(i, t) {\n  if (!i.display) return 0;\n  var e = X(i.font, t),\n    s = et(i.padding);\n  return (N(i.text) ? i.text.length : 1) * e.lineHeight + s.height;\n}\nfunction al(i, t) {\n  return Bt(i, {\n    scale: t,\n    type: \"scale\"\n  });\n}\nfunction ll(i, t, e) {\n  return Bt(i, {\n    tick: e,\n    index: t,\n    type: \"tick\"\n  });\n}\nfunction cl(i, t, e) {\n  var s = zi(i);\n  return (e && t !== \"right\" || !e && t === \"right\") && (s = nl(s)), s;\n}\nfunction hl(i, t, e, s) {\n  var n = i.top,\n    o = i.left,\n    r = i.bottom,\n    a = i.right,\n    l = i.chart,\n    c = l.chartArea,\n    h = l.scales;\n  var d = 0,\n    u,\n    f,\n    p;\n  var g = r - n,\n    m = a - o;\n  if (i.isHorizontal()) {\n    if (f = Y(s, o, a), T(e)) {\n      var b = Object.keys(e)[0],\n        _ = e[b];\n      p = h[b].getPixelForValue(_) + g - t;\n    } else e === \"center\" ? p = (c.bottom + c.top) / 2 + g - t : p = Rs(i, e, t);\n    u = a - o;\n  } else {\n    if (T(e)) {\n      var _b = Object.keys(e)[0],\n        _3 = e[_b];\n      f = h[_b].getPixelForValue(_3) - m + t;\n    } else e === \"center\" ? f = (c.left + c.right) / 2 - m + t : f = Rs(i, e, t);\n    p = Y(s, r, n), d = e === \"left\" ? -V : V;\n  }\n  return {\n    titleX: f,\n    titleY: p,\n    maxWidth: u,\n    rotation: d\n  };\n}\nvar Gt = /*#__PURE__*/function (_st) {\n  function Gt(t) {\n    var _this8;\n    _classCallCheck(this, Gt);\n    _this8 = _callSuper(this, Gt), _this8.id = t.id, _this8.type = t.type, _this8.options = void 0, _this8.ctx = t.ctx, _this8.chart = t.chart, _this8.top = void 0, _this8.bottom = void 0, _this8.left = void 0, _this8.right = void 0, _this8.width = void 0, _this8.height = void 0, _this8._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, _this8.maxWidth = void 0, _this8.maxHeight = void 0, _this8.paddingTop = void 0, _this8.paddingBottom = void 0, _this8.paddingLeft = void 0, _this8.paddingRight = void 0, _this8.axis = void 0, _this8.labelRotation = void 0, _this8.min = void 0, _this8.max = void 0, _this8._range = void 0, _this8.ticks = [], _this8._gridLineItems = null, _this8._labelItems = null, _this8._labelSizes = null, _this8._length = 0, _this8._maxLength = 0, _this8._longestTextCache = {}, _this8._startPixel = void 0, _this8._endPixel = void 0, _this8._reversePixels = !1, _this8._userMax = void 0, _this8._userMin = void 0, _this8._suggestedMax = void 0, _this8._suggestedMin = void 0, _this8._ticksLength = 0, _this8._borderValue = 0, _this8._cache = {}, _this8._dataLimitsCached = !1, _this8.$context = void 0;\n    return _this8;\n  }\n  _inherits(Gt, _st);\n  return _createClass(Gt, [{\n    key: \"init\",\n    value: function init(t) {\n      this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(t, e) {\n      return t;\n    }\n  }, {\n    key: \"getUserBounds\",\n    value: function getUserBounds() {\n      var t = this._userMin,\n        e = this._userMax,\n        s = this._suggestedMin,\n        n = this._suggestedMax;\n      return t = ot(t, Number.POSITIVE_INFINITY), e = ot(e, Number.NEGATIVE_INFINITY), s = ot(s, Number.POSITIVE_INFINITY), n = ot(n, Number.NEGATIVE_INFINITY), {\n        min: ot(t, s),\n        max: ot(e, n),\n        minDefined: q(t),\n        maxDefined: q(e)\n      };\n    }\n  }, {\n    key: \"getMinMax\",\n    value: function getMinMax(t) {\n      var _this$getUserBounds = this.getUserBounds(),\n        e = _this$getUserBounds.min,\n        s = _this$getUserBounds.max,\n        n = _this$getUserBounds.minDefined,\n        o = _this$getUserBounds.maxDefined,\n        r;\n      if (n && o) return {\n        min: e,\n        max: s\n      };\n      var a = this.getMatchingVisibleMetas();\n      for (var l = 0, c = a.length; l < c; ++l) r = a[l].controller.getMinMax(this, t), n || (e = Math.min(e, r.min)), o || (s = Math.max(s, r.max));\n      return e = o && e > s ? s : e, s = n && e > s ? e : s, {\n        min: ot(e, ot(s, e)),\n        max: ot(s, ot(e, s))\n      };\n    }\n  }, {\n    key: \"getPadding\",\n    value: function getPadding() {\n      return {\n        left: this.paddingLeft || 0,\n        top: this.paddingTop || 0,\n        right: this.paddingRight || 0,\n        bottom: this.paddingBottom || 0\n      };\n    }\n  }, {\n    key: \"getTicks\",\n    value: function getTicks() {\n      return this.ticks;\n    }\n  }, {\n    key: \"getLabels\",\n    value: function getLabels() {\n      var t = this.chart.data;\n      return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];\n    }\n  }, {\n    key: \"getLabelItems\",\n    value: function getLabelItems() {\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.chart.chartArea;\n      return this._labelItems || (this._labelItems = this._computeLabelItems(t));\n    }\n  }, {\n    key: \"beforeLayout\",\n    value: function beforeLayout() {\n      this._cache = {}, this._dataLimitsCached = !1;\n    }\n  }, {\n    key: \"beforeUpdate\",\n    value: function beforeUpdate() {\n      I(this.options.beforeUpdate, [this]);\n    }\n  }, {\n    key: \"update\",\n    value: function update(t, e, s) {\n      var _this$options4 = this.options,\n        n = _this$options4.beginAtZero,\n        o = _this$options4.grace,\n        r = _this$options4.ticks,\n        a = r.sampleSize;\n      this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = s = Object.assign({\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }, s), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + s.left + s.right : this.height + s.top + s.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = xr(this, o, n), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();\n      var l = a < this.ticks.length;\n      this._convertTicksToLabels(l ? Es(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), r.display && (r.autoSkip || r.source === \"auto\") && (this.ticks = Za(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();\n    }\n  }, {\n    key: \"configure\",\n    value: function configure() {\n      var t = this.options.reverse,\n        e,\n        s;\n      this.isHorizontal() ? (e = this.left, s = this.right) : (e = this.top, s = this.bottom, t = !t), this._startPixel = e, this._endPixel = s, this._reversePixels = t, this._length = s - e, this._alignToPixels = this.options.alignToPixels;\n    }\n  }, {\n    key: \"afterUpdate\",\n    value: function afterUpdate() {\n      I(this.options.afterUpdate, [this]);\n    }\n  }, {\n    key: \"beforeSetDimensions\",\n    value: function beforeSetDimensions() {\n      I(this.options.beforeSetDimensions, [this]);\n    }\n  }, {\n    key: \"setDimensions\",\n    value: function setDimensions() {\n      this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;\n    }\n  }, {\n    key: \"afterSetDimensions\",\n    value: function afterSetDimensions() {\n      I(this.options.afterSetDimensions, [this]);\n    }\n  }, {\n    key: \"_callHooks\",\n    value: function _callHooks(t) {\n      this.chart.notifyPlugins(t, this.getContext()), I(this.options[t], [this]);\n    }\n  }, {\n    key: \"beforeDataLimits\",\n    value: function beforeDataLimits() {\n      this._callHooks(\"beforeDataLimits\");\n    }\n  }, {\n    key: \"determineDataLimits\",\n    value: function determineDataLimits() {}\n  }, {\n    key: \"afterDataLimits\",\n    value: function afterDataLimits() {\n      this._callHooks(\"afterDataLimits\");\n    }\n  }, {\n    key: \"beforeBuildTicks\",\n    value: function beforeBuildTicks() {\n      this._callHooks(\"beforeBuildTicks\");\n    }\n  }, {\n    key: \"buildTicks\",\n    value: function buildTicks() {\n      return [];\n    }\n  }, {\n    key: \"afterBuildTicks\",\n    value: function afterBuildTicks() {\n      this._callHooks(\"afterBuildTicks\");\n    }\n  }, {\n    key: \"beforeTickToLabelConversion\",\n    value: function beforeTickToLabelConversion() {\n      I(this.options.beforeTickToLabelConversion, [this]);\n    }\n  }, {\n    key: \"generateTickLabels\",\n    value: function generateTickLabels(t) {\n      var e = this.options.ticks;\n      var s, n, o;\n      for (s = 0, n = t.length; s < n; s++) o = t[s], o.label = I(e.callback, [o.value, s, t], this);\n    }\n  }, {\n    key: \"afterTickToLabelConversion\",\n    value: function afterTickToLabelConversion() {\n      I(this.options.afterTickToLabelConversion, [this]);\n    }\n  }, {\n    key: \"beforeCalculateLabelRotation\",\n    value: function beforeCalculateLabelRotation() {\n      I(this.options.beforeCalculateLabelRotation, [this]);\n    }\n  }, {\n    key: \"calculateLabelRotation\",\n    value: function calculateLabelRotation() {\n      var t = this.options,\n        e = t.ticks,\n        s = Ls(this.ticks.length, t.ticks.maxTicksLimit),\n        n = e.minRotation || 0,\n        o = e.maxRotation;\n      var r = n,\n        a,\n        l,\n        c;\n      if (!this._isVisible() || !e.display || n >= o || s <= 1 || !this.isHorizontal()) {\n        this.labelRotation = n;\n        return;\n      }\n      var h = this._getLabelSizes(),\n        d = h.widest.width,\n        u = h.highest.height,\n        f = U(this.chart.width - d, 0, this.maxWidth);\n      a = t.offset ? this.maxWidth / s : f / (s - 1), d + 6 > a && (a = f / (s - (t.offset ? 0.5 : 1)), l = this.maxHeight - ie(t.grid) - e.padding - Fs(t.title, this.chart.options.font), c = Math.sqrt(d * d + u * u), r = Uo(Math.min(Math.asin(U((h.highest.height + 6) / a, -1, 1)), Math.asin(U(l / c, -1, 1)) - Math.asin(U(u / c, -1, 1)))), r = Math.max(n, Math.min(o, r))), this.labelRotation = r;\n    }\n  }, {\n    key: \"afterCalculateLabelRotation\",\n    value: function afterCalculateLabelRotation() {\n      I(this.options.afterCalculateLabelRotation, [this]);\n    }\n  }, {\n    key: \"afterAutoSkip\",\n    value: function afterAutoSkip() {}\n  }, {\n    key: \"beforeFit\",\n    value: function beforeFit() {\n      I(this.options.beforeFit, [this]);\n    }\n  }, {\n    key: \"fit\",\n    value: function fit() {\n      var t = {\n          width: 0,\n          height: 0\n        },\n        e = this.chart,\n        _this$options5 = this.options,\n        s = _this$options5.ticks,\n        n = _this$options5.title,\n        o = _this$options5.grid,\n        r = this._isVisible(),\n        a = this.isHorizontal();\n      if (r) {\n        var l = Fs(n, e.options.font);\n        if (a ? (t.width = this.maxWidth, t.height = ie(o) + l) : (t.height = this.maxHeight, t.width = ie(o) + l), s.display && this.ticks.length) {\n          var _this$_getLabelSizes = this._getLabelSizes(),\n            c = _this$_getLabelSizes.first,\n            h = _this$_getLabelSizes.last,\n            d = _this$_getLabelSizes.widest,\n            u = _this$_getLabelSizes.highest,\n            f = s.padding * 2,\n            p = bt(this.labelRotation),\n            g = Math.cos(p),\n            m = Math.sin(p);\n          if (a) {\n            var b = s.mirror ? 0 : m * d.width + g * u.height;\n            t.height = Math.min(this.maxHeight, t.height + b + f);\n          } else {\n            var _b2 = s.mirror ? 0 : g * d.width + m * u.height;\n            t.width = Math.min(this.maxWidth, t.width + _b2 + f);\n          }\n          this._calculatePadding(c, h, m, g);\n        }\n      }\n      this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom);\n    }\n  }, {\n    key: \"_calculatePadding\",\n    value: function _calculatePadding(t, e, s, n) {\n      var _this$options6 = this.options,\n        _this$options6$ticks = _this$options6.ticks,\n        o = _this$options6$ticks.align,\n        r = _this$options6$ticks.padding,\n        a = _this$options6.position,\n        l = this.labelRotation !== 0,\n        c = a !== \"top\" && this.axis === \"x\";\n      if (this.isHorizontal()) {\n        var h = this.getPixelForTick(0) - this.left,\n          d = this.right - this.getPixelForTick(this.ticks.length - 1);\n        var u = 0,\n          f = 0;\n        l ? c ? (u = n * t.width, f = s * e.height) : (u = s * t.height, f = n * e.width) : o === \"start\" ? f = e.width : o === \"end\" ? u = t.width : o !== \"inner\" && (u = t.width / 2, f = e.width / 2), this.paddingLeft = Math.max((u - h + r) * this.width / (this.width - h), 0), this.paddingRight = Math.max((f - d + r) * this.width / (this.width - d), 0);\n      } else {\n        var _h2 = e.height / 2,\n          _d3 = t.height / 2;\n        o === \"start\" ? (_h2 = 0, _d3 = t.height) : o === \"end\" && (_h2 = e.height, _d3 = 0), this.paddingTop = _h2 + r, this.paddingBottom = _d3 + r;\n      }\n    }\n  }, {\n    key: \"_handleMargins\",\n    value: function _handleMargins() {\n      this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));\n    }\n  }, {\n    key: \"afterFit\",\n    value: function afterFit() {\n      I(this.options.afterFit, [this]);\n    }\n  }, {\n    key: \"isHorizontal\",\n    value: function isHorizontal() {\n      var _this$options7 = this.options,\n        t = _this$options7.axis,\n        e = _this$options7.position;\n      return e === \"top\" || e === \"bottom\" || t === \"x\";\n    }\n  }, {\n    key: \"isFullSize\",\n    value: function isFullSize() {\n      return this.options.fullSize;\n    }\n  }, {\n    key: \"_convertTicksToLabels\",\n    value: function _convertTicksToLabels(t) {\n      this.beforeTickToLabelConversion(), this.generateTickLabels(t);\n      var e, s;\n      for (e = 0, s = t.length; e < s; e++) R(t[e].label) && (t.splice(e, 1), s--, e--);\n      this.afterTickToLabelConversion();\n    }\n  }, {\n    key: \"_getLabelSizes\",\n    value: function _getLabelSizes() {\n      var t = this._labelSizes;\n      if (!t) {\n        var e = this.options.ticks.sampleSize;\n        var s = this.ticks;\n        e < s.length && (s = Es(s, e)), this._labelSizes = t = this._computeLabelSizes(s, s.length, this.options.ticks.maxTicksLimit);\n      }\n      return t;\n    }\n  }, {\n    key: \"_computeLabelSizes\",\n    value: function _computeLabelSizes(t, e, s) {\n      var n = this.ctx,\n        o = this._longestTextCache,\n        r = [],\n        a = [],\n        l = Math.floor(e / Ls(e, s));\n      var c = 0,\n        h = 0,\n        d,\n        u,\n        f,\n        p,\n        g,\n        m,\n        b,\n        _,\n        v,\n        y,\n        x;\n      for (d = 0; d < e; d += l) {\n        if (p = t[d].label, g = this._resolveTickFontOptions(d), n.font = m = g.string, b = o[m] = o[m] || {\n          data: {},\n          gc: []\n        }, _ = g.lineHeight, v = y = 0, !R(p) && !N(p)) v = ls(n, b.data, b.gc, v, p), y = _;else if (N(p)) for (u = 0, f = p.length; u < f; ++u) x = p[u], !R(x) && !N(x) && (v = ls(n, b.data, b.gc, v, x), y += _);\n        r.push(v), a.push(y), c = Math.max(v, c), h = Math.max(y, h);\n      }\n      rl(o, e);\n      var M = r.indexOf(c),\n        S = a.indexOf(h),\n        k = function k(P) {\n          return {\n            width: r[P] || 0,\n            height: a[P] || 0\n          };\n        };\n      return {\n        first: k(0),\n        last: k(e - 1),\n        widest: k(M),\n        highest: k(S),\n        widths: r,\n        heights: a\n      };\n    }\n  }, {\n    key: \"getLabelForValue\",\n    value: function getLabelForValue(t) {\n      return t;\n    }\n  }, {\n    key: \"getPixelForValue\",\n    value: function getPixelForValue(t, e) {\n      return NaN;\n    }\n  }, {\n    key: \"getValueForPixel\",\n    value: function getValueForPixel(t) {}\n  }, {\n    key: \"getPixelForTick\",\n    value: function getPixelForTick(t) {\n      var e = this.ticks;\n      return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n    }\n  }, {\n    key: \"getPixelForDecimal\",\n    value: function getPixelForDecimal(t) {\n      this._reversePixels && (t = 1 - t);\n      var e = this._startPixel + t * this._length;\n      return qo(this._alignToPixels ? Ot(this.chart, e, 0) : e);\n    }\n  }, {\n    key: \"getDecimalForPixel\",\n    value: function getDecimalForPixel(t) {\n      var e = (t - this._startPixel) / this._length;\n      return this._reversePixels ? 1 - e : e;\n    }\n  }, {\n    key: \"getBasePixel\",\n    value: function getBasePixel() {\n      return this.getPixelForValue(this.getBaseValue());\n    }\n  }, {\n    key: \"getBaseValue\",\n    value: function getBaseValue() {\n      var t = this.min,\n        e = this.max;\n      return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext(t) {\n      var e = this.ticks || [];\n      if (t >= 0 && t < e.length) {\n        var s = e[t];\n        return s.$context || (s.$context = ll(this.getContext(), t, s));\n      }\n      return this.$context || (this.$context = al(this.chart.getContext(), this));\n    }\n  }, {\n    key: \"_tickSize\",\n    value: function _tickSize() {\n      var t = this.options.ticks,\n        e = bt(this.labelRotation),\n        s = Math.abs(Math.cos(e)),\n        n = Math.abs(Math.sin(e)),\n        o = this._getLabelSizes(),\n        r = t.autoSkipPadding || 0,\n        a = o ? o.widest.width + r : 0,\n        l = o ? o.highest.height + r : 0;\n      return this.isHorizontal() ? l * s > a * n ? a / s : l / n : l * n < a * s ? l / s : a / n;\n    }\n  }, {\n    key: \"_isVisible\",\n    value: function _isVisible() {\n      var t = this.options.display;\n      return t !== \"auto\" ? !!t : this.getMatchingVisibleMetas().length > 0;\n    }\n  }, {\n    key: \"_computeGridLineItems\",\n    value: function _computeGridLineItems(t) {\n      var e = this.axis,\n        s = this.chart,\n        n = this.options,\n        o = n.grid,\n        r = n.position,\n        a = n.border,\n        l = o.offset,\n        c = this.isHorizontal(),\n        d = this.ticks.length + (l ? 1 : 0),\n        u = ie(o),\n        f = [],\n        p = a.setContext(this.getContext()),\n        g = p.display ? p.width : 0,\n        m = g / 2,\n        b = function b(z) {\n          return Ot(s, z, g);\n        };\n      var _, v, y, x, M, S, k, P, C, O, A, j;\n      if (r === \"top\") _ = b(this.bottom), S = this.bottom - u, P = _ - m, O = b(t.top) + m, j = t.bottom;else if (r === \"bottom\") _ = b(this.top), O = t.top, j = b(t.bottom) - m, S = _ + m, P = this.top + u;else if (r === \"left\") _ = b(this.right), M = this.right - u, k = _ - m, C = b(t.left) + m, A = t.right;else if (r === \"right\") _ = b(this.left), C = t.left, A = b(t.right) - m, M = _ + m, k = this.left + u;else if (e === \"x\") {\n        if (r === \"center\") _ = b((t.top + t.bottom) / 2 + 0.5);else if (T(r)) {\n          var z = Object.keys(r)[0],\n            H = r[z];\n          _ = b(this.chart.scales[z].getPixelForValue(H));\n        }\n        O = t.top, j = t.bottom, S = _ + m, P = S + u;\n      } else if (e === \"y\") {\n        if (r === \"center\") _ = b((t.left + t.right) / 2);else if (T(r)) {\n          var _z = Object.keys(r)[0],\n            _H = r[_z];\n          _ = b(this.chart.scales[_z].getPixelForValue(_H));\n        }\n        M = _ - m, k = M - u, C = t.left, A = t.right;\n      }\n      var J = D(n.ticks.maxTicksLimit, d),\n        F = Math.max(1, Math.ceil(d / J));\n      for (v = 0; v < d; v += F) {\n        var _z2 = this.getContext(v),\n          _H2 = o.setContext(_z2),\n          it = a.setContext(_z2),\n          $ = _H2.lineWidth,\n          Ht = _H2.color,\n          ye = it.dash || [],\n          Wt = it.dashOffset,\n          Jt = _H2.tickWidth,\n          Pt = _H2.tickColor,\n          Zt = _H2.tickBorderDash || [],\n          Dt = _H2.tickBorderDashOffset;\n        y = ol(this, v, l), y !== void 0 && (x = Ot(s, y, $), c ? M = k = C = A = x : S = P = O = j = x, f.push({\n          tx1: M,\n          ty1: S,\n          tx2: k,\n          ty2: P,\n          x1: C,\n          y1: O,\n          x2: A,\n          y2: j,\n          width: $,\n          color: Ht,\n          borderDash: ye,\n          borderDashOffset: Wt,\n          tickWidth: Jt,\n          tickColor: Pt,\n          tickBorderDash: Zt,\n          tickBorderDashOffset: Dt\n        }));\n      }\n      return this._ticksLength = d, this._borderValue = _, f;\n    }\n  }, {\n    key: \"_computeLabelItems\",\n    value: function _computeLabelItems(t) {\n      var e = this.axis,\n        s = this.options,\n        n = s.position,\n        o = s.ticks,\n        r = this.isHorizontal(),\n        a = this.ticks,\n        l = o.align,\n        c = o.crossAlign,\n        h = o.padding,\n        d = o.mirror,\n        u = ie(s.grid),\n        f = u + h,\n        p = d ? -h : f,\n        g = -bt(this.labelRotation),\n        m = [];\n      var b,\n        _,\n        v,\n        y,\n        x,\n        M,\n        S,\n        k,\n        P,\n        C,\n        O,\n        A,\n        j = \"middle\";\n      if (n === \"top\") M = this.bottom - p, S = this._getXAxisLabelAlignment();else if (n === \"bottom\") M = this.top + p, S = this._getXAxisLabelAlignment();else if (n === \"left\") {\n        var F = this._getYAxisLabelAlignment(u);\n        S = F.textAlign, x = F.x;\n      } else if (n === \"right\") {\n        var _F = this._getYAxisLabelAlignment(u);\n        S = _F.textAlign, x = _F.x;\n      } else if (e === \"x\") {\n        if (n === \"center\") M = (t.top + t.bottom) / 2 + f;else if (T(n)) {\n          var _F2 = Object.keys(n)[0],\n            z = n[_F2];\n          M = this.chart.scales[_F2].getPixelForValue(z) + f;\n        }\n        S = this._getXAxisLabelAlignment();\n      } else if (e === \"y\") {\n        if (n === \"center\") x = (t.left + t.right) / 2 - f;else if (T(n)) {\n          var _F3 = Object.keys(n)[0],\n            _z3 = n[_F3];\n          x = this.chart.scales[_F3].getPixelForValue(_z3);\n        }\n        S = this._getYAxisLabelAlignment(u).textAlign;\n      }\n      e === \"y\" && (l === \"start\" ? j = \"top\" : l === \"end\" && (j = \"bottom\"));\n      var J = this._getLabelSizes();\n      for (b = 0, _ = a.length; b < _; ++b) {\n        v = a[b], y = v.label;\n        var _F4 = o.setContext(this.getContext(b));\n        k = this.getPixelForTick(b) + o.labelOffset, P = this._resolveTickFontOptions(b), C = P.lineHeight, O = N(y) ? y.length : 1;\n        var _z4 = O / 2,\n          H = _F4.color,\n          it = _F4.textStrokeColor,\n          $ = _F4.textStrokeWidth;\n        var Ht = S;\n        r ? (x = k, S === \"inner\" && (b === _ - 1 ? Ht = this.options.reverse ? \"left\" : \"right\" : b === 0 ? Ht = this.options.reverse ? \"right\" : \"left\" : Ht = \"center\"), n === \"top\" ? c === \"near\" || g !== 0 ? A = -O * C + C / 2 : c === \"center\" ? A = -J.highest.height / 2 - _z4 * C + C : A = -J.highest.height + C / 2 : c === \"near\" || g !== 0 ? A = C / 2 : c === \"center\" ? A = J.highest.height / 2 - _z4 * C : A = J.highest.height - O * C, d && (A *= -1), g !== 0 && !_F4.showLabelBackdrop && (x += C / 2 * Math.sin(g))) : (M = k, A = (1 - O) * C / 2);\n        var ye = void 0;\n        if (_F4.showLabelBackdrop) {\n          var Wt = et(_F4.backdropPadding),\n            Jt = J.heights[b],\n            Pt = J.widths[b];\n          var Zt = A - Wt.top,\n            Dt = 0 - Wt.left;\n          switch (j) {\n            case \"middle\":\n              Zt -= Jt / 2;\n              break;\n            case \"bottom\":\n              Zt -= Jt;\n              break;\n          }\n          switch (S) {\n            case \"center\":\n              Dt -= Pt / 2;\n              break;\n            case \"right\":\n              Dt -= Pt;\n              break;\n            case \"inner\":\n              b === _ - 1 ? Dt -= Pt : b > 0 && (Dt -= Pt / 2);\n              break;\n          }\n          ye = {\n            left: Dt,\n            top: Zt,\n            width: Pt + Wt.width,\n            height: Jt + Wt.height,\n            color: _F4.backdropColor\n          };\n        }\n        m.push({\n          label: y,\n          font: P,\n          textOffset: A,\n          options: {\n            rotation: g,\n            color: H,\n            strokeColor: it,\n            strokeWidth: $,\n            textAlign: Ht,\n            textBaseline: j,\n            translation: [x, M],\n            backdrop: ye\n          }\n        });\n      }\n      return m;\n    }\n  }, {\n    key: \"_getXAxisLabelAlignment\",\n    value: function _getXAxisLabelAlignment() {\n      var _this$options8 = this.options,\n        t = _this$options8.position,\n        e = _this$options8.ticks;\n      if (-bt(this.labelRotation)) return t === \"top\" ? \"left\" : \"right\";\n      var n = \"center\";\n      return e.align === \"start\" ? n = \"left\" : e.align === \"end\" ? n = \"right\" : e.align === \"inner\" && (n = \"inner\"), n;\n    }\n  }, {\n    key: \"_getYAxisLabelAlignment\",\n    value: function _getYAxisLabelAlignment(t) {\n      var _this$options9 = this.options,\n        e = _this$options9.position,\n        _this$options9$ticks = _this$options9.ticks,\n        s = _this$options9$ticks.crossAlign,\n        n = _this$options9$ticks.mirror,\n        o = _this$options9$ticks.padding,\n        r = this._getLabelSizes(),\n        a = t + o,\n        l = r.widest.width;\n      var c, h;\n      return e === \"left\" ? n ? (h = this.right + o, s === \"near\" ? c = \"left\" : s === \"center\" ? (c = \"center\", h += l / 2) : (c = \"right\", h += l)) : (h = this.right - a, s === \"near\" ? c = \"right\" : s === \"center\" ? (c = \"center\", h -= l / 2) : (c = \"left\", h = this.left)) : e === \"right\" ? n ? (h = this.left + o, s === \"near\" ? c = \"right\" : s === \"center\" ? (c = \"center\", h -= l / 2) : (c = \"left\", h -= l)) : (h = this.left + a, s === \"near\" ? c = \"left\" : s === \"center\" ? (c = \"center\", h += l / 2) : (c = \"right\", h = this.right)) : c = \"right\", {\n        textAlign: c,\n        x: h\n      };\n    }\n  }, {\n    key: \"_computeLabelArea\",\n    value: function _computeLabelArea() {\n      if (this.options.ticks.mirror) return;\n      var t = this.chart,\n        e = this.options.position;\n      if (e === \"left\" || e === \"right\") return {\n        top: 0,\n        left: this.left,\n        bottom: t.height,\n        right: this.right\n      };\n      if (e === \"top\" || e === \"bottom\") return {\n        top: this.top,\n        left: 0,\n        bottom: this.bottom,\n        right: t.width\n      };\n    }\n  }, {\n    key: \"drawBackground\",\n    value: function drawBackground() {\n      var t = this.ctx,\n        e = this.options.backgroundColor,\n        s = this.left,\n        n = this.top,\n        o = this.width,\n        r = this.height;\n      e && (t.save(), t.fillStyle = e, t.fillRect(s, n, o, r), t.restore());\n    }\n  }, {\n    key: \"getLineWidthForValue\",\n    value: function getLineWidthForValue(t) {\n      var e = this.options.grid;\n      if (!this._isVisible() || !e.display) return 0;\n      var n = this.ticks.findIndex(function (o) {\n        return o.value === t;\n      });\n      return n >= 0 ? e.setContext(this.getContext(n)).lineWidth : 0;\n    }\n  }, {\n    key: \"drawGrid\",\n    value: function drawGrid(t) {\n      var e = this.options.grid,\n        s = this.ctx,\n        n = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));\n      var o, r;\n      var a = function a(l, c, h) {\n        !h.width || !h.color || (s.save(), s.lineWidth = h.width, s.strokeStyle = h.color, s.setLineDash(h.borderDash || []), s.lineDashOffset = h.borderDashOffset, s.beginPath(), s.moveTo(l.x, l.y), s.lineTo(c.x, c.y), s.stroke(), s.restore());\n      };\n      if (e.display) for (o = 0, r = n.length; o < r; ++o) {\n        var l = n[o];\n        e.drawOnChartArea && a({\n          x: l.x1,\n          y: l.y1\n        }, {\n          x: l.x2,\n          y: l.y2\n        }, l), e.drawTicks && a({\n          x: l.tx1,\n          y: l.ty1\n        }, {\n          x: l.tx2,\n          y: l.ty2\n        }, {\n          color: l.tickColor,\n          width: l.tickWidth,\n          borderDash: l.tickBorderDash,\n          borderDashOffset: l.tickBorderDashOffset\n        });\n      }\n    }\n  }, {\n    key: \"drawBorder\",\n    value: function drawBorder() {\n      var t = this.chart,\n        e = this.ctx,\n        _this$options0 = this.options,\n        s = _this$options0.border,\n        n = _this$options0.grid,\n        o = s.setContext(this.getContext()),\n        r = s.display ? o.width : 0;\n      if (!r) return;\n      var a = n.setContext(this.getContext(0)).lineWidth,\n        l = this._borderValue;\n      var c, h, d, u;\n      this.isHorizontal() ? (c = Ot(t, this.left, r) - r / 2, h = Ot(t, this.right, a) + a / 2, d = u = l) : (d = Ot(t, this.top, r) - r / 2, u = Ot(t, this.bottom, a) + a / 2, c = h = l), e.save(), e.lineWidth = o.width, e.strokeStyle = o.color, e.beginPath(), e.moveTo(c, d), e.lineTo(h, u), e.stroke(), e.restore();\n    }\n  }, {\n    key: \"drawLabels\",\n    value: function drawLabels(t) {\n      if (!this.options.ticks.display) return;\n      var s = this.ctx,\n        n = this._computeLabelArea();\n      n && Je(s, n);\n      var o = this.getLabelItems(t);\n      var _iterator20 = _createForOfIteratorHelper(o),\n        _step20;\n      try {\n        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n          var r = _step20.value;\n          var a = r.options,\n            l = r.font,\n            c = r.label,\n            h = r.textOffset;\n          be(s, c, 0, h, l, a);\n        }\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n      n && Ze(s);\n    }\n  }, {\n    key: \"drawTitle\",\n    value: function drawTitle() {\n      var t = this.ctx,\n        _this$options1 = this.options,\n        e = _this$options1.position,\n        s = _this$options1.title,\n        n = _this$options1.reverse;\n      if (!s.display) return;\n      var o = X(s.font),\n        r = et(s.padding),\n        a = s.align;\n      var l = o.lineHeight / 2;\n      e === \"bottom\" || e === \"center\" || T(e) ? (l += r.bottom, N(s.text) && (l += o.lineHeight * (s.text.length - 1))) : l += r.top;\n      var _hl = hl(this, l, e, a),\n        c = _hl.titleX,\n        h = _hl.titleY,\n        d = _hl.maxWidth,\n        u = _hl.rotation;\n      be(t, s.text, 0, 0, o, {\n        color: s.color,\n        maxWidth: d,\n        rotation: u,\n        textAlign: cl(a, e, n),\n        textBaseline: \"middle\",\n        translation: [c, h]\n      });\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(t) {\n      this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));\n    }\n  }, {\n    key: \"_layers\",\n    value: function _layers() {\n      var _this9 = this;\n      var t = this.options,\n        e = t.ticks && t.ticks.z || 0,\n        s = D(t.grid && t.grid.z, -1),\n        n = D(t.border && t.border.z, 0);\n      return !this._isVisible() || this.draw !== Gt.prototype.draw ? [{\n        z: e,\n        draw: function draw(o) {\n          _this9.draw(o);\n        }\n      }] : [{\n        z: s,\n        draw: function draw(o) {\n          _this9.drawBackground(), _this9.drawGrid(o), _this9.drawTitle();\n        }\n      }, {\n        z: n,\n        draw: function draw() {\n          _this9.drawBorder();\n        }\n      }, {\n        z: e,\n        draw: function draw(o) {\n          _this9.drawLabels(o);\n        }\n      }];\n    }\n  }, {\n    key: \"getMatchingVisibleMetas\",\n    value: function getMatchingVisibleMetas(t) {\n      var e = this.chart.getSortedVisibleDatasetMetas(),\n        s = this.axis + \"AxisID\",\n        n = [];\n      var o, r;\n      for (o = 0, r = e.length; o < r; ++o) {\n        var a = e[o];\n        a[s] === this.id && (!t || a.type === t) && n.push(a);\n      }\n      return n;\n    }\n  }, {\n    key: \"_resolveTickFontOptions\",\n    value: function _resolveTickFontOptions(t) {\n      var e = this.options.ticks.setContext(this.getContext(t));\n      return X(e.font);\n    }\n  }, {\n    key: \"_maxDigits\",\n    value: function _maxDigits() {\n      var t = this._resolveTickFontOptions(0).lineHeight;\n      return (this.isHorizontal() ? this.width : this.height) / t;\n    }\n  }]);\n}(st);\nvar Te = /*#__PURE__*/function () {\n  function Te(t, e, s) {\n    _classCallCheck(this, Te);\n    this.type = t, this.scope = e, this.override = s, this.items = /* @__PURE__ */Object.create(null);\n  }\n  return _createClass(Te, [{\n    key: \"isForType\",\n    value: function isForType(t) {\n      return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);\n    }\n  }, {\n    key: \"register\",\n    value: function register(t) {\n      var e = Object.getPrototypeOf(t);\n      var s;\n      fl(e) && (s = this.register(e));\n      var n = this.items,\n        o = t.id,\n        r = this.scope + \".\" + o;\n      if (!o) throw new Error(\"class does not have id: \" + t);\n      return o in n || (n[o] = t, dl(t, r, s), this.override && W.override(t.id, t.overrides)), r;\n    }\n  }, {\n    key: \"get\",\n    value: function get(t) {\n      return this.items[t];\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister(t) {\n      var e = this.items,\n        s = t.id,\n        n = this.scope;\n      s in e && delete e[s], n && s in W[n] && (delete W[n][s], this.override && delete zt[s]);\n    }\n  }]);\n}();\nfunction dl(i, t, e) {\n  var s = fe(/* @__PURE__ */Object.create(null), [e ? W.get(e) : {}, W.get(t), i.defaults]);\n  W.set(t, s), i.defaultRoutes && ul(t, i.defaultRoutes), i.descriptors && W.describe(t, i.descriptors);\n}\nfunction ul(i, t) {\n  Object.keys(t).forEach(function (e) {\n    var s = e.split(\".\"),\n      n = s.pop(),\n      o = [i].concat(s).join(\".\"),\n      r = t[e].split(\".\"),\n      a = r.pop(),\n      l = r.join(\".\");\n    W.route(o, n, l, a);\n  });\n}\nfunction fl(i) {\n  return \"id\" in i && \"defaults\" in i;\n}\nvar gl = /*#__PURE__*/function () {\n  function gl() {\n    _classCallCheck(this, gl);\n    this.controllers = new Te(kt, \"datasets\", !0), this.elements = new Te(st, \"elements\"), this.plugins = new Te(Object, \"plugins\"), this.scales = new Te(Gt, \"scales\"), this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n  return _createClass(gl, [{\n    key: \"add\",\n    value: function add() {\n      for (var _len4 = arguments.length, t = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        t[_key4] = arguments[_key4];\n      }\n      this._each(\"register\", t);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      for (var _len5 = arguments.length, t = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        t[_key5] = arguments[_key5];\n      }\n      this._each(\"unregister\", t);\n    }\n  }, {\n    key: \"addControllers\",\n    value: function addControllers() {\n      for (var _len6 = arguments.length, t = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        t[_key6] = arguments[_key6];\n      }\n      this._each(\"register\", t, this.controllers);\n    }\n  }, {\n    key: \"addElements\",\n    value: function addElements() {\n      for (var _len7 = arguments.length, t = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        t[_key7] = arguments[_key7];\n      }\n      this._each(\"register\", t, this.elements);\n    }\n  }, {\n    key: \"addPlugins\",\n    value: function addPlugins() {\n      for (var _len8 = arguments.length, t = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        t[_key8] = arguments[_key8];\n      }\n      this._each(\"register\", t, this.plugins);\n    }\n  }, {\n    key: \"addScales\",\n    value: function addScales() {\n      for (var _len9 = arguments.length, t = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        t[_key9] = arguments[_key9];\n      }\n      this._each(\"register\", t, this.scales);\n    }\n  }, {\n    key: \"getController\",\n    value: function getController(t) {\n      return this._get(t, this.controllers, \"controller\");\n    }\n  }, {\n    key: \"getElement\",\n    value: function getElement(t) {\n      return this._get(t, this.elements, \"element\");\n    }\n  }, {\n    key: \"getPlugin\",\n    value: function getPlugin(t) {\n      return this._get(t, this.plugins, \"plugin\");\n    }\n  }, {\n    key: \"getScale\",\n    value: function getScale(t) {\n      return this._get(t, this.scales, \"scale\");\n    }\n  }, {\n    key: \"removeControllers\",\n    value: function removeControllers() {\n      for (var _len0 = arguments.length, t = new Array(_len0), _key0 = 0; _key0 < _len0; _key0++) {\n        t[_key0] = arguments[_key0];\n      }\n      this._each(\"unregister\", t, this.controllers);\n    }\n  }, {\n    key: \"removeElements\",\n    value: function removeElements() {\n      for (var _len1 = arguments.length, t = new Array(_len1), _key1 = 0; _key1 < _len1; _key1++) {\n        t[_key1] = arguments[_key1];\n      }\n      this._each(\"unregister\", t, this.elements);\n    }\n  }, {\n    key: \"removePlugins\",\n    value: function removePlugins() {\n      for (var _len10 = arguments.length, t = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        t[_key10] = arguments[_key10];\n      }\n      this._each(\"unregister\", t, this.plugins);\n    }\n  }, {\n    key: \"removeScales\",\n    value: function removeScales() {\n      for (var _len11 = arguments.length, t = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        t[_key11] = arguments[_key11];\n      }\n      this._each(\"unregister\", t, this.scales);\n    }\n  }, {\n    key: \"_each\",\n    value: function _each(t, e, s) {\n      var _this0 = this;\n      _toConsumableArray(e).forEach(function (n) {\n        var o = s || _this0._getRegistryForType(n);\n        s || o.isForType(n) || o === _this0.plugins && n.id ? _this0._exec(t, o, n) : L(n, function (r) {\n          var a = s || _this0._getRegistryForType(r);\n          _this0._exec(t, a, r);\n        });\n      });\n    }\n  }, {\n    key: \"_exec\",\n    value: function _exec(t, e, s) {\n      var n = Fi(t);\n      I(s[\"before\" + n], [], s), e[t](s), I(s[\"after\" + n], [], s);\n    }\n  }, {\n    key: \"_getRegistryForType\",\n    value: function _getRegistryForType(t) {\n      for (var e = 0; e < this._typedRegistries.length; e++) {\n        var s = this._typedRegistries[e];\n        if (s.isForType(t)) return s;\n      }\n      return this.plugins;\n    }\n  }, {\n    key: \"_get\",\n    value: function _get(t, e, s) {\n      var n = e.get(t);\n      if (n === void 0) throw new Error('\"' + t + '\" is not a registered ' + s + \".\");\n      return n;\n    }\n  }]);\n}();\nvar at = /* @__PURE__ */new gl();\nvar pl = /*#__PURE__*/function () {\n  function pl() {\n    _classCallCheck(this, pl);\n    this._init = void 0;\n  }\n  return _createClass(pl, [{\n    key: \"notify\",\n    value: function notify(t, e, s, n) {\n      if (e === \"beforeInit\" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, \"install\")), this._init === void 0) return;\n      var o = n ? this._descriptors(t).filter(n) : this._descriptors(t),\n        r = this._notify(o, t, e, s);\n      return e === \"afterDestroy\" && (this._notify(o, t, \"stop\"), this._notify(this._init, t, \"uninstall\"), this._init = void 0), r;\n    }\n  }, {\n    key: \"_notify\",\n    value: function _notify(t, e, s, n) {\n      n = n || {};\n      var _iterator21 = _createForOfIteratorHelper(t),\n        _step21;\n      try {\n        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n          var o = _step21.value;\n          var r = o.plugin,\n            a = r[s],\n            l = [e, n, o.options];\n          if (I(a, l, r) === !1 && n.cancelable) return !1;\n        }\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n      return !0;\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate() {\n      R(this._cache) || (this._oldCache = this._cache, this._cache = void 0);\n    }\n  }, {\n    key: \"_descriptors\",\n    value: function _descriptors(t) {\n      if (this._cache) return this._cache;\n      var e = this._cache = this._createDescriptors(t);\n      return this._notifyStateChanges(t), e;\n    }\n  }, {\n    key: \"_createDescriptors\",\n    value: function _createDescriptors(t, e) {\n      var s = t && t.config,\n        n = D(s.options && s.options.plugins, {}),\n        o = ml(s);\n      return n === !1 && !e ? [] : _l(t, o, n, e);\n    }\n  }, {\n    key: \"_notifyStateChanges\",\n    value: function _notifyStateChanges(t) {\n      var e = this._oldCache || [],\n        s = this._cache,\n        n = function n(o, r) {\n          return o.filter(function (a) {\n            return !r.some(function (l) {\n              return a.plugin.id === l.plugin.id;\n            });\n          });\n        };\n      this._notify(n(e, s), t, \"stop\"), this._notify(n(s, e), t, \"start\");\n    }\n  }]);\n}();\nfunction ml(i) {\n  var t = {},\n    e = [],\n    s = Object.keys(at.plugins.items);\n  for (var o = 0; o < s.length; o++) e.push(at.getPlugin(s[o]));\n  var n = i.plugins || [];\n  for (var _o3 = 0; _o3 < n.length; _o3++) {\n    var r = n[_o3];\n    e.indexOf(r) === -1 && (e.push(r), t[r.id] = !0);\n  }\n  return {\n    plugins: e,\n    localIds: t\n  };\n}\nfunction bl(i, t) {\n  return !t && i === !1 ? null : i === !0 ? {} : i;\n}\nfunction _l(i, _ref3, s, n) {\n  var t = _ref3.plugins,\n    e = _ref3.localIds;\n  var o = [],\n    r = i.getContext();\n  var _iterator22 = _createForOfIteratorHelper(t),\n    _step22;\n  try {\n    for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n      var a = _step22.value;\n      var l = a.id,\n        c = bl(s[l], n);\n      c !== null && o.push({\n        plugin: a,\n        options: xl(i.config, {\n          plugin: a,\n          local: e[l]\n        }, c, r)\n      });\n    }\n  } catch (err) {\n    _iterator22.e(err);\n  } finally {\n    _iterator22.f();\n  }\n  return o;\n}\nfunction xl(i, _ref4, s, n) {\n  var t = _ref4.plugin,\n    e = _ref4.local;\n  var o = i.pluginScopeKeys(t),\n    r = i.getOptionScopes(s, o);\n  return e && t.defaults && r.push(t.defaults), i.createResolver(r, n, [\"\"], {\n    scriptable: !1,\n    indexable: !1,\n    allKeys: !0\n  });\n}\nfunction wi(i, t) {\n  var e = W.datasets[i] || {};\n  return ((t.datasets || {})[i] || {}).indexAxis || t.indexAxis || e.indexAxis || \"x\";\n}\nfunction yl(i, t) {\n  var e = i;\n  return i === \"_index_\" ? e = t : i === \"_value_\" && (e = t === \"x\" ? \"y\" : \"x\"), e;\n}\nfunction vl(i, t) {\n  return i === t ? \"_index_\" : \"_value_\";\n}\nfunction Is(i) {\n  if (i === \"x\" || i === \"y\" || i === \"r\") return i;\n}\nfunction Ml(i) {\n  if (i === \"top\" || i === \"bottom\") return \"x\";\n  if (i === \"left\" || i === \"right\") return \"y\";\n}\nfunction Pi(i) {\n  if (Is(i)) return i;\n  for (var _len12 = arguments.length, t = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {\n    t[_key12 - 1] = arguments[_key12];\n  }\n  for (var _i3 = 0, _t3 = t; _i3 < _t3.length; _i3++) {\n    var e = _t3[_i3];\n    var s = e.axis || Ml(e.position) || i.length > 1 && Is(i[0].toLowerCase());\n    if (s) return s;\n  }\n  throw new Error(\"Cannot determine type of '\".concat(i, \"' axis. Please provide 'axis' or 'position' option.\"));\n}\nfunction zs(i, t, e) {\n  if (e[t + \"AxisID\"] === i) return {\n    axis: t\n  };\n}\nfunction Sl(i, t) {\n  if (t.data && t.data.datasets) {\n    var e = t.data.datasets.filter(function (s) {\n      return s.xAxisID === i || s.yAxisID === i;\n    });\n    if (e.length) return zs(i, \"x\", e[0]) || zs(i, \"y\", e[0]);\n  }\n  return {};\n}\nfunction kl(i, t) {\n  var e = zt[i.type] || {\n      scales: {}\n    },\n    s = t.scales || {},\n    n = wi(i.type, t),\n    o = /* @__PURE__ */Object.create(null);\n  return Object.keys(s).forEach(function (r) {\n    var a = s[r];\n    if (!T(a)) return console.error(\"Invalid scale configuration for scale: \".concat(r));\n    if (a._proxy) return console.warn(\"Ignoring resolver passed as options for scale: \".concat(r));\n    var l = Pi(r, a, Sl(r, i), W.scales[a.type]),\n      c = vl(l, n),\n      h = e.scales || {};\n    o[r] = le(/* @__PURE__ */Object.create(null), [{\n      axis: l\n    }, a, h[l], h[c]]);\n  }), i.data.datasets.forEach(function (r) {\n    var a = r.type || i.type,\n      l = r.indexAxis || wi(a, t),\n      h = (zt[a] || {}).scales || {};\n    Object.keys(h).forEach(function (d) {\n      var u = yl(d, l),\n        f = r[u + \"AxisID\"] || u;\n      o[f] = o[f] || /* @__PURE__ */Object.create(null), le(o[f], [{\n        axis: u\n      }, s[f], h[d]]);\n    });\n  }), Object.keys(o).forEach(function (r) {\n    var a = o[r];\n    le(a, [W.scales[a.type], W.scale]);\n  }), o;\n}\nfunction Kn(i) {\n  var t = i.options || (i.options = {});\n  t.plugins = D(t.plugins, {}), t.scales = kl(i, t);\n}\nfunction Gn(i) {\n  return i = i || {}, i.datasets = i.datasets || [], i.labels = i.labels || [], i;\n}\nfunction wl(i) {\n  return i = i || {}, i.data = Gn(i.data), Kn(i), i;\n}\nvar Bs = /* @__PURE__ */new Map(),\n  Jn = /* @__PURE__ */new Set();\nfunction Ae(i, t) {\n  var e = Bs.get(i);\n  return e || (e = t(), Bs.set(i, e), Jn.add(e)), e;\n}\nvar se = function se(i, t, e) {\n  var s = It(t, e);\n  s !== void 0 && i.add(s);\n};\nvar Pl = /*#__PURE__*/function () {\n  function Pl(t) {\n    _classCallCheck(this, Pl);\n    this._config = wl(t), this._scopeCache = /* @__PURE__ */new Map(), this._resolverCache = /* @__PURE__ */new Map();\n  }\n  return _createClass(Pl, [{\n    key: \"platform\",\n    get: function get() {\n      return this._config.platform;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._config.type;\n    },\n    set: function set(t) {\n      this._config.type = t;\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this._config.data;\n    },\n    set: function set(t) {\n      this._config.data = Gn(t);\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this._config.options;\n    },\n    set: function set(t) {\n      this._config.options = t;\n    }\n  }, {\n    key: \"plugins\",\n    get: function get() {\n      return this._config.plugins;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var t = this._config;\n      this.clearCache(), Kn(t);\n    }\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      this._scopeCache.clear(), this._resolverCache.clear();\n    }\n  }, {\n    key: \"datasetScopeKeys\",\n    value: function datasetScopeKeys(t) {\n      return Ae(t, function () {\n        return [[\"datasets.\".concat(t), \"\"]];\n      });\n    }\n  }, {\n    key: \"datasetAnimationScopeKeys\",\n    value: function datasetAnimationScopeKeys(t, e) {\n      return Ae(\"\".concat(t, \".transition.\").concat(e), function () {\n        return [[\"datasets.\".concat(t, \".transitions.\").concat(e), \"transitions.\".concat(e)], [\"datasets.\".concat(t), \"\"]];\n      });\n    }\n  }, {\n    key: \"datasetElementScopeKeys\",\n    value: function datasetElementScopeKeys(t, e) {\n      return Ae(\"\".concat(t, \"-\").concat(e), function () {\n        return [[\"datasets.\".concat(t, \".elements.\").concat(e), \"datasets.\".concat(t), \"elements.\".concat(e), \"\"]];\n      });\n    }\n  }, {\n    key: \"pluginScopeKeys\",\n    value: function pluginScopeKeys(t) {\n      var e = t.id,\n        s = this.type;\n      return Ae(\"\".concat(s, \"-plugin-\").concat(e), function () {\n        return [[\"plugins.\".concat(e)].concat(_toConsumableArray(t.additionalOptionScopes || []))];\n      });\n    }\n  }, {\n    key: \"_cachedScopes\",\n    value: function _cachedScopes(t, e) {\n      var s = this._scopeCache;\n      var n = s.get(t);\n      return (!n || e) && (n = /* @__PURE__ */new Map(), s.set(t, n)), n;\n    }\n  }, {\n    key: \"getOptionScopes\",\n    value: function getOptionScopes(t, e, s) {\n      var n = this.options,\n        o = this.type,\n        r = this._cachedScopes(t, s),\n        a = r.get(e);\n      if (a) return a;\n      var l = /* @__PURE__ */new Set();\n      e.forEach(function (h) {\n        t && (l.add(t), h.forEach(function (d) {\n          return se(l, t, d);\n        })), h.forEach(function (d) {\n          return se(l, n, d);\n        }), h.forEach(function (d) {\n          return se(l, zt[o] || {}, d);\n        }), h.forEach(function (d) {\n          return se(l, W, d);\n        }), h.forEach(function (d) {\n          return se(l, Mi, d);\n        });\n      });\n      var c = Array.from(l);\n      return c.length === 0 && c.push(/* @__PURE__ */Object.create(null)), Jn.has(e) && r.set(e, c), c;\n    }\n  }, {\n    key: \"chartOptionScopes\",\n    value: function chartOptionScopes() {\n      var t = this.options,\n        e = this.type;\n      return [t, zt[e] || {}, W.datasets[e] || {}, {\n        type: e\n      }, W, Mi];\n    }\n  }, {\n    key: \"resolveNamedOptions\",\n    value: function resolveNamedOptions(t, e, s) {\n      var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [\"\"];\n      var o = {\n          $shared: !0\n        },\n        _Hs = Hs(this._resolverCache, t, n),\n        r = _Hs.resolver,\n        a = _Hs.subPrefixes;\n      var l = r;\n      if (Cl(r, e)) {\n        o.$shared = !1, s = wt(s) ? s() : s;\n        var c = this.createResolver(t, s, a);\n        l = qt(r, s, c);\n      }\n      var _iterator23 = _createForOfIteratorHelper(e),\n        _step23;\n      try {\n        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n          var _c2 = _step23.value;\n          o[_c2] = l[_c2];\n        }\n      } catch (err) {\n        _iterator23.e(err);\n      } finally {\n        _iterator23.f();\n      }\n      return o;\n    }\n  }, {\n    key: \"createResolver\",\n    value: function createResolver(t, e) {\n      var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [\"\"];\n      var n = arguments.length > 3 ? arguments[3] : undefined;\n      var _Hs2 = Hs(this._resolverCache, t, s),\n        o = _Hs2.resolver;\n      return T(e) ? qt(o, e, void 0, n) : o;\n    }\n  }]);\n}();\nfunction Hs(i, t, e) {\n  var s = i.get(t);\n  s || (s = /* @__PURE__ */new Map(), i.set(t, s));\n  var n = e.join();\n  var o = s.get(n);\n  return o || (o = {\n    resolver: Ni(t, e),\n    subPrefixes: e.filter(function (a) {\n      return !a.toLowerCase().includes(\"hover\");\n    })\n  }, s.set(n, o)), o;\n}\nvar Dl = function Dl(i) {\n  return T(i) && Object.getOwnPropertyNames(i).some(function (t) {\n    return wt(i[t]);\n  });\n};\nfunction Cl(i, t) {\n  var _Tn = Tn(i),\n    e = _Tn.isScriptable,\n    s = _Tn.isIndexable;\n  var _iterator24 = _createForOfIteratorHelper(t),\n    _step24;\n  try {\n    for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n      var n = _step24.value;\n      var o = e(n),\n        r = s(n),\n        a = (r || o) && i[n];\n      if (o && (wt(a) || Dl(a)) || r && N(a)) return !0;\n    }\n  } catch (err) {\n    _iterator24.e(err);\n  } finally {\n    _iterator24.f();\n  }\n  return !1;\n}\nvar Ol = \"4.5.1\";\nvar Tl = [\"top\", \"bottom\", \"left\", \"right\", \"chartArea\"];\nfunction Ws(i, t) {\n  return i === \"top\" || i === \"bottom\" || Tl.indexOf(i) === -1 && t === \"x\";\n}\nfunction Ns(i, t) {\n  return function (e, s) {\n    return e[i] === s[i] ? e[t] - s[t] : e[i] - s[i];\n  };\n}\nfunction Vs(i) {\n  var t = i.chart,\n    e = t.options.animation;\n  t.notifyPlugins(\"afterRender\"), I(e && e.onComplete, [i], t);\n}\nfunction Al(i) {\n  var t = i.chart,\n    e = t.options.animation;\n  I(e && e.onProgress, [i], t);\n}\nfunction Zn(i) {\n  return $i() && typeof i == \"string\" ? i = document.getElementById(i) : i && i.length && (i = i[0]), i && i.canvas && (i = i.canvas), i;\n}\nvar Be = {},\n  js = function js(i) {\n    var t = Zn(i);\n    return Object.values(Be).filter(function (e) {\n      return e.canvas === t;\n    }).pop();\n  };\nfunction Rl(i, t, e) {\n  var s = Object.keys(i);\n  for (var _i4 = 0, _s2 = s; _i4 < _s2.length; _i4++) {\n    var n = _s2[_i4];\n    var o = +n;\n    if (o >= t) {\n      var r = i[n];\n      delete i[n], (e > 0 || o > t) && (i[o + e] = r);\n    }\n  }\n}\nfunction Ll(i, t, e, s) {\n  return !e || i.type === \"mouseout\" ? null : s ? t : i;\n}\nvar mt = /*#__PURE__*/function () {\n  function mt(t, e) {\n    var _this1 = this;\n    _classCallCheck(this, mt);\n    var s = this.config = new Pl(e),\n      n = Zn(t),\n      o = js(n);\n    if (o) throw new Error(\"Canvas is already in use. Chart with ID '\" + o.id + \"' must be destroyed before the canvas with ID '\" + o.canvas.id + \"' can be reused.\");\n    var r = s.createResolver(s.chartOptionScopes(), this.getContext());\n    this.platform = new (s.platform || Ja(n))(), this.platform.updateConfig(s);\n    var a = this.platform.acquireContext(n, r.aspectRatio),\n      l = a && a.canvas,\n      c = l && l.height,\n      h = l && l.width;\n    if (this.id = Lo(), this.ctx = a, this.canvas = l, this.width = h, this.height = c, this._options = r, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new pl(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = Zo(function (d) {\n      return _this1.update(d);\n    }, r.resizeDelay || 0), this._dataChanges = [], Be[this.id] = this, !a || !l) {\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n    ut.listen(this, \"complete\", Vs), ut.listen(this, \"progress\", Al), this._initialize(), this.attached && this.update();\n  }\n  return _createClass(mt, [{\n    key: \"aspectRatio\",\n    get: function get() {\n      var _this$options10 = this.options,\n        t = _this$options10.aspectRatio,\n        e = _this$options10.maintainAspectRatio,\n        s = this.width,\n        n = this.height,\n        o = this._aspectRatio;\n      return R(t) ? e && o ? o : n ? s / n : null : t;\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this.config.data;\n    },\n    set: function set(t) {\n      this.config.data = t;\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this._options;\n    },\n    set: function set(t) {\n      this.config.options = t;\n    }\n  }, {\n    key: \"registry\",\n    get: function get() {\n      return at;\n    }\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      return this.notifyPlugins(\"beforeInit\"), this.options.responsive ? this.resize() : us(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins(\"afterInit\"), this;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      return cs(this.canvas, this.ctx), this;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      return ut.stop(this), this;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(t, e) {\n      ut.running(this) ? this._resizeBeforeDraw = {\n        width: t,\n        height: e\n      } : this._resize(t, e);\n    }\n  }, {\n    key: \"_resize\",\n    value: function _resize(t, e) {\n      var s = this.options,\n        n = this.canvas,\n        o = s.maintainAspectRatio && this.aspectRatio,\n        r = this.platform.getMaximumSize(n, t, e, o),\n        a = s.devicePixelRatio || this.platform.getDevicePixelRatio(),\n        l = this.width ? \"resize\" : \"attach\";\n      this.width = r.width, this.height = r.height, this._aspectRatio = this.aspectRatio, us(this, a, !0) && (this.notifyPlugins(\"resize\", {\n        size: r\n      }), I(s.onResize, [this, r], this), this.attached && this._doResize(l) && this.render());\n    }\n  }, {\n    key: \"ensureScalesHaveIDs\",\n    value: function ensureScalesHaveIDs() {\n      var e = this.options.scales || {};\n      L(e, function (s, n) {\n        s.id = n;\n      });\n    }\n  }, {\n    key: \"buildOrUpdateScales\",\n    value: function buildOrUpdateScales() {\n      var _this10 = this;\n      var t = this.options,\n        e = t.scales,\n        s = this.scales,\n        n = Object.keys(s).reduce(function (r, a) {\n          return r[a] = !1, r;\n        }, {});\n      var o = [];\n      e && (o = o.concat(Object.keys(e).map(function (r) {\n        var a = e[r],\n          l = Pi(r, a),\n          c = l === \"r\",\n          h = l === \"x\";\n        return {\n          options: a,\n          dposition: c ? \"chartArea\" : h ? \"bottom\" : \"left\",\n          dtype: c ? \"radialLinear\" : h ? \"category\" : \"linear\"\n        };\n      }))), L(o, function (r) {\n        var a = r.options,\n          l = a.id,\n          c = Pi(l, a),\n          h = D(a.type, r.dtype);\n        (a.position === void 0 || Ws(a.position, c) !== Ws(r.dposition)) && (a.position = r.dposition), n[l] = !0;\n        var d = null;\n        if (l in s && s[l].type === h) d = s[l];else {\n          var u = at.getScale(h);\n          d = new u({\n            id: l,\n            type: h,\n            ctx: _this10.ctx,\n            chart: _this10\n          }), s[d.id] = d;\n        }\n        d.init(a, t);\n      }), L(n, function (r, a) {\n        r || delete s[a];\n      }), L(s, function (r) {\n        tt.configure(_this10, r, r.options), tt.addBox(_this10, r);\n      });\n    }\n  }, {\n    key: \"_updateMetasets\",\n    value: function _updateMetasets() {\n      var t = this._metasets,\n        e = this.data.datasets.length,\n        s = t.length;\n      if (t.sort(function (n, o) {\n        return n.index - o.index;\n      }), s > e) {\n        for (var n = e; n < s; ++n) this._destroyDatasetMeta(n);\n        t.splice(e, s - e);\n      }\n      this._sortedMetasets = t.slice(0).sort(Ns(\"order\", \"index\"));\n    }\n  }, {\n    key: \"_removeUnreferencedMetasets\",\n    value: function _removeUnreferencedMetasets() {\n      var _this11 = this;\n      var t = this._metasets,\n        e = this.data.datasets;\n      t.length > e.length && delete this._stacks, t.forEach(function (s, n) {\n        e.filter(function (o) {\n          return o === s._dataset;\n        }).length === 0 && _this11._destroyDatasetMeta(n);\n      });\n    }\n  }, {\n    key: \"buildOrUpdateControllers\",\n    value: function buildOrUpdateControllers() {\n      var t = [],\n        e = this.data.datasets;\n      var s, n;\n      for (this._removeUnreferencedMetasets(), s = 0, n = e.length; s < n; s++) {\n        var o = e[s];\n        var r = this.getDatasetMeta(s);\n        var a = o.type || this.config.type;\n        if (r.type && r.type !== a && (this._destroyDatasetMeta(s), r = this.getDatasetMeta(s)), r.type = a, r.indexAxis = o.indexAxis || wi(a, this.options), r.order = o.order || 0, r.index = s, r.label = \"\" + o.label, r.visible = this.isDatasetVisible(s), r.controller) r.controller.updateIndex(s), r.controller.linkScales();else {\n          var l = at.getController(a),\n            _W$datasets$a = W.datasets[a],\n            c = _W$datasets$a.datasetElementType,\n            h = _W$datasets$a.dataElementType;\n          Object.assign(l, {\n            dataElementType: at.getElement(h),\n            datasetElementType: c && at.getElement(c)\n          }), r.controller = new l(this, s), t.push(r.controller);\n        }\n      }\n      return this._updateMetasets(), t;\n    }\n  }, {\n    key: \"_resetElements\",\n    value: function _resetElements() {\n      var _this12 = this;\n      L(this.data.datasets, function (t, e) {\n        _this12.getDatasetMeta(e).controller.reset();\n      }, this);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._resetElements(), this.notifyPlugins(\"reset\");\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = this.config;\n      e.update();\n      var s = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()),\n        n = this._animationsDisabled = !s.animation;\n      if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins(\"beforeUpdate\", {\n        mode: t,\n        cancelable: !0\n      }) === !1) return;\n      var o = this.buildOrUpdateControllers();\n      this.notifyPlugins(\"beforeElementsUpdate\");\n      var r = 0;\n      for (var c = 0, h = this.data.datasets.length; c < h; c++) {\n        var _this$getDatasetMeta = this.getDatasetMeta(c),\n          d = _this$getDatasetMeta.controller,\n          u = !n && o.indexOf(d) === -1;\n        d.buildOrUpdateElements(u), r = Math.max(+d.getMaxOverflow(), r);\n      }\n      r = this._minPadding = s.layout.autoPadding ? r : 0, this._updateLayout(r), n || L(o, function (c) {\n        c.reset();\n      }), this._updateDatasets(t), this.notifyPlugins(\"afterUpdate\", {\n        mode: t\n      }), this._layers.sort(Ns(\"z\", \"_idx\"));\n      var a = this._active,\n        l = this._lastEvent;\n      l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render();\n    }\n  }, {\n    key: \"_updateScales\",\n    value: function _updateScales() {\n      var _this13 = this;\n      L(this.scales, function (t) {\n        tt.removeBox(_this13, t);\n      }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();\n    }\n  }, {\n    key: \"_checkEventBindings\",\n    value: function _checkEventBindings() {\n      var t = this.options,\n        e = new Set(Object.keys(this._listeners)),\n        s = new Set(t.events);\n      (!Qi(e, s) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());\n    }\n  }, {\n    key: \"_updateHiddenIndices\",\n    value: function _updateHiddenIndices() {\n      var t = this._hiddenIndices,\n        e = this._getUniformDataChanges() || [];\n      var _iterator25 = _createForOfIteratorHelper(e),\n        _step25;\n      try {\n        for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n          var _step25$value = _step25.value,\n            s = _step25$value.method,\n            n = _step25$value.start,\n            o = _step25$value.count;\n          var r = s === \"_removeElements\" ? -o : o;\n          Rl(t, n, r);\n        }\n      } catch (err) {\n        _iterator25.e(err);\n      } finally {\n        _iterator25.f();\n      }\n    }\n  }, {\n    key: \"_getUniformDataChanges\",\n    value: function _getUniformDataChanges() {\n      var t = this._dataChanges;\n      if (!t || !t.length) return;\n      this._dataChanges = [];\n      var e = this.data.datasets.length,\n        s = function s(o) {\n          return new Set(t.filter(function (r) {\n            return r[0] === o;\n          }).map(function (r, a) {\n            return a + \",\" + r.splice(1).join(\",\");\n          }));\n        },\n        n = s(0);\n      for (var o = 1; o < e; o++) if (!Qi(n, s(o))) return;\n      return Array.from(n).map(function (o) {\n        return o.split(\",\");\n      }).map(function (o) {\n        return {\n          method: o[1],\n          start: +o[2],\n          count: +o[3]\n        };\n      });\n    }\n  }, {\n    key: \"_updateLayout\",\n    value: function _updateLayout(t) {\n      var _this14 = this;\n      if (this.notifyPlugins(\"beforeLayout\", {\n        cancelable: !0\n      }) === !1) return;\n      tt.update(this, this.width, this.height, t);\n      var e = this.chartArea,\n        s = e.width <= 0 || e.height <= 0;\n      this._layers = [], L(this.boxes, function (n) {\n        var _this14$_layers;\n        s && n.position === \"chartArea\" || (n.configure && n.configure(), (_this14$_layers = _this14._layers).push.apply(_this14$_layers, _toConsumableArray(n._layers())));\n      }, this), this._layers.forEach(function (n, o) {\n        n._idx = o;\n      }), this.notifyPlugins(\"afterLayout\");\n    }\n  }, {\n    key: \"_updateDatasets\",\n    value: function _updateDatasets(t) {\n      if (this.notifyPlugins(\"beforeDatasetsUpdate\", {\n        mode: t,\n        cancelable: !0\n      }) !== !1) {\n        for (var e = 0, s = this.data.datasets.length; e < s; ++e) this.getDatasetMeta(e).controller.configure();\n        for (var _e3 = 0, _s3 = this.data.datasets.length; _e3 < _s3; ++_e3) this._updateDataset(_e3, wt(t) ? t({\n          datasetIndex: _e3\n        }) : t);\n        this.notifyPlugins(\"afterDatasetsUpdate\", {\n          mode: t\n        });\n      }\n    }\n  }, {\n    key: \"_updateDataset\",\n    value: function _updateDataset(t, e) {\n      var s = this.getDatasetMeta(t),\n        n = {\n          meta: s,\n          index: t,\n          mode: e,\n          cancelable: !0\n        };\n      this.notifyPlugins(\"beforeDatasetUpdate\", n) !== !1 && (s.controller._update(e), n.cancelable = !1, this.notifyPlugins(\"afterDatasetUpdate\", n));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.notifyPlugins(\"beforeRender\", {\n        cancelable: !0\n      }) !== !1 && (ut.has(this) ? this.attached && !ut.running(this) && ut.start(this) : (this.draw(), Vs({\n        chart: this\n      })));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var t;\n      if (this._resizeBeforeDraw) {\n        var _this$_resizeBeforeDr = this._resizeBeforeDraw,\n          s = _this$_resizeBeforeDr.width,\n          n = _this$_resizeBeforeDr.height;\n        this._resizeBeforeDraw = null, this._resize(s, n);\n      }\n      if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins(\"beforeDraw\", {\n        cancelable: !0\n      }) === !1) return;\n      var e = this._layers;\n      for (t = 0; t < e.length && e[t].z <= 0; ++t) e[t].draw(this.chartArea);\n      for (this._drawDatasets(); t < e.length; ++t) e[t].draw(this.chartArea);\n      this.notifyPlugins(\"afterDraw\");\n    }\n  }, {\n    key: \"_getSortedDatasetMetas\",\n    value: function _getSortedDatasetMetas(t) {\n      var e = this._sortedMetasets,\n        s = [];\n      var n, o;\n      for (n = 0, o = e.length; n < o; ++n) {\n        var r = e[n];\n        (!t || r.visible) && s.push(r);\n      }\n      return s;\n    }\n  }, {\n    key: \"getSortedVisibleDatasetMetas\",\n    value: function getSortedVisibleDatasetMetas() {\n      return this._getSortedDatasetMetas(!0);\n    }\n  }, {\n    key: \"_drawDatasets\",\n    value: function _drawDatasets() {\n      if (this.notifyPlugins(\"beforeDatasetsDraw\", {\n        cancelable: !0\n      }) === !1) return;\n      var t = this.getSortedVisibleDatasetMetas();\n      for (var e = t.length - 1; e >= 0; --e) this._drawDataset(t[e]);\n      this.notifyPlugins(\"afterDatasetsDraw\");\n    }\n  }, {\n    key: \"_drawDataset\",\n    value: function _drawDataset(t) {\n      var e = this.ctx,\n        s = {\n          meta: t,\n          index: t.index,\n          cancelable: !0\n        },\n        n = Wn(this, t);\n      this.notifyPlugins(\"beforeDatasetDraw\", s) !== !1 && (n && Je(e, n), t.controller.draw(), n && Ze(e), s.cancelable = !1, this.notifyPlugins(\"afterDatasetDraw\", s));\n    }\n  }, {\n    key: \"isPointInArea\",\n    value: function isPointInArea(t) {\n      return me(t, this.chartArea, this._minPadding);\n    }\n  }, {\n    key: \"getElementsAtEventForMode\",\n    value: function getElementsAtEventForMode(t, e, s, n) {\n      var o = Ta.modes[e];\n      return typeof o == \"function\" ? o(this, t, s, n) : [];\n    }\n  }, {\n    key: \"getDatasetMeta\",\n    value: function getDatasetMeta(t) {\n      var e = this.data.datasets[t],\n        s = this._metasets;\n      var n = s.filter(function (o) {\n        return o && o._dataset === e;\n      }).pop();\n      return n || (n = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\n        xAxisID: null,\n        yAxisID: null,\n        order: e && e.order || 0,\n        index: t,\n        _dataset: e,\n        _parsed: [],\n        _sorted: !1\n      }, s.push(n)), n;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.$context || (this.$context = Bt(null, {\n        chart: this,\n        type: \"chart\"\n      }));\n    }\n  }, {\n    key: \"getVisibleDatasetCount\",\n    value: function getVisibleDatasetCount() {\n      return this.getSortedVisibleDatasetMetas().length;\n    }\n  }, {\n    key: \"isDatasetVisible\",\n    value: function isDatasetVisible(t) {\n      var e = this.data.datasets[t];\n      if (!e) return !1;\n      var s = this.getDatasetMeta(t);\n      return typeof s.hidden == \"boolean\" ? !s.hidden : !e.hidden;\n    }\n  }, {\n    key: \"setDatasetVisibility\",\n    value: function setDatasetVisibility(t, e) {\n      var s = this.getDatasetMeta(t);\n      s.hidden = !e;\n    }\n  }, {\n    key: \"toggleDataVisibility\",\n    value: function toggleDataVisibility(t) {\n      this._hiddenIndices[t] = !this._hiddenIndices[t];\n    }\n  }, {\n    key: \"getDataVisibility\",\n    value: function getDataVisibility(t) {\n      return !this._hiddenIndices[t];\n    }\n  }, {\n    key: \"_updateVisibility\",\n    value: function _updateVisibility(t, e, s) {\n      var n = s ? \"show\" : \"hide\",\n        o = this.getDatasetMeta(t),\n        r = o.controller._resolveAnimations(void 0, n);\n      ge(e) ? (o.data[e].hidden = !s, this.update()) : (this.setDatasetVisibility(t, s), r.update(o, {\n        visible: s\n      }), this.update(function (a) {\n        return a.datasetIndex === t ? n : void 0;\n      }));\n    }\n  }, {\n    key: \"hide\",\n    value: function hide(t, e) {\n      this._updateVisibility(t, e, !1);\n    }\n  }, {\n    key: \"show\",\n    value: function show(t, e) {\n      this._updateVisibility(t, e, !0);\n    }\n  }, {\n    key: \"_destroyDatasetMeta\",\n    value: function _destroyDatasetMeta(t) {\n      var e = this._metasets[t];\n      e && e.controller && e.controller._destroy(), delete this._metasets[t];\n    }\n  }, {\n    key: \"_stop\",\n    value: function _stop() {\n      var t, e;\n      for (this.stop(), ut.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t) this._destroyDatasetMeta(t);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.notifyPlugins(\"beforeDestroy\");\n      var t = this.canvas,\n        e = this.ctx;\n      this._stop(), this.config.clearCache(), t && (this.unbindEvents(), cs(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), delete Be[this.id], this.notifyPlugins(\"afterDestroy\");\n    }\n  }, {\n    key: \"toBase64Image\",\n    value: function toBase64Image() {\n      var _this$canvas;\n      return (_this$canvas = this.canvas).toDataURL.apply(_this$canvas, arguments);\n    }\n  }, {\n    key: \"bindEvents\",\n    value: function bindEvents() {\n      this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;\n    }\n  }, {\n    key: \"bindUserEvents\",\n    value: function bindUserEvents() {\n      var _this15 = this;\n      var t = this._listeners,\n        e = this.platform,\n        s = function s(o, r) {\n          e.addEventListener(_this15, o, r), t[o] = r;\n        },\n        n = function n(o, r, a) {\n          o.offsetX = r, o.offsetY = a, _this15._eventHandler(o);\n        };\n      L(this.options.events, function (o) {\n        return s(o, n);\n      });\n    }\n  }, {\n    key: \"bindResponsiveEvents\",\n    value: function bindResponsiveEvents() {\n      var _this16 = this;\n      this._responsiveListeners || (this._responsiveListeners = {});\n      var t = this._responsiveListeners,\n        e = this.platform,\n        s = function s(l, c) {\n          e.addEventListener(_this16, l, c), t[l] = c;\n        },\n        n = function n(l, c) {\n          t[l] && (e.removeEventListener(_this16, l, c), delete t[l]);\n        },\n        o = function o(l, c) {\n          _this16.canvas && _this16.resize(l, c);\n        };\n      var r;\n      var _a2 = function a() {\n        n(\"attach\", _a2), _this16.attached = !0, _this16.resize(), s(\"resize\", o), s(\"detach\", r);\n      };\n      r = function r() {\n        _this16.attached = !1, n(\"resize\", o), _this16._stop(), _this16._resize(0, 0), s(\"attach\", _a2);\n      }, e.isAttached(this.canvas) ? _a2() : r();\n    }\n  }, {\n    key: \"unbindEvents\",\n    value: function unbindEvents() {\n      var _this17 = this;\n      L(this._listeners, function (t, e) {\n        _this17.platform.removeEventListener(_this17, e, t);\n      }), this._listeners = {}, L(this._responsiveListeners, function (t, e) {\n        _this17.platform.removeEventListener(_this17, e, t);\n      }), this._responsiveListeners = void 0;\n    }\n  }, {\n    key: \"updateHoverStyle\",\n    value: function updateHoverStyle(t, e, s) {\n      var n = s ? \"set\" : \"remove\";\n      var o, r, a, l;\n      for (e === \"dataset\" && (o = this.getDatasetMeta(t[0].datasetIndex), o.controller[\"_\" + n + \"DatasetHoverStyle\"]()), a = 0, l = t.length; a < l; ++a) {\n        r = t[a];\n        var c = r && this.getDatasetMeta(r.datasetIndex).controller;\n        c && c[n + \"HoverStyle\"](r.element, r.datasetIndex, r.index);\n      }\n    }\n  }, {\n    key: \"getActiveElements\",\n    value: function getActiveElements() {\n      return this._active || [];\n    }\n  }, {\n    key: \"setActiveElements\",\n    value: function setActiveElements(t) {\n      var _this18 = this;\n      var e = this._active || [],\n        s = t.map(function (_ref5) {\n          var o = _ref5.datasetIndex,\n            r = _ref5.index;\n          var a = _this18.getDatasetMeta(o);\n          if (!a) throw new Error(\"No dataset found at index \" + o);\n          return {\n            datasetIndex: o,\n            element: a.data[r],\n            index: r\n          };\n        });\n      !je(s, e) && (this._active = s, this._lastEvent = null, this._updateHoverStyles(s, e));\n    }\n  }, {\n    key: \"notifyPlugins\",\n    value: function notifyPlugins(t, e, s) {\n      return this._plugins.notify(this, t, e, s);\n    }\n  }, {\n    key: \"isPluginEnabled\",\n    value: function isPluginEnabled(t) {\n      return this._plugins._cache.filter(function (e) {\n        return e.plugin.id === t;\n      }).length === 1;\n    }\n  }, {\n    key: \"_updateHoverStyles\",\n    value: function _updateHoverStyles(t, e, s) {\n      var n = this.options.hover,\n        o = function o(l, c) {\n          return l.filter(function (h) {\n            return !c.some(function (d) {\n              return h.datasetIndex === d.datasetIndex && h.index === d.index;\n            });\n          });\n        },\n        r = o(e, t),\n        a = s ? t : o(t, e);\n      r.length && this.updateHoverStyle(r, n.mode, !1), a.length && n.mode && this.updateHoverStyle(a, n.mode, !0);\n    }\n  }, {\n    key: \"_eventHandler\",\n    value: function _eventHandler(t, e) {\n      var _this19 = this;\n      var s = {\n          event: t,\n          replay: e,\n          cancelable: !0,\n          inChartArea: this.isPointInArea(t)\n        },\n        n = function n(r) {\n          return (r.options.events || _this19.options.events).includes(t[\"native\"].type);\n        };\n      if (this.notifyPlugins(\"beforeEvent\", s, n) === !1) return;\n      var o = this._handleEvent(t, e, s.inChartArea);\n      return s.cancelable = !1, this.notifyPlugins(\"afterEvent\", s, n), (o || s.changed) && this.render(), this;\n    }\n  }, {\n    key: \"_handleEvent\",\n    value: function _handleEvent(t, e, s) {\n      var _this$_active = this._active,\n        n = _this$_active === void 0 ? [] : _this$_active,\n        o = this.options,\n        r = e,\n        a = this._getActiveElements(t, n, s, r),\n        l = Ho(t),\n        c = Ll(t, this._lastEvent, s, l);\n      s && (this._lastEvent = null, I(o.onHover, [t, a, this], this), l && I(o.onClick, [t, a, this], this));\n      var h = !je(a, n);\n      return (h || e) && (this._active = a, this._updateHoverStyles(a, n, e)), this._lastEvent = c, h;\n    }\n  }, {\n    key: \"_getActiveElements\",\n    value: function _getActiveElements(t, e, s, n) {\n      if (t.type === \"mouseout\") return [];\n      if (!s) return e;\n      var o = this.options.hover;\n      return this.getElementsAtEventForMode(t, o.mode, o, n);\n    }\n  }], [{\n    key: \"register\",\n    value: function register() {\n      at.add.apply(at, arguments), $s();\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister() {\n      at.remove.apply(at, arguments), $s();\n    }\n  }]);\n}();\nw(mt, \"defaults\", W), w(mt, \"instances\", Be), w(mt, \"overrides\", zt), w(mt, \"registry\", at), w(mt, \"version\", Ol), w(mt, \"getChart\", js);\nfunction $s() {\n  return L(mt.instances, function (i) {\n    return i._plugins.invalidate();\n  });\n}\nfunction El(i, t, e) {\n  var s = t.startAngle,\n    n = t.x,\n    o = t.y,\n    r = t.outerRadius,\n    a = t.innerRadius,\n    l = t.options,\n    c = l.borderWidth,\n    h = l.borderJoinStyle,\n    d = Math.min(c / r, Z(s - e));\n  if (i.beginPath(), i.arc(n, o, r - c / 2, s + d / 2, e - d / 2), a > 0) {\n    var u = Math.min(c / a, Z(s - e));\n    i.arc(n, o, a + c / 2, e - u / 2, s + u / 2, !0);\n  } else {\n    var _u3 = Math.min(c / 2, r * Z(s - e));\n    if (h === \"round\") i.arc(n, o, _u3, e - E / 2, s + E / 2, !0);else if (h === \"bevel\") {\n      var f = 2 * _u3 * _u3,\n        p = -f * Math.cos(e + E / 2) + n,\n        g = -f * Math.sin(e + E / 2) + o,\n        m = f * Math.cos(s + E / 2) + n,\n        b = f * Math.sin(s + E / 2) + o;\n      i.lineTo(p, g), i.lineTo(m, b);\n    }\n  }\n  i.closePath(), i.moveTo(0, 0), i.rect(0, 0, i.canvas.width, i.canvas.height), i.clip(\"evenodd\");\n}\nfunction Fl(i, t, e) {\n  var s = t.startAngle,\n    n = t.pixelMargin,\n    o = t.x,\n    r = t.y,\n    a = t.outerRadius,\n    l = t.innerRadius;\n  var c = n / a;\n  i.beginPath(), i.arc(o, r, a, s - c, e + c), l > n ? (c = n / l, i.arc(o, r, l, e + c, s - c, !0)) : i.arc(o, r, n, e + V, s - V), i.closePath(), i.clip();\n}\nfunction Il(i) {\n  return Wi(i, [\"outerStart\", \"outerEnd\", \"innerStart\", \"innerEnd\"]);\n}\nfunction zl(i, t, e, s) {\n  var n = Il(i.options.borderRadius),\n    o = (e - t) / 2,\n    r = Math.min(o, s * t / 2),\n    a = function a(l) {\n      var c = (e - Math.min(o, l)) * s / 2;\n      return U(l, 0, Math.min(o, c));\n    };\n  return {\n    outerStart: a(n.outerStart),\n    outerEnd: a(n.outerEnd),\n    innerStart: U(n.innerStart, 0, r),\n    innerEnd: U(n.innerEnd, 0, r)\n  };\n}\nfunction Vt(i, t, e, s) {\n  return {\n    x: e + i * Math.cos(t),\n    y: s + i * Math.sin(t)\n  };\n}\nfunction Ke(i, t, e, s, n, o) {\n  var r = t.x,\n    a = t.y,\n    l = t.startAngle,\n    c = t.pixelMargin,\n    h = t.innerRadius,\n    d = Math.max(t.outerRadius + s + e - c, 0),\n    u = h > 0 ? h + s + e + c : 0;\n  var f = 0;\n  var p = n - l;\n  if (s) {\n    var F = h > 0 ? h - s : 0,\n      z = d > 0 ? d - s : 0,\n      H = (F + z) / 2,\n      it = H !== 0 ? p * H / (H + s) : p;\n    f = (p - it) / 2;\n  }\n  var g = Math.max(1e-3, p * d - e / E) / d,\n    m = (p - g) / 2,\n    b = l + m + f,\n    _ = n - m - f,\n    _zl = zl(t, u, d, _ - b),\n    v = _zl.outerStart,\n    y = _zl.outerEnd,\n    x = _zl.innerStart,\n    M = _zl.innerEnd,\n    S = d - v,\n    k = d - y,\n    P = b + v / S,\n    C = _ - y / k,\n    O = u + x,\n    A = u + M,\n    j = b + x / O,\n    J = _ - M / A;\n  if (i.beginPath(), o) {\n    var _F5 = (P + C) / 2;\n    if (i.arc(r, a, d, P, _F5), i.arc(r, a, d, _F5, C), y > 0) {\n      var $ = Vt(k, C, r, a);\n      i.arc($.x, $.y, y, C, _ + V);\n    }\n    var _z5 = Vt(A, _, r, a);\n    if (i.lineTo(_z5.x, _z5.y), M > 0) {\n      var _$ = Vt(A, J, r, a);\n      i.arc(_$.x, _$.y, M, _ + V, J + Math.PI);\n    }\n    var _H3 = (_ - M / u + (b + x / u)) / 2;\n    if (i.arc(r, a, u, _ - M / u, _H3, !0), i.arc(r, a, u, _H3, b + x / u, !0), x > 0) {\n      var _$2 = Vt(O, j, r, a);\n      i.arc(_$2.x, _$2.y, x, j + Math.PI, b - V);\n    }\n    var _it = Vt(S, b, r, a);\n    if (i.lineTo(_it.x, _it.y), v > 0) {\n      var _$3 = Vt(S, P, r, a);\n      i.arc(_$3.x, _$3.y, v, b - V, P);\n    }\n  } else {\n    i.moveTo(r, a);\n    var _F6 = Math.cos(P) * d + r,\n      _z6 = Math.sin(P) * d + a;\n    i.lineTo(_F6, _z6);\n    var _H4 = Math.cos(C) * d + r,\n      _it2 = Math.sin(C) * d + a;\n    i.lineTo(_H4, _it2);\n  }\n  i.closePath();\n}\nfunction Bl(i, t, e, s, n) {\n  var o = t.fullCircles,\n    r = t.startAngle,\n    a = t.circumference;\n  var l = t.endAngle;\n  if (o) {\n    Ke(i, t, e, s, l, n);\n    for (var c = 0; c < o; ++c) i.fill();\n    isNaN(a) || (l = r + (a % B || B));\n  }\n  return Ke(i, t, e, s, l, n), i.fill(), l;\n}\nfunction Hl(i, t, e, s, n) {\n  var o = t.fullCircles,\n    r = t.startAngle,\n    a = t.circumference,\n    l = t.options,\n    c = l.borderWidth,\n    h = l.borderJoinStyle,\n    d = l.borderDash,\n    u = l.borderDashOffset,\n    f = l.borderRadius,\n    p = l.borderAlign === \"inner\";\n  if (!c) return;\n  i.setLineDash(d || []), i.lineDashOffset = u, p ? (i.lineWidth = c * 2, i.lineJoin = h || \"round\") : (i.lineWidth = c, i.lineJoin = h || \"bevel\");\n  var g = t.endAngle;\n  if (o) {\n    Ke(i, t, e, s, g, n);\n    for (var m = 0; m < o; ++m) i.stroke();\n    isNaN(a) || (g = r + (a % B || B));\n  }\n  p && Fl(i, t, g), l.selfJoin && g - r >= E && f === 0 && h !== \"miter\" && El(i, t, g), o || (Ke(i, t, e, s, g, n), i.stroke());\n}\nvar re = /*#__PURE__*/function (_st2) {\n  function re(e) {\n    var _this20;\n    _classCallCheck(this, re);\n    _this20 = _callSuper(this, re);\n    w(_this20, \"circumference\");\n    w(_this20, \"endAngle\");\n    w(_this20, \"fullCircles\");\n    w(_this20, \"innerRadius\");\n    w(_this20, \"outerRadius\");\n    w(_this20, \"pixelMargin\");\n    w(_this20, \"startAngle\");\n    _this20.options = void 0, _this20.circumference = void 0, _this20.startAngle = void 0, _this20.endAngle = void 0, _this20.innerRadius = void 0, _this20.outerRadius = void 0, _this20.pixelMargin = 0, _this20.fullCircles = 0, e && Object.assign(_this20, e);\n    return _this20;\n  }\n  _inherits(re, _st2);\n  return _createClass(re, [{\n    key: \"inRange\",\n    value: function inRange(e, s, n) {\n      var o = this.getProps([\"x\", \"y\"], n),\n        _yn2 = yn(o, {\n          x: e,\n          y: s\n        }),\n        r = _yn2.angle,\n        a = _yn2.distance,\n        _this$getProps2 = this.getProps([\"startAngle\", \"endAngle\", \"innerRadius\", \"outerRadius\", \"circumference\"], n),\n        l = _this$getProps2.startAngle,\n        c = _this$getProps2.endAngle,\n        h = _this$getProps2.innerRadius,\n        d = _this$getProps2.outerRadius,\n        u = _this$getProps2.circumference,\n        f = (this.options.spacing + this.options.borderWidth) / 2,\n        p = D(u, c - l),\n        g = pe(r, l, c) && l !== c,\n        m = p >= B || g,\n        b = _t(a, h + f, d + f);\n      return m && b;\n    }\n  }, {\n    key: \"getCenterPoint\",\n    value: function getCenterPoint(e) {\n      var _this$getProps3 = this.getProps([\"x\", \"y\", \"startAngle\", \"endAngle\", \"innerRadius\", \"outerRadius\"], e),\n        s = _this$getProps3.x,\n        n = _this$getProps3.y,\n        o = _this$getProps3.startAngle,\n        r = _this$getProps3.endAngle,\n        a = _this$getProps3.innerRadius,\n        l = _this$getProps3.outerRadius,\n        _this$options11 = this.options,\n        c = _this$options11.offset,\n        h = _this$options11.spacing,\n        d = (o + r) / 2,\n        u = (a + l + h + c) / 2;\n      return {\n        x: s + Math.cos(d) * u,\n        y: n + Math.sin(d) * u\n      };\n    }\n  }, {\n    key: \"tooltipPosition\",\n    value: function tooltipPosition(e) {\n      return this.getCenterPoint(e);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(e) {\n      var s = this.options,\n        n = this.circumference,\n        o = (s.offset || 0) / 4,\n        r = (s.spacing || 0) / 2,\n        a = s.circular;\n      if (this.pixelMargin = s.borderAlign === \"inner\" ? 0.33 : 0, this.fullCircles = n > B ? Math.floor(n / B) : 0, n === 0 || this.innerRadius < 0 || this.outerRadius < 0) return;\n      e.save();\n      var l = (this.startAngle + this.endAngle) / 2;\n      e.translate(Math.cos(l) * o, Math.sin(l) * o);\n      var c = 1 - Math.sin(Math.min(E, n || 0)),\n        h = o * c;\n      e.fillStyle = s.backgroundColor, e.strokeStyle = s.borderColor, Bl(e, this, h, r, a), Hl(e, this, h, r, a), e.restore();\n    }\n  }]);\n}(st);\nw(re, \"id\", \"arc\"), w(re, \"defaults\", {\n  borderAlign: \"center\",\n  borderColor: \"#fff\",\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: void 0,\n  borderRadius: 0,\n  borderWidth: 2,\n  offset: 0,\n  spacing: 0,\n  angle: void 0,\n  circular: !0,\n  selfJoin: !1\n}), w(re, \"defaultRoutes\", {\n  backgroundColor: \"backgroundColor\"\n}), w(re, \"descriptors\", {\n  _scriptable: !0,\n  _indexable: function _indexable(e) {\n    return e !== \"borderDash\";\n  }\n});\nfunction Qn(i, t) {\n  var e = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : t;\n  i.lineCap = D(e.borderCapStyle, t.borderCapStyle), i.setLineDash(D(e.borderDash, t.borderDash)), i.lineDashOffset = D(e.borderDashOffset, t.borderDashOffset), i.lineJoin = D(e.borderJoinStyle, t.borderJoinStyle), i.lineWidth = D(e.borderWidth, t.borderWidth), i.strokeStyle = D(e.borderColor, t.borderColor);\n}\nfunction Wl(i, t, e) {\n  i.lineTo(e.x, e.y);\n}\nfunction Nl(i) {\n  return i.stepped ? hr : i.tension || i.cubicInterpolationMode === \"monotone\" ? dr : Wl;\n}\nfunction to(i, t) {\n  var e = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var s = i.length,\n    _e$start = e.start,\n    n = _e$start === void 0 ? 0 : _e$start,\n    _e$end = e.end,\n    o = _e$end === void 0 ? s - 1 : _e$end,\n    r = t.start,\n    a = t.end,\n    l = Math.max(n, r),\n    c = Math.min(o, a),\n    h = n < r && o < r || n > a && o > a;\n  return {\n    count: s,\n    start: l,\n    loop: t.loop,\n    ilen: c < l && !h ? s + c - l : c - l\n  };\n}\nfunction Vl(i, t, e, s) {\n  var n = t.points,\n    o = t.options,\n    _to = to(n, e, s),\n    r = _to.count,\n    a = _to.start,\n    l = _to.loop,\n    c = _to.ilen,\n    h = Nl(o);\n  var _ref6 = s || {},\n    _ref6$move = _ref6.move,\n    d = _ref6$move === void 0 ? !0 : _ref6$move,\n    u = _ref6.reverse,\n    f,\n    p,\n    g;\n  for (f = 0; f <= c; ++f) p = n[(a + (u ? c - f : f)) % r], !p.skip && (d ? (i.moveTo(p.x, p.y), d = !1) : h(i, g, p, u, o.stepped), g = p);\n  return l && (p = n[(a + (u ? c : 0)) % r], h(i, g, p, u, o.stepped)), !!l;\n}\nfunction jl(i, t, e, s) {\n  var n = t.points,\n    _to2 = to(n, e, s),\n    o = _to2.count,\n    r = _to2.start,\n    a = _to2.ilen,\n    _ref7 = s || {},\n    _ref7$move = _ref7.move,\n    l = _ref7$move === void 0 ? !0 : _ref7$move,\n    c = _ref7.reverse;\n  var h = 0,\n    d = 0,\n    u,\n    f,\n    p,\n    g,\n    m,\n    b;\n  var _ = function _(y) {\n      return (r + (c ? a - y : y)) % o;\n    },\n    v = function v() {\n      g !== m && (i.lineTo(h, m), i.lineTo(h, g), i.lineTo(h, b));\n    };\n  for (l && (f = n[_(0)], i.moveTo(f.x, f.y)), u = 0; u <= a; ++u) {\n    if (f = n[_(u)], f.skip) continue;\n    var y = f.x,\n      x = f.y,\n      M = y | 0;\n    M === p ? (x < g ? g = x : x > m && (m = x), h = (d * h + y) / ++d) : (v(), i.lineTo(y, x), p = M, d = 0, g = m = x), b = x;\n  }\n  v();\n}\nfunction Di(i) {\n  var t = i.options,\n    e = t.borderDash && t.borderDash.length;\n  return !i._decimated && !i._loop && !t.tension && t.cubicInterpolationMode !== \"monotone\" && !t.stepped && !e ? jl : Vl;\n}\nfunction $l(i) {\n  return i.stepped ? jr : i.tension || i.cubicInterpolationMode === \"monotone\" ? $r : Rt;\n}\nfunction Yl(i, t, e, s) {\n  var n = t._path;\n  n || (n = t._path = new Path2D(), t.path(n, e, s) && n.closePath()), Qn(i, t.options), i.stroke(n);\n}\nfunction Ul(i, t, e, s) {\n  var n = t.segments,\n    o = t.options,\n    r = Di(t);\n  var _iterator26 = _createForOfIteratorHelper(n),\n    _step26;\n  try {\n    for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n      var a = _step26.value;\n      Qn(i, o, a.style), i.beginPath(), r(i, t, a, {\n        start: e,\n        end: e + s - 1\n      }) && i.closePath(), i.stroke();\n    }\n  } catch (err) {\n    _iterator26.e(err);\n  } finally {\n    _iterator26.f();\n  }\n}\nvar Xl = typeof Path2D == \"function\";\nfunction ql(i, t, e, s) {\n  Xl && !t.options.segment ? Yl(i, t, e, s) : Ul(i, t, e, s);\n}\nvar vt = /*#__PURE__*/function (_st3) {\n  function vt(t) {\n    var _this21;\n    _classCallCheck(this, vt);\n    _this21 = _callSuper(this, vt), _this21.animated = !0, _this21.options = void 0, _this21._chart = void 0, _this21._loop = void 0, _this21._fullLoop = void 0, _this21._path = void 0, _this21._points = void 0, _this21._segments = void 0, _this21._decimated = !1, _this21._pointsUpdated = !1, _this21._datasetIndex = void 0, t && Object.assign(_assertThisInitialized(_this21), t);\n    return _this21;\n  }\n  _inherits(vt, _st3);\n  return _createClass(vt, [{\n    key: \"updateControlPoints\",\n    value: function updateControlPoints(t, e) {\n      var s = this.options;\n      if ((s.tension || s.cubicInterpolationMode === \"monotone\") && !s.stepped && !this._pointsUpdated) {\n        var n = s.spanGaps ? this._loop : this._fullLoop;\n        Fr(this._points, s, t, n, e), this._pointsUpdated = !0;\n      }\n    }\n  }, {\n    key: \"points\",\n    get: function get() {\n      return this._points;\n    },\n    set: function set(t) {\n      this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;\n    }\n  }, {\n    key: \"segments\",\n    get: function get() {\n      return this._segments || (this._segments = Gr(this, this.options.segment));\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      var t = this.segments,\n        e = this.points;\n      return t.length && e[t[0].start];\n    }\n  }, {\n    key: \"last\",\n    value: function last() {\n      var t = this.segments,\n        e = this.points,\n        s = t.length;\n      return s && e[t[s - 1].end];\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(t, e) {\n      var s = this.options,\n        n = t[e],\n        o = this.points,\n        r = Hn(this, {\n          property: e,\n          start: n,\n          end: n\n        });\n      if (!r.length) return;\n      var a = [],\n        l = $l(s);\n      var c, h;\n      for (c = 0, h = r.length; c < h; ++c) {\n        var _r$c = r[c],\n          d = _r$c.start,\n          u = _r$c.end,\n          f = o[d],\n          p = o[u];\n        if (f === p) {\n          a.push(f);\n          continue;\n        }\n        var g = Math.abs((n - f[e]) / (p[e] - f[e])),\n          m = l(f, p, g, s.stepped);\n        m[e] = t[e], a.push(m);\n      }\n      return a.length === 1 ? a[0] : a;\n    }\n  }, {\n    key: \"pathSegment\",\n    value: function pathSegment(t, e, s) {\n      return Di(this)(t, this, e, s);\n    }\n  }, {\n    key: \"path\",\n    value: function path(t, e, s) {\n      var n = this.segments,\n        o = Di(this);\n      var r = this._loop;\n      e = e || 0, s = s || this.points.length - e;\n      var _iterator27 = _createForOfIteratorHelper(n),\n        _step27;\n      try {\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var a = _step27.value;\n          r &= o(t, this, a, {\n            start: e,\n            end: e + s - 1\n          });\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n      return !!r;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(t, e, s, n) {\n      var o = this.options || {};\n      (this.points || []).length && o.borderWidth && (t.save(), ql(t, this, s, n), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);\n    }\n  }]);\n}(st);\nw(vt, \"id\", \"line\"), w(vt, \"defaults\", {\n  borderCapStyle: \"butt\",\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: \"miter\",\n  borderWidth: 3,\n  capBezierPoints: !0,\n  cubicInterpolationMode: \"default\",\n  fill: !1,\n  spanGaps: !1,\n  stepped: !1,\n  tension: 0\n}), w(vt, \"defaultRoutes\", {\n  backgroundColor: \"backgroundColor\",\n  borderColor: \"borderColor\"\n}), w(vt, \"descriptors\", {\n  _scriptable: !0,\n  _indexable: function _indexable(t) {\n    return t !== \"borderDash\" && t !== \"fill\";\n  }\n});\nfunction Ys(i, t, e, s) {\n  var n = i.options,\n    _i$getProps = i.getProps([e], s),\n    o = _i$getProps[e];\n  return Math.abs(t - o) < n.radius + n.hitRadius;\n}\nvar He = /*#__PURE__*/function (_st4) {\n  function He(e) {\n    var _this22;\n    _classCallCheck(this, He);\n    _this22 = _callSuper(this, He);\n    w(_this22, \"parsed\");\n    w(_this22, \"skip\");\n    w(_this22, \"stop\");\n    _this22.options = void 0, _this22.parsed = void 0, _this22.skip = void 0, _this22.stop = void 0, e && Object.assign(_this22, e);\n    return _this22;\n  }\n  _inherits(He, _st4);\n  return _createClass(He, [{\n    key: \"inRange\",\n    value: function inRange(e, s, n) {\n      var o = this.options,\n        _this$getProps4 = this.getProps([\"x\", \"y\"], n),\n        r = _this$getProps4.x,\n        a = _this$getProps4.y;\n      return Math.pow(e - r, 2) + Math.pow(s - a, 2) < Math.pow(o.hitRadius + o.radius, 2);\n    }\n  }, {\n    key: \"inXRange\",\n    value: function inXRange(e, s) {\n      return Ys(this, e, \"x\", s);\n    }\n  }, {\n    key: \"inYRange\",\n    value: function inYRange(e, s) {\n      return Ys(this, e, \"y\", s);\n    }\n  }, {\n    key: \"getCenterPoint\",\n    value: function getCenterPoint(e) {\n      var _this$getProps5 = this.getProps([\"x\", \"y\"], e),\n        s = _this$getProps5.x,\n        n = _this$getProps5.y;\n      return {\n        x: s,\n        y: n\n      };\n    }\n  }, {\n    key: \"size\",\n    value: function size(e) {\n      e = e || this.options || {};\n      var s = e.radius || 0;\n      s = Math.max(s, s && e.hoverRadius || 0);\n      var n = s && e.borderWidth || 0;\n      return (s + n) * 2;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(e, s) {\n      var n = this.options;\n      this.skip || n.radius < 0.1 || !me(this, s, this.size(n) / 2) || (e.strokeStyle = n.borderColor, e.lineWidth = n.borderWidth, e.fillStyle = n.backgroundColor, Si(e, n, this.x, this.y));\n    }\n  }, {\n    key: \"getRange\",\n    value: function getRange() {\n      var e = this.options || {};\n      return e.radius + e.hitRadius;\n    }\n  }]);\n}(st);\nw(He, \"id\", \"point\"),\n/**\n* @type {any}\n*/\nw(He, \"defaults\", {\n  borderWidth: 1,\n  hitRadius: 1,\n  hoverBorderWidth: 1,\n  hoverRadius: 4,\n  pointStyle: \"circle\",\n  radius: 3,\n  rotation: 0\n}),\n/**\n* @type {any}\n*/\nw(He, \"defaultRoutes\", {\n  backgroundColor: \"backgroundColor\",\n  borderColor: \"borderColor\"\n});\nfunction eo(i, t) {\n  var _i$getProps2 = i.getProps([\"x\", \"y\", \"base\", \"width\", \"height\"], t),\n    e = _i$getProps2.x,\n    s = _i$getProps2.y,\n    n = _i$getProps2.base,\n    o = _i$getProps2.width,\n    r = _i$getProps2.height;\n  var a, l, c, h, d;\n  return i.horizontal ? (d = r / 2, a = Math.min(e, n), l = Math.max(e, n), c = s - d, h = s + d) : (d = o / 2, a = e - d, l = e + d, c = Math.min(s, n), h = Math.max(s, n)), {\n    left: a,\n    top: c,\n    right: l,\n    bottom: h\n  };\n}\nfunction Mt(i, t, e, s) {\n  return i ? 0 : U(t, e, s);\n}\nfunction Kl(i, t, e) {\n  var s = i.options.borderWidth,\n    n = i.borderSkipped,\n    o = On(s);\n  return {\n    t: Mt(n.top, o.top, 0, e),\n    r: Mt(n.right, o.right, 0, t),\n    b: Mt(n.bottom, o.bottom, 0, e),\n    l: Mt(n.left, o.left, 0, t)\n  };\n}\nfunction Gl(i, t, e) {\n  var _i$getProps3 = i.getProps([\"enableBorderRadius\"]),\n    s = _i$getProps3.enableBorderRadius,\n    n = i.options.borderRadius,\n    o = Yt(n),\n    r = Math.min(t, e),\n    a = i.borderSkipped,\n    l = s || T(n);\n  return {\n    topLeft: Mt(!l || a.top || a.left, o.topLeft, 0, r),\n    topRight: Mt(!l || a.top || a.right, o.topRight, 0, r),\n    bottomLeft: Mt(!l || a.bottom || a.left, o.bottomLeft, 0, r),\n    bottomRight: Mt(!l || a.bottom || a.right, o.bottomRight, 0, r)\n  };\n}\nfunction Jl(i) {\n  var t = eo(i),\n    e = t.right - t.left,\n    s = t.bottom - t.top,\n    n = Kl(i, e / 2, s / 2),\n    o = Gl(i, e / 2, s / 2);\n  return {\n    outer: {\n      x: t.left,\n      y: t.top,\n      w: e,\n      h: s,\n      radius: o\n    },\n    inner: {\n      x: t.left + n.l,\n      y: t.top + n.t,\n      w: e - n.l - n.r,\n      h: s - n.t - n.b,\n      radius: {\n        topLeft: Math.max(0, o.topLeft - Math.max(n.t, n.l)),\n        topRight: Math.max(0, o.topRight - Math.max(n.t, n.r)),\n        bottomLeft: Math.max(0, o.bottomLeft - Math.max(n.b, n.l)),\n        bottomRight: Math.max(0, o.bottomRight - Math.max(n.b, n.r))\n      }\n    }\n  };\n}\nfunction fi(i, t, e, s) {\n  var n = t === null,\n    o = e === null,\n    a = i && !(n && o) && eo(i, s);\n  return a && (n || _t(t, a.left, a.right)) && (o || _t(e, a.top, a.bottom));\n}\nfunction Zl(i) {\n  return i.topLeft || i.topRight || i.bottomLeft || i.bottomRight;\n}\nfunction Ql(i, t) {\n  i.rect(t.x, t.y, t.w, t.h);\n}\nfunction gi(i, t) {\n  var e = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var s = i.x !== e.x ? -t : 0,\n    n = i.y !== e.y ? -t : 0,\n    o = (i.x + i.w !== e.x + e.w ? t : 0) - s,\n    r = (i.y + i.h !== e.y + e.h ? t : 0) - n;\n  return {\n    x: i.x + s,\n    y: i.y + n,\n    w: i.w + o,\n    h: i.h + r,\n    radius: i.radius\n  };\n}\nvar We = /*#__PURE__*/function (_st5) {\n  function We(t) {\n    var _this23;\n    _classCallCheck(this, We);\n    _this23 = _callSuper(this, We), _this23.options = void 0, _this23.horizontal = void 0, _this23.base = void 0, _this23.width = void 0, _this23.height = void 0, _this23.inflateAmount = void 0, t && Object.assign(_assertThisInitialized(_this23), t);\n    return _this23;\n  }\n  _inherits(We, _st5);\n  return _createClass(We, [{\n    key: \"draw\",\n    value: function draw(t) {\n      var e = this.inflateAmount,\n        _this$options12 = this.options,\n        s = _this$options12.borderColor,\n        n = _this$options12.backgroundColor,\n        _Jl = Jl(this),\n        o = _Jl.inner,\n        r = _Jl.outer,\n        a = Zl(r.radius) ? Ue : Ql;\n      t.save(), (r.w !== o.w || r.h !== o.h) && (t.beginPath(), a(t, gi(r, e, o)), t.clip(), a(t, gi(o, -e, r)), t.fillStyle = s, t.fill(\"evenodd\")), t.beginPath(), a(t, gi(o, e)), t.fillStyle = n, t.fill(), t.restore();\n    }\n  }, {\n    key: \"inRange\",\n    value: function inRange(t, e, s) {\n      return fi(this, t, e, s);\n    }\n  }, {\n    key: \"inXRange\",\n    value: function inXRange(t, e) {\n      return fi(this, t, null, e);\n    }\n  }, {\n    key: \"inYRange\",\n    value: function inYRange(t, e) {\n      return fi(this, null, t, e);\n    }\n  }, {\n    key: \"getCenterPoint\",\n    value: function getCenterPoint(t) {\n      var _this$getProps6 = this.getProps([\"x\", \"y\", \"base\", \"horizontal\"], t),\n        e = _this$getProps6.x,\n        s = _this$getProps6.y,\n        n = _this$getProps6.base,\n        o = _this$getProps6.horizontal;\n      return {\n        x: o ? (e + n) / 2 : e,\n        y: o ? s : (s + n) / 2\n      };\n    }\n  }, {\n    key: \"getRange\",\n    value: function getRange(t) {\n      return t === \"x\" ? this.width / 2 : this.height / 2;\n    }\n  }]);\n}(st);\nw(We, \"id\", \"bar\"), w(We, \"defaults\", {\n  borderSkipped: \"start\",\n  borderWidth: 0,\n  borderRadius: 0,\n  inflateAmount: \"auto\",\n  pointStyle: void 0\n}), w(We, \"defaultRoutes\", {\n  backgroundColor: \"backgroundColor\",\n  borderColor: \"borderColor\"\n});\nfunction tc(i, t, e) {\n  var s = i.segments,\n    n = i.points,\n    o = t.points,\n    r = [];\n  var _iterator28 = _createForOfIteratorHelper(s),\n    _step28;\n  try {\n    for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n      var a = _step28.value;\n      var l = a.start,\n        c = a.end;\n      c = ei(l, c, n);\n      var h = Ci(e, n[l], n[c], a.loop);\n      if (!t.segments) {\n        r.push({\n          source: a,\n          target: h,\n          start: n[l],\n          end: n[c]\n        });\n        continue;\n      }\n      var d = Hn(t, h);\n      var _iterator29 = _createForOfIteratorHelper(d),\n        _step29;\n      try {\n        for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n          var u = _step29.value;\n          var f = Ci(e, o[u.start], o[u.end], u.loop),\n            p = Bn(a, n, f);\n          var _iterator30 = _createForOfIteratorHelper(p),\n            _step30;\n          try {\n            for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n              var g = _step30.value;\n              r.push({\n                source: g,\n                target: u,\n                start: _defineProperty({}, e, Us(h, f, \"start\", Math.max)),\n                end: _defineProperty({}, e, Us(h, f, \"end\", Math.min))\n              });\n            }\n          } catch (err) {\n            _iterator30.e(err);\n          } finally {\n            _iterator30.f();\n          }\n        }\n      } catch (err) {\n        _iterator29.e(err);\n      } finally {\n        _iterator29.f();\n      }\n    }\n  } catch (err) {\n    _iterator28.e(err);\n  } finally {\n    _iterator28.f();\n  }\n  return r;\n}\nfunction Ci(i, t, e, s) {\n  if (s) return;\n  var n = t[i],\n    o = e[i];\n  return i === \"angle\" && (n = Z(n), o = Z(o)), {\n    property: i,\n    start: n,\n    end: o\n  };\n}\nfunction ec(i, t) {\n  var _ref8 = i || {},\n    _ref8$x = _ref8.x,\n    e = _ref8$x === void 0 ? null : _ref8$x,\n    _ref8$y = _ref8.y,\n    s = _ref8$y === void 0 ? null : _ref8$y,\n    n = t.points,\n    o = [];\n  return t.segments.forEach(function (_ref9) {\n    var r = _ref9.start,\n      a = _ref9.end;\n    a = ei(r, a, n);\n    var l = n[r],\n      c = n[a];\n    s !== null ? (o.push({\n      x: l.x,\n      y: s\n    }), o.push({\n      x: c.x,\n      y: s\n    })) : e !== null && (o.push({\n      x: e,\n      y: l.y\n    }), o.push({\n      x: e,\n      y: c.y\n    }));\n  }), o;\n}\nfunction ei(i, t, e) {\n  for (; t > i; t--) {\n    var s = e[t];\n    if (!isNaN(s.x) && !isNaN(s.y)) break;\n  }\n  return t;\n}\nfunction Us(i, t, e, s) {\n  return i && t ? s(i[e], t[e]) : i ? i[e] : t ? t[e] : 0;\n}\nfunction io(i, t) {\n  var e = [],\n    s = !1;\n  return N(i) ? (s = !0, e = i) : e = ec(i, t), e.length ? new vt({\n    points: e,\n    options: {\n      tension: 0\n    },\n    _loop: s,\n    _fullLoop: s\n  }) : null;\n}\nfunction Xs(i) {\n  return i && i.fill !== !1;\n}\nfunction ic(i, t, e) {\n  var n = i[t].fill;\n  var o = [t];\n  var r;\n  if (!e) return n;\n  for (; n !== !1 && o.indexOf(n) === -1;) {\n    if (!q(n)) return n;\n    if (r = i[n], !r) return !1;\n    if (r.visible) return n;\n    o.push(n), n = r.fill;\n  }\n  return !1;\n}\nfunction sc(i, t, e) {\n  var s = ac(i);\n  if (T(s)) return isNaN(s.value) ? !1 : s;\n  var n = parseFloat(s);\n  return q(n) && Math.floor(n) === n ? nc(s[0], t, n, e) : [\"origin\", \"start\", \"end\", \"stack\", \"shape\"].indexOf(s) >= 0 && s;\n}\nfunction nc(i, t, e, s) {\n  return (i === \"-\" || i === \"+\") && (e = t + e), e === t || e < 0 || e >= s ? !1 : e;\n}\nfunction oc(i, t) {\n  var e = null;\n  return i === \"start\" ? e = t.bottom : i === \"end\" ? e = t.top : T(i) ? e = t.getPixelForValue(i.value) : t.getBasePixel && (e = t.getBasePixel()), e;\n}\nfunction rc(i, t, e) {\n  var s;\n  return i === \"start\" ? s = e : i === \"end\" ? s = t.options.reverse ? t.min : t.max : T(i) ? s = i.value : s = t.getBaseValue(), s;\n}\nfunction ac(i) {\n  var t = i.options,\n    e = t.fill;\n  var s = D(e && e.target, e);\n  return s === void 0 && (s = !!t.backgroundColor), s === !1 || s === null ? !1 : s === !0 ? \"origin\" : s;\n}\nfunction lc(i) {\n  var t = i.scale,\n    e = i.index,\n    s = i.line,\n    n = [],\n    o = s.segments,\n    r = s.points,\n    a = cc(t, e);\n  a.push(io({\n    x: null,\n    y: t.bottom\n  }, s));\n  for (var l = 0; l < o.length; l++) {\n    var c = o[l];\n    for (var h = c.start; h <= c.end; h++) hc(n, r[h], a);\n  }\n  return new vt({\n    points: n,\n    options: {}\n  });\n}\nfunction cc(i, t) {\n  var e = [],\n    s = i.getMatchingVisibleMetas(\"line\");\n  for (var n = 0; n < s.length; n++) {\n    var o = s[n];\n    if (o.index === t) break;\n    o.hidden || e.unshift(o.dataset);\n  }\n  return e;\n}\nfunction hc(i, t, e) {\n  var s = [];\n  for (var n = 0; n < e.length; n++) {\n    var o = e[n],\n      _dc = dc(o, t, \"x\"),\n      r = _dc.first,\n      a = _dc.last,\n      l = _dc.point;\n    if (!(!l || r && a)) {\n      if (r) s.unshift(l);else if (i.push(l), !a) break;\n    }\n  }\n  i.push.apply(i, s);\n}\nfunction dc(i, t, e) {\n  var s = i.interpolate(t, e);\n  if (!s) return {};\n  var n = s[e],\n    o = i.segments,\n    r = i.points;\n  var a = !1,\n    l = !1;\n  for (var c = 0; c < o.length; c++) {\n    var h = o[c],\n      d = r[h.start][e],\n      u = r[h.end][e];\n    if (_t(n, d, u)) {\n      a = n === d, l = n === u;\n      break;\n    }\n  }\n  return {\n    first: a,\n    last: l,\n    point: s\n  };\n}\nvar so = /*#__PURE__*/function () {\n  function so(t) {\n    _classCallCheck(this, so);\n    this.x = t.x, this.y = t.y, this.radius = t.radius;\n  }\n  return _createClass(so, [{\n    key: \"pathSegment\",\n    value: function pathSegment(t, e, s) {\n      var n = this.x,\n        o = this.y,\n        r = this.radius;\n      return e = e || {\n        start: 0,\n        end: B\n      }, t.arc(n, o, r, e.end, e.start, !0), !s.bounds;\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(t) {\n      var e = this.x,\n        s = this.y,\n        n = this.radius,\n        o = t.angle;\n      return {\n        x: e + Math.cos(o) * n,\n        y: s + Math.sin(o) * n,\n        angle: o\n      };\n    }\n  }]);\n}();\nfunction uc(i) {\n  var t = i.chart,\n    e = i.fill,\n    s = i.line;\n  if (q(e)) return fc(t, e);\n  if (e === \"stack\") return lc(i);\n  if (e === \"shape\") return !0;\n  var n = gc(i);\n  return n instanceof so ? n : io(n, s);\n}\nfunction fc(i, t) {\n  var e = i.getDatasetMeta(t);\n  return e && i.isDatasetVisible(t) ? e.dataset : null;\n}\nfunction gc(i) {\n  return (i.scale || {}).getPointPositionForValue ? mc(i) : pc(i);\n}\nfunction pc(i) {\n  var _i$scale = i.scale,\n    t = _i$scale === void 0 ? {} : _i$scale,\n    e = i.fill,\n    s = oc(e, t);\n  if (q(s)) {\n    var n = t.isHorizontal();\n    return {\n      x: n ? s : null,\n      y: n ? null : s\n    };\n  }\n  return null;\n}\nfunction mc(i) {\n  var t = i.scale,\n    e = i.fill,\n    s = t.options,\n    n = t.getLabels().length,\n    o = s.reverse ? t.max : t.min,\n    r = rc(e, t, o),\n    a = [];\n  if (s.grid.circular) {\n    var l = t.getPointPositionForValue(0, o);\n    return new so({\n      x: l.x,\n      y: l.y,\n      radius: t.getDistanceFromCenterForValue(r)\n    });\n  }\n  for (var _l2 = 0; _l2 < n; ++_l2) a.push(t.getPointPositionForValue(_l2, r));\n  return a;\n}\nfunction pi(i, t, e) {\n  var s = uc(t),\n    n = t.chart,\n    o = t.index,\n    r = t.line,\n    a = t.scale,\n    l = t.axis,\n    c = r.options,\n    h = c.fill,\n    d = c.backgroundColor,\n    _ref0 = h || {},\n    _ref0$above = _ref0.above,\n    u = _ref0$above === void 0 ? d : _ref0$above,\n    _ref0$below = _ref0.below,\n    f = _ref0$below === void 0 ? d : _ref0$below,\n    p = n.getDatasetMeta(o),\n    g = Wn(n, p);\n  s && r.points.length && (Je(i, e), bc(i, {\n    line: r,\n    target: s,\n    above: u,\n    below: f,\n    area: e,\n    scale: a,\n    axis: l,\n    clip: g\n  }), Ze(i));\n}\nfunction bc(i, t) {\n  var e = t.line,\n    s = t.target,\n    n = t.above,\n    o = t.below,\n    r = t.area,\n    a = t.scale,\n    l = t.clip,\n    c = e._loop ? \"angle\" : t.axis;\n  i.save();\n  var h = o;\n  o !== n && (c === \"x\" ? (qs(i, s, r.top), mi(i, {\n    line: e,\n    target: s,\n    color: n,\n    scale: a,\n    property: c,\n    clip: l\n  }), i.restore(), i.save(), qs(i, s, r.bottom)) : c === \"y\" && (Ks(i, s, r.left), mi(i, {\n    line: e,\n    target: s,\n    color: o,\n    scale: a,\n    property: c,\n    clip: l\n  }), i.restore(), i.save(), Ks(i, s, r.right), h = n)), mi(i, {\n    line: e,\n    target: s,\n    color: h,\n    scale: a,\n    property: c,\n    clip: l\n  }), i.restore();\n}\nfunction qs(i, t, e) {\n  var s = t.segments,\n    n = t.points;\n  var o = !0,\n    r = !1;\n  i.beginPath();\n  var _iterator31 = _createForOfIteratorHelper(s),\n    _step31;\n  try {\n    for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n      var a = _step31.value;\n      var l = a.start,\n        c = a.end,\n        h = n[l],\n        d = n[ei(l, c, n)];\n      o ? (i.moveTo(h.x, h.y), o = !1) : (i.lineTo(h.x, e), i.lineTo(h.x, h.y)), r = !!t.pathSegment(i, a, {\n        move: r\n      }), r ? i.closePath() : i.lineTo(d.x, e);\n    }\n  } catch (err) {\n    _iterator31.e(err);\n  } finally {\n    _iterator31.f();\n  }\n  i.lineTo(t.first().x, e), i.closePath(), i.clip();\n}\nfunction Ks(i, t, e) {\n  var s = t.segments,\n    n = t.points;\n  var o = !0,\n    r = !1;\n  i.beginPath();\n  var _iterator32 = _createForOfIteratorHelper(s),\n    _step32;\n  try {\n    for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n      var a = _step32.value;\n      var l = a.start,\n        c = a.end,\n        h = n[l],\n        d = n[ei(l, c, n)];\n      o ? (i.moveTo(h.x, h.y), o = !1) : (i.lineTo(e, h.y), i.lineTo(h.x, h.y)), r = !!t.pathSegment(i, a, {\n        move: r\n      }), r ? i.closePath() : i.lineTo(e, d.y);\n    }\n  } catch (err) {\n    _iterator32.e(err);\n  } finally {\n    _iterator32.f();\n  }\n  i.lineTo(e, t.first().y), i.closePath(), i.clip();\n}\nfunction mi(i, t) {\n  var e = t.line,\n    s = t.target,\n    n = t.property,\n    o = t.color,\n    r = t.scale,\n    a = t.clip,\n    l = tc(e, s, n);\n  var _iterator33 = _createForOfIteratorHelper(l),\n    _step33;\n  try {\n    for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n      var _step33$value = _step33.value,\n        c = _step33$value.source,\n        h = _step33$value.target,\n        d = _step33$value.start,\n        u = _step33$value.end;\n      var _c$style = c.style,\n        _c$style2 = _c$style === void 0 ? {} : _c$style,\n        _c$style2$backgroundC = _c$style2.backgroundColor,\n        f = _c$style2$backgroundC === void 0 ? o : _c$style2$backgroundC,\n        p = s !== !0;\n      i.save(), i.fillStyle = f, _c(i, r, a, p && Ci(n, d, u)), i.beginPath();\n      var g = !!e.pathSegment(i, c);\n      var m = void 0;\n      if (p) {\n        g ? i.closePath() : Gs(i, s, u, n);\n        var b = !!s.pathSegment(i, h, {\n          move: g,\n          reverse: !0\n        });\n        m = g && b, m || Gs(i, s, d, n);\n      }\n      i.closePath(), i.fill(m ? \"evenodd\" : \"nonzero\"), i.restore();\n    }\n  } catch (err) {\n    _iterator33.e(err);\n  } finally {\n    _iterator33.f();\n  }\n}\nfunction _c(i, t, e, s) {\n  var n = t.chart.chartArea,\n    _ref1 = s || {},\n    o = _ref1.property,\n    r = _ref1.start,\n    a = _ref1.end;\n  if (o === \"x\" || o === \"y\") {\n    var l, c, h, d;\n    o === \"x\" ? (l = r, c = n.top, h = a, d = n.bottom) : (l = n.left, c = r, h = n.right, d = a), i.beginPath(), e && (l = Math.max(l, e.left), h = Math.min(h, e.right), c = Math.max(c, e.top), d = Math.min(d, e.bottom)), i.rect(l, c, h - l, d - c), i.clip();\n  }\n}\nfunction Gs(i, t, e, s) {\n  var n = t.interpolate(e, s);\n  n && i.lineTo(n.x, n.y);\n}\nvar xc = {\n  id: \"filler\",\n  afterDatasetsUpdate: function afterDatasetsUpdate(i, t, e) {\n    var s = (i.data.datasets || []).length,\n      n = [];\n    var o, r, a, l;\n    for (r = 0; r < s; ++r) o = i.getDatasetMeta(r), a = o.dataset, l = null, a && a.options && a instanceof vt && (l = {\n      visible: i.isDatasetVisible(r),\n      index: r,\n      fill: sc(a, r, s),\n      chart: i,\n      axis: o.controller.options.indexAxis,\n      scale: o.vScale,\n      line: a\n    }), o.$filler = l, n.push(l);\n    for (r = 0; r < s; ++r) l = n[r], !(!l || l.fill === !1) && (l.fill = ic(n, r, e.propagate));\n  },\n  beforeDraw: function beforeDraw(i, t, e) {\n    var s = e.drawTime === \"beforeDraw\",\n      n = i.getSortedVisibleDatasetMetas(),\n      o = i.chartArea;\n    for (var r = n.length - 1; r >= 0; --r) {\n      var a = n[r].$filler;\n      a && (a.line.updateControlPoints(o, a.axis), s && a.fill && pi(i.ctx, a, o));\n    }\n  },\n  beforeDatasetsDraw: function beforeDatasetsDraw(i, t, e) {\n    if (e.drawTime !== \"beforeDatasetsDraw\") return;\n    var s = i.getSortedVisibleDatasetMetas();\n    for (var n = s.length - 1; n >= 0; --n) {\n      var o = s[n].$filler;\n      Xs(o) && pi(i.ctx, o, i.chartArea);\n    }\n  },\n  beforeDatasetDraw: function beforeDatasetDraw(i, t, e) {\n    var s = t.meta.$filler;\n    !Xs(s) || e.drawTime !== \"beforeDatasetDraw\" || pi(i.ctx, s, i.chartArea);\n  },\n  defaults: {\n    propagate: !0,\n    drawTime: \"beforeDatasetDraw\"\n  }\n};\nvar Js = function Js(i, t) {\n    var _i$boxHeight = i.boxHeight,\n      e = _i$boxHeight === void 0 ? t : _i$boxHeight,\n      _i$boxWidth = i.boxWidth,\n      s = _i$boxWidth === void 0 ? t : _i$boxWidth;\n    return i.usePointStyle && (e = Math.min(e, t), s = i.pointStyleWidth || Math.min(s, t)), {\n      boxWidth: s,\n      boxHeight: e,\n      itemHeight: Math.max(t, e)\n    };\n  },\n  yc = function yc(i, t) {\n    return i !== null && t !== null && i.datasetIndex === t.datasetIndex && i.index === t.index;\n  };\nvar Zs = /*#__PURE__*/function (_st6) {\n  function Zs(t) {\n    var _this24;\n    _classCallCheck(this, Zs);\n    _this24 = _callSuper(this, Zs), _this24._added = !1, _this24.legendHitBoxes = [], _this24._hoveredItem = null, _this24.doughnutMode = !1, _this24.chart = t.chart, _this24.options = t.options, _this24.ctx = t.ctx, _this24.legendItems = void 0, _this24.columnSizes = void 0, _this24.lineWidths = void 0, _this24.maxHeight = void 0, _this24.maxWidth = void 0, _this24.top = void 0, _this24.bottom = void 0, _this24.left = void 0, _this24.right = void 0, _this24.height = void 0, _this24.width = void 0, _this24._margins = void 0, _this24.position = void 0, _this24.weight = void 0, _this24.fullSize = void 0;\n    return _this24;\n  }\n  _inherits(Zs, _st6);\n  return _createClass(Zs, [{\n    key: \"update\",\n    value: function update(t, e, s) {\n      this.maxWidth = t, this.maxHeight = e, this._margins = s, this.setDimensions(), this.buildLabels(), this.fit();\n    }\n  }, {\n    key: \"setDimensions\",\n    value: function setDimensions() {\n      this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);\n    }\n  }, {\n    key: \"buildLabels\",\n    value: function buildLabels() {\n      var _this25 = this;\n      var t = this.options.labels || {};\n      var e = I(t.generateLabels, [this.chart], this) || [];\n      t.filter && (e = e.filter(function (s) {\n        return t.filter(s, _this25.chart.data);\n      })), t.sort && (e = e.sort(function (s, n) {\n        return t.sort(s, n, _this25.chart.data);\n      })), this.options.reverse && e.reverse(), this.legendItems = e;\n    }\n  }, {\n    key: \"fit\",\n    value: function fit() {\n      var t = this.options,\n        e = this.ctx;\n      if (!t.display) {\n        this.width = this.height = 0;\n        return;\n      }\n      var s = t.labels,\n        n = X(s.font),\n        o = n.size,\n        r = this._computeTitleHeight(),\n        _Js = Js(s, o),\n        a = _Js.boxWidth,\n        l = _Js.itemHeight;\n      var c, h;\n      e.font = n.string, this.isHorizontal() ? (c = this.maxWidth, h = this._fitRows(r, o, a, l) + 10) : (h = this.maxHeight, c = this._fitCols(r, n, a, l) + 10), this.width = Math.min(c, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight);\n    }\n  }, {\n    key: \"_fitRows\",\n    value: function _fitRows(t, e, s, n) {\n      var o = this.ctx,\n        r = this.maxWidth,\n        a = this.options.labels.padding,\n        l = this.legendHitBoxes = [],\n        c = this.lineWidths = [0],\n        h = n + a;\n      var d = t;\n      o.textAlign = \"left\", o.textBaseline = \"middle\";\n      var u = -1,\n        f = -h;\n      return this.legendItems.forEach(function (p, g) {\n        var m = s + e / 2 + o.measureText(p.text).width;\n        (g === 0 || c[c.length - 1] + m + 2 * a > r) && (d += h, c[c.length - (g > 0 ? 0 : 1)] = 0, f += h, u++), l[g] = {\n          left: 0,\n          top: f,\n          row: u,\n          width: m,\n          height: n\n        }, c[c.length - 1] += m + a;\n      }), d;\n    }\n  }, {\n    key: \"_fitCols\",\n    value: function _fitCols(t, e, s, n) {\n      var o = this.ctx,\n        r = this.maxHeight,\n        a = this.options.labels.padding,\n        l = this.legendHitBoxes = [],\n        c = this.columnSizes = [],\n        h = r - t;\n      var d = a,\n        u = 0,\n        f = 0,\n        p = 0,\n        g = 0;\n      return this.legendItems.forEach(function (m, b) {\n        var _vc = vc(s, e, o, m, n),\n          _ = _vc.itemWidth,\n          v = _vc.itemHeight;\n        b > 0 && f + v + 2 * a > h && (d += u + a, c.push({\n          width: u,\n          height: f\n        }), p += u + a, g++, u = f = 0), l[b] = {\n          left: p,\n          top: f,\n          col: g,\n          width: _,\n          height: v\n        }, u = Math.max(u, _), f += v + a;\n      }), d += u, c.push({\n        width: u,\n        height: f\n      }), d;\n    }\n  }, {\n    key: \"adjustHitBoxes\",\n    value: function adjustHitBoxes() {\n      if (!this.options.display) return;\n      var t = this._computeTitleHeight(),\n        e = this.legendHitBoxes,\n        _this$options13 = this.options,\n        s = _this$options13.align,\n        n = _this$options13.labels.padding,\n        o = _this$options13.rtl,\n        r = Ut(o, this.left, this.width);\n      if (this.isHorizontal()) {\n        var a = 0,\n          l = Y(s, this.left + n, this.right - this.lineWidths[a]);\n        var _iterator34 = _createForOfIteratorHelper(e),\n          _step34;\n        try {\n          for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n            var c = _step34.value;\n            a !== c.row && (a = c.row, l = Y(s, this.left + n, this.right - this.lineWidths[a])), c.top += this.top + t + n, c.left = r.leftForLtr(r.x(l), c.width), l += c.width + n;\n          }\n        } catch (err) {\n          _iterator34.e(err);\n        } finally {\n          _iterator34.f();\n        }\n      } else {\n        var _a3 = 0,\n          _l3 = Y(s, this.top + t + n, this.bottom - this.columnSizes[_a3].height);\n        var _iterator35 = _createForOfIteratorHelper(e),\n          _step35;\n        try {\n          for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n            var _c3 = _step35.value;\n            _c3.col !== _a3 && (_a3 = _c3.col, _l3 = Y(s, this.top + t + n, this.bottom - this.columnSizes[_a3].height)), _c3.top = _l3, _c3.left += this.left + n, _c3.left = r.leftForLtr(r.x(_c3.left), _c3.width), _l3 += _c3.height + n;\n          }\n        } catch (err) {\n          _iterator35.e(err);\n        } finally {\n          _iterator35.f();\n        }\n      }\n    }\n  }, {\n    key: \"isHorizontal\",\n    value: function isHorizontal() {\n      return this.options.position === \"top\" || this.options.position === \"bottom\";\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      if (this.options.display) {\n        var t = this.ctx;\n        Je(t, this), this._draw(), Ze(t);\n      }\n    }\n  }, {\n    key: \"_draw\",\n    value: function _draw() {\n      var _this26 = this;\n      var t = this.options,\n        e = this.columnSizes,\n        s = this.lineWidths,\n        n = this.ctx,\n        o = t.align,\n        r = t.labels,\n        a = W.color,\n        l = Ut(t.rtl, this.left, this.width),\n        c = X(r.font),\n        h = r.padding,\n        d = c.size,\n        u = d / 2;\n      var f;\n      this.drawTitle(), n.textAlign = l.textAlign(\"left\"), n.textBaseline = \"middle\", n.lineWidth = 0.5, n.font = c.string;\n      var _Js2 = Js(r, d),\n        p = _Js2.boxWidth,\n        g = _Js2.boxHeight,\n        m = _Js2.itemHeight,\n        b = function b(M, S, k) {\n          if (isNaN(p) || p <= 0 || isNaN(g) || g < 0) return;\n          n.save();\n          var P = D(k.lineWidth, 1);\n          if (n.fillStyle = D(k.fillStyle, a), n.lineCap = D(k.lineCap, \"butt\"), n.lineDashOffset = D(k.lineDashOffset, 0), n.lineJoin = D(k.lineJoin, \"miter\"), n.lineWidth = P, n.strokeStyle = D(k.strokeStyle, a), n.setLineDash(D(k.lineDash, [])), r.usePointStyle) {\n            var C = {\n                radius: g * Math.SQRT2 / 2,\n                pointStyle: k.pointStyle,\n                rotation: k.rotation,\n                borderWidth: P\n              },\n              O = l.xPlus(M, p / 2),\n              A = S + u;\n            Cn(n, C, O, A, r.pointStyleWidth && p);\n          } else {\n            var _C = S + Math.max((d - g) / 2, 0),\n              _O = l.leftForLtr(M, p),\n              _A = Yt(k.borderRadius);\n            n.beginPath(), Object.values(_A).some(function (j) {\n              return j !== 0;\n            }) ? Ue(n, {\n              x: _O,\n              y: _C,\n              w: p,\n              h: g,\n              radius: _A\n            }) : n.rect(_O, _C, p, g), n.fill(), P !== 0 && n.stroke();\n          }\n          n.restore();\n        },\n        _ = function _(M, S, k) {\n          be(n, k.text, M, S + m / 2, c, {\n            strikethrough: k.hidden,\n            textAlign: l.textAlign(k.textAlign)\n          });\n        },\n        v = this.isHorizontal(),\n        y = this._computeTitleHeight();\n      v ? f = {\n        x: Y(o, this.left + h, this.right - s[0]),\n        y: this.top + h + y,\n        line: 0\n      } : f = {\n        x: this.left + h,\n        y: Y(o, this.top + y + h, this.bottom - e[0].height),\n        line: 0\n      }, Fn(this.ctx, t.textDirection);\n      var x = m + h;\n      this.legendItems.forEach(function (M, S) {\n        n.strokeStyle = M.fontColor, n.fillStyle = M.fontColor;\n        var k = n.measureText(M.text).width,\n          P = l.textAlign(M.textAlign || (M.textAlign = r.textAlign)),\n          C = p + u + k;\n        var O = f.x,\n          A = f.y;\n        l.setWidth(_this26.width), v ? S > 0 && O + C + h > _this26.right && (A = f.y += x, f.line++, O = f.x = Y(o, _this26.left + h, _this26.right - s[f.line])) : S > 0 && A + x > _this26.bottom && (O = f.x = O + e[f.line].width + h, f.line++, A = f.y = Y(o, _this26.top + y + h, _this26.bottom - e[f.line].height));\n        var j = l.x(O);\n        if (b(j, A, M), O = Qo(P, O + p + u, v ? O + C : _this26.right, t.rtl), _(l.x(O), A, M), v) f.x += C + h;else if (typeof M.text != \"string\") {\n          var J = c.lineHeight;\n          f.y += no(M, J) + h;\n        } else f.y += x;\n      }), In(this.ctx, t.textDirection);\n    }\n  }, {\n    key: \"drawTitle\",\n    value: function drawTitle() {\n      var t = this.options,\n        e = t.title,\n        s = X(e.font),\n        n = et(e.padding);\n      if (!e.display) return;\n      var o = Ut(t.rtl, this.left, this.width),\n        r = this.ctx,\n        a = e.position,\n        l = s.size / 2,\n        c = n.top + l;\n      var h,\n        d = this.left,\n        u = this.width;\n      if (this.isHorizontal()) u = Math.max.apply(Math, _toConsumableArray(this.lineWidths)), h = this.top + c, d = Y(t.align, d, this.right - u);else {\n        var p = this.columnSizes.reduce(function (g, m) {\n          return Math.max(g, m.height);\n        }, 0);\n        h = c + Y(t.align, this.top, this.bottom - p - t.labels.padding - this._computeTitleHeight());\n      }\n      var f = Y(a, d, d + u);\n      r.textAlign = o.textAlign(zi(a)), r.textBaseline = \"middle\", r.strokeStyle = e.color, r.fillStyle = e.color, r.font = s.string, be(r, e.text, f, h, s);\n    }\n  }, {\n    key: \"_computeTitleHeight\",\n    value: function _computeTitleHeight() {\n      var t = this.options.title,\n        e = X(t.font),\n        s = et(t.padding);\n      return t.display ? e.lineHeight + s.height : 0;\n    }\n  }, {\n    key: \"_getLegendItemAt\",\n    value: function _getLegendItemAt(t, e) {\n      var s, n, o;\n      if (_t(t, this.left, this.right) && _t(e, this.top, this.bottom)) {\n        for (o = this.legendHitBoxes, s = 0; s < o.length; ++s) if (n = o[s], _t(t, n.left, n.left + n.width) && _t(e, n.top, n.top + n.height)) return this.legendItems[s];\n      }\n      return null;\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(t) {\n      var e = this.options;\n      if (!kc(t.type, e)) return;\n      var s = this._getLegendItemAt(t.x, t.y);\n      if (t.type === \"mousemove\" || t.type === \"mouseout\") {\n        var n = this._hoveredItem,\n          o = yc(n, s);\n        n && !o && I(e.onLeave, [t, n, this], this), this._hoveredItem = s, s && !o && I(e.onHover, [t, s, this], this);\n      } else s && I(e.onClick, [t, s, this], this);\n    }\n  }]);\n}(st);\nfunction vc(i, t, e, s, n) {\n  var o = Mc(s, i, t, e),\n    r = Sc(n, s, t.lineHeight);\n  return {\n    itemWidth: o,\n    itemHeight: r\n  };\n}\nfunction Mc(i, t, e, s) {\n  var n = i.text;\n  return n && typeof n != \"string\" && (n = n.reduce(function (o, r) {\n    return o.length > r.length ? o : r;\n  })), t + e.size / 2 + s.measureText(n).width;\n}\nfunction Sc(i, t, e) {\n  var s = i;\n  return typeof t.text != \"string\" && (s = no(t, e)), s;\n}\nfunction no(i, t) {\n  var e = i.text ? i.text.length : 0;\n  return t * e;\n}\nfunction kc(i, t) {\n  return !!((i === \"mousemove\" || i === \"mouseout\") && (t.onHover || t.onLeave) || t.onClick && (i === \"click\" || i === \"mouseup\"));\n}\nvar wc = {\n  id: \"legend\",\n  _element: Zs,\n  start: function start(i, t, e) {\n    var s = i.legend = new Zs({\n      ctx: i.ctx,\n      options: e,\n      chart: i\n    });\n    tt.configure(i, s, e), tt.addBox(i, s);\n  },\n  stop: function stop(i) {\n    tt.removeBox(i, i.legend), delete i.legend;\n  },\n  beforeUpdate: function beforeUpdate(i, t, e) {\n    var s = i.legend;\n    tt.configure(i, s, e), s.options = e;\n  },\n  afterUpdate: function afterUpdate(i) {\n    var t = i.legend;\n    t.buildLabels(), t.adjustHitBoxes();\n  },\n  afterEvent: function afterEvent(i, t) {\n    t.replay || i.legend.handleEvent(t.event);\n  },\n  defaults: {\n    display: !0,\n    position: \"top\",\n    align: \"center\",\n    fullSize: !0,\n    reverse: !1,\n    weight: 1e3,\n    onClick: function onClick(i, t, e) {\n      var s = t.datasetIndex,\n        n = e.chart;\n      n.isDatasetVisible(s) ? (n.hide(s), t.hidden = !0) : (n.show(s), t.hidden = !1);\n    },\n    onHover: null,\n    onLeave: null,\n    labels: {\n      color: function color(i) {\n        return i.chart.options.color;\n      },\n      boxWidth: 40,\n      padding: 10,\n      generateLabels: function generateLabels(i) {\n        var t = i.data.datasets,\n          _i$legend$options$lab = i.legend.options.labels,\n          e = _i$legend$options$lab.usePointStyle,\n          s = _i$legend$options$lab.pointStyle,\n          n = _i$legend$options$lab.textAlign,\n          o = _i$legend$options$lab.color,\n          r = _i$legend$options$lab.useBorderRadius,\n          a = _i$legend$options$lab.borderRadius;\n        return i._getSortedDatasetMetas().map(function (l) {\n          var c = l.controller.getStyle(e ? 0 : void 0),\n            h = et(c.borderWidth);\n          return {\n            text: t[l.index].label,\n            fillStyle: c.backgroundColor,\n            fontColor: o,\n            hidden: !l.visible,\n            lineCap: c.borderCapStyle,\n            lineDash: c.borderDash,\n            lineDashOffset: c.borderDashOffset,\n            lineJoin: c.borderJoinStyle,\n            lineWidth: (h.width + h.height) / 4,\n            strokeStyle: c.borderColor,\n            pointStyle: s || c.pointStyle,\n            rotation: c.rotation,\n            textAlign: n || c.textAlign,\n            borderRadius: r && (a || c.borderRadius),\n            datasetIndex: l.index\n          };\n        }, this);\n      }\n    },\n    title: {\n      color: function color(i) {\n        return i.chart.options.color;\n      },\n      display: !1,\n      position: \"center\",\n      text: \"\"\n    }\n  },\n  descriptors: {\n    _scriptable: function _scriptable(i) {\n      return !i.startsWith(\"on\");\n    },\n    labels: {\n      _scriptable: function _scriptable(i) {\n        return ![\"generateLabels\", \"filter\", \"sort\"].includes(i);\n      }\n    }\n  }\n};\nvar oo = /*#__PURE__*/function (_st7) {\n  function oo(t) {\n    var _this27;\n    _classCallCheck(this, oo);\n    _this27 = _callSuper(this, oo), _this27.chart = t.chart, _this27.options = t.options, _this27.ctx = t.ctx, _this27._padding = void 0, _this27.top = void 0, _this27.bottom = void 0, _this27.left = void 0, _this27.right = void 0, _this27.width = void 0, _this27.height = void 0, _this27.position = void 0, _this27.weight = void 0, _this27.fullSize = void 0;\n    return _this27;\n  }\n  _inherits(oo, _st7);\n  return _createClass(oo, [{\n    key: \"update\",\n    value: function update(t, e) {\n      var s = this.options;\n      if (this.left = 0, this.top = 0, !s.display) {\n        this.width = this.height = this.right = this.bottom = 0;\n        return;\n      }\n      this.width = this.right = t, this.height = this.bottom = e;\n      var n = N(s.text) ? s.text.length : 1;\n      this._padding = et(s.padding);\n      var o = n * X(s.font).lineHeight + this._padding.height;\n      this.isHorizontal() ? this.height = o : this.width = o;\n    }\n  }, {\n    key: \"isHorizontal\",\n    value: function isHorizontal() {\n      var t = this.options.position;\n      return t === \"top\" || t === \"bottom\";\n    }\n  }, {\n    key: \"_drawArgs\",\n    value: function _drawArgs(t) {\n      var e = this.top,\n        s = this.left,\n        n = this.bottom,\n        o = this.right,\n        r = this.options,\n        a = r.align;\n      var l = 0,\n        c,\n        h,\n        d;\n      return this.isHorizontal() ? (h = Y(a, s, o), d = e + t, c = o - s) : (r.position === \"left\" ? (h = s + t, d = Y(a, n, e), l = E * -0.5) : (h = o - t, d = Y(a, e, n), l = E * 0.5), c = n - e), {\n        titleX: h,\n        titleY: d,\n        maxWidth: c,\n        rotation: l\n      };\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var t = this.ctx,\n        e = this.options;\n      if (!e.display) return;\n      var s = X(e.font),\n        o = s.lineHeight / 2 + this._padding.top,\n        _this$_drawArgs = this._drawArgs(o),\n        r = _this$_drawArgs.titleX,\n        a = _this$_drawArgs.titleY,\n        l = _this$_drawArgs.maxWidth,\n        c = _this$_drawArgs.rotation;\n      be(t, e.text, 0, 0, s, {\n        color: e.color,\n        maxWidth: l,\n        rotation: c,\n        textAlign: zi(e.align),\n        textBaseline: \"middle\",\n        translation: [r, a]\n      });\n    }\n  }]);\n}(st);\nfunction Pc(i, t) {\n  var e = new oo({\n    ctx: i.ctx,\n    options: t,\n    chart: i\n  });\n  tt.configure(i, e, t), tt.addBox(i, e), i.titleBlock = e;\n}\nvar Dc = {\n  id: \"title\",\n  _element: oo,\n  start: function start(i, t, e) {\n    Pc(i, e);\n  },\n  stop: function stop(i) {\n    var t = i.titleBlock;\n    tt.removeBox(i, t), delete i.titleBlock;\n  },\n  beforeUpdate: function beforeUpdate(i, t, e) {\n    var s = i.titleBlock;\n    tt.configure(i, s, e), s.options = e;\n  },\n  defaults: {\n    align: \"center\",\n    display: !1,\n    font: {\n      weight: \"bold\"\n    },\n    fullSize: !0,\n    padding: 10,\n    position: \"top\",\n    text: \"\",\n    weight: 2e3\n  },\n  defaultRoutes: {\n    color: \"color\"\n  },\n  descriptors: {\n    _scriptable: !0,\n    _indexable: !1\n  }\n};\nvar ae = {\n  average: function average(i) {\n    if (!i.length) return !1;\n    var t,\n      e,\n      s = /* @__PURE__ */new Set(),\n      n = 0,\n      o = 0;\n    for (t = 0, e = i.length; t < e; ++t) {\n      var a = i[t].element;\n      if (a && a.hasValue()) {\n        var l = a.tooltipPosition();\n        s.add(l.x), n += l.y, ++o;\n      }\n    }\n    return o === 0 || s.size === 0 ? !1 : {\n      x: _toConsumableArray(s).reduce(function (a, l) {\n        return a + l;\n      }) / s.size,\n      y: n / o\n    };\n  },\n  nearest: function nearest(i, t) {\n    if (!i.length) return !1;\n    var e = t.x,\n      s = t.y,\n      n = Number.POSITIVE_INFINITY,\n      o,\n      r,\n      a;\n    for (o = 0, r = i.length; o < r; ++o) {\n      var l = i[o].element;\n      if (l && l.hasValue()) {\n        var c = l.getCenterPoint(),\n          h = vi(t, c);\n        h < n && (n = h, a = l);\n      }\n    }\n    if (a) {\n      var _l4 = a.tooltipPosition();\n      e = _l4.x, s = _l4.y;\n    }\n    return {\n      x: e,\n      y: s\n    };\n  }\n};\nfunction rt(i, t) {\n  return t && (N(t) ? Array.prototype.push.apply(i, t) : i.push(t)), i;\n}\nfunction ft(i) {\n  return (typeof i == \"string\" || i instanceof String) && i.indexOf(\"\\n\") > -1 ? i.split(\"\\n\") : i;\n}\nfunction Cc(i, t) {\n  var e = t.element,\n    s = t.datasetIndex,\n    n = t.index,\n    o = i.getDatasetMeta(s).controller,\n    _o$getLabelAndValue = o.getLabelAndValue(n),\n    r = _o$getLabelAndValue.label,\n    a = _o$getLabelAndValue.value;\n  return {\n    chart: i,\n    label: r,\n    parsed: o.getParsed(n),\n    raw: i.data.datasets[s].data[n],\n    formattedValue: a,\n    dataset: o.getDataset(),\n    dataIndex: n,\n    datasetIndex: s,\n    element: e\n  };\n}\nfunction Qs(i, t) {\n  var e = i.chart.ctx,\n    s = i.body,\n    n = i.footer,\n    o = i.title,\n    r = t.boxWidth,\n    a = t.boxHeight,\n    l = X(t.bodyFont),\n    c = X(t.titleFont),\n    h = X(t.footerFont),\n    d = o.length,\n    u = n.length,\n    f = s.length,\n    p = et(t.padding);\n  var g = p.height,\n    m = 0,\n    b = s.reduce(function (y, x) {\n      return y + x.before.length + x.lines.length + x.after.length;\n    }, 0);\n  if (b += i.beforeBody.length + i.afterBody.length, d && (g += d * c.lineHeight + (d - 1) * t.titleSpacing + t.titleMarginBottom), b) {\n    var y = t.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight;\n    g += f * y + (b - f) * l.lineHeight + (b - 1) * t.bodySpacing;\n  }\n  u && (g += t.footerMarginTop + u * h.lineHeight + (u - 1) * t.footerSpacing);\n  var _ = 0;\n  var v = function v(y) {\n    m = Math.max(m, e.measureText(y).width + _);\n  };\n  return e.save(), e.font = c.string, L(i.title, v), e.font = l.string, L(i.beforeBody.concat(i.afterBody), v), _ = t.displayColors ? r + 2 + t.boxPadding : 0, L(s, function (y) {\n    L(y.before, v), L(y.lines, v), L(y.after, v);\n  }), _ = 0, e.font = h.string, L(i.footer, v), e.restore(), m += p.width, {\n    width: m,\n    height: g\n  };\n}\nfunction Oc(i, t) {\n  var e = t.y,\n    s = t.height;\n  return e < s / 2 ? \"top\" : e > i.height - s / 2 ? \"bottom\" : \"center\";\n}\nfunction Tc(i, t, e, s) {\n  var n = s.x,\n    o = s.width,\n    r = e.caretSize + e.caretPadding;\n  if (i === \"left\" && n + o + r > t.width || i === \"right\" && n - o - r < 0) return !0;\n}\nfunction Ac(i, t, e, s) {\n  var n = e.x,\n    o = e.width,\n    r = i.width,\n    _i$chartArea = i.chartArea,\n    a = _i$chartArea.left,\n    l = _i$chartArea.right;\n  var c = \"center\";\n  return s === \"center\" ? c = n <= (a + l) / 2 ? \"left\" : \"right\" : n <= o / 2 ? c = \"left\" : n >= r - o / 2 && (c = \"right\"), Tc(c, i, t, e) && (c = \"center\"), c;\n}\nfunction tn(i, t, e) {\n  var s = e.yAlign || t.yAlign || Oc(i, e);\n  return {\n    xAlign: e.xAlign || t.xAlign || Ac(i, t, e, s),\n    yAlign: s\n  };\n}\nfunction Rc(i, t) {\n  var e = i.x,\n    s = i.width;\n  return t === \"right\" ? e -= s : t === \"center\" && (e -= s / 2), e;\n}\nfunction Lc(i, t, e) {\n  var s = i.y,\n    n = i.height;\n  return t === \"top\" ? s += e : t === \"bottom\" ? s -= n + e : s -= n / 2, s;\n}\nfunction en(i, t, e, s) {\n  var n = i.caretSize,\n    o = i.caretPadding,\n    r = i.cornerRadius,\n    a = e.xAlign,\n    l = e.yAlign,\n    c = n + o,\n    _Yt = Yt(r),\n    h = _Yt.topLeft,\n    d = _Yt.topRight,\n    u = _Yt.bottomLeft,\n    f = _Yt.bottomRight;\n  var p = Rc(t, a);\n  var g = Lc(t, l, c);\n  return l === \"center\" ? a === \"left\" ? p += c : a === \"right\" && (p -= c) : a === \"left\" ? p -= Math.max(h, u) + n : a === \"right\" && (p += Math.max(d, f) + n), {\n    x: U(p, 0, s.width - t.width),\n    y: U(g, 0, s.height - t.height)\n  };\n}\nfunction Re(i, t, e) {\n  var s = et(e.padding);\n  return t === \"center\" ? i.x + i.width / 2 : t === \"right\" ? i.x + i.width - s.right : i.x + s.left;\n}\nfunction sn(i) {\n  return rt([], ft(i));\n}\nfunction Ec(i, t, e) {\n  return Bt(i, {\n    tooltip: t,\n    tooltipItems: e,\n    type: \"tooltip\"\n  });\n}\nfunction nn(i, t) {\n  var e = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;\n  return e ? i.override(e) : i;\n}\nvar ro = {\n  beforeTitle: dt,\n  title: function title(i) {\n    if (i.length > 0) {\n      var t = i[0],\n        e = t.chart.data.labels,\n        s = e ? e.length : 0;\n      if (this && this.options && this.options.mode === \"dataset\") return t.dataset.label || \"\";\n      if (t.label) return t.label;\n      if (s > 0 && t.dataIndex < s) return e[t.dataIndex];\n    }\n    return \"\";\n  },\n  afterTitle: dt,\n  beforeBody: dt,\n  beforeLabel: dt,\n  label: function label(i) {\n    if (this && this.options && this.options.mode === \"dataset\") return i.label + \": \" + i.formattedValue || i.formattedValue;\n    var t = i.dataset.label || \"\";\n    t && (t += \": \");\n    var e = i.formattedValue;\n    return R(e) || (t += e), t;\n  },\n  labelColor: function labelColor(i) {\n    var e = i.chart.getDatasetMeta(i.datasetIndex).controller.getStyle(i.dataIndex);\n    return {\n      borderColor: e.borderColor,\n      backgroundColor: e.backgroundColor,\n      borderWidth: e.borderWidth,\n      borderDash: e.borderDash,\n      borderDashOffset: e.borderDashOffset,\n      borderRadius: 0\n    };\n  },\n  labelTextColor: function labelTextColor() {\n    return this.options.bodyColor;\n  },\n  labelPointStyle: function labelPointStyle(i) {\n    var e = i.chart.getDatasetMeta(i.datasetIndex).controller.getStyle(i.dataIndex);\n    return {\n      pointStyle: e.pointStyle,\n      rotation: e.rotation\n    };\n  },\n  afterLabel: dt,\n  afterBody: dt,\n  beforeFooter: dt,\n  footer: dt,\n  afterFooter: dt\n};\nfunction K(i, t, e, s) {\n  var n = i[t].call(e, s);\n  return _typeof(n) > \"u\" ? ro[t].call(e, s) : n;\n}\nvar Oi = /*#__PURE__*/function (_st8) {\n  function Oi(t) {\n    var _this28;\n    _classCallCheck(this, Oi);\n    _this28 = _callSuper(this, Oi), _this28.opacity = 0, _this28._active = [], _this28._eventPosition = void 0, _this28._size = void 0, _this28._cachedAnimations = void 0, _this28._tooltipItems = [], _this28.$animations = void 0, _this28.$context = void 0, _this28.chart = t.chart, _this28.options = t.options, _this28.dataPoints = void 0, _this28.title = void 0, _this28.beforeBody = void 0, _this28.body = void 0, _this28.afterBody = void 0, _this28.footer = void 0, _this28.xAlign = void 0, _this28.yAlign = void 0, _this28.x = void 0, _this28.y = void 0, _this28.height = void 0, _this28.width = void 0, _this28.caretX = void 0, _this28.caretY = void 0, _this28.labelColors = void 0, _this28.labelPointStyles = void 0, _this28.labelTextColors = void 0;\n    return _this28;\n  }\n  _inherits(Oi, _st8);\n  return _createClass(Oi, [{\n    key: \"initialize\",\n    value: function initialize(t) {\n      this.options = t, this._cachedAnimations = void 0, this.$context = void 0;\n    }\n  }, {\n    key: \"_resolveAnimations\",\n    value: function _resolveAnimations() {\n      var t = this._cachedAnimations;\n      if (t) return t;\n      var e = this.chart,\n        s = this.options.setContext(this.getContext()),\n        n = s.enabled && e.options.animation && s.animations,\n        o = new Nn(this.chart, n);\n      return n._cacheable && (this._cachedAnimations = Object.freeze(o)), o;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.$context || (this.$context = Ec(this.chart.getContext(), this, this._tooltipItems));\n    }\n  }, {\n    key: \"getTitle\",\n    value: function getTitle(t, e) {\n      var s = e.callbacks,\n        n = K(s, \"beforeTitle\", this, t),\n        o = K(s, \"title\", this, t),\n        r = K(s, \"afterTitle\", this, t);\n      var a = [];\n      return a = rt(a, ft(n)), a = rt(a, ft(o)), a = rt(a, ft(r)), a;\n    }\n  }, {\n    key: \"getBeforeBody\",\n    value: function getBeforeBody(t, e) {\n      return sn(K(e.callbacks, \"beforeBody\", this, t));\n    }\n  }, {\n    key: \"getBody\",\n    value: function getBody(t, e) {\n      var _this29 = this;\n      var s = e.callbacks,\n        n = [];\n      return L(t, function (o) {\n        var r = {\n            before: [],\n            lines: [],\n            after: []\n          },\n          a = nn(s, o);\n        rt(r.before, ft(K(a, \"beforeLabel\", _this29, o))), rt(r.lines, K(a, \"label\", _this29, o)), rt(r.after, ft(K(a, \"afterLabel\", _this29, o))), n.push(r);\n      }), n;\n    }\n  }, {\n    key: \"getAfterBody\",\n    value: function getAfterBody(t, e) {\n      return sn(K(e.callbacks, \"afterBody\", this, t));\n    }\n  }, {\n    key: \"getFooter\",\n    value: function getFooter(t, e) {\n      var s = e.callbacks,\n        n = K(s, \"beforeFooter\", this, t),\n        o = K(s, \"footer\", this, t),\n        r = K(s, \"afterFooter\", this, t);\n      var a = [];\n      return a = rt(a, ft(n)), a = rt(a, ft(o)), a = rt(a, ft(r)), a;\n    }\n  }, {\n    key: \"_createItems\",\n    value: function _createItems(t) {\n      var _this30 = this;\n      var e = this._active,\n        s = this.chart.data,\n        n = [],\n        o = [],\n        r = [];\n      var a = [],\n        l,\n        c;\n      for (l = 0, c = e.length; l < c; ++l) a.push(Cc(this.chart, e[l]));\n      return t.filter && (a = a.filter(function (h, d, u) {\n        return t.filter(h, d, u, s);\n      })), t.itemSort && (a = a.sort(function (h, d) {\n        return t.itemSort(h, d, s);\n      })), L(a, function (h) {\n        var d = nn(t.callbacks, h);\n        n.push(K(d, \"labelColor\", _this30, h)), o.push(K(d, \"labelPointStyle\", _this30, h)), r.push(K(d, \"labelTextColor\", _this30, h));\n      }), this.labelColors = n, this.labelPointStyles = o, this.labelTextColors = r, this.dataPoints = a, a;\n    }\n  }, {\n    key: \"update\",\n    value: function update(t, e) {\n      var s = this.options.setContext(this.getContext()),\n        n = this._active;\n      var o,\n        r = [];\n      if (!n.length) this.opacity !== 0 && (o = {\n        opacity: 0\n      });else {\n        var a = ae[s.position].call(this, n, this._eventPosition);\n        r = this._createItems(s), this.title = this.getTitle(r, s), this.beforeBody = this.getBeforeBody(r, s), this.body = this.getBody(r, s), this.afterBody = this.getAfterBody(r, s), this.footer = this.getFooter(r, s);\n        var l = this._size = Qs(this, s),\n          c = Object.assign({}, a, l),\n          h = tn(this.chart, s, c),\n          d = en(s, c, h, this.chart);\n        this.xAlign = h.xAlign, this.yAlign = h.yAlign, o = {\n          opacity: 1,\n          x: d.x,\n          y: d.y,\n          width: l.width,\n          height: l.height,\n          caretX: a.x,\n          caretY: a.y\n        };\n      }\n      this._tooltipItems = r, this.$context = void 0, o && this._resolveAnimations().update(this, o), t && s.external && s.external.call(this, {\n        chart: this.chart,\n        tooltip: this,\n        replay: e\n      });\n    }\n  }, {\n    key: \"drawCaret\",\n    value: function drawCaret(t, e, s, n) {\n      var o = this.getCaretPosition(t, s, n);\n      e.lineTo(o.x1, o.y1), e.lineTo(o.x2, o.y2), e.lineTo(o.x3, o.y3);\n    }\n  }, {\n    key: \"getCaretPosition\",\n    value: function getCaretPosition(t, e, s) {\n      var n = this.xAlign,\n        o = this.yAlign,\n        r = s.caretSize,\n        a = s.cornerRadius,\n        _Yt2 = Yt(a),\n        l = _Yt2.topLeft,\n        c = _Yt2.topRight,\n        h = _Yt2.bottomLeft,\n        d = _Yt2.bottomRight,\n        u = t.x,\n        f = t.y,\n        p = e.width,\n        g = e.height;\n      var m, b, _, v, y, x;\n      return o === \"center\" ? (y = f + g / 2, n === \"left\" ? (m = u, b = m - r, v = y + r, x = y - r) : (m = u + p, b = m + r, v = y - r, x = y + r), _ = m) : (n === \"left\" ? b = u + Math.max(l, h) + r : n === \"right\" ? b = u + p - Math.max(c, d) - r : b = this.caretX, o === \"top\" ? (v = f, y = v - r, m = b - r, _ = b + r) : (v = f + g, y = v + r, m = b + r, _ = b - r), x = v), {\n        x1: m,\n        x2: b,\n        x3: _,\n        y1: v,\n        y2: y,\n        y3: x\n      };\n    }\n  }, {\n    key: \"drawTitle\",\n    value: function drawTitle(t, e, s) {\n      var n = this.title,\n        o = n.length;\n      var r, a, l;\n      if (o) {\n        var c = Ut(s.rtl, this.x, this.width);\n        for (t.x = Re(this, s.titleAlign, s), e.textAlign = c.textAlign(s.titleAlign), e.textBaseline = \"middle\", r = X(s.titleFont), a = s.titleSpacing, e.fillStyle = s.titleColor, e.font = r.string, l = 0; l < o; ++l) e.fillText(n[l], c.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + a, l + 1 === o && (t.y += s.titleMarginBottom - a);\n      }\n    }\n  }, {\n    key: \"_drawColorBox\",\n    value: function _drawColorBox(t, e, s, n, o) {\n      var r = this.labelColors[s],\n        a = this.labelPointStyles[s],\n        l = o.boxHeight,\n        c = o.boxWidth,\n        h = X(o.bodyFont),\n        d = Re(this, \"left\", o),\n        u = n.x(d),\n        f = l < h.lineHeight ? (h.lineHeight - l) / 2 : 0,\n        p = e.y + f;\n      if (o.usePointStyle) {\n        var g = {\n            radius: Math.min(c, l) / 2,\n            pointStyle: a.pointStyle,\n            rotation: a.rotation,\n            borderWidth: 1\n          },\n          m = n.leftForLtr(u, c) + c / 2,\n          b = p + l / 2;\n        t.strokeStyle = o.multiKeyBackground, t.fillStyle = o.multiKeyBackground, Si(t, g, m, b), t.strokeStyle = r.borderColor, t.fillStyle = r.backgroundColor, Si(t, g, m, b);\n      } else {\n        t.lineWidth = T(r.borderWidth) ? Math.max.apply(Math, _toConsumableArray(Object.values(r.borderWidth))) : r.borderWidth || 1, t.strokeStyle = r.borderColor, t.setLineDash(r.borderDash || []), t.lineDashOffset = r.borderDashOffset || 0;\n        var _g2 = n.leftForLtr(u, c),\n          _m = n.leftForLtr(n.xPlus(u, 1), c - 2),\n          _b3 = Yt(r.borderRadius);\n        Object.values(_b3).some(function (_) {\n          return _ !== 0;\n        }) ? (t.beginPath(), t.fillStyle = o.multiKeyBackground, Ue(t, {\n          x: _g2,\n          y: p,\n          w: c,\n          h: l,\n          radius: _b3\n        }), t.fill(), t.stroke(), t.fillStyle = r.backgroundColor, t.beginPath(), Ue(t, {\n          x: _m,\n          y: p + 1,\n          w: c - 2,\n          h: l - 2,\n          radius: _b3\n        }), t.fill()) : (t.fillStyle = o.multiKeyBackground, t.fillRect(_g2, p, c, l), t.strokeRect(_g2, p, c, l), t.fillStyle = r.backgroundColor, t.fillRect(_m, p + 1, c - 2, l - 2));\n      }\n      t.fillStyle = this.labelTextColors[s];\n    }\n  }, {\n    key: \"drawBody\",\n    value: function drawBody(t, e, s) {\n      var n = this.body,\n        o = s.bodySpacing,\n        r = s.bodyAlign,\n        a = s.displayColors,\n        l = s.boxHeight,\n        c = s.boxWidth,\n        h = s.boxPadding,\n        d = X(s.bodyFont);\n      var u = d.lineHeight,\n        f = 0;\n      var p = Ut(s.rtl, this.x, this.width),\n        g = function g(k) {\n          e.fillText(k, p.x(t.x + f), t.y + u / 2), t.y += u + o;\n        },\n        m = p.textAlign(r);\n      var b, _, v, y, x, M, S;\n      for (e.textAlign = r, e.textBaseline = \"middle\", e.font = d.string, t.x = Re(this, m, s), e.fillStyle = s.bodyColor, L(this.beforeBody, g), f = a && m !== \"right\" ? r === \"center\" ? c / 2 + h : c + 2 + h : 0, y = 0, M = n.length; y < M; ++y) {\n        for (b = n[y], _ = this.labelTextColors[y], e.fillStyle = _, L(b.before, g), v = b.lines, a && v.length && (this._drawColorBox(e, t, y, p, s), u = Math.max(d.lineHeight, l)), x = 0, S = v.length; x < S; ++x) g(v[x]), u = d.lineHeight;\n        L(b.after, g);\n      }\n      f = 0, u = d.lineHeight, L(this.afterBody, g), t.y -= o;\n    }\n  }, {\n    key: \"drawFooter\",\n    value: function drawFooter(t, e, s) {\n      var n = this.footer,\n        o = n.length;\n      var r, a;\n      if (o) {\n        var l = Ut(s.rtl, this.x, this.width);\n        for (t.x = Re(this, s.footerAlign, s), t.y += s.footerMarginTop, e.textAlign = l.textAlign(s.footerAlign), e.textBaseline = \"middle\", r = X(s.footerFont), e.fillStyle = s.footerColor, e.font = r.string, a = 0; a < o; ++a) e.fillText(n[a], l.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + s.footerSpacing;\n      }\n    }\n  }, {\n    key: \"drawBackground\",\n    value: function drawBackground(t, e, s, n) {\n      var o = this.xAlign,\n        r = this.yAlign,\n        a = t.x,\n        l = t.y,\n        c = s.width,\n        h = s.height,\n        _Yt3 = Yt(n.cornerRadius),\n        d = _Yt3.topLeft,\n        u = _Yt3.topRight,\n        f = _Yt3.bottomLeft,\n        p = _Yt3.bottomRight;\n      e.fillStyle = n.backgroundColor, e.strokeStyle = n.borderColor, e.lineWidth = n.borderWidth, e.beginPath(), e.moveTo(a + d, l), r === \"top\" && this.drawCaret(t, e, s, n), e.lineTo(a + c - u, l), e.quadraticCurveTo(a + c, l, a + c, l + u), r === \"center\" && o === \"right\" && this.drawCaret(t, e, s, n), e.lineTo(a + c, l + h - p), e.quadraticCurveTo(a + c, l + h, a + c - p, l + h), r === \"bottom\" && this.drawCaret(t, e, s, n), e.lineTo(a + f, l + h), e.quadraticCurveTo(a, l + h, a, l + h - f), r === \"center\" && o === \"left\" && this.drawCaret(t, e, s, n), e.lineTo(a, l + d), e.quadraticCurveTo(a, l, a + d, l), e.closePath(), e.fill(), n.borderWidth > 0 && e.stroke();\n    }\n  }, {\n    key: \"_updateAnimationTarget\",\n    value: function _updateAnimationTarget(t) {\n      var e = this.chart,\n        s = this.$animations,\n        n = s && s.x,\n        o = s && s.y;\n      if (n || o) {\n        var r = ae[t.position].call(this, this._active, this._eventPosition);\n        if (!r) return;\n        var a = this._size = Qs(this, t),\n          l = Object.assign({}, r, this._size),\n          c = tn(e, t, l),\n          h = en(t, l, c, e);\n        (n._to !== h.x || o._to !== h.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = a.width, this.height = a.height, this.caretX = r.x, this.caretY = r.y, this._resolveAnimations().update(this, h));\n      }\n    }\n  }, {\n    key: \"_willRender\",\n    value: function _willRender() {\n      return !!this.opacity;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(t) {\n      var e = this.options.setContext(this.getContext());\n      var s = this.opacity;\n      if (!s) return;\n      this._updateAnimationTarget(e);\n      var n = {\n          width: this.width,\n          height: this.height\n        },\n        o = {\n          x: this.x,\n          y: this.y\n        };\n      s = Math.abs(s) < 1e-3 ? 0 : s;\n      var r = et(e.padding),\n        a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n      e.enabled && a && (t.save(), t.globalAlpha = s, this.drawBackground(o, t, n, e), Fn(t, e.textDirection), o.y += r.top, this.drawTitle(o, t, e), this.drawBody(o, t, e), this.drawFooter(o, t, e), In(t, e.textDirection), t.restore());\n    }\n  }, {\n    key: \"getActiveElements\",\n    value: function getActiveElements() {\n      return this._active || [];\n    }\n  }, {\n    key: \"setActiveElements\",\n    value: function setActiveElements(t, e) {\n      var _this31 = this;\n      var s = this._active,\n        n = t.map(function (_ref10) {\n          var a = _ref10.datasetIndex,\n            l = _ref10.index;\n          var c = _this31.chart.getDatasetMeta(a);\n          if (!c) throw new Error(\"Cannot find a dataset at index \" + a);\n          return {\n            datasetIndex: a,\n            element: c.data[l],\n            index: l\n          };\n        }),\n        o = !je(s, n),\n        r = this._positionChanged(n, e);\n      (o || r) && (this._active = n, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0));\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(t, e) {\n      var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;\n      if (e && this._ignoreReplayEvents) return !1;\n      this._ignoreReplayEvents = !1;\n      var n = this.options,\n        o = this._active || [],\n        r = this._getActiveElements(t, o, e, s),\n        a = this._positionChanged(r, t),\n        l = e || !je(r, o) || a;\n      return l && (this._active = r, (n.enabled || n.external) && (this._eventPosition = {\n        x: t.x,\n        y: t.y\n      }, this.update(!0, e))), l;\n    }\n  }, {\n    key: \"_getActiveElements\",\n    value: function _getActiveElements(t, e, s, n) {\n      var _this32 = this;\n      var o = this.options;\n      if (t.type === \"mouseout\") return [];\n      if (!n) return e.filter(function (a) {\n        return _this32.chart.data.datasets[a.datasetIndex] && _this32.chart.getDatasetMeta(a.datasetIndex).controller.getParsed(a.index) !== void 0;\n      });\n      var r = this.chart.getElementsAtEventForMode(t, o.mode, o, s);\n      return o.reverse && r.reverse(), r;\n    }\n  }, {\n    key: \"_positionChanged\",\n    value: function _positionChanged(t, e) {\n      var s = this.caretX,\n        n = this.caretY,\n        o = this.options,\n        r = ae[o.position].call(this, t, e);\n      return r !== !1 && (s !== r.x || n !== r.y);\n    }\n  }]);\n}(st);\nw(Oi, \"positioners\", ae);\nvar Fc = {\n  id: \"tooltip\",\n  _element: Oi,\n  positioners: ae,\n  afterInit: function afterInit(i, t, e) {\n    e && (i.tooltip = new Oi({\n      chart: i,\n      options: e\n    }));\n  },\n  beforeUpdate: function beforeUpdate(i, t, e) {\n    i.tooltip && i.tooltip.initialize(e);\n  },\n  reset: function reset(i, t, e) {\n    i.tooltip && i.tooltip.initialize(e);\n  },\n  afterDraw: function afterDraw(i) {\n    var t = i.tooltip;\n    if (t && t._willRender()) {\n      var e = {\n        tooltip: t\n      };\n      if (i.notifyPlugins(\"beforeTooltipDraw\", _objectSpread(_objectSpread({}, e), {}, {\n        cancelable: !0\n      })) === !1) return;\n      t.draw(i.ctx), i.notifyPlugins(\"afterTooltipDraw\", e);\n    }\n  },\n  afterEvent: function afterEvent(i, t) {\n    if (i.tooltip) {\n      var e = t.replay;\n      i.tooltip.handleEvent(t.event, e, t.inChartArea) && (t.changed = !0);\n    }\n  },\n  defaults: {\n    enabled: !0,\n    external: null,\n    position: \"average\",\n    backgroundColor: \"rgba(0,0,0,0.8)\",\n    titleColor: \"#fff\",\n    titleFont: {\n      weight: \"bold\"\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: \"left\",\n    bodyColor: \"#fff\",\n    bodySpacing: 2,\n    bodyFont: {},\n    bodyAlign: \"left\",\n    footerColor: \"#fff\",\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: \"bold\"\n    },\n    footerAlign: \"left\",\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: function boxHeight(i, t) {\n      return t.bodyFont.size;\n    },\n    boxWidth: function boxWidth(i, t) {\n      return t.bodyFont.size;\n    },\n    multiKeyBackground: \"#fff\",\n    displayColors: !0,\n    boxPadding: 0,\n    borderColor: \"rgba(0,0,0,0)\",\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: \"easeOutQuart\"\n    },\n    animations: {\n      numbers: {\n        type: \"number\",\n        properties: [\"x\", \"y\", \"width\", \"height\", \"caretX\", \"caretY\"]\n      },\n      opacity: {\n        easing: \"linear\",\n        duration: 200\n      }\n    },\n    callbacks: ro\n  },\n  defaultRoutes: {\n    bodyFont: \"font\",\n    footerFont: \"font\",\n    titleFont: \"font\"\n  },\n  descriptors: {\n    _scriptable: function _scriptable(i) {\n      return i !== \"filter\" && i !== \"itemSort\" && i !== \"external\";\n    },\n    _indexable: !1,\n    callbacks: {\n      _scriptable: !1,\n      _indexable: !1\n    },\n    animation: {\n      _fallback: !1\n    },\n    animations: {\n      _fallback: \"animation\"\n    }\n  },\n  additionalOptionScopes: [\"interaction\"]\n};\nvar Ic = function Ic(i, t, e, s) {\n  return typeof t == \"string\" ? (e = i.push(t) - 1, s.unshift({\n    index: e,\n    label: t\n  })) : isNaN(t) && (e = null), e;\n};\nfunction zc(i, t, e, s) {\n  var n = i.indexOf(t);\n  if (n === -1) return Ic(i, t, e, s);\n  var o = i.lastIndexOf(t);\n  return n !== o ? e : n;\n}\nvar Bc = function Bc(i, t) {\n  return i === null ? null : U(Math.round(i), 0, t);\n};\nfunction on(i) {\n  var t = this.getLabels();\n  return i >= 0 && i < t.length ? t[i] : i;\n}\nvar Ti = /*#__PURE__*/function (_Gt) {\n  function Ti(t) {\n    var _this33;\n    _classCallCheck(this, Ti);\n    _this33 = _callSuper(this, Ti, [t]), _this33._startValue = void 0, _this33._valueRange = 0, _this33._addedLabels = [];\n    return _this33;\n  }\n  _inherits(Ti, _Gt);\n  return _createClass(Ti, [{\n    key: \"init\",\n    value: function init(t) {\n      var e = this._addedLabels;\n      if (e.length) {\n        var s = this.getLabels();\n        var _iterator36 = _createForOfIteratorHelper(e),\n          _step36;\n        try {\n          for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n            var _step36$value = _step36.value,\n              n = _step36$value.index,\n              o = _step36$value.label;\n            s[n] === o && s.splice(n, 1);\n          }\n        } catch (err) {\n          _iterator36.e(err);\n        } finally {\n          _iterator36.f();\n        }\n        this._addedLabels = [];\n      }\n      _superPropGet(Ti, \"init\", this, 3)([t]);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(t, e) {\n      if (R(t)) return null;\n      var s = this.getLabels();\n      return e = isFinite(e) && s[e] === t ? e : zc(s, t, D(e, t), this._addedLabels), Bc(e, s.length - 1);\n    }\n  }, {\n    key: \"determineDataLimits\",\n    value: function determineDataLimits() {\n      var _this$getUserBounds2 = this.getUserBounds(),\n        t = _this$getUserBounds2.minDefined,\n        e = _this$getUserBounds2.maxDefined;\n      var _this$getMinMax = this.getMinMax(!0),\n        s = _this$getMinMax.min,\n        n = _this$getMinMax.max;\n      this.options.bounds === \"ticks\" && (t || (s = 0), e || (n = this.getLabels().length - 1)), this.min = s, this.max = n;\n    }\n  }, {\n    key: \"buildTicks\",\n    value: function buildTicks() {\n      var t = this.min,\n        e = this.max,\n        s = this.options.offset,\n        n = [];\n      var o = this.getLabels();\n      o = t === 0 && e === o.length - 1 ? o : o.slice(t, e + 1), this._valueRange = Math.max(o.length - (s ? 0 : 1), 1), this._startValue = this.min - (s ? 0.5 : 0);\n      for (var r = t; r <= e; r++) n.push({\n        value: r\n      });\n      return n;\n    }\n  }, {\n    key: \"getLabelForValue\",\n    value: function getLabelForValue(t) {\n      return on.call(this, t);\n    }\n  }, {\n    key: \"configure\",\n    value: function configure() {\n      _superPropGet(Ti, \"configure\", this, 3)([]), this.isHorizontal() || (this._reversePixels = !this._reversePixels);\n    }\n  }, {\n    key: \"getPixelForValue\",\n    value: function getPixelForValue(t) {\n      return typeof t != \"number\" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n    }\n  }, {\n    key: \"getPixelForTick\",\n    value: function getPixelForTick(t) {\n      var e = this.ticks;\n      return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n    }\n  }, {\n    key: \"getValueForPixel\",\n    value: function getValueForPixel(t) {\n      return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);\n    }\n  }, {\n    key: \"getBasePixel\",\n    value: function getBasePixel() {\n      return this.bottom;\n    }\n  }]);\n}(Gt);\nw(Ti, \"id\", \"category\"), w(Ti, \"defaults\", {\n  ticks: {\n    callback: on\n  }\n});\nfunction Hc(i, t) {\n  var e = [],\n    n = i.bounds,\n    o = i.step,\n    r = i.min,\n    a = i.max,\n    l = i.precision,\n    c = i.count,\n    h = i.maxTicks,\n    d = i.maxDigits,\n    u = i.includeBounds,\n    f = o || 1,\n    p = h - 1,\n    g = t.min,\n    m = t.max,\n    b = !R(r),\n    _ = !R(a),\n    v = !R(c),\n    y = (m - g) / (d + 1);\n  var x = es((m - g) / p / f) * f,\n    M,\n    S,\n    k,\n    P;\n  if (x < 1e-14 && !b && !_) return [{\n    value: g\n  }, {\n    value: m\n  }];\n  P = Math.ceil(m / x) - Math.floor(g / x), P > p && (x = es(P * x / p / f) * f), R(l) || (M = Math.pow(10, l), x = Math.ceil(x * M) / M), n === \"ticks\" ? (S = Math.floor(g / x) * x, k = Math.ceil(m / x) * x) : (S = g, k = m), b && _ && o && $o((a - r) / o, x / 1e3) ? (P = Math.round(Math.min((a - r) / x, h)), x = (a - r) / P, S = r, k = a) : v ? (S = b ? r : S, k = _ ? a : k, P = c - 1, x = (k - S) / P) : (P = (k - S) / x, ce(P, Math.round(P), x / 1e3) ? P = Math.round(P) : P = Math.ceil(P));\n  var C = Math.max(is(x), is(S));\n  M = Math.pow(10, R(l) ? C : l), S = Math.round(S * M) / M, k = Math.round(k * M) / M;\n  var O = 0;\n  for (b && (u && S !== r ? (e.push({\n    value: r\n  }), S < r && O++, ce(Math.round((S + O * x) * M) / M, r, rn(r, y, i)) && O++) : S < r && O++); O < P; ++O) {\n    var A = Math.round((S + O * x) * M) / M;\n    if (_ && A > a) break;\n    e.push({\n      value: A\n    });\n  }\n  return _ && u && k !== a ? e.length && ce(e[e.length - 1].value, a, rn(a, y, i)) ? e[e.length - 1].value = a : e.push({\n    value: a\n  }) : (!_ || k === a) && e.push({\n    value: k\n  }), e;\n}\nfunction rn(i, t, _ref11) {\n  var e = _ref11.horizontal,\n    s = _ref11.minRotation;\n  var n = bt(s),\n    o = (e ? Math.sin(n) : Math.cos(n)) || 1e-3,\n    r = 0.75 * t * (\"\" + i).length;\n  return Math.min(t / o, r);\n}\nvar Wc = /*#__PURE__*/function (_Gt2) {\n  function Wc(t) {\n    var _this34;\n    _classCallCheck(this, Wc);\n    _this34 = _callSuper(this, Wc, [t]), _this34.start = void 0, _this34.end = void 0, _this34._startValue = void 0, _this34._endValue = void 0, _this34._valueRange = 0;\n    return _this34;\n  }\n  _inherits(Wc, _Gt2);\n  return _createClass(Wc, [{\n    key: \"parse\",\n    value: function parse(t, e) {\n      return R(t) || (typeof t == \"number\" || t instanceof Number) && !isFinite(+t) ? null : +t;\n    }\n  }, {\n    key: \"handleTickRangeOptions\",\n    value: function handleTickRangeOptions() {\n      var t = this.options.beginAtZero,\n        _this$getUserBounds3 = this.getUserBounds(),\n        e = _this$getUserBounds3.minDefined,\n        s = _this$getUserBounds3.maxDefined;\n      var n = this.min,\n        o = this.max;\n      var r = function r(l) {\n          return n = e ? n : l;\n        },\n        a = function a(l) {\n          return o = s ? o : l;\n        };\n      if (t) {\n        var l = lt(n),\n          c = lt(o);\n        l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && r(0);\n      }\n      if (n === o) {\n        var _l5 = o === 0 ? 1 : Math.abs(o * 0.05);\n        a(o + _l5), t || r(n - _l5);\n      }\n      this.min = n, this.max = o;\n    }\n  }, {\n    key: \"getTickLimit\",\n    value: function getTickLimit() {\n      var t = this.options.ticks;\n      var e = t.maxTicksLimit,\n        s = t.stepSize,\n        n;\n      return s ? (n = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, n > 1e3 && (console.warn(\"scales.\".concat(this.id, \".ticks.stepSize: \").concat(s, \" would result generating up to \").concat(n, \" ticks. Limiting to 1000.\")), n = 1e3)) : (n = this.computeTickLimit(), e = e || 11), e && (n = Math.min(e, n)), n;\n    }\n  }, {\n    key: \"computeTickLimit\",\n    value: function computeTickLimit() {\n      return Number.POSITIVE_INFINITY;\n    }\n  }, {\n    key: \"buildTicks\",\n    value: function buildTicks() {\n      var t = this.options,\n        e = t.ticks;\n      var s = this.getTickLimit();\n      s = Math.max(2, s);\n      var n = {\n          maxTicks: s,\n          bounds: t.bounds,\n          min: t.min,\n          max: t.max,\n          precision: e.precision,\n          step: e.stepSize,\n          count: e.count,\n          maxDigits: this._maxDigits(),\n          horizontal: this.isHorizontal(),\n          minRotation: e.minRotation || 0,\n          includeBounds: e.includeBounds !== !1\n        },\n        o = this._range || this,\n        r = Hc(n, o);\n      return t.bounds === \"ticks\" && Yo(r, this, \"value\"), t.reverse ? (r.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), r;\n    }\n  }, {\n    key: \"configure\",\n    value: function configure() {\n      var t = this.ticks;\n      var e = this.min,\n        s = this.max;\n      if (_superPropGet(Wc, \"configure\", this, 3)([]), this.options.offset && t.length) {\n        var n = (s - e) / Math.max(t.length - 1, 1) / 2;\n        e -= n, s += n;\n      }\n      this._startValue = e, this._endValue = s, this._valueRange = s - e;\n    }\n  }, {\n    key: \"getLabelForValue\",\n    value: function getLabelForValue(t) {\n      return Hi(t, this.chart.options.locale, this.options.ticks.format);\n    }\n  }]);\n}(Gt);\nvar Ai = /*#__PURE__*/function (_Wc) {\n  function Ai() {\n    _classCallCheck(this, Ai);\n    return _callSuper(this, Ai, arguments);\n  }\n  _inherits(Ai, _Wc);\n  return _createClass(Ai, [{\n    key: \"determineDataLimits\",\n    value: function determineDataLimits() {\n      var _this$getMinMax2 = this.getMinMax(!0),\n        t = _this$getMinMax2.min,\n        e = _this$getMinMax2.max;\n      this.min = q(t) ? t : 0, this.max = q(e) ? e : 1, this.handleTickRangeOptions();\n    }\n  }, {\n    key: \"computeTickLimit\",\n    value: function computeTickLimit() {\n      var t = this.isHorizontal(),\n        e = t ? this.width : this.height,\n        s = bt(this.options.ticks.minRotation),\n        n = (t ? Math.sin(s) : Math.cos(s)) || 1e-3,\n        o = this._resolveTickFontOptions(0);\n      return Math.ceil(e / Math.min(40, o.lineHeight / n));\n    }\n  }, {\n    key: \"getPixelForValue\",\n    value: function getPixelForValue(t) {\n      return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n    }\n  }, {\n    key: \"getValueForPixel\",\n    value: function getValueForPixel(t) {\n      return this._startValue + this.getDecimalForPixel(t) * this._valueRange;\n    }\n  }]);\n}(Wc);\nw(Ai, \"id\", \"linear\"), w(Ai, \"defaults\", {\n  ticks: {\n    callback: Dn.formatters.numeric\n  }\n});\nvar ii = {\n    millisecond: {\n      common: !0,\n      size: 1,\n      steps: 1e3\n    },\n    second: {\n      common: !0,\n      size: 1e3,\n      steps: 60\n    },\n    minute: {\n      common: !0,\n      size: 6e4,\n      steps: 60\n    },\n    hour: {\n      common: !0,\n      size: 36e5,\n      steps: 24\n    },\n    day: {\n      common: !0,\n      size: 864e5,\n      steps: 30\n    },\n    week: {\n      common: !1,\n      size: 6048e5,\n      steps: 4\n    },\n    month: {\n      common: !0,\n      size: 2628e6,\n      steps: 12\n    },\n    quarter: {\n      common: !1,\n      size: 7884e6,\n      steps: 4\n    },\n    year: {\n      common: !0,\n      size: 3154e7\n    }\n  },\n  G = /* @__PURE__ */Object.keys(ii);\nfunction an(i, t) {\n  return i - t;\n}\nfunction ln(i, t) {\n  if (R(t)) return null;\n  var e = i._adapter,\n    _i$_parseOpts = i._parseOpts,\n    s = _i$_parseOpts.parser,\n    n = _i$_parseOpts.round,\n    o = _i$_parseOpts.isoWeekday;\n  var r = t;\n  return typeof s == \"function\" && (r = s(r)), q(r) || (r = typeof s == \"string\" ? e.parse(r, s) : e.parse(r)), r === null ? null : (n && (r = n === \"week\" && (Xt(o) || o === !0) ? e.startOf(r, \"isoWeek\", o) : e.startOf(r, n)), +r);\n}\nfunction cn(i, t, e, s) {\n  var n = G.length;\n  for (var o = G.indexOf(i); o < n - 1; ++o) {\n    var r = ii[G[o]],\n      a = r.steps ? r.steps : Number.MAX_SAFE_INTEGER;\n    if (r.common && Math.ceil((e - t) / (a * r.size)) <= s) return G[o];\n  }\n  return G[n - 1];\n}\nfunction Nc(i, t, e, s, n) {\n  for (var o = G.length - 1; o >= G.indexOf(e); o--) {\n    var r = G[o];\n    if (ii[r].common && i._adapter.diff(n, s, r) >= t - 1) return r;\n  }\n  return G[e ? G.indexOf(e) : 0];\n}\nfunction Vc(i) {\n  for (var t = G.indexOf(i) + 1, e = G.length; t < e; ++t) if (ii[G[t]].common) return G[t];\n}\nfunction hn(i, t, e) {\n  if (!e) i[t] = !0;else if (e.length) {\n    var _Ii = Ii(e, t),\n      s = _Ii.lo,\n      n = _Ii.hi,\n      o = e[s] >= t ? e[s] : e[n];\n    i[o] = !0;\n  }\n}\nfunction jc(i, t, e, s) {\n  var n = i._adapter,\n    o = +n.startOf(t[0].value, s),\n    r = t[t.length - 1].value;\n  var a, l;\n  for (a = o; a <= r; a = +n.add(a, 1, s)) l = e[a], l >= 0 && (t[l].major = !0);\n  return t;\n}\nfunction dn(i, t, e) {\n  var s = [],\n    n = {},\n    o = t.length;\n  var r, a;\n  for (r = 0; r < o; ++r) a = t[r], n[a] = r, s.push({\n    value: a,\n    major: !1\n  });\n  return o === 0 || !e ? s : jc(i, s, n, e);\n}\nvar Ge = /*#__PURE__*/function (_Gt3) {\n  function Ge(t) {\n    var _this35;\n    _classCallCheck(this, Ge);\n    _this35 = _callSuper(this, Ge, [t]), _this35._cache = {\n      data: [],\n      labels: [],\n      all: []\n    }, _this35._unit = \"day\", _this35._majorUnit = void 0, _this35._offsets = {}, _this35._normalized = !1, _this35._parseOpts = void 0;\n    return _this35;\n  }\n  _inherits(Ge, _Gt3);\n  return _createClass(Ge, [{\n    key: \"init\",\n    value: function init(t) {\n      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var s = t.time || (t.time = {}),\n        n = this._adapter = new wa._date(t.adapters.date);\n      n.init(e), le(s.displayFormats, n.formats()), this._parseOpts = {\n        parser: s.parser,\n        round: s.round,\n        isoWeekday: s.isoWeekday\n      }, _superPropGet(Ge, \"init\", this, 3)([t]), this._normalized = e.normalized;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(t, e) {\n      return t === void 0 ? null : ln(this, t);\n    }\n  }, {\n    key: \"beforeLayout\",\n    value: function beforeLayout() {\n      _superPropGet(Ge, \"beforeLayout\", this, 3)([]), this._cache = {\n        data: [],\n        labels: [],\n        all: []\n      };\n    }\n  }, {\n    key: \"determineDataLimits\",\n    value: function determineDataLimits() {\n      var t = this.options,\n        e = this._adapter,\n        s = t.time.unit || \"day\";\n      var _this$getUserBounds4 = this.getUserBounds(),\n        n = _this$getUserBounds4.min,\n        o = _this$getUserBounds4.max,\n        r = _this$getUserBounds4.minDefined,\n        a = _this$getUserBounds4.maxDefined;\n      function l(c) {\n        !r && !isNaN(c.min) && (n = Math.min(n, c.min)), !a && !isNaN(c.max) && (o = Math.max(o, c.max));\n      }\n      (!r || !a) && (l(this._getLabelBounds()), (t.bounds !== \"ticks\" || t.ticks.source !== \"labels\") && l(this.getMinMax(!1))), n = q(n) && !isNaN(n) ? n : +e.startOf(Date.now(), s), o = q(o) && !isNaN(o) ? o : +e.endOf(Date.now(), s) + 1, this.min = Math.min(n, o - 1), this.max = Math.max(n + 1, o);\n    }\n  }, {\n    key: \"_getLabelBounds\",\n    value: function _getLabelBounds() {\n      var t = this.getLabelTimestamps();\n      var e = Number.POSITIVE_INFINITY,\n        s = Number.NEGATIVE_INFINITY;\n      return t.length && (e = t[0], s = t[t.length - 1]), {\n        min: e,\n        max: s\n      };\n    }\n  }, {\n    key: \"buildTicks\",\n    value: function buildTicks() {\n      var t = this.options,\n        e = t.time,\n        s = t.ticks,\n        n = s.source === \"labels\" ? this.getLabelTimestamps() : this._generate();\n      t.bounds === \"ticks\" && n.length && (this.min = this._userMin || n[0], this.max = this._userMax || n[n.length - 1]);\n      var o = this.min,\n        r = this.max,\n        a = Go(n, o, r);\n      return this._unit = e.unit || (s.autoSkip ? cn(e.minUnit, this.min, this.max, this._getLabelCapacity(o)) : Nc(this, a.length, e.minUnit, this.min, this.max)), this._majorUnit = !s.major.enabled || this._unit === \"year\" ? void 0 : Vc(this._unit), this.initOffsets(n), t.reverse && a.reverse(), dn(this, a, this._majorUnit);\n    }\n  }, {\n    key: \"afterAutoSkip\",\n    value: function afterAutoSkip() {\n      this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(function (t) {\n        return +t.value;\n      }));\n    }\n  }, {\n    key: \"initOffsets\",\n    value: function initOffsets() {\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var e = 0,\n        s = 0,\n        n,\n        o;\n      this.options.offset && t.length && (n = this.getDecimalForValue(t[0]), t.length === 1 ? e = 1 - n : e = (this.getDecimalForValue(t[1]) - n) / 2, o = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? s = o : s = (o - this.getDecimalForValue(t[t.length - 2])) / 2);\n      var r = t.length < 3 ? 0.5 : 0.25;\n      e = U(e, 0, r), s = U(s, 0, r), this._offsets = {\n        start: e,\n        end: s,\n        factor: 1 / (e + 1 + s)\n      };\n    }\n  }, {\n    key: \"_generate\",\n    value: function _generate() {\n      var t = this._adapter,\n        e = this.min,\n        s = this.max,\n        n = this.options,\n        o = n.time,\n        r = o.unit || cn(o.minUnit, e, s, this._getLabelCapacity(e)),\n        a = D(n.ticks.stepSize, 1),\n        l = r === \"week\" ? o.isoWeekday : !1,\n        c = Xt(l) || l === !0,\n        h = {};\n      var d = e,\n        u,\n        f;\n      if (c && (d = +t.startOf(d, \"isoWeek\", l)), d = +t.startOf(d, c ? \"day\" : r), t.diff(s, e, r) > 1e5 * a) throw new Error(e + \" and \" + s + \" are too far apart with stepSize of \" + a + \" \" + r);\n      var p = n.ticks.source === \"data\" && this.getDataTimestamps();\n      for (u = d, f = 0; u < s; u = +t.add(u, a, r), f++) hn(h, u, p);\n      return (u === s || n.bounds === \"ticks\" || f === 1) && hn(h, u, p), Object.keys(h).sort(an).map(function (g) {\n        return +g;\n      });\n    }\n  }, {\n    key: \"getLabelForValue\",\n    value: function getLabelForValue(t) {\n      var e = this._adapter,\n        s = this.options.time;\n      return s.tooltipFormat ? e.format(t, s.tooltipFormat) : e.format(t, s.displayFormats.datetime);\n    }\n  }, {\n    key: \"format\",\n    value: function format(t, e) {\n      var n = this.options.time.displayFormats,\n        o = this._unit,\n        r = e || n[o];\n      return this._adapter.format(t, r);\n    }\n  }, {\n    key: \"_tickFormatFunction\",\n    value: function _tickFormatFunction(t, e, s, n) {\n      var o = this.options,\n        r = o.ticks.callback;\n      if (r) return I(r, [t, e, s], this);\n      var a = o.time.displayFormats,\n        l = this._unit,\n        c = this._majorUnit,\n        h = l && a[l],\n        d = c && a[c],\n        u = s[e],\n        f = c && d && u && u.major;\n      return this._adapter.format(t, n || (f ? d : h));\n    }\n  }, {\n    key: \"generateTickLabels\",\n    value: function generateTickLabels(t) {\n      var e, s, n;\n      for (e = 0, s = t.length; e < s; ++e) n = t[e], n.label = this._tickFormatFunction(n.value, e, t);\n    }\n  }, {\n    key: \"getDecimalForValue\",\n    value: function getDecimalForValue(t) {\n      return t === null ? NaN : (t - this.min) / (this.max - this.min);\n    }\n  }, {\n    key: \"getPixelForValue\",\n    value: function getPixelForValue(t) {\n      var e = this._offsets,\n        s = this.getDecimalForValue(t);\n      return this.getPixelForDecimal((e.start + s) * e.factor);\n    }\n  }, {\n    key: \"getValueForPixel\",\n    value: function getValueForPixel(t) {\n      var e = this._offsets,\n        s = this.getDecimalForPixel(t) / e.factor - e.end;\n      return this.min + s * (this.max - this.min);\n    }\n  }, {\n    key: \"_getLabelSize\",\n    value: function _getLabelSize(t) {\n      var e = this.options.ticks,\n        s = this.ctx.measureText(t).width,\n        n = bt(this.isHorizontal() ? e.maxRotation : e.minRotation),\n        o = Math.cos(n),\n        r = Math.sin(n),\n        a = this._resolveTickFontOptions(0).size;\n      return {\n        w: s * o + a * r,\n        h: s * r + a * o\n      };\n    }\n  }, {\n    key: \"_getLabelCapacity\",\n    value: function _getLabelCapacity(t) {\n      var e = this.options.time,\n        s = e.displayFormats,\n        n = s[e.unit] || s.millisecond,\n        o = this._tickFormatFunction(t, 0, dn(this, [t], this._majorUnit), n),\n        r = this._getLabelSize(o),\n        a = Math.floor(this.isHorizontal() ? this.width / r.w : this.height / r.h) - 1;\n      return a > 0 ? a : 1;\n    }\n  }, {\n    key: \"getDataTimestamps\",\n    value: function getDataTimestamps() {\n      var t = this._cache.data || [],\n        e,\n        s;\n      if (t.length) return t;\n      var n = this.getMatchingVisibleMetas();\n      if (this._normalized && n.length) return this._cache.data = n[0].controller.getAllParsedValues(this);\n      for (e = 0, s = n.length; e < s; ++e) t = t.concat(n[e].controller.getAllParsedValues(this));\n      return this._cache.data = this.normalize(t);\n    }\n  }, {\n    key: \"getLabelTimestamps\",\n    value: function getLabelTimestamps() {\n      var t = this._cache.labels || [];\n      var e, s;\n      if (t.length) return t;\n      var n = this.getLabels();\n      for (e = 0, s = n.length; e < s; ++e) t.push(ln(this, n[e]));\n      return this._cache.labels = this._normalized ? t : this.normalize(t);\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize(t) {\n      return Mn(t.sort(an));\n    }\n  }]);\n}(Gt);\nw(Ge, \"id\", \"time\"), w(Ge, \"defaults\", {\n  bounds: \"data\",\n  adapters: {},\n  time: {\n    parser: !1,\n    unit: !1,\n    round: !1,\n    isoWeekday: !1,\n    minUnit: \"millisecond\",\n    displayFormats: {}\n  },\n  ticks: {\n    source: \"auto\",\n    callback: !1,\n    major: {\n      enabled: !1\n    }\n  }\n});\nfunction Le(i, t, e) {\n  var _Et, _i$s, _i$n, _Et2, _i$s2, _i$n2;\n  var s = 0,\n    n = i.length - 1,\n    o,\n    r,\n    a,\n    l;\n  e ? (t >= i[s].pos && t <= i[n].pos && (_Et = Et(i, \"pos\", t), s = _Et.lo, n = _Et.hi, _Et), _i$s = i[s], o = _i$s.pos, a = _i$s.time, _i$n = i[n], r = _i$n.pos, l = _i$n.time) : (t >= i[s].time && t <= i[n].time && (_Et2 = Et(i, \"time\", t), s = _Et2.lo, n = _Et2.hi, _Et2), _i$s2 = i[s], o = _i$s2.time, a = _i$s2.pos, _i$n2 = i[n], r = _i$n2.time, l = _i$n2.pos);\n  var c = r - o;\n  return c ? a + (l - a) * (t - o) / c : a;\n}\nvar un = /*#__PURE__*/function (_Ge) {\n  function un(t) {\n    var _this36;\n    _classCallCheck(this, un);\n    _this36 = _callSuper(this, un, [t]), _this36._table = [], _this36._minPos = void 0, _this36._tableRange = void 0;\n    return _this36;\n  }\n  _inherits(un, _Ge);\n  return _createClass(un, [{\n    key: \"initOffsets\",\n    value: function initOffsets() {\n      var t = this._getTimestampsForTable(),\n        e = this._table = this.buildLookupTable(t);\n      this._minPos = Le(e, this.min), this._tableRange = Le(e, this.max) - this._minPos, _superPropGet(un, \"initOffsets\", this, 3)([t]);\n    }\n  }, {\n    key: \"buildLookupTable\",\n    value: function buildLookupTable(t) {\n      var e = this.min,\n        s = this.max,\n        n = [],\n        o = [];\n      var r, a, l, c, h;\n      for (r = 0, a = t.length; r < a; ++r) c = t[r], c >= e && c <= s && n.push(c);\n      if (n.length < 2) return [{\n        time: e,\n        pos: 0\n      }, {\n        time: s,\n        pos: 1\n      }];\n      for (r = 0, a = n.length; r < a; ++r) h = n[r + 1], l = n[r - 1], c = n[r], Math.round((h + l) / 2) !== c && o.push({\n        time: c,\n        pos: r / (a - 1)\n      });\n      return o;\n    }\n  }, {\n    key: \"_generate\",\n    value: function _generate() {\n      var t = this.min,\n        e = this.max;\n      var s = _superPropGet(un, \"getDataTimestamps\", this, 3)([]);\n      return (!s.includes(t) || !s.length) && s.splice(0, 0, t), (!s.includes(e) || s.length === 1) && s.push(e), s.sort(function (n, o) {\n        return n - o;\n      });\n    }\n  }, {\n    key: \"_getTimestampsForTable\",\n    value: function _getTimestampsForTable() {\n      var t = this._cache.all || [];\n      if (t.length) return t;\n      var e = this.getDataTimestamps(),\n        s = this.getLabelTimestamps();\n      return e.length && s.length ? t = this.normalize(e.concat(s)) : t = e.length ? e : s, t = this._cache.all = t, t;\n    }\n  }, {\n    key: \"getDecimalForValue\",\n    value: function getDecimalForValue(t) {\n      return (Le(this._table, t) - this._minPos) / this._tableRange;\n    }\n  }, {\n    key: \"getValueForPixel\",\n    value: function getValueForPixel(t) {\n      var e = this._offsets,\n        s = this.getDecimalForPixel(t) / e.factor - e.end;\n      return Le(this._table, s * this._tableRange + this._minPos, !0);\n    }\n  }]);\n}(Ge);\nw(un, \"id\", \"timeseries\"), w(un, \"defaults\", Ge.defaults);\nmt.register(Ti, Ai, Ee, We, Fe, vt, He, ki, jt, re, Ie, xc, wc, Dc, Fc);\nvar fn = /*#__PURE__*/function () {\n  function fn(t) {\n    _classCallCheck(this, fn);\n    this.chart = null, this.canvas = t;\n  }\n  return _createClass(fn, [{\n    key: \"render\",\n    value: function render(t) {\n      var _ref12, _ref13;\n      var r, a;\n      this.chart && (this.chart.destroy(), this.chart = null);\n      var e = t.chartSpec,\n        s = t.data,\n        n = this.mapChartType(e.type),\n        o = {\n          type: n,\n          data: {\n            labels: s.labels,\n            datasets: s.datasets.map(function (l) {\n              return _objectSpread(_objectSpread({}, l), {}, {\n                fill: e.type === \"area\",\n                tension: e.type === \"line\" || e.type === \"area\" ? 0.3 : 0\n              });\n            })\n          },\n          options: {\n            responsive: !0,\n            maintainAspectRatio: !1,\n            plugins: {\n              title: {\n                display: !!e.title,\n                text: e.title,\n                font: {\n                  size: 16,\n                  weight: \"bold\"\n                }\n              },\n              legend: {\n                display: (_ref12 = (r = e.legend) == null ? void 0 : r.display) !== null && _ref12 !== void 0 ? _ref12 : !0,\n                position: (_ref13 = (a = e.legend) == null ? void 0 : a.position) !== null && _ref13 !== void 0 ? _ref13 : \"top\"\n              },\n              tooltip: {\n                enabled: !0\n              }\n            },\n            scales: this.buildScales(e, n)\n          }\n        };\n      this.chart = new mt(this.canvas, o);\n    }\n  }, {\n    key: \"mapChartType\",\n    value: function mapChartType(t) {\n      switch (t) {\n        case \"area\":\n          return \"line\";\n        case \"bar\":\n        case \"line\":\n        case \"pie\":\n        case \"doughnut\":\n        case \"scatter\":\n          return t;\n        default:\n          return \"bar\";\n      }\n    }\n  }, {\n    key: \"buildScales\",\n    value: function buildScales(t, e) {\n      var s, n, o, r;\n      if (!(e === \"pie\" || e === \"doughnut\")) return {\n        x: {\n          display: !0,\n          title: {\n            display: !!((s = t.xAxis) != null && s.label),\n            text: (n = t.xAxis) == null ? void 0 : n.label\n          }\n        },\n        y: {\n          display: !0,\n          title: {\n            display: !!((o = t.yAxis) != null && o.label),\n            text: (r = t.yAxis) == null ? void 0 : r.label\n          },\n          beginAtZero: !0\n        }\n      };\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.chart && (this.chart.destroy(), this.chart = null);\n    }\n  }]);\n}();\nvar $c = /*#__PURE__*/function () {\n  function $c(t) {\n    _classCallCheck(this, $c);\n    this._chartRenderers = [], this._container = t;\n  }\n  return _createClass($c, [{\n    key: \"renderEmptyState\",\n    value: function renderEmptyState() {\n      this._container.innerHTML = \"\\n      <div class=\\\"empty-state\\\">\\n        <span>Set a prompt to generate a chart</span>\\n      </div>\\n    \";\n    }\n  }, {\n    key: \"showLoading\",\n    value: function showLoading() {\n      this._container.innerHTML = \"\\n      <div class=\\\"loading-overlay\\\">\\n        <div class=\\\"spinner\\\"></div>\\n        <div class=\\\"loading-text\\\">Generating chart...</div>\\n      </div>\\n      <div class=\\\"chart-wrapper\\\">\\n        <canvas></canvas>\\n      </div>\\n    \";\n    }\n  }, {\n    key: \"showError\",\n    value: function showError(t, e) {\n      this._container.innerHTML = \"\\n      <div class=\\\"error-container\\\">\\n        <div class=\\\"error-icon\\\">!</div>\\n        <div class=\\\"error-message\\\">\".concat(this._escapeHtml(t), \"</div>\\n        <button class=\\\"retry-button\\\">Retry</button>\\n      </div>\\n    \");\n      var s = this._container.querySelector(\".retry-button\");\n      s == null || s.addEventListener(\"click\", e);\n    }\n  }, {\n    key: \"renderChart\",\n    value: function renderChart(t) {\n      var _this37 = this;\n      this._destroyRenderers();\n      var e = Array.isArray(t) ? t : [t];\n      if (e.length > 1) {\n        this._container.innerHTML = '<div class=\"charts-grid\"></div>';\n        var n = this._container.querySelector(\".charts-grid\");\n        e.forEach(function (o) {\n          var r = document.createElement(\"div\");\n          r.className = \"chart-wrapper\", r.innerHTML = \"<canvas></canvas>\", n.appendChild(r);\n          var a = r.querySelector(\"canvas\"),\n            l = new fn(a);\n          l.render(o), _this37._chartRenderers.push(l);\n        });\n      } else {\n        this._container.innerHTML = \"\\n        <div class=\\\"chart-wrapper\\\">\\n          <canvas></canvas>\\n        </div>\\n      \";\n        var _n4 = this._container.querySelector(\"canvas\");\n        if (!_n4) return;\n        var o = new fn(_n4);\n        o.render(e[0]), this._chartRenderers.push(o);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._destroyRenderers();\n    }\n  }, {\n    key: \"_destroyRenderers\",\n    value: function _destroyRenderers() {\n      this._chartRenderers.forEach(function (t) {\n        return t.destroy();\n      }), this._chartRenderers = [];\n    }\n  }, {\n    key: \"_escapeHtml\",\n    value: function _escapeHtml(t) {\n      var e = document.createElement(\"div\");\n      return e.textContent = t, e.innerHTML;\n    }\n  }]);\n}();\nvar Yc = \"\\n  :host {\\n    display: block;\\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;\\n  }\\n\\n  .prompt-chart-container {\\n    position: relative;\\n    width: 100%;\\n    height: 100%;\\n    min-height: 300px;\\n  }\\n\\n  .chart-wrapper {\\n    width: 100%;\\n    height: 100%;\\n    min-height: 300px;\\n  }\\n\\n  .charts-grid {\\n    display: grid;\\n    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));\\n    gap: 20px;\\n    width: 100%;\\n    height: 100%;\\n  }\\n\\n  .charts-grid .chart-wrapper {\\n    border: 1px solid #e5e7eb;\\n    border-radius: 8px;\\n    padding: 16px;\\n    background: #fff;\\n  }\\n\\n  .loading-overlay {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    bottom: 0;\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    justify-content: center;\\n    background: rgba(255, 255, 255, 0.9);\\n    z-index: 10;\\n  }\\n\\n  .spinner {\\n    width: 40px;\\n    height: 40px;\\n    border: 3px solid #e5e7eb;\\n    border-top-color: #3b82f6;\\n    border-radius: 50%;\\n    animation: spin 1s linear infinite;\\n  }\\n\\n  @keyframes spin {\\n    to {\\n      transform: rotate(360deg);\\n    }\\n  }\\n\\n  .loading-text {\\n    margin-top: 12px;\\n    color: #6b7280;\\n    font-size: 14px;\\n  }\\n\\n  .error-container {\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    justify-content: center;\\n    height: 100%;\\n    min-height: 200px;\\n    padding: 20px;\\n    text-align: center;\\n    color: #dc2626;\\n  }\\n\\n  .error-icon {\\n    font-size: 48px;\\n    margin-bottom: 16px;\\n  }\\n\\n  .error-message {\\n    font-size: 14px;\\n    max-width: 400px;\\n  }\\n\\n  .retry-button {\\n    margin-top: 16px;\\n    padding: 8px 16px;\\n    background: #3b82f6;\\n    color: white;\\n    border: none;\\n    border-radius: 6px;\\n    cursor: pointer;\\n    font-size: 14px;\\n    transition: background 0.2s;\\n  }\\n\\n  .retry-button:hover {\\n    background: #2563eb;\\n  }\\n\\n  .empty-state {\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    justify-content: center;\\n    height: 100%;\\n    min-height: 200px;\\n    color: #9ca3af;\\n    font-size: 14px;\\n  }\\n\";\nvar Uc = Object.defineProperty,\n  ht = function ht(i, t, e, s) {\n    for (var n = void 0, o = i.length - 1, r; o >= 0; o--) (r = i[o]) && (n = r(t, e, n) || n);\n    return n && Uc(t, e, n), n;\n  };\nvar nt = /*#__PURE__*/function (_i5) {\n  function nt() {\n    var _this38;\n    _classCallCheck(this, nt);\n    _this38 = _callSuper(this, nt), _this38._hasBeenRendered = !1, _this38._abortController = null, _this38._shadow = _this38.attachShadow({\n      mode: \"open\"\n    });\n    var t = document.createElement(\"div\");\n    t.className = \"prompt-chart-container\", _this38._shadow.innerHTML = \"<style>\".concat(Yc, \"</style>\"), _this38._shadow.appendChild(t), _this38._stateRenderer = new $c(t), _this38._demoDataGenerator = new co(), _this38._stateRenderer.renderEmptyState(), setTimeout(function () {\n      _this38._hasBeenRendered || _this38.onRender();\n    }, 20);\n    return _this38;\n  }\n  // prettier-ignore\n  _inherits(nt, _i5);\n  return _createClass(nt, [{\n    key: \"onRender\",\n    value: function onRender() {\n      Ne.attemptAppendStyleSheetToHead(this.style), bi.applyDefaultStyleToComponent(this.style, this.containerStyle), this._hasBeenRendered = !0;\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      var t;\n      this.data ? this._renderData() : this.autoFetch && this.prompt && ((t = this.connect) != null && t.url || this.demo) && this.fetchChart();\n    }\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      this._cleanup();\n    }\n    // override onPropertyChange(property: string, _value: unknown): void {\n    //   if (property === 'data' && this.data) {\n    //     this._renderData();\n    //   } else if (property === 'prompt' && this.autoFetch && this.prompt && (this.connect?.url || this.demo)) {\n    //     this.fetchChart();\n    //   }\n    // }\n  }, {\n    key: \"_renderData\",\n    value: function _renderData() {\n      var t;\n      this.data && (this._stateRenderer.renderChart(this.data), this.dispatchEvent(new CustomEvent(\"chart-loaded\", {\n        detail: this.data,\n        bubbles: !0,\n        composed: !0\n      })), (t = this.onChartLoaded) == null || t.call(this, this.data));\n    }\n    /**\n     * Fetch and render a chart based on the current prompt\n     */\n  }, {\n    key: \"fetchChart\",\n    value: (function () {\n      var _fetchChart = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {\n        var _this39 = this;\n        var t;\n        return _regenerator().w(function (_context) {\n          while (1) switch (_context.n) {\n            case 0:\n              if (this.prompt) {\n                _context.n = 1;\n                break;\n              }\n              this._stateRenderer.showError(\"Missing prompt\", function () {\n                return _this39.fetchChart();\n              });\n              return _context.a(2);\n            case 1:\n              if (!(!this.demo && !((t = this.connect) != null && t.url))) {\n                _context.n = 2;\n                break;\n              }\n              this._stateRenderer.showError(\"Missing connect.url\", function () {\n                return _this39.fetchChart();\n              });\n              return _context.a(2);\n            case 2:\n              if (!this.demo) {\n                _context.n = 4;\n                break;\n              }\n              _context.n = 3;\n              return this._fetchDemoChart();\n            case 3:\n              return _context.a(2);\n            case 4:\n              _context.n = 5;\n              return this._fetchRemoteChart();\n            case 5:\n              return _context.a(2);\n          }\n        }, _callee, this);\n      }));\n      function fetchChart() {\n        return _fetchChart.apply(this, arguments);\n      }\n      return fetchChart;\n    }())\n  }, {\n    key: \"_fetchDemoChart\",\n    value: function () {\n      var _fetchDemoChart2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {\n        var e, t;\n        return _regenerator().w(function (_context2) {\n          while (1) switch (_context2.n) {\n            case 0:\n              this._stateRenderer.showLoading();\n              _context2.n = 1;\n              return new Promise(function (s) {\n                return setTimeout(s, 500);\n              });\n            case 1:\n              t = this._demoDataGenerator.generate(this.prompt);\n              this._stateRenderer.renderChart(t), this.dispatchEvent(new CustomEvent(\"chart-loaded\", {\n                detail: t,\n                bubbles: !0,\n                composed: !0\n              })), (e = this.onChartLoaded) == null || e.call(this, t);\n            case 2:\n              return _context2.a(2);\n          }\n        }, _callee2, this);\n      }));\n      function _fetchDemoChart() {\n        return _fetchDemoChart2.apply(this, arguments);\n      }\n      return _fetchDemoChart;\n    }()\n  }, {\n    key: \"_fetchRemoteChart\",\n    value: function () {\n      var _fetchRemoteChart2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {\n        var _this40 = this;\n        var t, e, s, _this$connect$method, n, o, l, r, a, _o4, _t4, _t5, _t6;\n        return _regenerator().w(function (_context3) {\n          while (1) switch (_context3.p = _context3.n) {\n            case 0:\n              (t = this._abortController) == null || t.abort(), this._abortController = new AbortController(), this._stateRenderer.showLoading();\n              _context3.p = 1;\n              n = {\n                endpoint: this.connect.url,\n                method: (_this$connect$method = this.connect.method) !== null && _this$connect$method !== void 0 ? _this$connect$method : \"POST\",\n                headers: _objectSpread({\n                  \"Content-Type\": \"application/json\"\n                }, this.connect.headers),\n                body: {\n                  prompt: this.prompt\n                }\n              };\n              _t4 = this.requestInterceptor;\n              if (!_t4) {\n                _context3.n = 3;\n                break;\n              }\n              _context3.n = 2;\n              return this.requestInterceptor(n);\n            case 2:\n              n = _context3.v;\n            case 3:\n              _context3.n = 4;\n              return fetch(n.endpoint, {\n                method: n.method,\n                headers: n.headers,\n                body: JSON.stringify(n.body),\n                signal: this._abortController.signal\n              });\n            case 4:\n              o = _context3.v;\n              if (o.ok) {\n                _context3.n = 6;\n                break;\n              }\n              _context3.n = 5;\n              return o.json()[\"catch\"](function () {\n                return {\n                  error: \"Request failed\"\n                };\n              });\n            case 5:\n              l = _context3.v;\n              throw new Error(l.error || \"HTTP \".concat(o.status));\n            case 6:\n              _context3.n = 7;\n              return o.json();\n            case 7:\n              r = _context3.v;\n              if (!this.responseInterceptor) {\n                _context3.n = 9;\n                break;\n              }\n              _context3.n = 8;\n              return this.responseInterceptor(r);\n            case 8:\n              _t5 = _context3.v;\n              _context3.n = 10;\n              break;\n            case 9:\n              _t5 = r;\n            case 10:\n              a = _t5;\n              this._stateRenderer.renderChart(a), this.dispatchEvent(new CustomEvent(\"chart-loaded\", {\n                detail: a,\n                bubbles: !0,\n                composed: !0\n              })), (e = this.onChartLoaded) == null || e.call(this, a);\n              _context3.n = 13;\n              break;\n            case 11:\n              _context3.p = 11;\n              _t6 = _context3.v;\n              if (!(_t6 instanceof Error && _t6.name === \"AbortError\")) {\n                _context3.n = 12;\n                break;\n              }\n              return _context3.a(2);\n            case 12:\n              _o4 = _t6 instanceof Error ? _t6.message : \"Unknown error\";\n              this._stateRenderer.showError(_o4, function () {\n                return _this40.fetchChart();\n              }), this.dispatchEvent(new CustomEvent(\"chart-error\", {\n                detail: {\n                  error: _o4\n                },\n                bubbles: !0,\n                composed: !0\n              })), (s = this.onChartError) == null || s.call(this);\n            case 13:\n              return _context3.a(2);\n          }\n        }, _callee3, this, [[1, 11]]);\n      }));\n      function _fetchRemoteChart() {\n        return _fetchRemoteChart2.apply(this, arguments);\n      }\n      return _fetchRemoteChart;\n    }()\n  }, {\n    key: \"_cleanup\",\n    value: function _cleanup() {\n      var t;\n      (t = this._abortController) == null || t.abort(), this._stateRenderer.destroy();\n    }\n  }]);\n}(_i);\nht([ct(\"object\")], nt.prototype, \"connect\");\nht([ct(\"string\")], nt.prototype, \"prompt\");\nht([ct(\"boolean\")], nt.prototype, \"autoFetch\");\nht([ct(\"object\")], nt.prototype, \"containerStyle\");\nht([ct(\"function\")], nt.prototype, \"onChartLoaded\");\nht([ct(\"function\")], nt.prototype, \"onChartError\");\nht([ct(\"function\")], nt.prototype, \"requestInterceptor\");\nht([ct(\"function\")], nt.prototype, \"responseInterceptor\");\nht([ct(\"boolean\")], nt.prototype, \"demo\");\nht([ct(\"object\")], nt.prototype, \"data\");\ncustomElements.get(\"prompt-chart\") || customElements.define(\"prompt-chart\", nt);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9tcHQtY2hhcnQvZGlzdC9wcm9tcHRDaGFydC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDBCQUEwQiwwTkFBME4sd0VBQXdFLHlCQUF5QiwrRkFBK0YsOERBQThELCtDQUErQywrREFBK0QsNkNBQTZDLG1CQUFtQiwwQkFBMEIsK0JBQStCLE9BQU8sb0NBQW9DLDhPQUE4TywwQkFBMEIsbUJBQW1CLDRCQUE0Qiw0REFBNEQsNENBQTRDLDBCQUEwQixJQUFJLHVFQUF1RSxNQUFNLGdCQUFnQixtQ0FBbUMsOEVBQThFLHVCQUF1QixpQ0FBaUMsdUlBQXVJLFNBQVMsZ0VBQWdFLFlBQVksdUJBQXVCLFVBQVUsV0FBVyxTQUFTLHlCQUF5QixxQkFBcUIsWUFBWSx3QkFBd0IsZ0NBQWdDLHlDQUF5QywyQkFBMkIsMkRBQTJELG1CQUFtQixjQUFjLDBGQUEwRixnQkFBZ0IsdU5BQXVOLDZiQUE2YixjQUFjLG9EQUFvRCw4QkFBOEIsNkNBQTZDLFNBQVMsZUFBZTtBQUM3NEYsMkNBQTJDLCtCQUErQixNQUFNLElBQUksUUFBUSxLQUFLLFlBQVksU0FBUyxnRUFBZ0UsbUJBQW1CLHlDQUF5QywrQkFBK0IsS0FBSyxrQkFBa0IsMERBQTBELCtEQUErRDtBQUNqYSxtREFBbUQsTUFBTSxnQ0FBZ0MsWUFBWSxvQkFBb0I7QUFDekgsZ0NBQWdDLHFCQUFxQiw2QkFBNkIscUNBQXFDLHVCQUF1QixvQkFBb0IseURBQXlELHFCQUFxQiwwREFBMEQsZ0JBQWdCO0FBQzFULHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxxQ0FBcUMsOERBQThELHdEQUF3RCx3QkFBd0I7QUFDbkwsa0JBQWtCLHVHQUF1Ryw4QkFBOEIsU0FBUywrQ0FBK0Msc0VBQXNFO0FBQ3JSLGdDQUFnQyxPQUFPLEdBQUcsZ0VBQWdFLEdBQUc7QUFDN0csZ0NBQWdDO0FBQ2hDLDhCQUE4QjtBQUM5Qix1Q0FBdUMsa0dBQWtHLGlCQUFpQix3Q0FBd0MsTUFBTSx5Q0FBeUMsNkJBQTZCLFVBQVUsWUFBWSxrRUFBa0UsV0FBVyxZQUFZLGlCQUFpQixVQUFVLE1BQU0saUZBQWlGLFVBQVUsb0JBQW9CO0FBQzdnQiw4QkFBOEI7QUFDOUIsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNENBQTRDLCtFQUErRSxVQUFVLHlHQUF5RyxjQUFjLGtDQUFrQyxTQUFTLHdCQUF3QiwyQkFBMkIsV0FBVyxJQUFJLDhCQUE4QixxQkFBcUIsVUFBVSxZQUFZLGdLQUFnSyx1QkFBdUIsU0FBUyxrQkFBa0IsZ0JBQWdCLG9CQUFvQixrQkFBa0IsdUJBQXVCLHFCQUFxQixnQkFBZ0Isb0JBQW9CLE1BQU0sNkNBQTZDLFVBQVU7QUFDdjBCLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsNkNBQTZDLFNBQVMsMERBQTBELFVBQVUsZ0NBQWdDO0FBQzFKLCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakMsbUNBQW1DLCtDQUErQyw4QkFBOEIsT0FBTyxrQkFBa0I7QUFDekksK0JBQStCO0FBQy9CLDRDQUE0Qyx1RUFBdUUsbUdBQW1HO0FBQ3ROLHFDQUFxQyx5R0FBeUc7QUFDOUksMkJBQTJCLHFIQUFxSCxnREFBZ0QsZUFBZSw0Q0FBNEMsMkNBQTJDLGNBQWM7QUFDcFQsK0JBQStCLHVEQUF1RCx5REFBeUQsbURBQW1ELHVHQUF1RyxvQkFBb0IsK0JBQStCLHFCQUFxQixxQkFBcUIsc0VBQXNFLHdEQUF3RCxlQUFlLGtFQUFrRSxpQ0FBaUM7QUFDdG5CLCtCQUErQixrRkFBa0YsZ0JBQWdCLG9CQUFvQixvQ0FBb0M7QUFDekwsdUNBQXVDLE1BQU0scUZBQXFGLE1BQU0sYUFBYSwyRUFBMkUsYUFBYTtBQUM3TyxnQ0FBZ0MsTUFBTSxvRUFBb0UsWUFBWTtBQUN0SCxpQ0FBaUMsa0dBQWtHLDRCQUE0QjtBQUMvSiw4QkFBOEIsK0ZBQStGLGlEQUFpRDtBQUM5SyxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1Esc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELE9BQU87QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUIsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPLHdCQUF3Qiw2REFBNkQsT0FBTztBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0NBQWdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0QkFBNEI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrQkFBa0I7QUFDM0IsU0FBUyxzQkFBc0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsYUFBYTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGVBQWU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxlQUFlO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9KQUFvSjtBQUNwSjtBQUNBLEtBQUssb0JBQW9CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGlCQUFpQjtBQUN0QjtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLLCtHQUErRyw2REFBNkQ7QUFDakw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRIO0FBQzVIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0NBQWdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxTQUFTLEVBQUU7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHNEQUFzRDtBQUN6RDtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0NBQWtDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUMsU0FBUyxtQkFBbUI7QUFDNUIsOEJBQThCLHVCQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGdCQUFnQjtBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyx3REFBd0Q7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxtQ0FBbUM7QUFDbkMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTyx5REFBeUQ7QUFDekY7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUVBQWlFO0FBQ25GO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxXQUFXO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQyw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU8scUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFDQUFxQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msd0JBQXdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQ0FBa0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxPQUFPO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsTUFBTTtBQUNuRiwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssbWRBQW1kLDRRQUE0UTtBQUNwdUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsU0FBUyxvRkFBb0YseUNBQXlDLE9BQU87QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLHNHQUFzRyx3R0FBd0csdUdBQXVHO0FBQy9aLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSw4RUFBOEU7QUFDN0o7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsZUFBZTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMEVBQTBFLGVBQWU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwRUFBMEUsZUFBZTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMEVBQTBFLGVBQWU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwRUFBMEUsZUFBZTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMEVBQTBFLGVBQWU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZFQUE2RSxpQkFBaUI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZFQUE2RSxpQkFBaUI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0JBQXNCLGtDQUFrQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQ0FBa0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixpQkFBaUI7QUFDL0c7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Qsa0NBQWtDO0FBQ2xDLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQ0FBa0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa1dBQWtXLGlGQUFpRiw4Q0FBOEMsMEJBQTBCO0FBQzNmO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsT0FBTztBQUMzRTtBQUNBO0FBQ0E7QUFDQSx1VUFBdVU7QUFDdlU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx1REFBdUQsT0FBTztBQUM5RCwyREFBMkQsV0FBVztBQUN0RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esa0JBQWtCLDZCQUE2QjtBQUMvQyxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLE9BQU87QUFDdEY7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx1QkFBdUI7QUFDOUI7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSkFBZ0osT0FBTztBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtDQUFrQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx1Q0FBdUM7QUFDdkMsZUFBZTtBQUNmO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdDQUFnQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQ0FBa0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQ0FBa0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQkFBZ0IsT0FBTztBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQ0FBa0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQ0FBa0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlIQUFpSDtBQUNqSDtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0o7QUFDbEo7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEVBQUU7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdOQUFnTixPQUFPO0FBQ3ZOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0T0FBNE8sT0FBTztBQUNuUCw0TUFBNE0sT0FBTztBQUNuTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBOQUEwTixPQUFPO0FBQ2pPO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsUUFBUTtBQUNyRjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQ0FBa0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw4RkFBOEYsT0FBTztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDJFQUEyRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QscUJBQXFCLHFCQUFxQixxR0FBcUcsS0FBSywrQkFBK0IseUJBQXlCLGtCQUFrQixtQkFBbUIsd0JBQXdCLEtBQUssc0JBQXNCLGtCQUFrQixtQkFBbUIsd0JBQXdCLEtBQUssb0JBQW9CLG9CQUFvQixrRUFBa0UsZ0JBQWdCLGtCQUFrQixtQkFBbUIsS0FBSyxtQ0FBbUMsZ0NBQWdDLHlCQUF5QixvQkFBb0IsdUJBQXVCLEtBQUssd0JBQXdCLHlCQUF5QixhQUFhLGNBQWMsZUFBZSxnQkFBZ0Isb0JBQW9CLDZCQUE2QiwwQkFBMEIsOEJBQThCLDJDQUEyQyxrQkFBa0IsS0FBSyxnQkFBZ0Isa0JBQWtCLG1CQUFtQixnQ0FBZ0MsZ0NBQWdDLHlCQUF5Qix5Q0FBeUMsS0FBSyx1QkFBdUIsVUFBVSxrQ0FBa0MsT0FBTyxLQUFLLHFCQUFxQix1QkFBdUIscUJBQXFCLHNCQUFzQixLQUFLLHdCQUF3QixvQkFBb0IsNkJBQTZCLDBCQUEwQiw4QkFBOEIsbUJBQW1CLHdCQUF3QixvQkFBb0IseUJBQXlCLHFCQUFxQixLQUFLLG1CQUFtQixzQkFBc0IsMEJBQTBCLEtBQUssc0JBQXNCLHNCQUFzQix1QkFBdUIsS0FBSyxxQkFBcUIsdUJBQXVCLHdCQUF3QiwwQkFBMEIsbUJBQW1CLG1CQUFtQix5QkFBeUIsc0JBQXNCLHNCQUFzQixrQ0FBa0MsS0FBSywyQkFBMkIsMEJBQTBCLEtBQUssb0JBQW9CLG9CQUFvQiw2QkFBNkIsMEJBQTBCLDhCQUE4QixtQkFBbUIsd0JBQXdCLHFCQUFxQixzQkFBc0IsS0FBSztBQUN4cEU7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvbXB0LWNoYXJ0L2Rpc3QvcHJvbXB0Q2hhcnQuanM/ZTZiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfcmVnZW5lcmF0b3IoKSB7IC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvYmxvYi9tYWluL3BhY2thZ2VzL2JhYmVsLWhlbHBlcnMvTElDRU5TRSAqLyB2YXIgZSwgdCwgciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sIG4gPSByLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiLCBvID0gci50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjsgZnVuY3Rpb24gaShyLCBuLCBvLCBpKSB7IHZhciBjID0gbiAmJiBuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG4gOiBHZW5lcmF0b3IsIHUgPSBPYmplY3QuY3JlYXRlKGMucHJvdG90eXBlKTsgcmV0dXJuIF9yZWdlbmVyYXRvckRlZmluZTIodSwgXCJfaW52b2tlXCIsIGZ1bmN0aW9uIChyLCBuLCBvKSB7IHZhciBpLCBjLCB1LCBmID0gMCwgcCA9IG8gfHwgW10sIHkgPSAhMSwgRyA9IHsgcDogMCwgbjogMCwgdjogZSwgYTogZCwgZjogZC5iaW5kKGUsIDQpLCBkOiBmdW5jdGlvbiBkKHQsIHIpIHsgcmV0dXJuIGkgPSB0LCBjID0gMCwgdSA9IGUsIEcubiA9IHIsIGE7IH0gfTsgZnVuY3Rpb24gZChyLCBuKSB7IGZvciAoYyA9IHIsIHUgPSBuLCB0ID0gMDsgIXkgJiYgZiAmJiAhbyAmJiB0IDwgcC5sZW5ndGg7IHQrKykgeyB2YXIgbywgaSA9IHBbdF0sIGQgPSBHLnAsIGwgPSBpWzJdOyByID4gMyA/IChvID0gbCA9PT0gbikgJiYgKHUgPSBpWyhjID0gaVs0XSkgPyA1IDogKGMgPSAzLCAzKV0sIGlbNF0gPSBpWzVdID0gZSkgOiBpWzBdIDw9IGQgJiYgKChvID0gciA8IDIgJiYgZCA8IGlbMV0pID8gKGMgPSAwLCBHLnYgPSBuLCBHLm4gPSBpWzFdKSA6IGQgPCBsICYmIChvID0gciA8IDMgfHwgaVswXSA+IG4gfHwgbiA+IGwpICYmIChpWzRdID0gciwgaVs1XSA9IG4sIEcubiA9IGwsIGMgPSAwKSk7IH0gaWYgKG8gfHwgciA+IDEpIHJldHVybiBhOyB0aHJvdyB5ID0gITAsIG47IH0gcmV0dXJuIGZ1bmN0aW9uIChvLCBwLCBsKSB7IGlmIChmID4gMSkgdGhyb3cgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTsgZm9yICh5ICYmIDEgPT09IHAgJiYgZChwLCBsKSwgYyA9IHAsIHUgPSBsOyAodCA9IGMgPCAyID8gZSA6IHUpIHx8ICF5OykgeyBpIHx8IChjID8gYyA8IDMgPyAoYyA+IDEgJiYgKEcubiA9IC0xKSwgZChjLCB1KSkgOiBHLm4gPSB1IDogRy52ID0gdSk7IHRyeSB7IGlmIChmID0gMiwgaSkgeyBpZiAoYyB8fCAobyA9IFwibmV4dFwiKSwgdCA9IGlbb10pIHsgaWYgKCEodCA9IHQuY2FsbChpLCB1KSkpIHRocm93IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpOyBpZiAoIXQuZG9uZSkgcmV0dXJuIHQ7IHUgPSB0LnZhbHVlLCBjIDwgMiAmJiAoYyA9IDApOyB9IGVsc2UgMSA9PT0gYyAmJiAodCA9IGlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbChpKSwgYyA8IDIgJiYgKHUgPSBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICdcIiArIG8gKyBcIicgbWV0aG9kXCIpLCBjID0gMSk7IGkgPSBlOyB9IGVsc2UgaWYgKCh0ID0gKHkgPSBHLm4gPCAwKSA/IHUgOiByLmNhbGwobiwgRykpICE9PSBhKSBicmVhazsgfSBjYXRjaCAodCkgeyBpID0gZSwgYyA9IDEsIHUgPSB0OyB9IGZpbmFsbHkgeyBmID0gMTsgfSB9IHJldHVybiB7IHZhbHVlOiB0LCBkb25lOiB5IH07IH07IH0ociwgbywgaSksICEwKSwgdTsgfSB2YXIgYSA9IHt9OyBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge30gdCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgdmFyIGMgPSBbXVtuXSA/IHQodChbXVtuXSgpKSkgOiAoX3JlZ2VuZXJhdG9yRGVmaW5lMih0ID0ge30sIG4sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCB0KSwgdSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGMpOyBmdW5jdGlvbiBmKGUpIHsgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihlLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAoZS5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgX3JlZ2VuZXJhdG9yRGVmaW5lMihlLCBvLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHUpLCBlOyB9IHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgX3JlZ2VuZXJhdG9yRGVmaW5lMih1LCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSwgX3JlZ2VuZXJhdG9yRGVmaW5lMihHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvbiksIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiLCBfcmVnZW5lcmF0b3JEZWZpbmUyKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBvLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBfcmVnZW5lcmF0b3JEZWZpbmUyKHUpLCBfcmVnZW5lcmF0b3JEZWZpbmUyKHUsIG8sIFwiR2VuZXJhdG9yXCIpLCBfcmVnZW5lcmF0b3JEZWZpbmUyKHUsIG4sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBfcmVnZW5lcmF0b3JEZWZpbmUyKHUsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjsgfSksIChfcmVnZW5lcmF0b3IgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3IoKSB7IHJldHVybiB7IHc6IGksIG06IGYgfTsgfSkoKTsgfVxuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yRGVmaW5lMihlLCByLCBuLCB0KSB7IHZhciBpID0gT2JqZWN0LmRlZmluZVByb3BlcnR5OyB0cnkgeyBpKHt9LCBcIlwiLCB7fSk7IH0gY2F0Y2ggKGUpIHsgaSA9IDA7IH0gX3JlZ2VuZXJhdG9yRGVmaW5lMiA9IGZ1bmN0aW9uIF9yZWdlbmVyYXRvckRlZmluZShlLCByLCBuLCB0KSB7IGZ1bmN0aW9uIG8ociwgbikgeyBfcmVnZW5lcmF0b3JEZWZpbmUyKGUsIHIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aGlzLl9pbnZva2UociwgbiwgZSk7IH0pOyB9IHIgPyBpID8gaShlLCByLCB7IHZhbHVlOiBuLCBlbnVtZXJhYmxlOiAhdCwgY29uZmlndXJhYmxlOiAhdCwgd3JpdGFibGU6ICF0IH0pIDogZVtyXSA9IG4gOiAobyhcIm5leHRcIiwgMCksIG8oXCJ0aHJvd1wiLCAxKSwgbyhcInJldHVyblwiLCAyKSk7IH0sIF9yZWdlbmVyYXRvckRlZmluZTIoZSwgciwgbiwgdCk7IH1cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChuLCB0LCBlLCByLCBvLCBhLCBjKSB7IHRyeSB7IHZhciBpID0gblthXShjKSwgdSA9IGkudmFsdWU7IH0gY2F0Y2ggKG4pIHsgcmV0dXJuIHZvaWQgZShuKTsgfSBpLmRvbmUgPyB0KHUpIDogUHJvbWlzZS5yZXNvbHZlKHUpLnRoZW4ociwgbyk7IH1cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHQgPSB0aGlzLCBlID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHIsIG8pIHsgdmFyIGEgPSBuLmFwcGx5KHQsIGUpOyBmdW5jdGlvbiBfbmV4dChuKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChhLCByLCBvLCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgbik7IH0gZnVuY3Rpb24gX3Rocm93KG4pIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGEsIHIsIG8sIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgbik7IH0gX25leHQodm9pZCAwKTsgfSk7IH07IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX3N1cGVyUHJvcEdldCh0LCBvLCBlLCByKSB7IHZhciBwID0gX2dldChfZ2V0UHJvdG90eXBlT2YoMSAmIHIgPyB0LnByb3RvdHlwZSA6IHQpLCBvLCBlKTsgcmV0dXJuIDIgJiByICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcCA/IGZ1bmN0aW9uICh0KSB7IHJldHVybiBwLmFwcGx5KGUsIHQpOyB9IDogcDsgfVxuZnVuY3Rpb24gX2dldCgpIHsgcmV0dXJuIF9nZXQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuZ2V0ID8gUmVmbGVjdC5nZXQuYmluZCgpIDogZnVuY3Rpb24gKGUsIHQsIHIpIHsgdmFyIHAgPSBfc3VwZXJQcm9wQmFzZShlLCB0KTsgaWYgKHApIHsgdmFyIG4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHAsIHQpOyByZXR1cm4gbi5nZXQgPyBuLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gZSA6IHIpIDogbi52YWx1ZTsgfSB9LCBfZ2V0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKHQsIG8pIHsgZm9yICg7ICF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIG8pICYmIG51bGwgIT09ICh0ID0gX2dldFByb3RvdHlwZU9mKHQpKTspOyByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7IGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihyLCBlKSB7IHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKCF0KSB7IGlmIChBcnJheS5pc0FycmF5KHIpIHx8ICh0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpKSB8fCBlICYmIHIgJiYgXCJudW1iZXJcIiA9PSB0eXBlb2Ygci5sZW5ndGgpIHsgdCAmJiAociA9IHQpOyB2YXIgX241ID0gMCwgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgcmV0dXJuIF9uNSA+PSByLmxlbmd0aCA/IHsgZG9uZTogITAgfSA6IHsgZG9uZTogITEsIHZhbHVlOiByW19uNSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdGhyb3cgcjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbywgYSA9ICEwLCB1ID0gITE7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IHQgPSB0LmNhbGwocik7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciByID0gdC5uZXh0KCk7IHJldHVybiBhID0gci5kb25lLCByOyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdSA9ICEwLCBvID0gcjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgYSB8fCBudWxsID09IHRbXCJyZXR1cm5cIl0gfHwgdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAodSkgdGhyb3cgbzsgfSB9IH07IH1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheShyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwOyB9IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkocikgeyBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gcltTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gcltcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKHIpOyB9XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIpOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgZSkgeyBpZiAoZSAmJiAoXCJvYmplY3RcIiA9PSBfdHlwZW9mKGUpIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSkpIHJldHVybiBlOyBpZiAodm9pZCAwICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHQpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGUpIHsgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2luaGVyaXRzKHQsIGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiB0LCB3cml0YWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAgfSB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlICYmIF9zZXRQcm90b3R5cGVPZih0LCBlKTsgfVxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcih0KSB7IHZhciByID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBNYXAgPyBuZXcgTWFwKCkgOiB2b2lkIDA7IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcih0KSB7IGlmIChudWxsID09PSB0IHx8ICFfaXNOYXRpdmVGdW5jdGlvbih0KSkgcmV0dXJuIHQ7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgaWYgKHZvaWQgMCAhPT0gcikgeyBpZiAoci5oYXModCkpIHJldHVybiByLmdldCh0KTsgci5zZXQodCwgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QodCwgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IHJldHVybiBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6ICExLCB3cml0YWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAgfSB9KSwgX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIHQpOyB9LCBfd3JhcE5hdGl2ZVN1cGVyKHQpOyB9XG5mdW5jdGlvbiBfY29uc3RydWN0KHQsIGUsIHIpIHsgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgcmV0dXJuIFJlZmxlY3QuY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IHZhciBvID0gW251bGxdOyBvLnB1c2guYXBwbHkobywgZSk7IHZhciBwID0gbmV3ICh0LmJpbmQuYXBwbHkodCwgbykpKCk7IHJldHVybiByICYmIF9zZXRQcm90b3R5cGVPZihwLCByLnByb3RvdHlwZSksIHA7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24odCkgeyB0cnkgeyByZXR1cm4gLTEgIT09IEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwodCkuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIik7IH0gY2F0Y2ggKG4pIHsgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdDsgfSB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YodCwgZSkgeyByZXR1cm4gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7IH0sIF9zZXRQcm90b3R5cGVPZih0LCBlKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKHQpIHsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpOyB9LCBfZ2V0UHJvdG90eXBlT2YodCk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbnZhciBhbyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBsbyA9IGZ1bmN0aW9uIGxvKGksIHQsIGUpIHtcbiAgcmV0dXJuIHQgaW4gaSA/IGFvKGksIHQsIHtcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIHdyaXRhYmxlOiAhMCxcbiAgICB2YWx1ZTogZVxuICB9KSA6IGlbdF0gPSBlO1xufTtcbnZhciB3ID0gZnVuY3Rpb24gdyhpLCB0LCBlKSB7XG4gIHJldHVybiBsbyhpLCBfdHlwZW9mKHQpICE9IFwic3ltYm9sXCIgPyB0ICsgXCJcIiA6IHQsIGUpO1xufTtcbnZhciBMdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEx0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMdCk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhMdCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiYXR0ZW1wdEFwcGVuZFN0eWxlU2hlZXRUb0hlYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0ZW1wdEFwcGVuZFN0eWxlU2hlZXRUb0hlYWQodCkge1xuICAgICAgaWYgKHQuZm9udEZhbWlseSAmJiB0LmZvbnRGYW1pbHkgIT09IEx0LkRFRkFVTFRfRk9OVF9GQU1JTFkpIHJldHVybjtcbiAgICAgIHZhciBlID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuICAgICAgaWYgKCFBcnJheS5mcm9tKGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsaW5rXCIpKS5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBuLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IEx0LkZPTlRfVVJMO1xuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICAgICAgbi5yZWwgPSBcInN0eWxlc2hlZXRcIiwgbi5ocmVmID0gTHQuRk9OVF9VUkwsIGUuYXBwZW5kQ2hpbGQobik7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG59KCk7XG5MdC5GT05UX1VSTCA9IFwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1JbnRlcjp3Z2h0QDQwMDs2MDAmZGlzcGxheT1zd2FwXCIsIEx0LkRFRkFVTFRfRk9OVF9GQU1JTFkgPSBcIidJbnRlcicsIHNhbnMtc2VyaWYsIEF2ZW5pciwgSGVsdmV0aWNhLCBBcmlhbFwiO1xudmFyIE5lID0gTHQ7XG52YXIgJHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiAkdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgJHQpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoJHQsIG51bGwsIFt7XG4gICAga2V5OiBcImFwcGx5VG9TdHlsZUlmTm90RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseVRvU3R5bGVJZk5vdERlZmluZWQodCwgZSkge1xuICAgICAgZm9yICh2YXIgcyBpbiBlKSB7XG4gICAgICAgIHZhciBuID0gcyxcbiAgICAgICAgICBvID0gZVtuXTtcbiAgICAgICAgdFtuXSA9PT0gXCJcIiAmJiBvICYmICh0W25dID0gbyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5RGVmYXVsdFN0eWxlVG9Db21wb25lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlEZWZhdWx0U3R5bGVUb0NvbXBvbmVudCh0LCBlKSB7XG4gICAgICBlICYmICR0LmFwcGx5VG9TdHlsZUlmTm90RGVmaW5lZCh0LCBlKSwgJHQuYXBwbHlUb1N0eWxlSWZOb3REZWZpbmVkKHQsICR0LkRFRkFVTFRfQ09NUE9ORU5UX1NUWUxFKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbiR0LkRFRkFVTFRfQ09NUE9ORU5UX1NUWUxFID0ge1xuICBoZWlnaHQ6IFwiMzUwcHhcIixcbiAgd2lkdGg6IFwiMTAwJVwiLFxuICBmb250RmFtaWx5OiBOZS5ERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICBmb250U2l6ZTogXCIwLjlyZW1cIixcbiAgYmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCIsXG4gIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gIG92ZXJmbG93OiBcImhpZGRlblwiXG59O1xudmFyIGJpID0gJHQ7XG52YXIgVmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmUpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVmUsIG51bGwsIFt7XG4gICAga2V5OiBcIndhaXRGb3JQcm9wZXJ0aWVzVG9CZVVwZGF0ZWRCZWZvcmVSZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2FpdEZvclByb3BlcnRpZXNUb0JlVXBkYXRlZEJlZm9yZVJlbmRlcih0KSB7XG4gICAgICB0Ll9wcm9wVXBkYXRlZF8gPSAhMSwgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHQuX3Byb3BVcGRhdGVkXyA/IFZlLndhaXRGb3JQcm9wZXJ0aWVzVG9CZVVwZGF0ZWRCZWZvcmVSZW5kZXIodCkgOiAodC5fd2FpdGluZ1RvUmVuZGVyXyA9ICExLCB0Lm9uUmVuZGVyKCkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF0dGVtcHRSZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0ZW1wdFJlbmRlcih0KSB7XG4gICAgICB0Ll9wcm9wVXBkYXRlZF8gPSAhMCwgdC5fd2FpdGluZ1RvUmVuZGVyXyB8fCAodC5fd2FpdGluZ1RvUmVuZGVyXyA9ICEwLCBWZS53YWl0Rm9yUHJvcGVydGllc1RvQmVVcGRhdGVkQmVmb3JlUmVuZGVyKHQpKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbnZhciBndCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0hUTUxFbGVtZW50KSB7XG4gIC8vIElmIHRoaXMgaXMgbm90IHdvcmtpbmcsIHRyeSB1c2luZyBwcm9wZXJ0eU5hbWUgZGlyZWN0bHlcbiAgZnVuY3Rpb24gZ3QoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBndCk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIGd0KSwgX3RoaXMuX3dhaXRpbmdUb1JlbmRlcl8gPSAhMSwgX3RoaXMuX3Byb3BVcGRhdGVkXyA9ICExLCBPYmplY3Qua2V5cyhndC5fYXR0cmlidXRlVG9Qcm9wZXJ0eV8pLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gZ3QuX2F0dHJpYnV0ZVRvUHJvcGVydHlfW3RdO1xuICAgICAgX3RoaXMuY29uc3RydWN0UHJvcGVydHlBY2Nlc3NvcnMoZSksIF90aGlzLmhhc093blByb3BlcnR5KHQpIHx8IF90aGlzLmNvbnN0cnVjdFByb3BlcnR5QWNjZXNzb3JzKGUsIHQpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoZ3QsIF9IVE1MRWxlbWVudCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoZ3QsIFt7XG4gICAga2V5OiBcImNvbnN0cnVjdFByb3BlcnR5QWNjZXNzb3JzXCIsXG4gICAgdmFsdWU6XG4gICAgLy8gbmVlZCB0byBiZSBjYWxsZWQgaGVyZSBhcyBhY2Nlc3NvcnMgbmVlZCB0byBiZSBzZXQgZm9yIHRoZSBjbGFzcyBpbnN0YW5jZVxuICAgIGZ1bmN0aW9uIGNvbnN0cnVjdFByb3BlcnR5QWNjZXNzb3JzKHQsIGUpIHtcbiAgICAgIHZhciBzO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGUgfHwgdCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQocikge1xuICAgICAgICAgIHMgPSByLCBlID8gdGhpc1t0XSA9IHIgOiBWZS5hdHRlbXB0UmVuZGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0LCBlLCBzKSB7XG4gICAgICBpZiAoZSA9PT0gcykgcmV0dXJuO1xuICAgICAgdmFyIG4gPSBndC5fYXR0cmlidXRlc19bdF0ocyksXG4gICAgICAgIG8gPSBndC5fYXR0cmlidXRlVG9Qcm9wZXJ0eV9bdF07XG4gICAgICB0aGlzW29dID0gbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25SZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25SZW5kZXIoKSB7fVxuICB9XSwgW3tcbiAgICBrZXk6IFwib2JzZXJ2ZWRBdHRyaWJ1dGVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoZ3QuX2F0dHJpYnV0ZXNfKSB8fCBbXTtcbiAgICB9XG4gIH1dKTtcbn0oLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoSFRNTEVsZW1lbnQpKTtcbmd0Ll9hdHRyaWJ1dGVzXyA9IHt9LCBndC5fYXR0cmlidXRlVG9Qcm9wZXJ0eV8gPSB7fTtcbnZhciBfaSA9IGd0O1xudmFyIGNvID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gY28oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIGNvKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKGNvLCBbe1xuICAgIGtleTogXCJnZW5lcmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZSh0KSB7XG4gICAgICB2YXIgZSA9IHQudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgcyA9IHRoaXMuZGV0ZWN0Q2hhcnRUeXBlKGUpLFxuICAgICAgICBuID0gdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHQuc2xpY2UoMSksXG4gICAgICAgIF90aGlzJGdlbmVyYXRlRGF0YXNldCA9IHRoaXMuZ2VuZXJhdGVEYXRhc2V0KGUpLFxuICAgICAgICBvID0gX3RoaXMkZ2VuZXJhdGVEYXRhc2V0LmxhYmVscyxcbiAgICAgICAgciA9IF90aGlzJGdlbmVyYXRlRGF0YXNldC5kYXRhc2V0cyxcbiAgICAgICAgYSA9IF90aGlzJGdlbmVyYXRlRGF0YXNldC5kYXRhc2V0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2hhcnRTcGVjOiB7XG4gICAgICAgICAgdHlwZTogcyxcbiAgICAgICAgICB0aXRsZTogbixcbiAgICAgICAgICB4QXhpczoge1xuICAgICAgICAgICAgbGFiZWw6IFwiQ2F0ZWdvcnlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgeUF4aXM6IHtcbiAgICAgICAgICAgIGxhYmVsOiBcIlZhbHVlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgZGlzcGxheTogci5sZW5ndGggPiAxIHx8IHMgPT09IFwicGllXCIgfHwgcyA9PT0gXCJkb3VnaG51dFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IFwidG9wXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBsYWJlbHM6IG8sXG4gICAgICAgICAgZGF0YXNldHM6IHJcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBnZW5lcmF0ZWRBdDogKC8qIEBfX1BVUkVfXyAqL25ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgZGF0YXNldDogYSxcbiAgICAgICAgICByZWNvcmRDb3VudDogby5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGV0ZWN0Q2hhcnRUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVjdENoYXJ0VHlwZSh0KSB7XG4gICAgICByZXR1cm4gdC5pbmNsdWRlcyhcInBpZVwiKSA/IFwicGllXCIgOiB0LmluY2x1ZGVzKFwiZG91Z2hudXRcIikgfHwgdC5pbmNsdWRlcyhcImRvbnV0XCIpID8gXCJkb3VnaG51dFwiIDogdC5pbmNsdWRlcyhcImxpbmVcIikgfHwgdC5pbmNsdWRlcyhcInRyZW5kXCIpID8gXCJsaW5lXCIgOiB0LmluY2x1ZGVzKFwiYXJlYVwiKSA/IFwiYXJlYVwiIDogdC5pbmNsdWRlcyhcInNjYXR0ZXJcIikgPyBcInNjYXR0ZXJcIiA6IFwiYmFyXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlRGF0YXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZURhdGFzZXQodCkge1xuICAgICAgcmV0dXJuIHQuaW5jbHVkZXMoXCJtb250aFwiKSB8fCB0LmluY2x1ZGVzKFwieWVhclwiKSA/IHRoaXMuZ2VuZXJhdGVNb250aGx5RGF0YSh0KSA6IHQuaW5jbHVkZXMoXCJwcm9kdWN0XCIpIHx8IHQuaW5jbHVkZXMoXCJyZXZlbnVlXCIpID8gdGhpcy5nZW5lcmF0ZVByb2R1Y3RSZXZlbnVlRGF0YSgpIDogdC5pbmNsdWRlcyhcInN0YXR1c1wiKSB8fCB0LmluY2x1ZGVzKFwib3JkZXJcIikgPyB0aGlzLmdlbmVyYXRlT3JkZXJTdGF0dXNEYXRhKCkgOiB0LmluY2x1ZGVzKFwic2lnbnVwXCIpIHx8IHQuaW5jbHVkZXMoXCJ1c2VyXCIpID8gdGhpcy5nZW5lcmF0ZVVzZXJTaWdudXBEYXRhKCkgOiB0LmluY2x1ZGVzKFwicHJvZml0XCIpIHx8IHQuaW5jbHVkZXMoXCJ0b3BcIikgPyB0aGlzLmdlbmVyYXRlUHJvZml0RGF0YSgpIDogdGhpcy5nZW5lcmF0ZURlZmF1bHREYXRhKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlTW9udGhseURhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVNb250aGx5RGF0YSh0KSB7XG4gICAgICB2YXIgZSA9IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXTtcbiAgICAgIHJldHVybiB0LmluY2x1ZGVzKFwicmVnaW9uXCIpID8ge1xuICAgICAgICBsYWJlbHM6IGUsXG4gICAgICAgIGRhdGFzZXRzOiBbe1xuICAgICAgICAgIGxhYmVsOiBcIk5vcnRoXCIsXG4gICAgICAgICAgZGF0YTogWzY1LCA3OCwgOTAsIDgxLCA5NiwgMTA1LCAxMTAsIDEwMiwgOTUsIDg4LCA5MiwgMTA4XSxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzNiODJmNlwiLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiMzYjgyZjZcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgbGFiZWw6IFwiU291dGhcIixcbiAgICAgICAgICBkYXRhOiBbNDUsIDUyLCA2MCwgNTUsIDcwLCA4MiwgODgsIDgwLCA3MiwgNjUsIDcwLCA4NV0sXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMxMGI5ODFcIixcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCIjMTBiOTgxXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGxhYmVsOiBcIkVhc3RcIixcbiAgICAgICAgICBkYXRhOiBbMzUsIDQwLCA0OCwgNDUsIDU1LCA2MiwgNjgsIDYwLCA1NSwgNTAsIDUyLCA2NV0sXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNTllMGJcIixcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCIjZjU5ZTBiXCJcbiAgICAgICAgfV0sXG4gICAgICAgIGRhdGFzZXQ6IFwic2FsZXNfYnlfcmVnaW9uXCJcbiAgICAgIH0gOiB7XG4gICAgICAgIGxhYmVsczogZSxcbiAgICAgICAgZGF0YXNldHM6IFt7XG4gICAgICAgICAgbGFiZWw6IFwiVmFsdWVcIixcbiAgICAgICAgICBkYXRhOiBbNjUsIDc4LCA5MCwgODEsIDk2LCAxMDUsIDExMCwgMTAyLCA5NSwgODgsIDkyLCAxMDhdLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjM2I4MmY2XCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzNiODJmNlwiXG4gICAgICAgIH1dLFxuICAgICAgICBkYXRhc2V0OiBcIm1vbnRobHlfZGF0YVwiXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZVByb2R1Y3RSZXZlbnVlRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZVByb2R1Y3RSZXZlbnVlRGF0YSgpIHtcbiAgICAgIHZhciB0ID0gW1wiUHJvZHVjdCBBXCIsIFwiUHJvZHVjdCBCXCIsIFwiUHJvZHVjdCBDXCIsIFwiUHJvZHVjdCBEXCIsIFwiUHJvZHVjdCBFXCJdLFxuICAgICAgICBlID0gW1wiIzNiODJmNlwiLCBcIiMxMGI5ODFcIiwgXCIjZjU5ZTBiXCIsIFwiI2VmNDQ0NFwiLCBcIiM4YjVjZjZcIl07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYWJlbHM6IHQsXG4gICAgICAgIGRhdGFzZXRzOiBbe1xuICAgICAgICAgIGxhYmVsOiBcIlJldmVudWVcIixcbiAgICAgICAgICBkYXRhOiBbNDJlMywgMzVlMywgMjhlMywgMjFlMywgMTVlM10sXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiBlXG4gICAgICAgIH1dLFxuICAgICAgICBkYXRhc2V0OiBcInByb2R1Y3RfcmV2ZW51ZVwiXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZU9yZGVyU3RhdHVzRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZU9yZGVyU3RhdHVzRGF0YSgpIHtcbiAgICAgIHZhciB0ID0gW1wiQ29tcGxldGVkXCIsIFwiUGVuZGluZ1wiLCBcIlByb2Nlc3NpbmdcIiwgXCJDYW5jZWxsZWRcIl0sXG4gICAgICAgIGUgPSBbXCIjMTBiOTgxXCIsIFwiI2Y1OWUwYlwiLCBcIiMzYjgyZjZcIiwgXCIjZWY0NDQ0XCJdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFiZWxzOiB0LFxuICAgICAgICBkYXRhc2V0czogW3tcbiAgICAgICAgICBsYWJlbDogXCJPcmRlcnNcIixcbiAgICAgICAgICBkYXRhOiBbMjQ1LCA4OSwgNTYsIDIzXSxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGUsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IGVcbiAgICAgICAgfV0sXG4gICAgICAgIGRhdGFzZXQ6IFwib3JkZXJfc3RhdHVzXCJcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlVXNlclNpZ251cERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVVc2VyU2lnbnVwRGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhYmVsczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdLFxuICAgICAgICBkYXRhc2V0czogW3tcbiAgICAgICAgICBsYWJlbDogXCJTaWdudXBzXCIsXG4gICAgICAgICAgZGF0YTogWzEyMCwgMTQ1LCAxODAsIDIyMCwgMjkwLCAzNTAsIDQyMCwgNDgwLCA1MjAsIDU4MCwgNjUwLCA3MjBdLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjOGI1Y2Y2XCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzhiNWNmNlwiXG4gICAgICAgIH1dLFxuICAgICAgICBkYXRhc2V0OiBcInVzZXJfc2lnbnVwc1wiXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZVByb2ZpdERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVQcm9maXREYXRhKCkge1xuICAgICAgdmFyIHQgPSBbXCJXaWRnZXQgUHJvXCIsIFwiR2FkZ2V0IFhcIiwgXCJUb29sIE1hc3RlclwiLCBcIkRldmljZSBQbHVzXCIsIFwiU21hcnQgS2l0XCJdLFxuICAgICAgICBlID0gW1wiIzNiODJmNlwiLCBcIiMxMGI5ODFcIiwgXCIjZjU5ZTBiXCIsIFwiI2VmNDQ0NFwiLCBcIiM4YjVjZjZcIl07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYWJlbHM6IHQsXG4gICAgICAgIGRhdGFzZXRzOiBbe1xuICAgICAgICAgIGxhYmVsOiBcIlByb2ZpdFwiLFxuICAgICAgICAgIGRhdGE6IFsxODUwMCwgMTUyMDAsIDEyODAwLCA5NTAwLCA3MjAwXSxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGUsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IGVcbiAgICAgICAgfV0sXG4gICAgICAgIGRhdGFzZXQ6IFwicHJvZHVjdF9wcm9maXRcIlxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VuZXJhdGVEZWZhdWx0RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZURlZmF1bHREYXRhKCkge1xuICAgICAgdmFyIHQgPSBbXCJDYXRlZ29yeSBBXCIsIFwiQ2F0ZWdvcnkgQlwiLCBcIkNhdGVnb3J5IENcIiwgXCJDYXRlZ29yeSBEXCIsIFwiQ2F0ZWdvcnkgRVwiXSxcbiAgICAgICAgZSA9IFtcIiMzYjgyZjZcIiwgXCIjMTBiOTgxXCIsIFwiI2Y1OWUwYlwiLCBcIiNlZjQ0NDRcIiwgXCIjOGI1Y2Y2XCJdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFiZWxzOiB0LFxuICAgICAgICBkYXRhc2V0czogW3tcbiAgICAgICAgICBsYWJlbDogXCJWYWx1ZVwiLFxuICAgICAgICAgIGRhdGE6IFs0MiwgMzUsIDI4LCAyMSwgMTVdLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZSxcbiAgICAgICAgICBib3JkZXJDb2xvcjogZVxuICAgICAgICB9XSxcbiAgICAgICAgZGF0YXNldDogXCJkZW1vX2RhdGFcIlxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbnZhciBYaSA9IC8qI19fUFVSRV9fKi9fY3JlYXRlQ2xhc3MoZnVuY3Rpb24gWGkoKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBYaSk7XG59KTtcblhpLmF0dGlidXRlcyA9IHtcbiAgc3RyaW5nOiBmdW5jdGlvbiBzdHJpbmcodCkge1xuICAgIHJldHVybiB0O1xuICB9LFxuICBudW1iZXI6IGZ1bmN0aW9uIG51bWJlcih0KSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodCk7XG4gIH0sXG4gIFwiYm9vbGVhblwiOiBmdW5jdGlvbiBib29sZWFuKHQpIHtcbiAgICByZXR1cm4gdCA9PT0gXCJ0cnVlXCI7XG4gIH0sXG4gIG9iamVjdDogZnVuY3Rpb24gb2JqZWN0KHQpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh0KTtcbiAgfSxcbiAgYXJyYXk6IGZ1bmN0aW9uIGFycmF5KHQpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh0KTtcbiAgfSxcbiAgXCJmdW5jdGlvblwiOiBmdW5jdGlvbiBfZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gXCIuY29uY2F0KHQpKSgpO1xuICB9XG59O1xudmFyIHhpID0gWGk7XG5mdW5jdGlvbiBjdChpKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodCwgZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBlLCB7fSk7XG4gICAgdmFyIHMgPSB0LmNvbnN0cnVjdG9yLFxuICAgICAgbiA9IGUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICBzLl9hdHRyaWJ1dGVzX1tuXSA9IHhpLmF0dGlidXRlc1tpXSwgcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eV9bbl0gPSBlO1xuICB9O1xufVxuLyohXG4gKiBAa3Vya2xlL2NvbG9yIHYwLjMuNFxuICogaHR0cHM6Ly9naXRodWIuY29tL2t1cmtsZS9jb2xvciNyZWFkbWVcbiAqIChjKSAyMDI0IEp1a2thIEt1cmtlbGFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5mdW5jdGlvbiB4ZShpKSB7XG4gIHJldHVybiBpICsgMC41IHwgMDtcbn1cbnZhciB4dCA9IGZ1bmN0aW9uIHh0KGksIHQsIGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGksIGUpLCB0KTtcbn07XG5mdW5jdGlvbiBuZShpKSB7XG4gIHJldHVybiB4dCh4ZShpICogMi41NSksIDAsIDI1NSk7XG59XG5mdW5jdGlvbiBTdChpKSB7XG4gIHJldHVybiB4dCh4ZShpICogMjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIHB0KGkpIHtcbiAgcmV0dXJuIHh0KHhlKGkgLyAyLjU1KSAvIDEwMCwgMCwgMSk7XG59XG5mdW5jdGlvbiBxaShpKSB7XG4gIHJldHVybiB4dCh4ZShpICogMTAwKSwgMCwgMTAwKTtcbn1cbnZhciBRID0ge1xuICAgIDA6IDAsXG4gICAgMTogMSxcbiAgICAyOiAyLFxuICAgIDM6IDMsXG4gICAgNDogNCxcbiAgICA1OiA1LFxuICAgIDY6IDYsXG4gICAgNzogNyxcbiAgICA4OiA4LFxuICAgIDk6IDksXG4gICAgQTogMTAsXG4gICAgQjogMTEsXG4gICAgQzogMTIsXG4gICAgRDogMTMsXG4gICAgRTogMTQsXG4gICAgRjogMTUsXG4gICAgYTogMTAsXG4gICAgYjogMTEsXG4gICAgYzogMTIsXG4gICAgZDogMTMsXG4gICAgZTogMTQsXG4gICAgZjogMTVcbiAgfSxcbiAgeWkgPSBfdG9Db25zdW1hYmxlQXJyYXkoXCIwMTIzNDU2Nzg5QUJDREVGXCIpLFxuICBobyA9IGZ1bmN0aW9uIGhvKGkpIHtcbiAgICByZXR1cm4geWlbaSAmIDE1XTtcbiAgfSxcbiAgdW8gPSBmdW5jdGlvbiB1byhpKSB7XG4gICAgcmV0dXJuIHlpWyhpICYgMjQwKSA+PiA0XSArIHlpW2kgJiAxNV07XG4gIH0sXG4gIHZlID0gZnVuY3Rpb24gdmUoaSkge1xuICAgIHJldHVybiAoaSAmIDI0MCkgPj4gNCA9PT0gKGkgJiAxNSk7XG4gIH0sXG4gIGZvID0gZnVuY3Rpb24gZm8oaSkge1xuICAgIHJldHVybiB2ZShpLnIpICYmIHZlKGkuZykgJiYgdmUoaS5iKSAmJiB2ZShpLmEpO1xuICB9O1xuZnVuY3Rpb24gZ28oaSkge1xuICB2YXIgdCA9IGkubGVuZ3RoLFxuICAgIGU7XG4gIHJldHVybiBpWzBdID09PSBcIiNcIiAmJiAodCA9PT0gNCB8fCB0ID09PSA1ID8gZSA9IHtcbiAgICByOiAyNTUgJiBRW2lbMV1dICogMTcsXG4gICAgZzogMjU1ICYgUVtpWzJdXSAqIDE3LFxuICAgIGI6IDI1NSAmIFFbaVszXV0gKiAxNyxcbiAgICBhOiB0ID09PSA1ID8gUVtpWzRdXSAqIDE3IDogMjU1XG4gIH0gOiAodCA9PT0gNyB8fCB0ID09PSA5KSAmJiAoZSA9IHtcbiAgICByOiBRW2lbMV1dIDw8IDQgfCBRW2lbMl1dLFxuICAgIGc6IFFbaVszXV0gPDwgNCB8IFFbaVs0XV0sXG4gICAgYjogUVtpWzVdXSA8PCA0IHwgUVtpWzZdXSxcbiAgICBhOiB0ID09PSA5ID8gUVtpWzddXSA8PCA0IHwgUVtpWzhdXSA6IDI1NVxuICB9KSksIGU7XG59XG52YXIgcG8gPSBmdW5jdGlvbiBwbyhpLCB0KSB7XG4gIHJldHVybiBpIDwgMjU1ID8gdChpKSA6IFwiXCI7XG59O1xuZnVuY3Rpb24gbW8oaSkge1xuICB2YXIgdCA9IGZvKGkpID8gaG8gOiB1bztcbiAgcmV0dXJuIGkgPyBcIiNcIiArIHQoaS5yKSArIHQoaS5nKSArIHQoaS5iKSArIHBvKGkuYSwgdCkgOiB2b2lkIDA7XG59XG52YXIgYm8gPSAvXihoc2xhP3xod2J8aHN2KVxcKFxccyooWy0rLmVcXGRdKykoPzpkZWcpP1tcXHMsXSsoWy0rLmVcXGRdKyklW1xccyxdKyhbLSsuZVxcZF0rKSUoPzpbXFxzLF0rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gZ24oaSwgdCwgZSkge1xuICB2YXIgcyA9IHQgKiBNYXRoLm1pbihlLCAxIC0gZSksXG4gICAgbiA9IGZ1bmN0aW9uIG4obykge1xuICAgICAgdmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IChvICsgaSAvIDMwKSAlIDEyO1xuICAgICAgcmV0dXJuIGUgLSBzICogTWF0aC5tYXgoTWF0aC5taW4ociAtIDMsIDkgLSByLCAxKSwgLTEpO1xuICAgIH07XG4gIHJldHVybiBbbigwKSwgbig4KSwgbig0KV07XG59XG5mdW5jdGlvbiBfbyhpLCB0LCBlKSB7XG4gIHZhciBzID0gZnVuY3Rpb24gcyhuKSB7XG4gICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IChuICsgaSAvIDYwKSAlIDY7XG4gICAgcmV0dXJuIGUgLSBlICogdCAqIE1hdGgubWF4KE1hdGgubWluKG8sIDQgLSBvLCAxKSwgMCk7XG4gIH07XG4gIHJldHVybiBbcyg1KSwgcygzKSwgcygxKV07XG59XG5mdW5jdGlvbiB4byhpLCB0LCBlKSB7XG4gIHZhciBzID0gZ24oaSwgMSwgMC41KTtcbiAgdmFyIG47XG4gIGZvciAodCArIGUgPiAxICYmIChuID0gMSAvICh0ICsgZSksIHQgKj0gbiwgZSAqPSBuKSwgbiA9IDA7IG4gPCAzOyBuKyspIHNbbl0gKj0gMSAtIHQgLSBlLCBzW25dICs9IHQ7XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24geW8oaSwgdCwgZSwgcywgbikge1xuICByZXR1cm4gaSA9PT0gbiA/ICh0IC0gZSkgLyBzICsgKHQgPCBlID8gNiA6IDApIDogdCA9PT0gbiA/IChlIC0gaSkgLyBzICsgMiA6IChpIC0gdCkgLyBzICsgNDtcbn1cbmZ1bmN0aW9uIFJpKGkpIHtcbiAgdmFyIGUgPSBpLnIgLyAyNTUsXG4gICAgcyA9IGkuZyAvIDI1NSxcbiAgICBuID0gaS5iIC8gMjU1LFxuICAgIG8gPSBNYXRoLm1heChlLCBzLCBuKSxcbiAgICByID0gTWF0aC5taW4oZSwgcywgbiksXG4gICAgYSA9IChvICsgcikgLyAyO1xuICB2YXIgbCwgYywgaDtcbiAgcmV0dXJuIG8gIT09IHIgJiYgKGggPSBvIC0gciwgYyA9IGEgPiAwLjUgPyBoIC8gKDIgLSBvIC0gcikgOiBoIC8gKG8gKyByKSwgbCA9IHlvKGUsIHMsIG4sIGgsIG8pLCBsID0gbCAqIDYwICsgMC41KSwgW2wgfCAwLCBjIHx8IDAsIGFdO1xufVxuZnVuY3Rpb24gTGkoaSwgdCwgZSwgcykge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkodCkgPyBpKHRbMF0sIHRbMV0sIHRbMl0pIDogaSh0LCBlLCBzKSkubWFwKFN0KTtcbn1cbmZ1bmN0aW9uIEVpKGksIHQsIGUpIHtcbiAgcmV0dXJuIExpKGduLCBpLCB0LCBlKTtcbn1cbmZ1bmN0aW9uIHZvKGksIHQsIGUpIHtcbiAgcmV0dXJuIExpKHhvLCBpLCB0LCBlKTtcbn1cbmZ1bmN0aW9uIE1vKGksIHQsIGUpIHtcbiAgcmV0dXJuIExpKF9vLCBpLCB0LCBlKTtcbn1cbmZ1bmN0aW9uIHBuKGkpIHtcbiAgcmV0dXJuIChpICUgMzYwICsgMzYwKSAlIDM2MDtcbn1cbmZ1bmN0aW9uIFNvKGkpIHtcbiAgdmFyIHQgPSBiby5leGVjKGkpO1xuICB2YXIgZSA9IDI1NSxcbiAgICBzO1xuICBpZiAoIXQpIHJldHVybjtcbiAgdFs1XSAhPT0gcyAmJiAoZSA9IHRbNl0gPyBuZSgrdFs1XSkgOiBTdCgrdFs1XSkpO1xuICB2YXIgbiA9IHBuKCt0WzJdKSxcbiAgICBvID0gK3RbM10gLyAxMDAsXG4gICAgciA9ICt0WzRdIC8gMTAwO1xuICByZXR1cm4gdFsxXSA9PT0gXCJod2JcIiA/IHMgPSB2byhuLCBvLCByKSA6IHRbMV0gPT09IFwiaHN2XCIgPyBzID0gTW8obiwgbywgcikgOiBzID0gRWkobiwgbywgciksIHtcbiAgICByOiBzWzBdLFxuICAgIGc6IHNbMV0sXG4gICAgYjogc1syXSxcbiAgICBhOiBlXG4gIH07XG59XG5mdW5jdGlvbiBrbyhpLCB0KSB7XG4gIHZhciBlID0gUmkoaSk7XG4gIGVbMF0gPSBwbihlWzBdICsgdCksIGUgPSBFaShlKSwgaS5yID0gZVswXSwgaS5nID0gZVsxXSwgaS5iID0gZVsyXTtcbn1cbmZ1bmN0aW9uIHdvKGkpIHtcbiAgaWYgKCFpKSByZXR1cm47XG4gIHZhciB0ID0gUmkoaSksXG4gICAgZSA9IHRbMF0sXG4gICAgcyA9IHFpKHRbMV0pLFxuICAgIG4gPSBxaSh0WzJdKTtcbiAgcmV0dXJuIGkuYSA8IDI1NSA/IFwiaHNsYShcIi5jb25jYXQoZSwgXCIsIFwiKS5jb25jYXQocywgXCIlLCBcIikuY29uY2F0KG4sIFwiJSwgXCIpLmNvbmNhdChwdChpLmEpLCBcIilcIikgOiBcImhzbChcIi5jb25jYXQoZSwgXCIsIFwiKS5jb25jYXQocywgXCIlLCBcIikuY29uY2F0KG4sIFwiJSlcIik7XG59XG52YXIgS2kgPSB7XG4gICAgeDogXCJkYXJrXCIsXG4gICAgWjogXCJsaWdodFwiLFxuICAgIFk6IFwicmVcIixcbiAgICBYOiBcImJsdVwiLFxuICAgIFc6IFwiZ3JcIixcbiAgICBWOiBcIm1lZGl1bVwiLFxuICAgIFU6IFwic2xhdGVcIixcbiAgICBBOiBcImVlXCIsXG4gICAgVDogXCJvbFwiLFxuICAgIFM6IFwib3JcIixcbiAgICBCOiBcInJhXCIsXG4gICAgQzogXCJsYXRlZ1wiLFxuICAgIEQ6IFwiaWdodHNcIixcbiAgICBSOiBcImluXCIsXG4gICAgUTogXCJ0dXJxdW9pc1wiLFxuICAgIEU6IFwiaGlcIixcbiAgICBQOiBcInJvXCIsXG4gICAgTzogXCJhbFwiLFxuICAgIE46IFwibGVcIixcbiAgICBNOiBcImRlXCIsXG4gICAgTDogXCJ5ZWxsb1wiLFxuICAgIEY6IFwiZW5cIixcbiAgICBLOiBcImNoXCIsXG4gICAgRzogXCJhcmtzXCIsXG4gICAgSDogXCJlYVwiLFxuICAgIEk6IFwiaWdodGdcIixcbiAgICBKOiBcIndoXCJcbiAgfSxcbiAgR2kgPSB7XG4gICAgT2ljZVhlOiBcImYwZjhmZlwiLFxuICAgIGFudGlxdWV3RXRlOiBcImZhZWJkN1wiLFxuICAgIGFxdWE6IFwiZmZmZlwiLFxuICAgIGFxdWFtYXJSZTogXCI3ZmZmZDRcIixcbiAgICBhenVZOiBcImYwZmZmZlwiLFxuICAgIGJlaWdlOiBcImY1ZjVkY1wiLFxuICAgIGJpc3F1ZTogXCJmZmU0YzRcIixcbiAgICBibGFjazogXCIwXCIsXG4gICAgYmxhbktlZE9tb25kOiBcImZmZWJjZFwiLFxuICAgIFhlOiBcImZmXCIsXG4gICAgWGV2aVRldDogXCI4YTJiZTJcIixcbiAgICBiUHduOiBcImE1MmEyYVwiLFxuICAgIGJ1cmx5d29vZDogXCJkZWI4ODdcIixcbiAgICBjYU10WGU6IFwiNWY5ZWEwXCIsXG4gICAgS2FydFl1c2U6IFwiN2ZmZjAwXCIsXG4gICAgS29jVGF0ZTogXCJkMjY5MWVcIixcbiAgICBjU086IFwiZmY3ZjUwXCIsXG4gICAgY1NuZmxvd2VyWGU6IFwiNjQ5NWVkXCIsXG4gICAgY1Nuc2lsazogXCJmZmY4ZGNcIixcbiAgICBjcmltc29uOiBcImRjMTQzY1wiLFxuICAgIGN5YW46IFwiZmZmZlwiLFxuICAgIHhYZTogXCI4YlwiLFxuICAgIHhjeWFuOiBcIjhiOGJcIixcbiAgICB4Z1RNblBkOiBcImI4ODYwYlwiLFxuICAgIHhXYXk6IFwiYTlhOWE5XCIsXG4gICAgeGdZRjogXCI2NDAwXCIsXG4gICAgeGdZeTogXCJhOWE5YTlcIixcbiAgICB4a2hha2k6IFwiYmRiNzZiXCIsXG4gICAgeG1hZ0Z0YTogXCI4YjAwOGJcIixcbiAgICB4VGl2ZWdZRjogXCI1NTZiMmZcIixcbiAgICB4U2FuZ2U6IFwiZmY4YzAwXCIsXG4gICAgeFNjRWQ6IFwiOTkzMmNjXCIsXG4gICAgeFlkOiBcIjhiMDAwMFwiLFxuICAgIHhzT21vbjogXCJlOTk2N2FcIixcbiAgICB4c0hnWUY6IFwiOGZiYzhmXCIsXG4gICAgeFVYZTogXCI0ODNkOGJcIixcbiAgICB4VVdheTogXCIyZjRmNGZcIixcbiAgICB4VWdZeTogXCIyZjRmNGZcIixcbiAgICB4UWU6IFwiY2VkMVwiLFxuICAgIHh2aVRldDogXCI5NDAwZDNcIixcbiAgICBkQXBwUms6IFwiZmYxNDkzXCIsXG4gICAgZEFwc2t5WGU6IFwiYmZmZlwiLFxuICAgIGRpbVdheTogXCI2OTY5NjlcIixcbiAgICBkaW1nWXk6IFwiNjk2OTY5XCIsXG4gICAgZG9kZ2VyWGU6IFwiMWU5MGZmXCIsXG4gICAgZmlZYnJpY2s6IFwiYjIyMjIyXCIsXG4gICAgZmxTT3dFdGU6IFwiZmZmYWYwXCIsXG4gICAgZm9Zc3RXQW46IFwiMjI4YjIyXCIsXG4gICAgZnVLc2lhOiBcImZmMDBmZlwiLFxuICAgIGdhUnNiU286IFwiZGNkY2RjXCIsXG4gICAgZ2hvc3R3RXRlOiBcImY4ZjhmZlwiLFxuICAgIGdUZDogXCJmZmQ3MDBcIixcbiAgICBnVE1uUGQ6IFwiZGFhNTIwXCIsXG4gICAgV2F5OiBcIjgwODA4MFwiLFxuICAgIGdZRjogXCI4MDAwXCIsXG4gICAgZ1lGTHc6IFwiYWRmZjJmXCIsXG4gICAgZ1l5OiBcIjgwODA4MFwiLFxuICAgIGhvbmV5TXc6IFwiZjBmZmYwXCIsXG4gICAgaG90cFJrOiBcImZmNjliNFwiLFxuICAgIFJkaWFuWWQ6IFwiY2Q1YzVjXCIsXG4gICAgUmRpZ286IFwiNGIwMDgyXCIsXG4gICAgaXZTeTogXCJmZmZmZjBcIixcbiAgICBraGFraTogXCJmMGU2OGNcIixcbiAgICBsYXZGTXI6IFwiZTZlNmZhXCIsXG4gICAgbGF2Rk1yWHNoOiBcImZmZjBmNVwiLFxuICAgIGxhd25nWUY6IFwiN2NmYzAwXCIsXG4gICAgTm1vbmNFZmZvbjogXCJmZmZhY2RcIixcbiAgICBaWGU6IFwiYWRkOGU2XCIsXG4gICAgWmNTTzogXCJmMDgwODBcIixcbiAgICBaY3lhbjogXCJlMGZmZmZcIixcbiAgICBaZ1RNblBkTHc6IFwiZmFmYWQyXCIsXG4gICAgWldheTogXCJkM2QzZDNcIixcbiAgICBaZ1lGOiBcIjkwZWU5MFwiLFxuICAgIFpnWXk6IFwiZDNkM2QzXCIsXG4gICAgWnBSazogXCJmZmI2YzFcIixcbiAgICBac09tb246IFwiZmZhMDdhXCIsXG4gICAgWnNIZ1lGOiBcIjIwYjJhYVwiLFxuICAgIFpza3lYZTogXCI4N2NlZmFcIixcbiAgICBaVVdheTogXCI3Nzg4OTlcIixcbiAgICBaVWdZeTogXCI3Nzg4OTlcIixcbiAgICBac3RBbFhlOiBcImIwYzRkZVwiLFxuICAgIFpMdzogXCJmZmZmZTBcIixcbiAgICBsaW1lOiBcImZmMDBcIixcbiAgICBsaW1lZ1lGOiBcIjMyY2QzMlwiLFxuICAgIGxSRjogXCJmYWYwZTZcIixcbiAgICBtYWdGdGE6IFwiZmYwMGZmXCIsXG4gICAgbWFQb246IFwiODAwMDAwXCIsXG4gICAgVmFxdWFtYXJSZTogXCI2NmNkYWFcIixcbiAgICBWWGU6IFwiY2RcIixcbiAgICBWU2NFZDogXCJiYTU1ZDNcIixcbiAgICBWcHVycE46IFwiOTM3MGRiXCIsXG4gICAgVnNIZ1lGOiBcIjNjYjM3MVwiLFxuICAgIFZVWGU6IFwiN2I2OGVlXCIsXG4gICAgVnNwclJnZ1lGOiBcImZhOWFcIixcbiAgICBWUWU6IFwiNDhkMWNjXCIsXG4gICAgVnZpVGV0WWQ6IFwiYzcxNTg1XCIsXG4gICAgbWlkbmlnaHRYZTogXCIxOTE5NzBcIixcbiAgICBtUnRjWWFtOiBcImY1ZmZmYVwiLFxuICAgIG1pc3R5UHNlOiBcImZmZTRlMVwiLFxuICAgIG1vY2Nhc1I6IFwiZmZlNGI1XCIsXG4gICAgbmF2YWpvd0V0ZTogXCJmZmRlYWRcIixcbiAgICBuYXZ5OiBcIjgwXCIsXG4gICAgVGRsYWNlOiBcImZkZjVlNlwiLFxuICAgIFRpdmU6IFwiODA4MDAwXCIsXG4gICAgVGl2ZWRCYjogXCI2YjhlMjNcIixcbiAgICBTYW5nZTogXCJmZmE1MDBcIixcbiAgICBTYW5nZVlkOiBcImZmNDUwMFwiLFxuICAgIFNjRWQ6IFwiZGE3MGQ2XCIsXG4gICAgcE9lZ1RNblBkOiBcImVlZThhYVwiLFxuICAgIHBPZWdZRjogXCI5OGZiOThcIixcbiAgICBwT2VRZTogXCJhZmVlZWVcIixcbiAgICBwT2V2aVRldFlkOiBcImRiNzA5M1wiLFxuICAgIHBhcGF5YXdFcDogXCJmZmVmZDVcIixcbiAgICBwSEtwdWZmOiBcImZmZGFiOVwiLFxuICAgIHBlcnU6IFwiY2Q4NTNmXCIsXG4gICAgcFJrOiBcImZmYzBjYlwiLFxuICAgIHBsdW06IFwiZGRhMGRkXCIsXG4gICAgcG93TXJYZTogXCJiMGUwZTZcIixcbiAgICBwdXJwTjogXCI4MDAwODBcIixcbiAgICBZYmVjY2FwdXJwTjogXCI2NjMzOTlcIixcbiAgICBZZDogXCJmZjAwMDBcIixcbiAgICBQc3licm93bjogXCJiYzhmOGZcIixcbiAgICBQeU9YZTogXCI0MTY5ZTFcIixcbiAgICBzYWRkTmJQd246IFwiOGI0NTEzXCIsXG4gICAgc09tb246IFwiZmE4MDcyXCIsXG4gICAgc2FuZHliUHduOiBcImY0YTQ2MFwiLFxuICAgIHNIZ1lGOiBcIjJlOGI1N1wiLFxuICAgIHNIc2hlbGw6IFwiZmZmNWVlXCIsXG4gICAgc2lGbmE6IFwiYTA1MjJkXCIsXG4gICAgc2lsdmVyOiBcImMwYzBjMFwiLFxuICAgIHNreVhlOiBcIjg3Y2VlYlwiLFxuICAgIFVYZTogXCI2YTVhY2RcIixcbiAgICBVV2F5OiBcIjcwODA5MFwiLFxuICAgIFVnWXk6IFwiNzA4MDkwXCIsXG4gICAgc25vdzogXCJmZmZhZmFcIixcbiAgICBzcHJSZ2dZRjogXCJmZjdmXCIsXG4gICAgc3RBbFhlOiBcIjQ2ODJiNFwiLFxuICAgIHRhbjogXCJkMmI0OGNcIixcbiAgICB0ZU86IFwiODA4MFwiLFxuICAgIHRFc3ROOiBcImQ4YmZkOFwiLFxuICAgIHRvbWF0bzogXCJmZjYzNDdcIixcbiAgICBRZTogXCI0MGUwZDBcIixcbiAgICB2aVRldDogXCJlZTgyZWVcIixcbiAgICBKSHQ6IFwiZjVkZWIzXCIsXG4gICAgd0V0ZTogXCJmZmZmZmZcIixcbiAgICB3RXRlc21va2U6IFwiZjVmNWY1XCIsXG4gICAgTHc6IFwiZmZmZjAwXCIsXG4gICAgTHdnWUY6IFwiOWFjZDMyXCJcbiAgfTtcbmZ1bmN0aW9uIFBvKCkge1xuICB2YXIgaSA9IHt9LFxuICAgIHQgPSBPYmplY3Qua2V5cyhHaSksXG4gICAgZSA9IE9iamVjdC5rZXlzKEtpKTtcbiAgdmFyIHMsIG4sIG8sIHIsIGE7XG4gIGZvciAocyA9IDA7IHMgPCB0Lmxlbmd0aDsgcysrKSB7XG4gICAgZm9yIChyID0gYSA9IHRbc10sIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykgbyA9IGVbbl0sIGEgPSBhLnJlcGxhY2UobywgS2lbb10pO1xuICAgIG8gPSBwYXJzZUludChHaVtyXSwgMTYpLCBpW2FdID0gW28gPj4gMTYgJiAyNTUsIG8gPj4gOCAmIDI1NSwgbyAmIDI1NV07XG4gIH1cbiAgcmV0dXJuIGk7XG59XG52YXIgTWU7XG5mdW5jdGlvbiBEbyhpKSB7XG4gIE1lIHx8IChNZSA9IFBvKCksIE1lLnRyYW5zcGFyZW50ID0gWzAsIDAsIDAsIDBdKTtcbiAgdmFyIHQgPSBNZVtpLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gdCAmJiB7XG4gICAgcjogdFswXSxcbiAgICBnOiB0WzFdLFxuICAgIGI6IHRbMl0sXG4gICAgYTogdC5sZW5ndGggPT09IDQgPyB0WzNdIDogMjU1XG4gIH07XG59XG52YXIgQ28gPSAvXnJnYmE/XFwoXFxzKihbLSsuXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT8oPzpbXFxzLC9dKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcbmZ1bmN0aW9uIE9vKGkpIHtcbiAgdmFyIHQgPSBDby5leGVjKGkpO1xuICB2YXIgZSA9IDI1NSxcbiAgICBzLFxuICAgIG4sXG4gICAgbztcbiAgaWYgKHQpIHtcbiAgICBpZiAodFs3XSAhPT0gcykge1xuICAgICAgdmFyIHIgPSArdFs3XTtcbiAgICAgIGUgPSB0WzhdID8gbmUocikgOiB4dChyICogMjU1LCAwLCAyNTUpO1xuICAgIH1cbiAgICByZXR1cm4gcyA9ICt0WzFdLCBuID0gK3RbM10sIG8gPSArdFs1XSwgcyA9IDI1NSAmICh0WzJdID8gbmUocykgOiB4dChzLCAwLCAyNTUpKSwgbiA9IDI1NSAmICh0WzRdID8gbmUobikgOiB4dChuLCAwLCAyNTUpKSwgbyA9IDI1NSAmICh0WzZdID8gbmUobykgOiB4dChvLCAwLCAyNTUpKSwge1xuICAgICAgcjogcyxcbiAgICAgIGc6IG4sXG4gICAgICBiOiBvLFxuICAgICAgYTogZVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIFRvKGkpIHtcbiAgcmV0dXJuIGkgJiYgKGkuYSA8IDI1NSA/IFwicmdiYShcIi5jb25jYXQoaS5yLCBcIiwgXCIpLmNvbmNhdChpLmcsIFwiLCBcIikuY29uY2F0KGkuYiwgXCIsIFwiKS5jb25jYXQocHQoaS5hKSwgXCIpXCIpIDogXCJyZ2IoXCIuY29uY2F0KGkuciwgXCIsIFwiKS5jb25jYXQoaS5nLCBcIiwgXCIpLmNvbmNhdChpLmIsIFwiKVwiKSk7XG59XG52YXIgc2kgPSBmdW5jdGlvbiBzaShpKSB7XG4gICAgcmV0dXJuIGkgPD0gMzEzMDhlLTcgPyBpICogMTIuOTIgOiBNYXRoLnBvdyhpLCAxIC8gMi40KSAqIDEuMDU1IC0gMC4wNTU7XG4gIH0sXG4gIE50ID0gZnVuY3Rpb24gTnQoaSkge1xuICAgIHJldHVybiBpIDw9IDAuMDQwNDUgPyBpIC8gMTIuOTIgOiBNYXRoLnBvdygoaSArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICB9O1xuZnVuY3Rpb24gQW8oaSwgdCwgZSkge1xuICB2YXIgcyA9IE50KHB0KGkucikpLFxuICAgIG4gPSBOdChwdChpLmcpKSxcbiAgICBvID0gTnQocHQoaS5iKSk7XG4gIHJldHVybiB7XG4gICAgcjogU3Qoc2kocyArIGUgKiAoTnQocHQodC5yKSkgLSBzKSkpLFxuICAgIGc6IFN0KHNpKG4gKyBlICogKE50KHB0KHQuZykpIC0gbikpKSxcbiAgICBiOiBTdChzaShvICsgZSAqIChOdChwdCh0LmIpKSAtIG8pKSksXG4gICAgYTogaS5hICsgZSAqICh0LmEgLSBpLmEpXG4gIH07XG59XG5mdW5jdGlvbiBTZShpLCB0LCBlKSB7XG4gIGlmIChpKSB7XG4gICAgdmFyIHMgPSBSaShpKTtcbiAgICBzW3RdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc1t0XSArIHNbdF0gKiBlLCB0ID09PSAwID8gMzYwIDogMSkpLCBzID0gRWkocyksIGkuciA9IHNbMF0sIGkuZyA9IHNbMV0sIGkuYiA9IHNbMl07XG4gIH1cbn1cbmZ1bmN0aW9uIG1uKGksIHQpIHtcbiAgcmV0dXJuIGkgJiYgT2JqZWN0LmFzc2lnbih0IHx8IHt9LCBpKTtcbn1cbmZ1bmN0aW9uIEppKGkpIHtcbiAgdmFyIHQgPSB7XG4gICAgcjogMCxcbiAgICBnOiAwLFxuICAgIGI6IDAsXG4gICAgYTogMjU1XG4gIH07XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGkpID8gaS5sZW5ndGggPj0gMyAmJiAodCA9IHtcbiAgICByOiBpWzBdLFxuICAgIGc6IGlbMV0sXG4gICAgYjogaVsyXSxcbiAgICBhOiAyNTVcbiAgfSwgaS5sZW5ndGggPiAzICYmICh0LmEgPSBTdChpWzNdKSkpIDogKHQgPSBtbihpLCB7XG4gICAgcjogMCxcbiAgICBnOiAwLFxuICAgIGI6IDAsXG4gICAgYTogMVxuICB9KSwgdC5hID0gU3QodC5hKSksIHQ7XG59XG5mdW5jdGlvbiBSbyhpKSB7XG4gIHJldHVybiBpLmNoYXJBdCgwKSA9PT0gXCJyXCIgPyBPbyhpKSA6IFNvKGkpO1xufVxudmFyIHVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gdWUodCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCB1ZSk7XG4gICAgaWYgKHQgaW5zdGFuY2VvZiB1ZSkgcmV0dXJuIHQ7XG4gICAgdmFyIGUgPSBfdHlwZW9mKHQpO1xuICAgIHZhciBzO1xuICAgIGUgPT09IFwib2JqZWN0XCIgPyBzID0gSmkodCkgOiBlID09PSBcInN0cmluZ1wiICYmIChzID0gZ28odCkgfHwgRG8odCkgfHwgUm8odCkpLCB0aGlzLl9yZ2IgPSBzLCB0aGlzLl92YWxpZCA9ICEhcztcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKHVlLCBbe1xuICAgIGtleTogXCJ2YWxpZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZ2JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciB0ID0gbW4odGhpcy5fcmdiKTtcbiAgICAgIHJldHVybiB0ICYmICh0LmEgPSBwdCh0LmEpKSwgdDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHQpIHtcbiAgICAgIHRoaXMuX3JnYiA9IEppKHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZ2JTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmdiU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gVG8odGhpcy5fcmdiKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGV4U3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhleFN0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWxpZCA/IG1vKHRoaXMuX3JnYikgOiB2b2lkIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhzbFN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoc2xTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyB3byh0aGlzLl9yZ2IpIDogdm9pZCAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWl4KHQsIGUpIHtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5yZ2IsXG4gICAgICAgICAgbiA9IHQucmdiO1xuICAgICAgICB2YXIgbztcbiAgICAgICAgdmFyIHIgPSBlID09PSBvID8gMC41IDogZSxcbiAgICAgICAgICBhID0gMiAqIHIgLSAxLFxuICAgICAgICAgIGwgPSBzLmEgLSBuLmEsXG4gICAgICAgICAgYyA9ICgoYSAqIGwgPT09IC0xID8gYSA6IChhICsgbCkgLyAoMSArIGEgKiBsKSkgKyAxKSAvIDI7XG4gICAgICAgIG8gPSAxIC0gYywgcy5yID0gMjU1ICYgYyAqIHMuciArIG8gKiBuLnIgKyAwLjUsIHMuZyA9IDI1NSAmIGMgKiBzLmcgKyBvICogbi5nICsgMC41LCBzLmIgPSAyNTUgJiBjICogcy5iICsgbyAqIG4uYiArIDAuNSwgcy5hID0gciAqIHMuYSArICgxIC0gcikgKiBuLmEsIHRoaXMucmdiID0gcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnBvbGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZSh0LCBlKSB7XG4gICAgICByZXR1cm4gdCAmJiAodGhpcy5fcmdiID0gQW8odGhpcy5fcmdiLCB0Ll9yZ2IsIGUpKSwgdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IHVlKHRoaXMucmdiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWxwaGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWxwaGEodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JnYi5hID0gU3QodCksIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJlcih0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX3JnYjtcbiAgICAgIHJldHVybiBlLmEgKj0gMSAtIHQsIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdyZXlzY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncmV5c2NhbGUoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX3JnYixcbiAgICAgICAgZSA9IHhlKHQuciAqIDAuMyArIHQuZyAqIDAuNTkgKyB0LmIgKiAwLjExKTtcbiAgICAgIHJldHVybiB0LnIgPSB0LmcgPSB0LmIgPSBlLCB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcGFxdWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wYXF1ZXIodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9yZ2I7XG4gICAgICByZXR1cm4gZS5hICo9IDEgKyB0LCB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZWdhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmVnYXRlKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9yZ2I7XG4gICAgICByZXR1cm4gdC5yID0gMjU1IC0gdC5yLCB0LmcgPSAyNTUgLSB0LmcsIHQuYiA9IDI1NSAtIHQuYiwgdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGlnaHRlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaWdodGVuKHQpIHtcbiAgICAgIHJldHVybiBTZSh0aGlzLl9yZ2IsIDIsIHQpLCB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXJrZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGFya2VuKHQpIHtcbiAgICAgIHJldHVybiBTZSh0aGlzLl9yZ2IsIDIsIC10KSwgdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2F0dXJhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2F0dXJhdGUodCkge1xuICAgICAgcmV0dXJuIFNlKHRoaXMuX3JnYiwgMSwgdCksIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc2F0dXJhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzYXR1cmF0ZSh0KSB7XG4gICAgICByZXR1cm4gU2UodGhpcy5fcmdiLCAxLCAtdCksIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3RhdGUodCkge1xuICAgICAgcmV0dXJuIGtvKHRoaXMuX3JnYiwgdCksIHRoaXM7XG4gICAgfVxuICB9XSk7XG59KCk7XG4vKiFcbiAqIENoYXJ0LmpzIHY0LjUuMVxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDI1IENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGR0KCkge31cbnZhciBMbyA9IC8qIEBfX1BVUkVfXyAqL2Z1bmN0aW9uICgpIHtcbiAgdmFyIGkgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpKys7XG4gIH07XG59KCk7XG5mdW5jdGlvbiBSKGkpIHtcbiAgcmV0dXJuIGkgPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIE4oaSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KGkpKSByZXR1cm4gITA7XG4gIHZhciB0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGkpO1xuICByZXR1cm4gdC5zbGljZSgwLCA3KSA9PT0gXCJbb2JqZWN0XCIgJiYgdC5zbGljZSgtNikgPT09IFwiQXJyYXldXCI7XG59XG5mdW5jdGlvbiBUKGkpIHtcbiAgcmV0dXJuIGkgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGkpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuZnVuY3Rpb24gcShpKSB7XG4gIHJldHVybiAodHlwZW9mIGkgPT0gXCJudW1iZXJcIiB8fCBpIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBpc0Zpbml0ZSgraSk7XG59XG5mdW5jdGlvbiBvdChpLCB0KSB7XG4gIHJldHVybiBxKGkpID8gaSA6IHQ7XG59XG5mdW5jdGlvbiBEKGksIHQpIHtcbiAgcmV0dXJuIF90eXBlb2YoaSkgPiBcInVcIiA/IHQgOiBpO1xufVxudmFyIEVvID0gZnVuY3Rpb24gRW8oaSwgdCkge1xuICAgIHJldHVybiB0eXBlb2YgaSA9PSBcInN0cmluZ1wiICYmIGkuZW5kc1dpdGgoXCIlXCIpID8gcGFyc2VGbG9hdChpKSAvIDEwMCA6ICtpIC8gdDtcbiAgfSxcbiAgYm4gPSBmdW5jdGlvbiBibihpLCB0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpID09IFwic3RyaW5nXCIgJiYgaS5lbmRzV2l0aChcIiVcIikgPyBwYXJzZUZsb2F0KGkpIC8gMTAwICogdCA6ICtpO1xuICB9O1xuZnVuY3Rpb24gSShpLCB0LCBlKSB7XG4gIGlmIChpICYmIHR5cGVvZiBpLmNhbGwgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gaS5hcHBseShlLCB0KTtcbn1cbmZ1bmN0aW9uIEwoaSwgdCwgZSwgcykge1xuICB2YXIgbiwgbywgcjtcbiAgaWYgKE4oaSkpIGZvciAobyA9IGkubGVuZ3RoLCBuID0gMDsgbiA8IG87IG4rKykgdC5jYWxsKGUsIGlbbl0sIG4pO2Vsc2UgaWYgKFQoaSkpIGZvciAociA9IE9iamVjdC5rZXlzKGkpLCBvID0gci5sZW5ndGgsIG4gPSAwOyBuIDwgbzsgbisrKSB0LmNhbGwoZSwgaVtyW25dXSwgcltuXSk7XG59XG5mdW5jdGlvbiBqZShpLCB0KSB7XG4gIHZhciBlLCBzLCBuLCBvO1xuICBpZiAoIWkgfHwgIXQgfHwgaS5sZW5ndGggIT09IHQubGVuZ3RoKSByZXR1cm4gITE7XG4gIGZvciAoZSA9IDAsIHMgPSBpLmxlbmd0aDsgZSA8IHM7ICsrZSkgaWYgKG4gPSBpW2VdLCBvID0gdFtlXSwgbi5kYXRhc2V0SW5kZXggIT09IG8uZGF0YXNldEluZGV4IHx8IG4uaW5kZXggIT09IG8uaW5kZXgpIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gJGUoaSkge1xuICBpZiAoTihpKSkgcmV0dXJuIGkubWFwKCRlKTtcbiAgaWYgKFQoaSkpIHtcbiAgICB2YXIgdCA9IC8qIEBfX1BVUkVfXyAqL09iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBlID0gT2JqZWN0LmtleXMoaSksXG4gICAgICBzID0gZS5sZW5ndGg7XG4gICAgdmFyIG4gPSAwO1xuICAgIGZvciAoOyBuIDwgczsgKytuKSB0W2Vbbl1dID0gJGUoaVtlW25dXSk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBfbihpKSB7XG4gIHJldHVybiBbXCJfX3Byb3RvX19cIiwgXCJwcm90b3R5cGVcIiwgXCJjb25zdHJ1Y3RvclwiXS5pbmRleE9mKGkpID09PSAtMTtcbn1cbmZ1bmN0aW9uIEZvKGksIHQsIGUsIHMpIHtcbiAgaWYgKCFfbihpKSkgcmV0dXJuO1xuICB2YXIgbiA9IHRbaV0sXG4gICAgbyA9IGVbaV07XG4gIFQobikgJiYgVChvKSA/IGZlKG4sIG8sIHMpIDogdFtpXSA9ICRlKG8pO1xufVxuZnVuY3Rpb24gZmUoaSwgdCwgZSkge1xuICB2YXIgcyA9IE4odCkgPyB0IDogW3RdLFxuICAgIG4gPSBzLmxlbmd0aDtcbiAgaWYgKCFUKGkpKSByZXR1cm4gaTtcbiAgZSA9IGUgfHwge307XG4gIHZhciBvID0gZS5tZXJnZXIgfHwgRm87XG4gIHZhciByO1xuICBmb3IgKHZhciBhID0gMDsgYSA8IG47ICsrYSkge1xuICAgIGlmIChyID0gc1thXSwgIVQocikpIGNvbnRpbnVlO1xuICAgIHZhciBsID0gT2JqZWN0LmtleXMocik7XG4gICAgZm9yICh2YXIgYyA9IDAsIGggPSBsLmxlbmd0aDsgYyA8IGg7ICsrYykgbyhsW2NdLCBpLCByLCBlKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIGxlKGksIHQpIHtcbiAgcmV0dXJuIGZlKGksIHQsIHtcbiAgICBtZXJnZXI6IElvXG4gIH0pO1xufVxuZnVuY3Rpb24gSW8oaSwgdCwgZSkge1xuICBpZiAoIV9uKGkpKSByZXR1cm47XG4gIHZhciBzID0gdFtpXSxcbiAgICBuID0gZVtpXTtcbiAgVChzKSAmJiBUKG4pID8gbGUocywgbikgOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCwgaSkgfHwgKHRbaV0gPSAkZShuKSk7XG59XG52YXIgWmkgPSB7XG4gIC8vIENoYXJ0LmhlbHBlcnMuY29yZSByZXNvbHZlT2JqZWN0S2V5IHNob3VsZCByZXNvbHZlIGVtcHR5IGtleSB0byByb290IG9iamVjdFxuICBcIlwiOiBmdW5jdGlvbiBfKGkpIHtcbiAgICByZXR1cm4gaTtcbiAgfSxcbiAgLy8gZGVmYXVsdCByZXNvbHZlcnNcbiAgeDogZnVuY3Rpb24geChpKSB7XG4gICAgcmV0dXJuIGkueDtcbiAgfSxcbiAgeTogZnVuY3Rpb24geShpKSB7XG4gICAgcmV0dXJuIGkueTtcbiAgfVxufTtcbmZ1bmN0aW9uIHpvKGkpIHtcbiAgdmFyIHQgPSBpLnNwbGl0KFwiLlwiKSxcbiAgICBlID0gW107XG4gIHZhciBzID0gXCJcIjtcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHQpLFxuICAgIF9zdGVwO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgbiA9IF9zdGVwLnZhbHVlO1xuICAgICAgcyArPSBuLCBzLmVuZHNXaXRoKFwiXFxcXFwiKSA/IHMgPSBzLnNsaWNlKDAsIC0xKSArIFwiLlwiIDogKGUucHVzaChzKSwgcyA9IFwiXCIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gQm8oaSkge1xuICB2YXIgdCA9IHpvKGkpO1xuICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHQpLFxuICAgICAgX3N0ZXAyO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICB2YXIgcyA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgaWYgKHMgPT09IFwiXCIpIGJyZWFrO1xuICAgICAgICBlID0gZSAmJiBlW3NdO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIEl0KGksIHQpIHtcbiAgcmV0dXJuIChaaVt0XSB8fCAoWmlbdF0gPSBCbyh0KSkpKGkpO1xufVxuZnVuY3Rpb24gRmkoaSkge1xuICByZXR1cm4gaS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGkuc2xpY2UoMSk7XG59XG52YXIgZ2UgPSBmdW5jdGlvbiBnZShpKSB7XG4gICAgcmV0dXJuIF90eXBlb2YoaSkgPCBcInVcIjtcbiAgfSxcbiAgd3QgPSBmdW5jdGlvbiB3dChpKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpID09IFwiZnVuY3Rpb25cIjtcbiAgfSxcbiAgUWkgPSBmdW5jdGlvbiBRaShpLCB0KSB7XG4gICAgaWYgKGkuc2l6ZSAhPT0gdC5zaXplKSByZXR1cm4gITE7XG4gICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpKSxcbiAgICAgIF9zdGVwMztcbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGUgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgIGlmICghdC5oYXMoZSkpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9O1xuZnVuY3Rpb24gSG8oaSkge1xuICByZXR1cm4gaS50eXBlID09PSBcIm1vdXNldXBcIiB8fCBpLnR5cGUgPT09IFwiY2xpY2tcIiB8fCBpLnR5cGUgPT09IFwiY29udGV4dG1lbnVcIjtcbn1cbnZhciBFID0gTWF0aC5QSSxcbiAgQiA9IDIgKiBFLFxuICBXbyA9IEIgKyBFLFxuICBZZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgTm8gPSBFIC8gMTgwLFxuICBWID0gRSAvIDIsXG4gIEN0ID0gRSAvIDQsXG4gIHRzID0gRSAqIDIgLyAzLFxuICB4biA9IE1hdGgubG9nMTAsXG4gIGx0ID0gTWF0aC5zaWduO1xuZnVuY3Rpb24gY2UoaSwgdCwgZSkge1xuICByZXR1cm4gTWF0aC5hYnMoaSAtIHQpIDwgZTtcbn1cbmZ1bmN0aW9uIGVzKGkpIHtcbiAgdmFyIHQgPSBNYXRoLnJvdW5kKGkpO1xuICBpID0gY2UoaSwgdCwgaSAvIDFlMykgPyB0IDogaTtcbiAgdmFyIGUgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcih4bihpKSkpLFxuICAgIHMgPSBpIC8gZTtcbiAgcmV0dXJuIChzIDw9IDEgPyAxIDogcyA8PSAyID8gMiA6IHMgPD0gNSA/IDUgOiAxMCkgKiBlO1xufVxuZnVuY3Rpb24gVm8oaSkge1xuICB2YXIgdCA9IFtdLFxuICAgIGUgPSBNYXRoLnNxcnQoaSk7XG4gIHZhciBzO1xuICBmb3IgKHMgPSAxOyBzIDwgZTsgcysrKSBpICUgcyA9PT0gMCAmJiAodC5wdXNoKHMpLCB0LnB1c2goaSAvIHMpKTtcbiAgcmV0dXJuIGUgPT09IChlIHwgMCkgJiYgdC5wdXNoKGUpLCB0LnNvcnQoZnVuY3Rpb24gKG4sIG8pIHtcbiAgICByZXR1cm4gbiAtIG87XG4gIH0pLnBvcCgpLCB0O1xufVxuZnVuY3Rpb24gam8oaSkge1xuICByZXR1cm4gX3R5cGVvZihpKSA9PSBcInN5bWJvbFwiIHx8IF90eXBlb2YoaSkgPT0gXCJvYmplY3RcIiAmJiBpICE9PSBudWxsICYmICEoU3ltYm9sLnRvUHJpbWl0aXZlIGluIGkgfHwgXCJ0b1N0cmluZ1wiIGluIGkgfHwgXCJ2YWx1ZU9mXCIgaW4gaSk7XG59XG5mdW5jdGlvbiBYdChpKSB7XG4gIHJldHVybiAham8oaSkgJiYgIWlzTmFOKHBhcnNlRmxvYXQoaSkpICYmIGlzRmluaXRlKGkpO1xufVxuZnVuY3Rpb24gJG8oaSwgdCkge1xuICB2YXIgZSA9IE1hdGgucm91bmQoaSk7XG4gIHJldHVybiBlIC0gdCA8PSBpICYmIGUgKyB0ID49IGk7XG59XG5mdW5jdGlvbiBZbyhpLCB0LCBlKSB7XG4gIHZhciBzLCBuLCBvO1xuICBmb3IgKHMgPSAwLCBuID0gaS5sZW5ndGg7IHMgPCBuOyBzKyspIG8gPSBpW3NdW2VdLCBpc05hTihvKSB8fCAodC5taW4gPSBNYXRoLm1pbih0Lm1pbiwgbyksIHQubWF4ID0gTWF0aC5tYXgodC5tYXgsIG8pKTtcbn1cbmZ1bmN0aW9uIGJ0KGkpIHtcbiAgcmV0dXJuIGkgKiAoRSAvIDE4MCk7XG59XG5mdW5jdGlvbiBVbyhpKSB7XG4gIHJldHVybiBpICogKDE4MCAvIEUpO1xufVxuZnVuY3Rpb24gaXMoaSkge1xuICBpZiAoIXEoaSkpIHJldHVybjtcbiAgdmFyIHQgPSAxLFxuICAgIGUgPSAwO1xuICBmb3IgKDsgTWF0aC5yb3VuZChpICogdCkgLyB0ICE9PSBpOykgdCAqPSAxMCwgZSsrO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHluKGksIHQpIHtcbiAgdmFyIGUgPSB0LnggLSBpLngsXG4gICAgcyA9IHQueSAtIGkueSxcbiAgICBuID0gTWF0aC5zcXJ0KGUgKiBlICsgcyAqIHMpO1xuICB2YXIgbyA9IE1hdGguYXRhbjIocywgZSk7XG4gIHJldHVybiBvIDwgLTAuNSAqIEUgJiYgKG8gKz0gQiksIHtcbiAgICBhbmdsZTogbyxcbiAgICBkaXN0YW5jZTogblxuICB9O1xufVxuZnVuY3Rpb24gdmkoaSwgdCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHQueCAtIGkueCwgMikgKyBNYXRoLnBvdyh0LnkgLSBpLnksIDIpKTtcbn1cbmZ1bmN0aW9uIFhvKGksIHQpIHtcbiAgcmV0dXJuIChpIC0gdCArIFdvKSAlIEIgLSBFO1xufVxuZnVuY3Rpb24gWihpKSB7XG4gIHJldHVybiAoaSAlIEIgKyBCKSAlIEI7XG59XG5mdW5jdGlvbiBwZShpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gWihpKSxcbiAgICBvID0gWih0KSxcbiAgICByID0gWihlKSxcbiAgICBhID0gWihvIC0gbiksXG4gICAgbCA9IFoociAtIG4pLFxuICAgIGMgPSBaKG4gLSBvKSxcbiAgICBoID0gWihuIC0gcik7XG4gIHJldHVybiBuID09PSBvIHx8IG4gPT09IHIgfHwgcyAmJiBvID09PSByIHx8IGEgPiBsICYmIGMgPCBoO1xufVxuZnVuY3Rpb24gVShpLCB0LCBlKSB7XG4gIHJldHVybiBNYXRoLm1heCh0LCBNYXRoLm1pbihlLCBpKSk7XG59XG5mdW5jdGlvbiBxbyhpKSB7XG4gIHJldHVybiBVKGksIC0zMjc2OCwgMzI3NjcpO1xufVxuZnVuY3Rpb24gX3QoaSwgdCwgZSkge1xuICB2YXIgcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMWUtNjtcbiAgcmV0dXJuIGkgPj0gTWF0aC5taW4odCwgZSkgLSBzICYmIGkgPD0gTWF0aC5tYXgodCwgZSkgKyBzO1xufVxuZnVuY3Rpb24gSWkoaSwgdCwgZSkge1xuICBlID0gZSB8fCBmdW5jdGlvbiAocikge1xuICAgIHJldHVybiBpW3JdIDwgdDtcbiAgfTtcbiAgdmFyIHMgPSBpLmxlbmd0aCAtIDEsXG4gICAgbiA9IDAsXG4gICAgbztcbiAgZm9yICg7IHMgLSBuID4gMTspIG8gPSBuICsgcyA+PiAxLCBlKG8pID8gbiA9IG8gOiBzID0gbztcbiAgcmV0dXJuIHtcbiAgICBsbzogbixcbiAgICBoaTogc1xuICB9O1xufVxudmFyIEV0ID0gZnVuY3Rpb24gRXQoaSwgdCwgZSwgcykge1xuICAgIHJldHVybiBJaShpLCBlLCBzID8gZnVuY3Rpb24gKG4pIHtcbiAgICAgIHZhciBvID0gaVtuXVt0XTtcbiAgICAgIHJldHVybiBvIDwgZSB8fCBvID09PSBlICYmIGlbbiArIDFdW3RdID09PSBlO1xuICAgIH0gOiBmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIGlbbl1bdF0gPCBlO1xuICAgIH0pO1xuICB9LFxuICBLbyA9IGZ1bmN0aW9uIEtvKGksIHQsIGUpIHtcbiAgICByZXR1cm4gSWkoaSwgZSwgZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiBpW3NdW3RdID49IGU7XG4gICAgfSk7XG4gIH07XG5mdW5jdGlvbiBHbyhpLCB0LCBlKSB7XG4gIHZhciBzID0gMCxcbiAgICBuID0gaS5sZW5ndGg7XG4gIGZvciAoOyBzIDwgbiAmJiBpW3NdIDwgdDspIHMrKztcbiAgZm9yICg7IG4gPiBzICYmIGlbbiAtIDFdID4gZTspIG4tLTtcbiAgcmV0dXJuIHMgPiAwIHx8IG4gPCBpLmxlbmd0aCA/IGkuc2xpY2UocywgbikgOiBpO1xufVxudmFyIHZuID0gW1wicHVzaFwiLCBcInBvcFwiLCBcInNoaWZ0XCIsIFwic3BsaWNlXCIsIFwidW5zaGlmdFwiXTtcbmZ1bmN0aW9uIEpvKGksIHQpIHtcbiAgaWYgKGkuX2NoYXJ0anMpIHtcbiAgICBpLl9jaGFydGpzLmxpc3RlbmVycy5wdXNoKHQpO1xuICAgIHJldHVybjtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJfY2hhcnRqc1wiLCB7XG4gICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICB2YWx1ZToge1xuICAgICAgbGlzdGVuZXJzOiBbdF1cbiAgICB9XG4gIH0pLCB2bi5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHMgPSBcIl9vbkRhdGFcIiArIEZpKGUpLFxuICAgICAgbiA9IGlbZV07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIGUsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG8gPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgb1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IG4uYXBwbHkodGhpcywgbyk7XG4gICAgICAgIHJldHVybiBpLl9jaGFydGpzLmxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgdHlwZW9mIGFbc10gPT0gXCJmdW5jdGlvblwiICYmIGFbc10uYXBwbHkoYSwgbyk7XG4gICAgICAgIH0pLCByO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNzKGksIHQpIHtcbiAgdmFyIGUgPSBpLl9jaGFydGpzO1xuICBpZiAoIWUpIHJldHVybjtcbiAgdmFyIHMgPSBlLmxpc3RlbmVycyxcbiAgICBuID0gcy5pbmRleE9mKHQpO1xuICBuICE9PSAtMSAmJiBzLnNwbGljZShuLCAxKSwgIShzLmxlbmd0aCA+IDApICYmICh2bi5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgZGVsZXRlIGlbb107XG4gIH0pLCBkZWxldGUgaS5fY2hhcnRqcyk7XG59XG5mdW5jdGlvbiBNbihpKSB7XG4gIHZhciB0ID0gbmV3IFNldChpKTtcbiAgcmV0dXJuIHQuc2l6ZSA9PT0gaS5sZW5ndGggPyBpIDogQXJyYXkuZnJvbSh0KTtcbn1cbnZhciBTbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yod2luZG93KSkgPiBcInVcIiA/IGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGkoKTtcbiAgfSA6IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG59KCk7XG5mdW5jdGlvbiBrbihpLCB0KSB7XG4gIHZhciBlID0gW10sXG4gICAgcyA9ICExO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgbiA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgbltfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICBlID0gbiwgcyB8fCAocyA9ICEwLCBTbi5jYWxsKHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgcyA9ICExLCBpLmFwcGx5KHQsIGUpO1xuICAgIH0pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFpvKGksIHQpIHtcbiAgdmFyIGU7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICBzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgfVxuICAgIHJldHVybiB0ID8gKGNsZWFyVGltZW91dChlKSwgZSA9IHNldFRpbWVvdXQoaSwgdCwgcykpIDogaS5hcHBseSh0aGlzLCBzKSwgdDtcbiAgfTtcbn1cbnZhciB6aSA9IGZ1bmN0aW9uIHppKGkpIHtcbiAgICByZXR1cm4gaSA9PT0gXCJzdGFydFwiID8gXCJsZWZ0XCIgOiBpID09PSBcImVuZFwiID8gXCJyaWdodFwiIDogXCJjZW50ZXJcIjtcbiAgfSxcbiAgWSA9IGZ1bmN0aW9uIFkoaSwgdCwgZSkge1xuICAgIHJldHVybiBpID09PSBcInN0YXJ0XCIgPyB0IDogaSA9PT0gXCJlbmRcIiA/IGUgOiAodCArIGUpIC8gMjtcbiAgfSxcbiAgUW8gPSBmdW5jdGlvbiBRbyhpLCB0LCBlLCBzKSB7XG4gICAgcmV0dXJuIGkgPT09IChzID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpID8gZSA6IGkgPT09IFwiY2VudGVyXCIgPyAodCArIGUpIC8gMiA6IHQ7XG4gIH07XG5mdW5jdGlvbiB3bihpLCB0LCBlKSB7XG4gIHZhciBzID0gdC5sZW5ndGg7XG4gIHZhciBuID0gMCxcbiAgICBvID0gcztcbiAgaWYgKGkuX3NvcnRlZCkge1xuICAgIHZhciByID0gaS5pU2NhbGUsXG4gICAgICBhID0gaS52U2NhbGUsXG4gICAgICBsID0gaS5fcGFyc2VkLFxuICAgICAgYyA9IGkuZGF0YXNldCAmJiBpLmRhdGFzZXQub3B0aW9ucyA/IGkuZGF0YXNldC5vcHRpb25zLnNwYW5HYXBzIDogbnVsbCxcbiAgICAgIGggPSByLmF4aXMsXG4gICAgICBfciRnZXRVc2VyQm91bmRzID0gci5nZXRVc2VyQm91bmRzKCksXG4gICAgICBkID0gX3IkZ2V0VXNlckJvdW5kcy5taW4sXG4gICAgICB1ID0gX3IkZ2V0VXNlckJvdW5kcy5tYXgsXG4gICAgICBmID0gX3IkZ2V0VXNlckJvdW5kcy5taW5EZWZpbmVkLFxuICAgICAgcCA9IF9yJGdldFVzZXJCb3VuZHMubWF4RGVmaW5lZDtcbiAgICBpZiAoZikge1xuICAgICAgaWYgKG4gPSBNYXRoLm1pbihcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byB0eXBlIF9wYXJzZWRcbiAgICAgIEV0KGwsIGgsIGQpLmxvLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOZWVkIHRvIGZpeCB0eXBlcyBvbiBfbG9va3VwQnlLZXlcbiAgICAgIGUgPyBzIDogRXQodCwgaCwgci5nZXRQaXhlbEZvclZhbHVlKGQpKS5sbyksIGMpIHtcbiAgICAgICAgdmFyIGcgPSBsLnNsaWNlKDAsIG4gKyAxKS5yZXZlcnNlKCkuZmluZEluZGV4KGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuICFSKG1bYS5heGlzXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBuIC09IE1hdGgubWF4KDAsIGcpO1xuICAgICAgfVxuICAgICAgbiA9IFUobiwgMCwgcyAtIDEpO1xuICAgIH1cbiAgICBpZiAocCkge1xuICAgICAgdmFyIF9nID0gTWF0aC5tYXgoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gdHlwZSBfcGFyc2VkXG4gICAgICBFdChsLCByLmF4aXMsIHUsICEwKS5oaSArIDEsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gZml4IHR5cGVzIG9uIF9sb29rdXBCeUtleVxuICAgICAgZSA/IDAgOiBFdCh0LCBoLCByLmdldFBpeGVsRm9yVmFsdWUodSksICEwKS5oaSArIDEpO1xuICAgICAgaWYgKGMpIHtcbiAgICAgICAgdmFyIG0gPSBsLnNsaWNlKF9nIC0gMSkuZmluZEluZGV4KGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgcmV0dXJuICFSKGJbYS5heGlzXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfZyArPSBNYXRoLm1heCgwLCBtKTtcbiAgICAgIH1cbiAgICAgIG8gPSBVKF9nLCBuLCBzKSAtIG47XG4gICAgfSBlbHNlIG8gPSBzIC0gbjtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBuLFxuICAgIGNvdW50OiBvXG4gIH07XG59XG5mdW5jdGlvbiBQbihpKSB7XG4gIHZhciB0ID0gaS54U2NhbGUsXG4gICAgZSA9IGkueVNjYWxlLFxuICAgIHMgPSBpLl9zY2FsZVJhbmdlcyxcbiAgICBuID0ge1xuICAgICAgeG1pbjogdC5taW4sXG4gICAgICB4bWF4OiB0Lm1heCxcbiAgICAgIHltaW46IGUubWluLFxuICAgICAgeW1heDogZS5tYXhcbiAgICB9O1xuICBpZiAoIXMpIHJldHVybiBpLl9zY2FsZVJhbmdlcyA9IG4sICEwO1xuICB2YXIgbyA9IHMueG1pbiAhPT0gdC5taW4gfHwgcy54bWF4ICE9PSB0Lm1heCB8fCBzLnltaW4gIT09IGUubWluIHx8IHMueW1heCAhPT0gZS5tYXg7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHMsIG4pLCBvO1xufVxudmFyIGtlID0gZnVuY3Rpb24ga2UoaSkge1xuICAgIHJldHVybiBpID09PSAwIHx8IGkgPT09IDE7XG4gIH0sXG4gIG5zID0gZnVuY3Rpb24gbnMoaSwgdCwgZSkge1xuICAgIHJldHVybiAtKE1hdGgucG93KDIsIDEwICogKGkgLT0gMSkpICogTWF0aC5zaW4oKGkgLSB0KSAqIEIgLyBlKSk7XG4gIH0sXG4gIG9zID0gZnVuY3Rpb24gb3MoaSwgdCwgZSkge1xuICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTAgKiBpKSAqIE1hdGguc2luKChpIC0gdCkgKiBCIC8gZSkgKyAxO1xuICB9LFxuICBoZSA9IHtcbiAgICBsaW5lYXI6IGZ1bmN0aW9uIGxpbmVhcihpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9LFxuICAgIGVhc2VJblF1YWQ6IGZ1bmN0aW9uIGVhc2VJblF1YWQoaSkge1xuICAgICAgcmV0dXJuIGkgKiBpO1xuICAgIH0sXG4gICAgZWFzZU91dFF1YWQ6IGZ1bmN0aW9uIGVhc2VPdXRRdWFkKGkpIHtcbiAgICAgIHJldHVybiAtaSAqIChpIC0gMik7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbiBlYXNlSW5PdXRRdWFkKGkpIHtcbiAgICAgIHJldHVybiAoaSAvPSAwLjUpIDwgMSA/IDAuNSAqIGkgKiBpIDogLTAuNSAqICgtLWkgKiAoaSAtIDIpIC0gMSk7XG4gICAgfSxcbiAgICBlYXNlSW5DdWJpYzogZnVuY3Rpb24gZWFzZUluQ3ViaWMoaSkge1xuICAgICAgcmV0dXJuIGkgKiBpICogaTtcbiAgICB9LFxuICAgIGVhc2VPdXRDdWJpYzogZnVuY3Rpb24gZWFzZU91dEN1YmljKGkpIHtcbiAgICAgIHJldHVybiAoaSAtPSAxKSAqIGkgKiBpICsgMTtcbiAgICB9LFxuICAgIGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbiBlYXNlSW5PdXRDdWJpYyhpKSB7XG4gICAgICByZXR1cm4gKGkgLz0gMC41KSA8IDEgPyAwLjUgKiBpICogaSAqIGkgOiAwLjUgKiAoKGkgLT0gMikgKiBpICogaSArIDIpO1xuICAgIH0sXG4gICAgZWFzZUluUXVhcnQ6IGZ1bmN0aW9uIGVhc2VJblF1YXJ0KGkpIHtcbiAgICAgIHJldHVybiBpICogaSAqIGkgKiBpO1xuICAgIH0sXG4gICAgZWFzZU91dFF1YXJ0OiBmdW5jdGlvbiBlYXNlT3V0UXVhcnQoaSkge1xuICAgICAgcmV0dXJuIC0oKGkgLT0gMSkgKiBpICogaSAqIGkgLSAxKTtcbiAgICB9LFxuICAgIGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbiBlYXNlSW5PdXRRdWFydChpKSB7XG4gICAgICByZXR1cm4gKGkgLz0gMC41KSA8IDEgPyAwLjUgKiBpICogaSAqIGkgKiBpIDogLTAuNSAqICgoaSAtPSAyKSAqIGkgKiBpICogaSAtIDIpO1xuICAgIH0sXG4gICAgZWFzZUluUXVpbnQ6IGZ1bmN0aW9uIGVhc2VJblF1aW50KGkpIHtcbiAgICAgIHJldHVybiBpICogaSAqIGkgKiBpICogaTtcbiAgICB9LFxuICAgIGVhc2VPdXRRdWludDogZnVuY3Rpb24gZWFzZU91dFF1aW50KGkpIHtcbiAgICAgIHJldHVybiAoaSAtPSAxKSAqIGkgKiBpICogaSAqIGkgKyAxO1xuICAgIH0sXG4gICAgZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uIGVhc2VJbk91dFF1aW50KGkpIHtcbiAgICAgIHJldHVybiAoaSAvPSAwLjUpIDwgMSA/IDAuNSAqIGkgKiBpICogaSAqIGkgKiBpIDogMC41ICogKChpIC09IDIpICogaSAqIGkgKiBpICogaSArIDIpO1xuICAgIH0sXG4gICAgZWFzZUluU2luZTogZnVuY3Rpb24gZWFzZUluU2luZShpKSB7XG4gICAgICByZXR1cm4gLU1hdGguY29zKGkgKiBWKSArIDE7XG4gICAgfSxcbiAgICBlYXNlT3V0U2luZTogZnVuY3Rpb24gZWFzZU91dFNpbmUoaSkge1xuICAgICAgcmV0dXJuIE1hdGguc2luKGkgKiBWKTtcbiAgICB9LFxuICAgIGVhc2VJbk91dFNpbmU6IGZ1bmN0aW9uIGVhc2VJbk91dFNpbmUoaSkge1xuICAgICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5jb3MoRSAqIGkpIC0gMSk7XG4gICAgfSxcbiAgICBlYXNlSW5FeHBvOiBmdW5jdGlvbiBlYXNlSW5FeHBvKGkpIHtcbiAgICAgIHJldHVybiBpID09PSAwID8gMCA6IE1hdGgucG93KDIsIDEwICogKGkgLSAxKSk7XG4gICAgfSxcbiAgICBlYXNlT3V0RXhwbzogZnVuY3Rpb24gZWFzZU91dEV4cG8oaSkge1xuICAgICAgcmV0dXJuIGkgPT09IDEgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIGkpICsgMTtcbiAgICB9LFxuICAgIGVhc2VJbk91dEV4cG86IGZ1bmN0aW9uIGVhc2VJbk91dEV4cG8oaSkge1xuICAgICAgcmV0dXJuIGtlKGkpID8gaSA6IGkgPCAwLjUgPyAwLjUgKiBNYXRoLnBvdygyLCAxMCAqIChpICogMiAtIDEpKSA6IDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKGkgKiAyIC0gMSkpICsgMik7XG4gICAgfSxcbiAgICBlYXNlSW5DaXJjOiBmdW5jdGlvbiBlYXNlSW5DaXJjKGkpIHtcbiAgICAgIHJldHVybiBpID49IDEgPyBpIDogLShNYXRoLnNxcnQoMSAtIGkgKiBpKSAtIDEpO1xuICAgIH0sXG4gICAgZWFzZU91dENpcmM6IGZ1bmN0aW9uIGVhc2VPdXRDaXJjKGkpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoMSAtIChpIC09IDEpICogaSk7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRDaXJjOiBmdW5jdGlvbiBlYXNlSW5PdXRDaXJjKGkpIHtcbiAgICAgIHJldHVybiAoaSAvPSAwLjUpIDwgMSA/IC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBpICogaSkgLSAxKSA6IDAuNSAqIChNYXRoLnNxcnQoMSAtIChpIC09IDIpICogaSkgKyAxKTtcbiAgICB9LFxuICAgIGVhc2VJbkVsYXN0aWM6IGZ1bmN0aW9uIGVhc2VJbkVsYXN0aWMoaSkge1xuICAgICAgcmV0dXJuIGtlKGkpID8gaSA6IG5zKGksIDAuMDc1LCAwLjMpO1xuICAgIH0sXG4gICAgZWFzZU91dEVsYXN0aWM6IGZ1bmN0aW9uIGVhc2VPdXRFbGFzdGljKGkpIHtcbiAgICAgIHJldHVybiBrZShpKSA/IGkgOiBvcyhpLCAwLjA3NSwgMC4zKTtcbiAgICB9LFxuICAgIGVhc2VJbk91dEVsYXN0aWM6IGZ1bmN0aW9uIGVhc2VJbk91dEVsYXN0aWMoaSkge1xuICAgICAgcmV0dXJuIGtlKGkpID8gaSA6IGkgPCAwLjUgPyAwLjUgKiBucyhpICogMiwgMC4xMTI1LCAwLjQ1KSA6IDAuNSArIDAuNSAqIG9zKGkgKiAyIC0gMSwgMC4xMTI1LCAwLjQ1KTtcbiAgICB9LFxuICAgIGVhc2VJbkJhY2s6IGZ1bmN0aW9uIGVhc2VJbkJhY2soaSkge1xuICAgICAgcmV0dXJuIGkgKiBpICogKCgxLjcwMTU4ICsgMSkgKiBpIC0gMS43MDE1OCk7XG4gICAgfSxcbiAgICBlYXNlT3V0QmFjazogZnVuY3Rpb24gZWFzZU91dEJhY2soaSkge1xuICAgICAgcmV0dXJuIChpIC09IDEpICogaSAqICgoMS43MDE1OCArIDEpICogaSArIDEuNzAxNTgpICsgMTtcbiAgICB9LFxuICAgIGVhc2VJbk91dEJhY2s6IGZ1bmN0aW9uIGVhc2VJbk91dEJhY2soaSkge1xuICAgICAgdmFyIHQgPSAxLjcwMTU4O1xuICAgICAgcmV0dXJuIChpIC89IDAuNSkgPCAxID8gMC41ICogKGkgKiBpICogKCgodCAqPSAxLjUyNSkgKyAxKSAqIGkgLSB0KSkgOiAwLjUgKiAoKGkgLT0gMikgKiBpICogKCgodCAqPSAxLjUyNSkgKyAxKSAqIGkgKyB0KSArIDIpO1xuICAgIH0sXG4gICAgZWFzZUluQm91bmNlOiBmdW5jdGlvbiBlYXNlSW5Cb3VuY2UoaSkge1xuICAgICAgcmV0dXJuIDEgLSBoZS5lYXNlT3V0Qm91bmNlKDEgLSBpKTtcbiAgICB9LFxuICAgIGVhc2VPdXRCb3VuY2U6IGZ1bmN0aW9uIGVhc2VPdXRCb3VuY2UoaSkge1xuICAgICAgcmV0dXJuIGkgPCAxIC8gMi43NSA/IDcuNTYyNSAqIGkgKiBpIDogaSA8IDIgLyAyLjc1ID8gNy41NjI1ICogKGkgLT0gMS41IC8gMi43NSkgKiBpICsgMC43NSA6IGkgPCAyLjUgLyAyLjc1ID8gNy41NjI1ICogKGkgLT0gMi4yNSAvIDIuNzUpICogaSArIDAuOTM3NSA6IDcuNTYyNSAqIChpIC09IDIuNjI1IC8gMi43NSkgKiBpICsgMC45ODQzNzU7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRCb3VuY2U6IGZ1bmN0aW9uIGVhc2VJbk91dEJvdW5jZShpKSB7XG4gICAgICByZXR1cm4gaSA8IDAuNSA/IGhlLmVhc2VJbkJvdW5jZShpICogMikgKiAwLjUgOiBoZS5lYXNlT3V0Qm91bmNlKGkgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XG4gICAgfVxuICB9O1xuZnVuY3Rpb24gQmkoaSkge1xuICBpZiAoaSAmJiBfdHlwZW9mKGkpID09IFwib2JqZWN0XCIpIHtcbiAgICB2YXIgdCA9IGkudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdCA9PT0gXCJbb2JqZWN0IENhbnZhc1BhdHRlcm5dXCIgfHwgdCA9PT0gXCJbb2JqZWN0IENhbnZhc0dyYWRpZW50XVwiO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIHJzKGkpIHtcbiAgcmV0dXJuIEJpKGkpID8gaSA6IG5ldyB1ZShpKTtcbn1cbmZ1bmN0aW9uIG5pKGkpIHtcbiAgcmV0dXJuIEJpKGkpID8gaSA6IG5ldyB1ZShpKS5zYXR1cmF0ZSgwLjUpLmRhcmtlbigwLjEpLmhleFN0cmluZygpO1xufVxudmFyIHRyID0gW1wieFwiLCBcInlcIiwgXCJib3JkZXJXaWR0aFwiLCBcInJhZGl1c1wiLCBcInRlbnNpb25cIl0sXG4gIGVyID0gW1wiY29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBcImJhY2tncm91bmRDb2xvclwiXTtcbmZ1bmN0aW9uIGlyKGkpIHtcbiAgaS5zZXQoXCJhbmltYXRpb25cIiwge1xuICAgIGRlbGF5OiB2b2lkIDAsXG4gICAgZHVyYXRpb246IDFlMyxcbiAgICBlYXNpbmc6IFwiZWFzZU91dFF1YXJ0XCIsXG4gICAgZm46IHZvaWQgMCxcbiAgICBmcm9tOiB2b2lkIDAsXG4gICAgbG9vcDogdm9pZCAwLFxuICAgIHRvOiB2b2lkIDAsXG4gICAgdHlwZTogdm9pZCAwXG4gIH0pLCBpLmRlc2NyaWJlKFwiYW5pbWF0aW9uXCIsIHtcbiAgICBfZmFsbGJhY2s6ICExLFxuICAgIF9pbmRleGFibGU6ICExLFxuICAgIF9zY3JpcHRhYmxlOiBmdW5jdGlvbiBfc2NyaXB0YWJsZSh0KSB7XG4gICAgICByZXR1cm4gdCAhPT0gXCJvblByb2dyZXNzXCIgJiYgdCAhPT0gXCJvbkNvbXBsZXRlXCIgJiYgdCAhPT0gXCJmblwiO1xuICAgIH1cbiAgfSksIGkuc2V0KFwiYW5pbWF0aW9uc1wiLCB7XG4gICAgY29sb3JzOiB7XG4gICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICBwcm9wZXJ0aWVzOiBlclxuICAgIH0sXG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgIHByb3BlcnRpZXM6IHRyXG4gICAgfVxuICB9KSwgaS5kZXNjcmliZShcImFuaW1hdGlvbnNcIiwge1xuICAgIF9mYWxsYmFjazogXCJhbmltYXRpb25cIlxuICB9KSwgaS5zZXQoXCJ0cmFuc2l0aW9uc1wiLCB7XG4gICAgYWN0aXZlOiB7XG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgZHVyYXRpb246IDQwMFxuICAgICAgfVxuICAgIH0sXG4gICAgcmVzaXplOiB7XG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgZHVyYXRpb246IDBcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3c6IHtcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgZnJvbTogXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgIH0sXG4gICAgICAgIHZpc2libGU6IHtcbiAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBoaWRlOiB7XG4gICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgIGNvbG9yczoge1xuICAgICAgICAgIHRvOiBcInRyYW5zcGFyZW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJsZToge1xuICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgIGVhc2luZzogXCJsaW5lYXJcIixcbiAgICAgICAgICBmbjogZnVuY3Rpb24gZm4odCkge1xuICAgICAgICAgICAgcmV0dXJuIHQgfCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBzcihpKSB7XG4gIGkuc2V0KFwibGF5b3V0XCIsIHtcbiAgICBhdXRvUGFkZGluZzogITAsXG4gICAgcGFkZGluZzoge1xuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfVxuICB9KTtcbn1cbnZhciBhcyA9IC8qIEBfX1BVUkVfXyAqL25ldyBNYXAoKTtcbmZ1bmN0aW9uIG5yKGksIHQpIHtcbiAgdCA9IHQgfHwge307XG4gIHZhciBlID0gaSArIEpTT04uc3RyaW5naWZ5KHQpO1xuICB2YXIgcyA9IGFzLmdldChlKTtcbiAgcmV0dXJuIHMgfHwgKHMgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQoaSwgdCksIGFzLnNldChlLCBzKSksIHM7XG59XG5mdW5jdGlvbiBIaShpLCB0LCBlKSB7XG4gIHJldHVybiBucih0LCBlKS5mb3JtYXQoaSk7XG59XG52YXIgb3IgPSB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKGkpIHtcbiAgICByZXR1cm4gTihpKSA/IGkgOiBcIlwiICsgaTtcbiAgfSxcbiAgbnVtZXJpYzogZnVuY3Rpb24gbnVtZXJpYyhpLCB0LCBlKSB7XG4gICAgaWYgKGkgPT09IDApIHJldHVybiBcIjBcIjtcbiAgICB2YXIgcyA9IHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGU7XG4gICAgdmFyIG4sXG4gICAgICBvID0gaTtcbiAgICBpZiAoZS5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgYyA9IE1hdGgubWF4KE1hdGguYWJzKGVbMF0udmFsdWUpLCBNYXRoLmFicyhlW2UubGVuZ3RoIC0gMV0udmFsdWUpKTtcbiAgICAgIChjIDwgMWUtNCB8fCBjID4gMWUxNSkgJiYgKG4gPSBcInNjaWVudGlmaWNcIiksIG8gPSBycihpLCBlKTtcbiAgICB9XG4gICAgdmFyIHIgPSB4bihNYXRoLmFicyhvKSksXG4gICAgICBhID0gaXNOYU4ocikgPyAxIDogTWF0aC5tYXgoTWF0aC5taW4oLTEgKiBNYXRoLmZsb29yKHIpLCAyMCksIDApLFxuICAgICAgbCA9IHtcbiAgICAgICAgbm90YXRpb246IG4sXG4gICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogYSxcbiAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBhXG4gICAgICB9O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGwsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpLCBIaShpLCBzLCBsKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJyKGksIHQpIHtcbiAgdmFyIGUgPSB0Lmxlbmd0aCA+IDMgPyB0WzJdLnZhbHVlIC0gdFsxXS52YWx1ZSA6IHRbMV0udmFsdWUgLSB0WzBdLnZhbHVlO1xuICByZXR1cm4gTWF0aC5hYnMoZSkgPj0gMSAmJiBpICE9PSBNYXRoLmZsb29yKGkpICYmIChlID0gaSAtIE1hdGguZmxvb3IoaSkpLCBlO1xufVxudmFyIERuID0ge1xuICBmb3JtYXR0ZXJzOiBvclxufTtcbmZ1bmN0aW9uIGFyKGkpIHtcbiAgaS5zZXQoXCJzY2FsZVwiLCB7XG4gICAgZGlzcGxheTogITAsXG4gICAgb2Zmc2V0OiAhMSxcbiAgICByZXZlcnNlOiAhMSxcbiAgICBiZWdpbkF0WmVybzogITEsXG4gICAgYm91bmRzOiBcInRpY2tzXCIsXG4gICAgY2xpcDogITAsXG4gICAgZ3JhY2U6IDAsXG4gICAgZ3JpZDoge1xuICAgICAgZGlzcGxheTogITAsXG4gICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICBkcmF3T25DaGFydEFyZWE6ICEwLFxuICAgICAgZHJhd1RpY2tzOiAhMCxcbiAgICAgIHRpY2tMZW5ndGg6IDgsXG4gICAgICB0aWNrV2lkdGg6IGZ1bmN0aW9uIHRpY2tXaWR0aCh0LCBlKSB7XG4gICAgICAgIHJldHVybiBlLmxpbmVXaWR0aDtcbiAgICAgIH0sXG4gICAgICB0aWNrQ29sb3I6IGZ1bmN0aW9uIHRpY2tDb2xvcih0LCBlKSB7XG4gICAgICAgIHJldHVybiBlLmNvbG9yO1xuICAgICAgfSxcbiAgICAgIG9mZnNldDogITFcbiAgICB9LFxuICAgIGJvcmRlcjoge1xuICAgICAgZGlzcGxheTogITAsXG4gICAgICBkYXNoOiBbXSxcbiAgICAgIGRhc2hPZmZzZXQ6IDAsXG4gICAgICB3aWR0aDogMVxuICAgIH0sXG4gICAgdGl0bGU6IHtcbiAgICAgIGRpc3BsYXk6ICExLFxuICAgICAgdGV4dDogXCJcIixcbiAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgdG9wOiA0LFxuICAgICAgICBib3R0b206IDRcbiAgICAgIH1cbiAgICB9LFxuICAgIHRpY2tzOiB7XG4gICAgICBtaW5Sb3RhdGlvbjogMCxcbiAgICAgIG1heFJvdGF0aW9uOiA1MCxcbiAgICAgIG1pcnJvcjogITEsXG4gICAgICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gICAgICB0ZXh0U3Ryb2tlQ29sb3I6IFwiXCIsXG4gICAgICBwYWRkaW5nOiAzLFxuICAgICAgZGlzcGxheTogITAsXG4gICAgICBhdXRvU2tpcDogITAsXG4gICAgICBhdXRvU2tpcFBhZGRpbmc6IDMsXG4gICAgICBsYWJlbE9mZnNldDogMCxcbiAgICAgIGNhbGxiYWNrOiBEbi5mb3JtYXR0ZXJzLnZhbHVlcyxcbiAgICAgIG1pbm9yOiB7fSxcbiAgICAgIG1ham9yOiB7fSxcbiAgICAgIGFsaWduOiBcImNlbnRlclwiLFxuICAgICAgY3Jvc3NBbGlnbjogXCJuZWFyXCIsXG4gICAgICBzaG93TGFiZWxCYWNrZHJvcDogITEsXG4gICAgICBiYWNrZHJvcENvbG9yOiBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSlcIixcbiAgICAgIGJhY2tkcm9wUGFkZGluZzogMlxuICAgIH1cbiAgfSksIGkucm91dGUoXCJzY2FsZS50aWNrc1wiLCBcImNvbG9yXCIsIFwiXCIsIFwiY29sb3JcIiksIGkucm91dGUoXCJzY2FsZS5ncmlkXCIsIFwiY29sb3JcIiwgXCJcIiwgXCJib3JkZXJDb2xvclwiKSwgaS5yb3V0ZShcInNjYWxlLmJvcmRlclwiLCBcImNvbG9yXCIsIFwiXCIsIFwiYm9yZGVyQ29sb3JcIiksIGkucm91dGUoXCJzY2FsZS50aXRsZVwiLCBcImNvbG9yXCIsIFwiXCIsIFwiY29sb3JcIiksIGkuZGVzY3JpYmUoXCJzY2FsZVwiLCB7XG4gICAgX2ZhbGxiYWNrOiAhMSxcbiAgICBfc2NyaXB0YWJsZTogZnVuY3Rpb24gX3NjcmlwdGFibGUodCkge1xuICAgICAgcmV0dXJuICF0LnN0YXJ0c1dpdGgoXCJiZWZvcmVcIikgJiYgIXQuc3RhcnRzV2l0aChcImFmdGVyXCIpICYmIHQgIT09IFwiY2FsbGJhY2tcIiAmJiB0ICE9PSBcInBhcnNlclwiO1xuICAgIH0sXG4gICAgX2luZGV4YWJsZTogZnVuY3Rpb24gX2luZGV4YWJsZSh0KSB7XG4gICAgICByZXR1cm4gdCAhPT0gXCJib3JkZXJEYXNoXCIgJiYgdCAhPT0gXCJ0aWNrQm9yZGVyRGFzaFwiICYmIHQgIT09IFwiZGFzaFwiO1xuICAgIH1cbiAgfSksIGkuZGVzY3JpYmUoXCJzY2FsZXNcIiwge1xuICAgIF9mYWxsYmFjazogXCJzY2FsZVwiXG4gIH0pLCBpLmRlc2NyaWJlKFwic2NhbGUudGlja3NcIiwge1xuICAgIF9zY3JpcHRhYmxlOiBmdW5jdGlvbiBfc2NyaXB0YWJsZSh0KSB7XG4gICAgICByZXR1cm4gdCAhPT0gXCJiYWNrZHJvcFBhZGRpbmdcIiAmJiB0ICE9PSBcImNhbGxiYWNrXCI7XG4gICAgfSxcbiAgICBfaW5kZXhhYmxlOiBmdW5jdGlvbiBfaW5kZXhhYmxlKHQpIHtcbiAgICAgIHJldHVybiB0ICE9PSBcImJhY2tkcm9wUGFkZGluZ1wiO1xuICAgIH1cbiAgfSk7XG59XG52YXIgenQgPSAvKiBAX19QVVJFX18gKi9PYmplY3QuY3JlYXRlKG51bGwpLFxuICBNaSA9IC8qIEBfX1BVUkVfXyAqL09iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBkZShpLCB0KSB7XG4gIGlmICghdCkgcmV0dXJuIGk7XG4gIHZhciBlID0gdC5zcGxpdChcIi5cIik7XG4gIGZvciAodmFyIHMgPSAwLCBuID0gZS5sZW5ndGg7IHMgPCBuOyArK3MpIHtcbiAgICB2YXIgbyA9IGVbc107XG4gICAgaSA9IGlbb10gfHwgKGlbb10gPSAvKiBAX19QVVJFX18gKi9PYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIG9pKGksIHQsIGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyBmZShkZShpLCB0KSwgZSkgOiBmZShkZShpLCBcIlwiKSwgdCk7XG59XG52YXIgbHIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBscih0LCBlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIGxyKTtcbiAgICB0aGlzLmFuaW1hdGlvbiA9IHZvaWQgMCwgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBcInJnYmEoMCwwLDAsMC4xKVwiLCB0aGlzLmJvcmRlckNvbG9yID0gXCJyZ2JhKDAsMCwwLDAuMSlcIiwgdGhpcy5jb2xvciA9IFwiIzY2NlwiLCB0aGlzLmRhdGFzZXRzID0ge30sIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcy5jaGFydC5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgfSwgdGhpcy5lbGVtZW50cyA9IHt9LCB0aGlzLmV2ZW50cyA9IFtcIm1vdXNlbW92ZVwiLCBcIm1vdXNlb3V0XCIsIFwiY2xpY2tcIiwgXCJ0b3VjaHN0YXJ0XCIsIFwidG91Y2htb3ZlXCJdLCB0aGlzLmZvbnQgPSB7XG4gICAgICBmYW1pbHk6IFwiJ0hlbHZldGljYSBOZXVlJywgJ0hlbHZldGljYScsICdBcmlhbCcsIHNhbnMtc2VyaWZcIixcbiAgICAgIHNpemU6IDEyLFxuICAgICAgc3R5bGU6IFwibm9ybWFsXCIsXG4gICAgICBsaW5lSGVpZ2h0OiAxLjIsXG4gICAgICB3ZWlnaHQ6IG51bGxcbiAgICB9LCB0aGlzLmhvdmVyID0ge30sIHRoaXMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPSBmdW5jdGlvbiAocywgbikge1xuICAgICAgcmV0dXJuIG5pKG4uYmFja2dyb3VuZENvbG9yKTtcbiAgICB9LCB0aGlzLmhvdmVyQm9yZGVyQ29sb3IgPSBmdW5jdGlvbiAocywgbikge1xuICAgICAgcmV0dXJuIG5pKG4uYm9yZGVyQ29sb3IpO1xuICAgIH0sIHRoaXMuaG92ZXJDb2xvciA9IGZ1bmN0aW9uIChzLCBuKSB7XG4gICAgICByZXR1cm4gbmkobi5jb2xvcik7XG4gICAgfSwgdGhpcy5pbmRleEF4aXMgPSBcInhcIiwgdGhpcy5pbnRlcmFjdGlvbiA9IHtcbiAgICAgIG1vZGU6IFwibmVhcmVzdFwiLFxuICAgICAgaW50ZXJzZWN0OiAhMCxcbiAgICAgIGluY2x1ZGVJbnZpc2libGU6ICExXG4gICAgfSwgdGhpcy5tYWludGFpbkFzcGVjdFJhdGlvID0gITAsIHRoaXMub25Ib3ZlciA9IG51bGwsIHRoaXMub25DbGljayA9IG51bGwsIHRoaXMucGFyc2luZyA9ICEwLCB0aGlzLnBsdWdpbnMgPSB7fSwgdGhpcy5yZXNwb25zaXZlID0gITAsIHRoaXMuc2NhbGUgPSB2b2lkIDAsIHRoaXMuc2NhbGVzID0ge30sIHRoaXMuc2hvd0xpbmUgPSAhMCwgdGhpcy5kcmF3QWN0aXZlRWxlbWVudHNPblRvcCA9ICEwLCB0aGlzLmRlc2NyaWJlKHQpLCB0aGlzLmFwcGx5KGUpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MobHIsIFt7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQodCwgZSkge1xuICAgICAgcmV0dXJuIG9pKHRoaXMsIHQsIGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KHQpIHtcbiAgICAgIHJldHVybiBkZSh0aGlzLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzY3JpYmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzY3JpYmUodCwgZSkge1xuICAgICAgcmV0dXJuIG9pKE1pLCB0LCBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3ZlcnJpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3ZlcnJpZGUodCwgZSkge1xuICAgICAgcmV0dXJuIG9pKHp0LCB0LCBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm91dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm91dGUodCwgZSwgcywgbikge1xuICAgICAgdmFyIG8gPSBkZSh0aGlzLCB0KSxcbiAgICAgICAgciA9IGRlKHRoaXMsIHMpLFxuICAgICAgICBhID0gXCJfXCIgKyBlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobywgX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eSh7fSwgYSwge1xuICAgICAgICB2YWx1ZTogb1tlXSxcbiAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICB9KSwgZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgdmFyIGwgPSB0aGlzW2FdLFxuICAgICAgICAgICAgYyA9IHJbbl07XG4gICAgICAgICAgcmV0dXJuIFQobCkgPyBPYmplY3QuYXNzaWduKHt9LCBjLCBsKSA6IEQobCwgYyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGwpIHtcbiAgICAgICAgICB0aGlzW2FdID0gbDtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseSh0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHQuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZShfdGhpczIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG59KCk7XG52YXIgVyA9IC8qIEBfX1BVUkVfXyAqL25ldyBscih7XG4gIF9zY3JpcHRhYmxlOiBmdW5jdGlvbiBfc2NyaXB0YWJsZShpKSB7XG4gICAgcmV0dXJuICFpLnN0YXJ0c1dpdGgoXCJvblwiKTtcbiAgfSxcbiAgX2luZGV4YWJsZTogZnVuY3Rpb24gX2luZGV4YWJsZShpKSB7XG4gICAgcmV0dXJuIGkgIT09IFwiZXZlbnRzXCI7XG4gIH0sXG4gIGhvdmVyOiB7XG4gICAgX2ZhbGxiYWNrOiBcImludGVyYWN0aW9uXCJcbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBfc2NyaXB0YWJsZTogITEsXG4gICAgX2luZGV4YWJsZTogITFcbiAgfVxufSwgW2lyLCBzciwgYXJdKTtcbmZ1bmN0aW9uIGNyKGkpIHtcbiAgcmV0dXJuICFpIHx8IFIoaS5zaXplKSB8fCBSKGkuZmFtaWx5KSA/IG51bGwgOiAoaS5zdHlsZSA/IGkuc3R5bGUgKyBcIiBcIiA6IFwiXCIpICsgKGkud2VpZ2h0ID8gaS53ZWlnaHQgKyBcIiBcIiA6IFwiXCIpICsgaS5zaXplICsgXCJweCBcIiArIGkuZmFtaWx5O1xufVxuZnVuY3Rpb24gbHMoaSwgdCwgZSwgcywgbikge1xuICB2YXIgbyA9IHRbbl07XG4gIHJldHVybiBvIHx8IChvID0gdFtuXSA9IGkubWVhc3VyZVRleHQobikud2lkdGgsIGUucHVzaChuKSksIG8gPiBzICYmIChzID0gbyksIHM7XG59XG5mdW5jdGlvbiBPdChpLCB0LCBlKSB7XG4gIHZhciBzID0gaS5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyxcbiAgICBuID0gZSAhPT0gMCA/IE1hdGgubWF4KGUgLyAyLCAwLjUpIDogMDtcbiAgcmV0dXJuIE1hdGgucm91bmQoKHQgLSBuKSAqIHMpIC8gcyArIG47XG59XG5mdW5jdGlvbiBjcyhpLCB0KSB7XG4gICF0ICYmICFpIHx8ICh0ID0gdCB8fCBpLmdldENvbnRleHQoXCIyZFwiKSwgdC5zYXZlKCksIHQucmVzZXRUcmFuc2Zvcm0oKSwgdC5jbGVhclJlY3QoMCwgMCwgaS53aWR0aCwgaS5oZWlnaHQpLCB0LnJlc3RvcmUoKSk7XG59XG5mdW5jdGlvbiBTaShpLCB0LCBlLCBzKSB7XG4gIENuKGksIHQsIGUsIHMsIG51bGwpO1xufVxuZnVuY3Rpb24gQ24oaSwgdCwgZSwgcywgbikge1xuICB2YXIgbywgciwgYSwgbCwgYywgaCwgZCwgdTtcbiAgdmFyIGYgPSB0LnBvaW50U3R5bGUsXG4gICAgcCA9IHQucm90YXRpb24sXG4gICAgZyA9IHQucmFkaXVzO1xuICB2YXIgbSA9IChwIHx8IDApICogTm87XG4gIGlmIChmICYmIF90eXBlb2YoZikgPT0gXCJvYmplY3RcIiAmJiAobyA9IGYudG9TdHJpbmcoKSwgbyA9PT0gXCJbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdXCIgfHwgbyA9PT0gXCJbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XVwiKSkge1xuICAgIGkuc2F2ZSgpLCBpLnRyYW5zbGF0ZShlLCBzKSwgaS5yb3RhdGUobSksIGkuZHJhd0ltYWdlKGYsIC1mLndpZHRoIC8gMiwgLWYuaGVpZ2h0IC8gMiwgZi53aWR0aCwgZi5oZWlnaHQpLCBpLnJlc3RvcmUoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoaXNOYU4oZykgfHwgZyA8PSAwKSkge1xuICAgIHN3aXRjaCAoaS5iZWdpblBhdGgoKSwgZikge1xuICAgICAgLy8gRGVmYXVsdCBpbmNsdWRlcyBjaXJjbGVcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG4gPyBpLmVsbGlwc2UoZSwgcywgbiAvIDIsIGcsIDAsIDAsIEIpIDogaS5hcmMoZSwgcywgZywgMCwgQiksIGkuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRyaWFuZ2xlXCI6XG4gICAgICAgIGggPSBuID8gbiAvIDIgOiBnLCBpLm1vdmVUbyhlICsgTWF0aC5zaW4obSkgKiBoLCBzIC0gTWF0aC5jb3MobSkgKiBnKSwgbSArPSB0cywgaS5saW5lVG8oZSArIE1hdGguc2luKG0pICogaCwgcyAtIE1hdGguY29zKG0pICogZyksIG0gKz0gdHMsIGkubGluZVRvKGUgKyBNYXRoLnNpbihtKSAqIGgsIHMgLSBNYXRoLmNvcyhtKSAqIGcpLCBpLmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyZWN0Um91bmRlZFwiOlxuICAgICAgICBjID0gZyAqIDAuNTE2LCBsID0gZyAtIGMsIHIgPSBNYXRoLmNvcyhtICsgQ3QpICogbCwgZCA9IE1hdGguY29zKG0gKyBDdCkgKiAobiA/IG4gLyAyIC0gYyA6IGwpLCBhID0gTWF0aC5zaW4obSArIEN0KSAqIGwsIHUgPSBNYXRoLnNpbihtICsgQ3QpICogKG4gPyBuIC8gMiAtIGMgOiBsKSwgaS5hcmMoZSAtIGQsIHMgLSBhLCBjLCBtIC0gRSwgbSAtIFYpLCBpLmFyYyhlICsgdSwgcyAtIHIsIGMsIG0gLSBWLCBtKSwgaS5hcmMoZSArIGQsIHMgKyBhLCBjLCBtLCBtICsgViksIGkuYXJjKGUgLSB1LCBzICsgciwgYywgbSArIFYsIG0gKyBFKSwgaS5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmVjdFwiOlxuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICBsID0gTWF0aC5TUVJUMV8yICogZywgaCA9IG4gPyBuIC8gMiA6IGwsIGkucmVjdChlIC0gaCwgcyAtIGwsIDIgKiBoLCAyICogbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbSArPSBDdDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgXCJyZWN0Um90XCI6XG4gICAgICAgIGQgPSBNYXRoLmNvcyhtKSAqIChuID8gbiAvIDIgOiBnKSwgciA9IE1hdGguY29zKG0pICogZywgYSA9IE1hdGguc2luKG0pICogZywgdSA9IE1hdGguc2luKG0pICogKG4gPyBuIC8gMiA6IGcpLCBpLm1vdmVUbyhlIC0gZCwgcyAtIGEpLCBpLmxpbmVUbyhlICsgdSwgcyAtIHIpLCBpLmxpbmVUbyhlICsgZCwgcyArIGEpLCBpLmxpbmVUbyhlIC0gdSwgcyArIHIpLCBpLmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjcm9zc1JvdFwiOlxuICAgICAgICBtICs9IEN0O1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBcImNyb3NzXCI6XG4gICAgICAgIGQgPSBNYXRoLmNvcyhtKSAqIChuID8gbiAvIDIgOiBnKSwgciA9IE1hdGguY29zKG0pICogZywgYSA9IE1hdGguc2luKG0pICogZywgdSA9IE1hdGguc2luKG0pICogKG4gPyBuIC8gMiA6IGcpLCBpLm1vdmVUbyhlIC0gZCwgcyAtIGEpLCBpLmxpbmVUbyhlICsgZCwgcyArIGEpLCBpLm1vdmVUbyhlICsgdSwgcyAtIHIpLCBpLmxpbmVUbyhlIC0gdSwgcyArIHIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzdGFyXCI6XG4gICAgICAgIGQgPSBNYXRoLmNvcyhtKSAqIChuID8gbiAvIDIgOiBnKSwgciA9IE1hdGguY29zKG0pICogZywgYSA9IE1hdGguc2luKG0pICogZywgdSA9IE1hdGguc2luKG0pICogKG4gPyBuIC8gMiA6IGcpLCBpLm1vdmVUbyhlIC0gZCwgcyAtIGEpLCBpLmxpbmVUbyhlICsgZCwgcyArIGEpLCBpLm1vdmVUbyhlICsgdSwgcyAtIHIpLCBpLmxpbmVUbyhlIC0gdSwgcyArIHIpLCBtICs9IEN0LCBkID0gTWF0aC5jb3MobSkgKiAobiA/IG4gLyAyIDogZyksIHIgPSBNYXRoLmNvcyhtKSAqIGcsIGEgPSBNYXRoLnNpbihtKSAqIGcsIHUgPSBNYXRoLnNpbihtKSAqIChuID8gbiAvIDIgOiBnKSwgaS5tb3ZlVG8oZSAtIGQsIHMgLSBhKSwgaS5saW5lVG8oZSArIGQsIHMgKyBhKSwgaS5tb3ZlVG8oZSArIHUsIHMgLSByKSwgaS5saW5lVG8oZSAtIHUsIHMgKyByKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICByID0gbiA/IG4gLyAyIDogTWF0aC5jb3MobSkgKiBnLCBhID0gTWF0aC5zaW4obSkgKiBnLCBpLm1vdmVUbyhlIC0gciwgcyAtIGEpLCBpLmxpbmVUbyhlICsgciwgcyArIGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkYXNoXCI6XG4gICAgICAgIGkubW92ZVRvKGUsIHMpLCBpLmxpbmVUbyhlICsgTWF0aC5jb3MobSkgKiAobiA/IG4gLyAyIDogZyksIHMgKyBNYXRoLnNpbihtKSAqIGcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgITE6XG4gICAgICAgIGkuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpLmZpbGwoKSwgdC5ib3JkZXJXaWR0aCA+IDAgJiYgaS5zdHJva2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gbWUoaSwgdCwgZSkge1xuICByZXR1cm4gZSA9IGUgfHwgMC41LCAhdCB8fCBpICYmIGkueCA+IHQubGVmdCAtIGUgJiYgaS54IDwgdC5yaWdodCArIGUgJiYgaS55ID4gdC50b3AgLSBlICYmIGkueSA8IHQuYm90dG9tICsgZTtcbn1cbmZ1bmN0aW9uIEplKGksIHQpIHtcbiAgaS5zYXZlKCksIGkuYmVnaW5QYXRoKCksIGkucmVjdCh0LmxlZnQsIHQudG9wLCB0LnJpZ2h0IC0gdC5sZWZ0LCB0LmJvdHRvbSAtIHQudG9wKSwgaS5jbGlwKCk7XG59XG5mdW5jdGlvbiBaZShpKSB7XG4gIGkucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gaHIoaSwgdCwgZSwgcywgbikge1xuICBpZiAoIXQpIHJldHVybiBpLmxpbmVUbyhlLngsIGUueSk7XG4gIGlmIChuID09PSBcIm1pZGRsZVwiKSB7XG4gICAgdmFyIG8gPSAodC54ICsgZS54KSAvIDI7XG4gICAgaS5saW5lVG8obywgdC55KSwgaS5saW5lVG8obywgZS55KTtcbiAgfSBlbHNlIG4gPT09IFwiYWZ0ZXJcIiAhPSAhIXMgPyBpLmxpbmVUbyh0LngsIGUueSkgOiBpLmxpbmVUbyhlLngsIHQueSk7XG4gIGkubGluZVRvKGUueCwgZS55KTtcbn1cbmZ1bmN0aW9uIGRyKGksIHQsIGUsIHMpIHtcbiAgaWYgKCF0KSByZXR1cm4gaS5saW5lVG8oZS54LCBlLnkpO1xuICBpLmJlemllckN1cnZlVG8ocyA/IHQuY3AxeCA6IHQuY3AyeCwgcyA/IHQuY3AxeSA6IHQuY3AyeSwgcyA/IGUuY3AyeCA6IGUuY3AxeCwgcyA/IGUuY3AyeSA6IGUuY3AxeSwgZS54LCBlLnkpO1xufVxuZnVuY3Rpb24gdXIoaSwgdCkge1xuICB0LnRyYW5zbGF0aW9uICYmIGkudHJhbnNsYXRlKHQudHJhbnNsYXRpb25bMF0sIHQudHJhbnNsYXRpb25bMV0pLCBSKHQucm90YXRpb24pIHx8IGkucm90YXRlKHQucm90YXRpb24pLCB0LmNvbG9yICYmIChpLmZpbGxTdHlsZSA9IHQuY29sb3IpLCB0LnRleHRBbGlnbiAmJiAoaS50ZXh0QWxpZ24gPSB0LnRleHRBbGlnbiksIHQudGV4dEJhc2VsaW5lICYmIChpLnRleHRCYXNlbGluZSA9IHQudGV4dEJhc2VsaW5lKTtcbn1cbmZ1bmN0aW9uIGZyKGksIHQsIGUsIHMsIG4pIHtcbiAgaWYgKG4uc3RyaWtldGhyb3VnaCB8fCBuLnVuZGVybGluZSkge1xuICAgIHZhciBvID0gaS5tZWFzdXJlVGV4dChzKSxcbiAgICAgIHIgPSB0IC0gby5hY3R1YWxCb3VuZGluZ0JveExlZnQsXG4gICAgICBhID0gdCArIG8uYWN0dWFsQm91bmRpbmdCb3hSaWdodCxcbiAgICAgIGwgPSBlIC0gby5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCxcbiAgICAgIGMgPSBlICsgby5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICBoID0gbi5zdHJpa2V0aHJvdWdoID8gKGwgKyBjKSAvIDIgOiBjO1xuICAgIGkuc3Ryb2tlU3R5bGUgPSBpLmZpbGxTdHlsZSwgaS5iZWdpblBhdGgoKSwgaS5saW5lV2lkdGggPSBuLmRlY29yYXRpb25XaWR0aCB8fCAyLCBpLm1vdmVUbyhyLCBoKSwgaS5saW5lVG8oYSwgaCksIGkuc3Ryb2tlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdyKGksIHQpIHtcbiAgdmFyIGUgPSBpLmZpbGxTdHlsZTtcbiAgaS5maWxsU3R5bGUgPSB0LmNvbG9yLCBpLmZpbGxSZWN0KHQubGVmdCwgdC50b3AsIHQud2lkdGgsIHQuaGVpZ2h0KSwgaS5maWxsU3R5bGUgPSBlO1xufVxuZnVuY3Rpb24gYmUoaSwgdCwgZSwgcywgbikge1xuICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge307XG4gIHZhciByID0gTih0KSA/IHQgOiBbdF0sXG4gICAgYSA9IG8uc3Ryb2tlV2lkdGggPiAwICYmIG8uc3Ryb2tlQ29sb3IgIT09IFwiXCI7XG4gIHZhciBsLCBjO1xuICBmb3IgKGkuc2F2ZSgpLCBpLmZvbnQgPSBuLnN0cmluZywgdXIoaSwgbyksIGwgPSAwOyBsIDwgci5sZW5ndGg7ICsrbCkgYyA9IHJbbF0sIG8uYmFja2Ryb3AgJiYgZ3IoaSwgby5iYWNrZHJvcCksIGEgJiYgKG8uc3Ryb2tlQ29sb3IgJiYgKGkuc3Ryb2tlU3R5bGUgPSBvLnN0cm9rZUNvbG9yKSwgUihvLnN0cm9rZVdpZHRoKSB8fCAoaS5saW5lV2lkdGggPSBvLnN0cm9rZVdpZHRoKSwgaS5zdHJva2VUZXh0KGMsIGUsIHMsIG8ubWF4V2lkdGgpKSwgaS5maWxsVGV4dChjLCBlLCBzLCBvLm1heFdpZHRoKSwgZnIoaSwgZSwgcywgYywgbyksIHMgKz0gTnVtYmVyKG4ubGluZUhlaWdodCk7XG4gIGkucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gVWUoaSwgdCkge1xuICB2YXIgZSA9IHQueCxcbiAgICBzID0gdC55LFxuICAgIG4gPSB0LncsXG4gICAgbyA9IHQuaCxcbiAgICByID0gdC5yYWRpdXM7XG4gIGkuYXJjKGUgKyByLnRvcExlZnQsIHMgKyByLnRvcExlZnQsIHIudG9wTGVmdCwgMS41ICogRSwgRSwgITApLCBpLmxpbmVUbyhlLCBzICsgbyAtIHIuYm90dG9tTGVmdCksIGkuYXJjKGUgKyByLmJvdHRvbUxlZnQsIHMgKyBvIC0gci5ib3R0b21MZWZ0LCByLmJvdHRvbUxlZnQsIEUsIFYsICEwKSwgaS5saW5lVG8oZSArIG4gLSByLmJvdHRvbVJpZ2h0LCBzICsgbyksIGkuYXJjKGUgKyBuIC0gci5ib3R0b21SaWdodCwgcyArIG8gLSByLmJvdHRvbVJpZ2h0LCByLmJvdHRvbVJpZ2h0LCBWLCAwLCAhMCksIGkubGluZVRvKGUgKyBuLCBzICsgci50b3BSaWdodCksIGkuYXJjKGUgKyBuIC0gci50b3BSaWdodCwgcyArIHIudG9wUmlnaHQsIHIudG9wUmlnaHQsIDAsIC1WLCAhMCksIGkubGluZVRvKGUgKyByLnRvcExlZnQsIHMpO1xufVxudmFyIHByID0gL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC8sXG4gIG1yID0gL14obm9ybWFsfGl0YWxpY3xpbml0aWFsfGluaGVyaXR8dW5zZXR8KG9ibGlxdWUoIC0/WzAtOV0/WzAtOV1kZWcpPykpJC87XG5mdW5jdGlvbiBicihpLCB0KSB7XG4gIHZhciBlID0gKFwiXCIgKyBpKS5tYXRjaChwcik7XG4gIGlmICghZSB8fCBlWzFdID09PSBcIm5vcm1hbFwiKSByZXR1cm4gdCAqIDEuMjtcbiAgc3dpdGNoIChpID0gK2VbMl0sIGVbM10pIHtcbiAgICBjYXNlIFwicHhcIjpcbiAgICAgIHJldHVybiBpO1xuICAgIGNhc2UgXCIlXCI6XG4gICAgICBpIC89IDEwMDtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB0ICogaTtcbn1cbnZhciBfciA9IGZ1bmN0aW9uIF9yKGkpIHtcbiAgcmV0dXJuICtpIHx8IDA7XG59O1xuZnVuY3Rpb24gV2koaSwgdCkge1xuICB2YXIgZSA9IHt9LFxuICAgIHMgPSBUKHQpLFxuICAgIG4gPSBzID8gT2JqZWN0LmtleXModCkgOiB0LFxuICAgIG8gPSBUKGkpID8gcyA/IGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gRChpW3JdLCBpW3Rbcl1dKTtcbiAgICB9IDogZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiBpW3JdO1xuICAgIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9O1xuICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG4pLFxuICAgIF9zdGVwNDtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgdmFyIHIgPSBfc3RlcDQudmFsdWU7XG4gICAgICBlW3JdID0gX3IobyhyKSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3I0LmYoKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIE9uKGkpIHtcbiAgcmV0dXJuIFdpKGksIHtcbiAgICB0b3A6IFwieVwiLFxuICAgIHJpZ2h0OiBcInhcIixcbiAgICBib3R0b206IFwieVwiLFxuICAgIGxlZnQ6IFwieFwiXG4gIH0pO1xufVxuZnVuY3Rpb24gWXQoaSkge1xuICByZXR1cm4gV2koaSwgW1widG9wTGVmdFwiLCBcInRvcFJpZ2h0XCIsIFwiYm90dG9tTGVmdFwiLCBcImJvdHRvbVJpZ2h0XCJdKTtcbn1cbmZ1bmN0aW9uIGV0KGkpIHtcbiAgdmFyIHQgPSBPbihpKTtcbiAgcmV0dXJuIHQud2lkdGggPSB0LmxlZnQgKyB0LnJpZ2h0LCB0LmhlaWdodCA9IHQudG9wICsgdC5ib3R0b20sIHQ7XG59XG5mdW5jdGlvbiBYKGksIHQpIHtcbiAgaSA9IGkgfHwge30sIHQgPSB0IHx8IFcuZm9udDtcbiAgdmFyIGUgPSBEKGkuc2l6ZSwgdC5zaXplKTtcbiAgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiAmJiAoZSA9IHBhcnNlSW50KGUsIDEwKSk7XG4gIHZhciBzID0gRChpLnN0eWxlLCB0LnN0eWxlKTtcbiAgcyAmJiAhKFwiXCIgKyBzKS5tYXRjaChtcikgJiYgKGNvbnNvbGUud2FybignSW52YWxpZCBmb250IHN0eWxlIHNwZWNpZmllZDogXCInICsgcyArICdcIicpLCBzID0gdm9pZCAwKTtcbiAgdmFyIG4gPSB7XG4gICAgZmFtaWx5OiBEKGkuZmFtaWx5LCB0LmZhbWlseSksXG4gICAgbGluZUhlaWdodDogYnIoRChpLmxpbmVIZWlnaHQsIHQubGluZUhlaWdodCksIGUpLFxuICAgIHNpemU6IGUsXG4gICAgc3R5bGU6IHMsXG4gICAgd2VpZ2h0OiBEKGkud2VpZ2h0LCB0LndlaWdodCksXG4gICAgc3RyaW5nOiBcIlwiXG4gIH07XG4gIHJldHVybiBuLnN0cmluZyA9IGNyKG4pLCBuO1xufVxuZnVuY3Rpb24gd2UoaSwgdCwgZSwgcykge1xuICB2YXIgbiwgbywgcjtcbiAgZm9yIChuID0gMCwgbyA9IGkubGVuZ3RoOyBuIDwgbzsgKytuKSBpZiAociA9IGlbbl0sIHIgIT09IHZvaWQgMCAmJiByICE9PSB2b2lkIDApIHJldHVybiByO1xufVxuZnVuY3Rpb24geHIoaSwgdCwgZSkge1xuICB2YXIgcyA9IGkubWluLFxuICAgIG4gPSBpLm1heCxcbiAgICBvID0gYm4odCwgKG4gLSBzKSAvIDIpLFxuICAgIHIgPSBmdW5jdGlvbiByKGEsIGwpIHtcbiAgICAgIHJldHVybiBlICYmIGEgPT09IDAgPyAwIDogYSArIGw7XG4gICAgfTtcbiAgcmV0dXJuIHtcbiAgICBtaW46IHIocywgLU1hdGguYWJzKG8pKSxcbiAgICBtYXg6IHIobiwgbylcbiAgfTtcbn1cbmZ1bmN0aW9uIEJ0KGksIHQpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShpKSwgdCk7XG59XG5mdW5jdGlvbiBOaShpKSB7XG4gIHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXCJcIl07XG4gIHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlbMF07XG4gIH07XG4gIHZhciBvID0gZSB8fCBpO1xuICBfdHlwZW9mKHMpID4gXCJ1XCIgJiYgKHMgPSBMbihcIl9mYWxsYmFja1wiLCBpKSk7XG4gIHZhciByID0gX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KHt9LCBTeW1ib2wudG9TdHJpbmdUYWcsIFwiT2JqZWN0XCIpLCBcIl9jYWNoZWFibGVcIiwgITApLCBcIl9zY29wZXNcIiwgaSksIFwiX3Jvb3RTY29wZXNcIiwgbyksIFwiX2ZhbGxiYWNrXCIsIHMpLCBcIl9nZXRUYXJnZXRcIiwgbiksIFwib3ZlcnJpZGVcIiwgZnVuY3Rpb24gb3ZlcnJpZGUoYSkge1xuICAgIHJldHVybiBOaShbYV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShpKSksIHQsIG8sIHMpO1xuICB9KTtcbiAgcmV0dXJuIG5ldyBQcm94eShyLCB7XG4gICAgLyoqXG4gICAgKiBBIHRyYXAgZm9yIHRoZSBkZWxldGUgb3BlcmF0b3IuXG4gICAgKi9cbiAgICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkoYSwgbCkge1xuICAgICAgcmV0dXJuIGRlbGV0ZSBhW2xdLCBkZWxldGUgYS5fa2V5cywgZGVsZXRlIGlbMF1bbF0sICEwO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBBIHRyYXAgZm9yIGdldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoYSwgbCkge1xuICAgICAgcmV0dXJuIEFuKGEsIGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERyKGwsIHQsIGksIGEpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvci5cbiAgICAqIEFsc28gdXNlZCBieSBPYmplY3QuaGFzT3duUHJvcGVydHkuXG4gICAgKi9cbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLCBsKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYS5fc2NvcGVzWzBdLCBsKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YuXG4gICAgKi9cbiAgICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihpWzBdKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICogQSB0cmFwIGZvciB0aGUgaW4gb3BlcmF0b3IuXG4gICAgKi9cbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyhhLCBsKSB7XG4gICAgICByZXR1cm4gZHMoYSkuaW5jbHVkZXMobCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgYW5kIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMuXG4gICAgKi9cbiAgICBvd25LZXlzOiBmdW5jdGlvbiBvd25LZXlzKGEpIHtcbiAgICAgIHJldHVybiBkcyhhKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICogQSB0cmFwIGZvciBzZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gc2V0KGEsIGwsIGMpIHtcbiAgICAgIHZhciBoID0gYS5fc3RvcmFnZSB8fCAoYS5fc3RvcmFnZSA9IG4oKSk7XG4gICAgICByZXR1cm4gYVtsXSA9IGhbbF0gPSBjLCBkZWxldGUgYS5fa2V5cywgITA7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHF0KGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSB7XG4gICAgX2NhY2hlYWJsZTogITEsXG4gICAgX3Byb3h5OiBpLFxuICAgIF9jb250ZXh0OiB0LFxuICAgIF9zdWJQcm94eTogZSxcbiAgICBfc3RhY2s6IC8qIEBfX1BVUkVfXyAqL25ldyBTZXQoKSxcbiAgICBfZGVzY3JpcHRvcnM6IFRuKGksIHMpLFxuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uIHNldENvbnRleHQobykge1xuICAgICAgcmV0dXJuIHF0KGksIG8sIGUsIHMpO1xuICAgIH0sXG4gICAgb3ZlcnJpZGU6IGZ1bmN0aW9uIG92ZXJyaWRlKG8pIHtcbiAgICAgIHJldHVybiBxdChpLm92ZXJyaWRlKG8pLCB0LCBlLCBzKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkobiwge1xuICAgIC8qKlxuICAgICogQSB0cmFwIGZvciB0aGUgZGVsZXRlIG9wZXJhdG9yLlxuICAgICovXG4gICAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KG8sIHIpIHtcbiAgICAgIHJldHVybiBkZWxldGUgb1tyXSwgZGVsZXRlIGlbcl0sICEwO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBBIHRyYXAgZm9yIGdldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQobywgciwgYSkge1xuICAgICAgcmV0dXJuIEFuKG8sIHIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZyKG8sIHIsIGEpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvci5cbiAgICAqIEFsc28gdXNlZCBieSBPYmplY3QuaGFzT3duUHJvcGVydHkuXG4gICAgKi9cbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvLCByKSB7XG4gICAgICByZXR1cm4gby5fZGVzY3JpcHRvcnMuYWxsS2V5cyA/IFJlZmxlY3QuaGFzKGksIHIpID8ge1xuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSA6IHZvaWQgMCA6IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGksIHIpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZi5cbiAgICAqL1xuICAgIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKGkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBBIHRyYXAgZm9yIHRoZSBpbiBvcGVyYXRvci5cbiAgICAqL1xuICAgIGhhczogZnVuY3Rpb24gaGFzKG8sIHIpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmhhcyhpLCByKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyBhbmQgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scy5cbiAgICAqL1xuICAgIG93bktleXM6IGZ1bmN0aW9uIG93bktleXMoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKGkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBBIHRyYXAgZm9yIHNldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICovXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobywgciwgYSkge1xuICAgICAgcmV0dXJuIGlbcl0gPSBhLCBkZWxldGUgb1tyXSwgITA7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIFRuKGkpIHtcbiAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICBzY3JpcHRhYmxlOiAhMCxcbiAgICBpbmRleGFibGU6ICEwXG4gIH07XG4gIHZhciBfaSRfc2NyaXB0YWJsZSA9IGkuX3NjcmlwdGFibGUsXG4gICAgZSA9IF9pJF9zY3JpcHRhYmxlID09PSB2b2lkIDAgPyB0LnNjcmlwdGFibGUgOiBfaSRfc2NyaXB0YWJsZSxcbiAgICBfaSRfaW5kZXhhYmxlID0gaS5faW5kZXhhYmxlLFxuICAgIHMgPSBfaSRfaW5kZXhhYmxlID09PSB2b2lkIDAgPyB0LmluZGV4YWJsZSA6IF9pJF9pbmRleGFibGUsXG4gICAgX2kkX2FsbEtleXMgPSBpLl9hbGxLZXlzLFxuICAgIG4gPSBfaSRfYWxsS2V5cyA9PT0gdm9pZCAwID8gdC5hbGxLZXlzIDogX2kkX2FsbEtleXM7XG4gIHJldHVybiB7XG4gICAgYWxsS2V5czogbixcbiAgICBzY3JpcHRhYmxlOiBlLFxuICAgIGluZGV4YWJsZTogcyxcbiAgICBpc1NjcmlwdGFibGU6IHd0KGUpID8gZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH0sXG4gICAgaXNJbmRleGFibGU6IHd0KHMpID8gcyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgfTtcbn1cbnZhciB5ciA9IGZ1bmN0aW9uIHlyKGksIHQpIHtcbiAgICByZXR1cm4gaSA/IGkgKyBGaSh0KSA6IHQ7XG4gIH0sXG4gIFZpID0gZnVuY3Rpb24gVmkoaSwgdCkge1xuICAgIHJldHVybiBUKHQpICYmIGkgIT09IFwiYWRhcHRlcnNcIiAmJiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpID09PSBudWxsIHx8IHQuY29uc3RydWN0b3IgPT09IE9iamVjdCk7XG4gIH07XG5mdW5jdGlvbiBBbihpLCB0LCBlKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSwgdCkgfHwgdCA9PT0gXCJjb25zdHJ1Y3RvclwiKSByZXR1cm4gaVt0XTtcbiAgdmFyIHMgPSBlKCk7XG4gIHJldHVybiBpW3RdID0gcywgcztcbn1cbmZ1bmN0aW9uIHZyKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBpLl9wcm94eSxcbiAgICBuID0gaS5fY29udGV4dCxcbiAgICBvID0gaS5fc3ViUHJveHksXG4gICAgciA9IGkuX2Rlc2NyaXB0b3JzO1xuICB2YXIgYSA9IHNbdF07XG4gIHJldHVybiB3dChhKSAmJiByLmlzU2NyaXB0YWJsZSh0KSAmJiAoYSA9IE1yKHQsIGEsIGksIGUpKSwgTihhKSAmJiBhLmxlbmd0aCAmJiAoYSA9IFNyKHQsIGEsIGksIHIuaXNJbmRleGFibGUpKSwgVmkodCwgYSkgJiYgKGEgPSBxdChhLCBuLCBvICYmIG9bdF0sIHIpKSwgYTtcbn1cbmZ1bmN0aW9uIE1yKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBlLl9wcm94eSxcbiAgICBvID0gZS5fY29udGV4dCxcbiAgICByID0gZS5fc3ViUHJveHksXG4gICAgYSA9IGUuX3N0YWNrO1xuICBpZiAoYS5oYXMoaSkpIHRocm93IG5ldyBFcnJvcihcIlJlY3Vyc2lvbiBkZXRlY3RlZDogXCIgKyBBcnJheS5mcm9tKGEpLmpvaW4oXCItPlwiKSArIFwiLT5cIiArIGkpO1xuICBhLmFkZChpKTtcbiAgdmFyIGwgPSB0KG8sIHIgfHwgcyk7XG4gIHJldHVybiBhW1wiZGVsZXRlXCJdKGkpLCBWaShpLCBsKSAmJiAobCA9IGppKG4uX3Njb3BlcywgbiwgaSwgbCkpLCBsO1xufVxuZnVuY3Rpb24gU3IoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IGUuX3Byb3h5LFxuICAgIG8gPSBlLl9jb250ZXh0LFxuICAgIHIgPSBlLl9zdWJQcm94eSxcbiAgICBhID0gZS5fZGVzY3JpcHRvcnM7XG4gIGlmIChfdHlwZW9mKG8uaW5kZXgpIDwgXCJ1XCIgJiYgcyhpKSkgcmV0dXJuIHRbby5pbmRleCAlIHQubGVuZ3RoXTtcbiAgaWYgKFQodFswXSkpIHtcbiAgICB2YXIgbCA9IHQsXG4gICAgICBjID0gbi5fc2NvcGVzLmZpbHRlcihmdW5jdGlvbiAoaCkge1xuICAgICAgICByZXR1cm4gaCAhPT0gbDtcbiAgICAgIH0pO1xuICAgIHQgPSBbXTtcbiAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGwpLFxuICAgICAgX3N0ZXA1O1xuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICB2YXIgaCA9IF9zdGVwNS52YWx1ZTtcbiAgICAgICAgdmFyIGQgPSBqaShjLCBuLCBpLCBoKTtcbiAgICAgICAgdC5wdXNoKHF0KGQsIG8sIHIgJiYgcltpXSwgYSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yNS5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIFJuKGksIHQsIGUpIHtcbiAgcmV0dXJuIHd0KGkpID8gaSh0LCBlKSA6IGk7XG59XG52YXIga3IgPSBmdW5jdGlvbiBrcihpLCB0KSB7XG4gIHJldHVybiBpID09PSAhMCA/IHQgOiB0eXBlb2YgaSA9PSBcInN0cmluZ1wiID8gSXQodCwgaSkgOiB2b2lkIDA7XG59O1xuZnVuY3Rpb24gd3IoaSwgdCwgZSwgcywgbikge1xuICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHQpLFxuICAgIF9zdGVwNjtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgdmFyIG8gPSBfc3RlcDYudmFsdWU7XG4gICAgICB2YXIgciA9IGtyKGUsIG8pO1xuICAgICAgaWYgKHIpIHtcbiAgICAgICAgaS5hZGQocik7XG4gICAgICAgIHZhciBhID0gUm4oci5fZmFsbGJhY2ssIGUsIG4pO1xuICAgICAgICBpZiAoX3R5cGVvZihhKSA8IFwidVwiICYmIGEgIT09IGUgJiYgYSAhPT0gcykgcmV0dXJuIGE7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09ICExICYmIF90eXBlb2YocykgPCBcInVcIiAmJiBlICE9PSBzKSByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjYuZigpO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIGppKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSB0Ll9yb290U2NvcGVzLFxuICAgIG8gPSBSbih0Ll9mYWxsYmFjaywgZSwgcyksXG4gICAgciA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoaSksIF90b0NvbnN1bWFibGVBcnJheShuKSksXG4gICAgYSA9IC8qIEBfX1BVUkVfXyAqL25ldyBTZXQoKTtcbiAgYS5hZGQocyk7XG4gIHZhciBsID0gaHMoYSwgciwgZSwgbyB8fCBlLCBzKTtcbiAgcmV0dXJuIGwgPT09IG51bGwgfHwgX3R5cGVvZihvKSA8IFwidVwiICYmIG8gIT09IGUgJiYgKGwgPSBocyhhLCByLCBvLCBsLCBzKSwgbCA9PT0gbnVsbCkgPyAhMSA6IE5pKEFycmF5LmZyb20oYSksIFtcIlwiXSwgbiwgbywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBQcih0LCBlLCBzKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBocyhpLCB0LCBlLCBzLCBuKSB7XG4gIGZvciAoOyBlOykgZSA9IHdyKGksIHQsIGUsIHMsIG4pO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIFByKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBpLl9nZXRUYXJnZXQoKTtcbiAgdCBpbiBzIHx8IChzW3RdID0ge30pO1xuICB2YXIgbiA9IHNbdF07XG4gIHJldHVybiBOKG4pICYmIFQoZSkgPyBlIDogbiB8fCB7fTtcbn1cbmZ1bmN0aW9uIERyKGksIHQsIGUsIHMpIHtcbiAgdmFyIG47XG4gIHZhciBfaXRlcmF0b3I3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodCksXG4gICAgX3N0ZXA3O1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgbyA9IF9zdGVwNy52YWx1ZTtcbiAgICAgIGlmIChuID0gTG4oeXIobywgaSksIGUpLCBfdHlwZW9mKG4pIDwgXCJ1XCIpIHJldHVybiBWaShpLCBuKSA/IGppKGUsIHMsIGksIG4pIDogbjtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjcuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjcuZigpO1xuICB9XG59XG5mdW5jdGlvbiBMbihpLCB0KSB7XG4gIHZhciBfaXRlcmF0b3I4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodCksXG4gICAgX3N0ZXA4O1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yOC5zKCk7ICEoX3N0ZXA4ID0gX2l0ZXJhdG9yOC5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgZSA9IF9zdGVwOC52YWx1ZTtcbiAgICAgIGlmICghZSkgY29udGludWU7XG4gICAgICB2YXIgcyA9IGVbaV07XG4gICAgICBpZiAoX3R5cGVvZihzKSA8IFwidVwiKSByZXR1cm4gcztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjguZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjguZigpO1xuICB9XG59XG5mdW5jdGlvbiBkcyhpKSB7XG4gIHZhciB0ID0gaS5fa2V5cztcbiAgcmV0dXJuIHQgfHwgKHQgPSBpLl9rZXlzID0gQ3IoaS5fc2NvcGVzKSksIHQ7XG59XG5mdW5jdGlvbiBDcihpKSB7XG4gIHZhciB0ID0gLyogQF9fUFVSRV9fICovbmV3IFNldCgpO1xuICB2YXIgX2l0ZXJhdG9yOSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGkpLFxuICAgIF9zdGVwOTtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjkucygpOyAhKF9zdGVwOSA9IF9pdGVyYXRvcjkubigpKS5kb25lOykge1xuICAgICAgdmFyIGUgPSBfc3RlcDkudmFsdWU7XG4gICAgICB2YXIgX2l0ZXJhdG9yMCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKE9iamVjdC5rZXlzKGUpLmZpbHRlcihmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiAhbi5zdGFydHNXaXRoKFwiX1wiKTtcbiAgICAgICAgfSkpLFxuICAgICAgICBfc3RlcDA7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjAucygpOyAhKF9zdGVwMCA9IF9pdGVyYXRvcjAubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBzID0gX3N0ZXAwLnZhbHVlO1xuICAgICAgICAgIHQuYWRkKHMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IwLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjkuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjkuZigpO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHQpO1xufVxudmFyIE9yID0gTnVtYmVyLkVQU0lMT04gfHwgMWUtMTQsXG4gIEt0ID0gZnVuY3Rpb24gS3QoaSwgdCkge1xuICAgIHJldHVybiB0IDwgaS5sZW5ndGggJiYgIWlbdF0uc2tpcCAmJiBpW3RdO1xuICB9LFxuICBFbiA9IGZ1bmN0aW9uIEVuKGkpIHtcbiAgICByZXR1cm4gaSA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwiO1xuICB9O1xuZnVuY3Rpb24gVHIoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IGkuc2tpcCA/IHQgOiBpLFxuICAgIG8gPSB0LFxuICAgIHIgPSBlLnNraXAgPyB0IDogZSxcbiAgICBhID0gdmkobywgbiksXG4gICAgbCA9IHZpKHIsIG8pO1xuICB2YXIgYyA9IGEgLyAoYSArIGwpLFxuICAgIGggPSBsIC8gKGEgKyBsKTtcbiAgYyA9IGlzTmFOKGMpID8gMCA6IGMsIGggPSBpc05hTihoKSA/IDAgOiBoO1xuICB2YXIgZCA9IHMgKiBjLFxuICAgIHUgPSBzICogaDtcbiAgcmV0dXJuIHtcbiAgICBwcmV2aW91czoge1xuICAgICAgeDogby54IC0gZCAqIChyLnggLSBuLngpLFxuICAgICAgeTogby55IC0gZCAqIChyLnkgLSBuLnkpXG4gICAgfSxcbiAgICBuZXh0OiB7XG4gICAgICB4OiBvLnggKyB1ICogKHIueCAtIG4ueCksXG4gICAgICB5OiBvLnkgKyB1ICogKHIueSAtIG4ueSlcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBBcihpLCB0LCBlKSB7XG4gIHZhciBzID0gaS5sZW5ndGg7XG4gIHZhciBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhLFxuICAgIGwsXG4gICAgYyA9IEt0KGksIDApO1xuICBmb3IgKHZhciBoID0gMDsgaCA8IHMgLSAxOyArK2gpIGlmIChsID0gYywgYyA9IEt0KGksIGggKyAxKSwgISghbCB8fCAhYykpIHtcbiAgICBpZiAoY2UodFtoXSwgMCwgT3IpKSB7XG4gICAgICBlW2hdID0gZVtoICsgMV0gPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG4gPSBlW2hdIC8gdFtoXSwgbyA9IGVbaCArIDFdIC8gdFtoXSwgYSA9IE1hdGgucG93KG4sIDIpICsgTWF0aC5wb3cobywgMiksICEoYSA8PSA5KSAmJiAociA9IDMgLyBNYXRoLnNxcnQoYSksIGVbaF0gPSBuICogciAqIHRbaF0sIGVbaCArIDFdID0gbyAqIHIgKiB0W2hdKTtcbiAgfVxufVxuZnVuY3Rpb24gUnIoaSwgdCkge1xuICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJ4XCI7XG4gIHZhciBzID0gRW4oZSksXG4gICAgbiA9IGkubGVuZ3RoO1xuICB2YXIgbyxcbiAgICByLFxuICAgIGEsXG4gICAgbCA9IEt0KGksIDApO1xuICBmb3IgKHZhciBjID0gMDsgYyA8IG47ICsrYykge1xuICAgIGlmIChyID0gYSwgYSA9IGwsIGwgPSBLdChpLCBjICsgMSksICFhKSBjb250aW51ZTtcbiAgICB2YXIgaCA9IGFbZV0sXG4gICAgICBkID0gYVtzXTtcbiAgICByICYmIChvID0gKGggLSByW2VdKSAvIDMsIGFbXCJjcDFcIi5jb25jYXQoZSldID0gaCAtIG8sIGFbXCJjcDFcIi5jb25jYXQocyldID0gZCAtIG8gKiB0W2NdKSwgbCAmJiAobyA9IChsW2VdIC0gaCkgLyAzLCBhW1wiY3AyXCIuY29uY2F0KGUpXSA9IGggKyBvLCBhW1wiY3AyXCIuY29uY2F0KHMpXSA9IGQgKyBvICogdFtjXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIExyKGkpIHtcbiAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwieFwiO1xuICB2YXIgZSA9IEVuKHQpLFxuICAgIHMgPSBpLmxlbmd0aCxcbiAgICBuID0gQXJyYXkocykuZmlsbCgwKSxcbiAgICBvID0gQXJyYXkocyk7XG4gIHZhciByLFxuICAgIGEsXG4gICAgbCxcbiAgICBjID0gS3QoaSwgMCk7XG4gIGZvciAociA9IDA7IHIgPCBzOyArK3IpIGlmIChhID0gbCwgbCA9IGMsIGMgPSBLdChpLCByICsgMSksICEhbCkge1xuICAgIGlmIChjKSB7XG4gICAgICB2YXIgaCA9IGNbdF0gLSBsW3RdO1xuICAgICAgbltyXSA9IGggIT09IDAgPyAoY1tlXSAtIGxbZV0pIC8gaCA6IDA7XG4gICAgfVxuICAgIG9bcl0gPSBhID8gYyA/IGx0KG5bciAtIDFdKSAhPT0gbHQobltyXSkgPyAwIDogKG5bciAtIDFdICsgbltyXSkgLyAyIDogbltyIC0gMV0gOiBuW3JdO1xuICB9XG4gIEFyKGksIG4sIG8pLCBScihpLCBvLCB0KTtcbn1cbmZ1bmN0aW9uIFBlKGksIHQsIGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGksIGUpLCB0KTtcbn1cbmZ1bmN0aW9uIEVyKGksIHQpIHtcbiAgdmFyIGUsXG4gICAgcyxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhID0gbWUoaVswXSwgdCk7XG4gIGZvciAoZSA9IDAsIHMgPSBpLmxlbmd0aDsgZSA8IHM7ICsrZSkgciA9IG8sIG8gPSBhLCBhID0gZSA8IHMgLSAxICYmIG1lKGlbZSArIDFdLCB0KSwgbyAmJiAobiA9IGlbZV0sIHIgJiYgKG4uY3AxeCA9IFBlKG4uY3AxeCwgdC5sZWZ0LCB0LnJpZ2h0KSwgbi5jcDF5ID0gUGUobi5jcDF5LCB0LnRvcCwgdC5ib3R0b20pKSwgYSAmJiAobi5jcDJ4ID0gUGUobi5jcDJ4LCB0LmxlZnQsIHQucmlnaHQpLCBuLmNwMnkgPSBQZShuLmNwMnksIHQudG9wLCB0LmJvdHRvbSkpKTtcbn1cbmZ1bmN0aW9uIEZyKGksIHQsIGUsIHMsIG4pIHtcbiAgdmFyIG8sIHIsIGEsIGw7XG4gIGlmICh0LnNwYW5HYXBzICYmIChpID0gaS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gIWMuc2tpcDtcbiAgfSkpLCB0LmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09IFwibW9ub3RvbmVcIikgTHIoaSwgbik7ZWxzZSB7XG4gICAgdmFyIGMgPSBzID8gaVtpLmxlbmd0aCAtIDFdIDogaVswXTtcbiAgICBmb3IgKG8gPSAwLCByID0gaS5sZW5ndGg7IG8gPCByOyArK28pIGEgPSBpW29dLCBsID0gVHIoYywgYSwgaVtNYXRoLm1pbihvICsgMSwgciAtIChzID8gMCA6IDEpKSAlIHJdLCB0LnRlbnNpb24pLCBhLmNwMXggPSBsLnByZXZpb3VzLngsIGEuY3AxeSA9IGwucHJldmlvdXMueSwgYS5jcDJ4ID0gbC5uZXh0LngsIGEuY3AyeSA9IGwubmV4dC55LCBjID0gYTtcbiAgfVxuICB0LmNhcEJlemllclBvaW50cyAmJiBFcihpLCBlKTtcbn1cbmZ1bmN0aW9uICRpKCkge1xuICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih3aW5kb3cpKSA8IFwidVwiICYmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihkb2N1bWVudCkpIDwgXCJ1XCI7XG59XG5mdW5jdGlvbiBZaShpKSB7XG4gIHZhciB0ID0gaS5wYXJlbnROb2RlO1xuICByZXR1cm4gdCAmJiB0LnRvU3RyaW5nKCkgPT09IFwiW29iamVjdCBTaGFkb3dSb290XVwiICYmICh0ID0gdC5ob3N0KSwgdDtcbn1cbmZ1bmN0aW9uIFhlKGksIHQsIGUpIHtcbiAgdmFyIHM7XG4gIHJldHVybiB0eXBlb2YgaSA9PSBcInN0cmluZ1wiID8gKHMgPSBwYXJzZUludChpLCAxMCksIGkuaW5kZXhPZihcIiVcIikgIT09IC0xICYmIChzID0gcyAvIDEwMCAqIHQucGFyZW50Tm9kZVtlXSkpIDogcyA9IGksIHM7XG59XG52YXIgUWUgPSBmdW5jdGlvbiBRZShpKSB7XG4gIHJldHVybiBpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShpLCBudWxsKTtcbn07XG5mdW5jdGlvbiBJcihpLCB0KSB7XG4gIHJldHVybiBRZShpKS5nZXRQcm9wZXJ0eVZhbHVlKHQpO1xufVxudmFyIHpyID0gW1widG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdO1xuZnVuY3Rpb24gRnQoaSwgdCwgZSkge1xuICB2YXIgcyA9IHt9O1xuICBlID0gZSA/IFwiLVwiICsgZSA6IFwiXCI7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgNDsgbisrKSB7XG4gICAgdmFyIG8gPSB6cltuXTtcbiAgICBzW29dID0gcGFyc2VGbG9hdChpW3QgKyBcIi1cIiArIG8gKyBlXSkgfHwgMDtcbiAgfVxuICByZXR1cm4gcy53aWR0aCA9IHMubGVmdCArIHMucmlnaHQsIHMuaGVpZ2h0ID0gcy50b3AgKyBzLmJvdHRvbSwgcztcbn1cbnZhciBCciA9IGZ1bmN0aW9uIEJyKGksIHQsIGUpIHtcbiAgcmV0dXJuIChpID4gMCB8fCB0ID4gMCkgJiYgKCFlIHx8ICFlLnNoYWRvd1Jvb3QpO1xufTtcbmZ1bmN0aW9uIEhyKGksIHQpIHtcbiAgdmFyIGUgPSBpLnRvdWNoZXMsXG4gICAgcyA9IGUgJiYgZS5sZW5ndGggPyBlWzBdIDogaSxcbiAgICBuID0gcy5vZmZzZXRYLFxuICAgIG8gPSBzLm9mZnNldFk7XG4gIHZhciByID0gITEsXG4gICAgYSxcbiAgICBsO1xuICBpZiAoQnIobiwgbywgaS50YXJnZXQpKSBhID0gbiwgbCA9IG87ZWxzZSB7XG4gICAgdmFyIGMgPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGEgPSBzLmNsaWVudFggLSBjLmxlZnQsIGwgPSBzLmNsaWVudFkgLSBjLnRvcCwgciA9ICEwO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogYSxcbiAgICB5OiBsLFxuICAgIGJveDogclxuICB9O1xufVxuZnVuY3Rpb24gQXQoaSwgdCkge1xuICBpZiAoXCJuYXRpdmVcIiBpbiBpKSByZXR1cm4gaTtcbiAgdmFyIGUgPSB0LmNhbnZhcyxcbiAgICBzID0gdC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyxcbiAgICBuID0gUWUoZSksXG4gICAgbyA9IG4uYm94U2l6aW5nID09PSBcImJvcmRlci1ib3hcIixcbiAgICByID0gRnQobiwgXCJwYWRkaW5nXCIpLFxuICAgIGEgPSBGdChuLCBcImJvcmRlclwiLCBcIndpZHRoXCIpLFxuICAgIF9IciA9IEhyKGksIGUpLFxuICAgIGwgPSBfSHIueCxcbiAgICBjID0gX0hyLnksXG4gICAgaCA9IF9Ici5ib3gsXG4gICAgZCA9IHIubGVmdCArIChoICYmIGEubGVmdCksXG4gICAgdSA9IHIudG9wICsgKGggJiYgYS50b3ApO1xuICB2YXIgZiA9IHQud2lkdGgsXG4gICAgcCA9IHQuaGVpZ2h0O1xuICByZXR1cm4gbyAmJiAoZiAtPSByLndpZHRoICsgYS53aWR0aCwgcCAtPSByLmhlaWdodCArIGEuaGVpZ2h0KSwge1xuICAgIHg6IE1hdGgucm91bmQoKGwgLSBkKSAvIGYgKiBlLndpZHRoIC8gcyksXG4gICAgeTogTWF0aC5yb3VuZCgoYyAtIHUpIC8gcCAqIGUuaGVpZ2h0IC8gcylcbiAgfTtcbn1cbmZ1bmN0aW9uIFdyKGksIHQsIGUpIHtcbiAgdmFyIHMsIG47XG4gIGlmICh0ID09PSB2b2lkIDAgfHwgZSA9PT0gdm9pZCAwKSB7XG4gICAgdmFyIG8gPSBpICYmIFlpKGkpO1xuICAgIGlmICghbykgdCA9IGkuY2xpZW50V2lkdGgsIGUgPSBpLmNsaWVudEhlaWdodDtlbHNlIHtcbiAgICAgIHZhciByID0gby5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgYSA9IFFlKG8pLFxuICAgICAgICBsID0gRnQoYSwgXCJib3JkZXJcIiwgXCJ3aWR0aFwiKSxcbiAgICAgICAgYyA9IEZ0KGEsIFwicGFkZGluZ1wiKTtcbiAgICAgIHQgPSByLndpZHRoIC0gYy53aWR0aCAtIGwud2lkdGgsIGUgPSByLmhlaWdodCAtIGMuaGVpZ2h0IC0gbC5oZWlnaHQsIHMgPSBYZShhLm1heFdpZHRoLCBvLCBcImNsaWVudFdpZHRoXCIpLCBuID0gWGUoYS5tYXhIZWlnaHQsIG8sIFwiY2xpZW50SGVpZ2h0XCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB0LFxuICAgIGhlaWdodDogZSxcbiAgICBtYXhXaWR0aDogcyB8fCBZZSxcbiAgICBtYXhIZWlnaHQ6IG4gfHwgWWVcbiAgfTtcbn1cbnZhciB5dCA9IGZ1bmN0aW9uIHl0KGkpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoaSAqIDEwKSAvIDEwO1xufTtcbmZ1bmN0aW9uIE5yKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBRZShpKSxcbiAgICBvID0gRnQobiwgXCJtYXJnaW5cIiksXG4gICAgciA9IFhlKG4ubWF4V2lkdGgsIGksIFwiY2xpZW50V2lkdGhcIikgfHwgWWUsXG4gICAgYSA9IFhlKG4ubWF4SGVpZ2h0LCBpLCBcImNsaWVudEhlaWdodFwiKSB8fCBZZSxcbiAgICBsID0gV3IoaSwgdCwgZSk7XG4gIHZhciBjID0gbC53aWR0aCxcbiAgICBoID0gbC5oZWlnaHQ7XG4gIGlmIChuLmJveFNpemluZyA9PT0gXCJjb250ZW50LWJveFwiKSB7XG4gICAgdmFyIHUgPSBGdChuLCBcImJvcmRlclwiLCBcIndpZHRoXCIpLFxuICAgICAgZiA9IEZ0KG4sIFwicGFkZGluZ1wiKTtcbiAgICBjIC09IGYud2lkdGggKyB1LndpZHRoLCBoIC09IGYuaGVpZ2h0ICsgdS5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIGMgPSBNYXRoLm1heCgwLCBjIC0gby53aWR0aCksIGggPSBNYXRoLm1heCgwLCBzID8gYyAvIHMgOiBoIC0gby5oZWlnaHQpLCBjID0geXQoTWF0aC5taW4oYywgciwgbC5tYXhXaWR0aCkpLCBoID0geXQoTWF0aC5taW4oaCwgYSwgbC5tYXhIZWlnaHQpKSwgYyAmJiAhaCAmJiAoaCA9IHl0KGMgLyAyKSksICh0ICE9PSB2b2lkIDAgfHwgZSAhPT0gdm9pZCAwKSAmJiBzICYmIGwuaGVpZ2h0ICYmIGggPiBsLmhlaWdodCAmJiAoaCA9IGwuaGVpZ2h0LCBjID0geXQoTWF0aC5mbG9vcihoICogcykpKSwge1xuICAgIHdpZHRoOiBjLFxuICAgIGhlaWdodDogaFxuICB9O1xufVxuZnVuY3Rpb24gdXMoaSwgdCwgZSkge1xuICB2YXIgcyA9IHQgfHwgMSxcbiAgICBuID0geXQoaS5oZWlnaHQgKiBzKSxcbiAgICBvID0geXQoaS53aWR0aCAqIHMpO1xuICBpLmhlaWdodCA9IHl0KGkuaGVpZ2h0KSwgaS53aWR0aCA9IHl0KGkud2lkdGgpO1xuICB2YXIgciA9IGkuY2FudmFzO1xuICByZXR1cm4gci5zdHlsZSAmJiAoZSB8fCAhci5zdHlsZS5oZWlnaHQgJiYgIXIuc3R5bGUud2lkdGgpICYmIChyLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGkuaGVpZ2h0LCBcInB4XCIpLCByLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQoaS53aWR0aCwgXCJweFwiKSksIGkuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IHMgfHwgci5oZWlnaHQgIT09IG4gfHwgci53aWR0aCAhPT0gbyA/IChpLmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gcywgci5oZWlnaHQgPSBuLCByLndpZHRoID0gbywgaS5jdHguc2V0VHJhbnNmb3JtKHMsIDAsIDAsIHMsIDAsIDApLCAhMCkgOiAhMTtcbn1cbnZhciBWciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGkgPSAhMTtcbiAgdHJ5IHtcbiAgICB2YXIgdCA9IHtcbiAgICAgIGdldCBwYXNzaXZlKCkge1xuICAgICAgICByZXR1cm4gaSA9ICEwLCAhMTtcbiAgICAgIH1cbiAgICB9O1xuICAgICRpKCkgJiYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCBudWxsLCB0KSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIG51bGwsIHQpKTtcbiAgfSBjYXRjaCAoX3VudXNlZCkge31cbiAgcmV0dXJuIGk7XG59KCk7XG5mdW5jdGlvbiBmcyhpLCB0KSB7XG4gIHZhciBlID0gSXIoaSwgdCksXG4gICAgcyA9IGUgJiYgZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcbiAgcmV0dXJuIHMgPyArc1sxXSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIFJ0KGksIHQsIGUsIHMpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBpLnggKyBlICogKHQueCAtIGkueCksXG4gICAgeTogaS55ICsgZSAqICh0LnkgLSBpLnkpXG4gIH07XG59XG5mdW5jdGlvbiBqcihpLCB0LCBlLCBzKSB7XG4gIHJldHVybiB7XG4gICAgeDogaS54ICsgZSAqICh0LnggLSBpLngpLFxuICAgIHk6IHMgPT09IFwibWlkZGxlXCIgPyBlIDwgMC41ID8gaS55IDogdC55IDogcyA9PT0gXCJhZnRlclwiID8gZSA8IDEgPyBpLnkgOiB0LnkgOiBlID4gMCA/IHQueSA6IGkueVxuICB9O1xufVxuZnVuY3Rpb24gJHIoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IHtcbiAgICAgIHg6IGkuY3AyeCxcbiAgICAgIHk6IGkuY3AyeVxuICAgIH0sXG4gICAgbyA9IHtcbiAgICAgIHg6IHQuY3AxeCxcbiAgICAgIHk6IHQuY3AxeVxuICAgIH0sXG4gICAgciA9IFJ0KGksIG4sIGUpLFxuICAgIGEgPSBSdChuLCBvLCBlKSxcbiAgICBsID0gUnQobywgdCwgZSksXG4gICAgYyA9IFJ0KHIsIGEsIGUpLFxuICAgIGggPSBSdChhLCBsLCBlKTtcbiAgcmV0dXJuIFJ0KGMsIGgsIGUpO1xufVxudmFyIFlyID0gZnVuY3Rpb24gWXIoaSwgdCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBmdW5jdGlvbiB4KGUpIHtcbiAgICAgICAgcmV0dXJuIGkgKyBpICsgdCAtIGU7XG4gICAgICB9LFxuICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uIHNldFdpZHRoKGUpIHtcbiAgICAgICAgdCA9IGU7XG4gICAgICB9LFxuICAgICAgdGV4dEFsaWduOiBmdW5jdGlvbiB0ZXh0QWxpZ24oZSkge1xuICAgICAgICByZXR1cm4gZSA9PT0gXCJjZW50ZXJcIiA/IGUgOiBlID09PSBcInJpZ2h0XCIgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbiAgICAgIH0sXG4gICAgICB4UGx1czogZnVuY3Rpb24geFBsdXMoZSwgcykge1xuICAgICAgICByZXR1cm4gZSAtIHM7XG4gICAgICB9LFxuICAgICAgbGVmdEZvckx0cjogZnVuY3Rpb24gbGVmdEZvckx0cihlLCBzKSB7XG4gICAgICAgIHJldHVybiBlIC0gcztcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBVciA9IGZ1bmN0aW9uIFVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBmdW5jdGlvbiB4KGkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9LFxuICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uIHNldFdpZHRoKGkpIHt9LFxuICAgICAgdGV4dEFsaWduOiBmdW5jdGlvbiB0ZXh0QWxpZ24oaSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH0sXG4gICAgICB4UGx1czogZnVuY3Rpb24geFBsdXMoaSwgdCkge1xuICAgICAgICByZXR1cm4gaSArIHQ7XG4gICAgICB9LFxuICAgICAgbGVmdEZvckx0cjogZnVuY3Rpb24gbGVmdEZvckx0cihpLCB0KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5mdW5jdGlvbiBVdChpLCB0LCBlKSB7XG4gIHJldHVybiBpID8gWXIodCwgZSkgOiBVcigpO1xufVxuZnVuY3Rpb24gRm4oaSwgdCkge1xuICB2YXIgZSwgcztcbiAgKHQgPT09IFwibHRyXCIgfHwgdCA9PT0gXCJydGxcIikgJiYgKGUgPSBpLmNhbnZhcy5zdHlsZSwgcyA9IFtlLmdldFByb3BlcnR5VmFsdWUoXCJkaXJlY3Rpb25cIiksIGUuZ2V0UHJvcGVydHlQcmlvcml0eShcImRpcmVjdGlvblwiKV0sIGUuc2V0UHJvcGVydHkoXCJkaXJlY3Rpb25cIiwgdCwgXCJpbXBvcnRhbnRcIiksIGkucHJldlRleHREaXJlY3Rpb24gPSBzKTtcbn1cbmZ1bmN0aW9uIEluKGksIHQpIHtcbiAgdCAhPT0gdm9pZCAwICYmIChkZWxldGUgaS5wcmV2VGV4dERpcmVjdGlvbiwgaS5jYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoXCJkaXJlY3Rpb25cIiwgdFswXSwgdFsxXSkpO1xufVxuZnVuY3Rpb24gem4oaSkge1xuICByZXR1cm4gaSA9PT0gXCJhbmdsZVwiID8ge1xuICAgIGJldHdlZW46IHBlLFxuICAgIGNvbXBhcmU6IFhvLFxuICAgIG5vcm1hbGl6ZTogWlxuICB9IDoge1xuICAgIGJldHdlZW46IF90LFxuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUodCwgZSkge1xuICAgICAgcmV0dXJuIHQgLSBlO1xuICAgIH0sXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbiBub3JtYWxpemUodCkge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ3MoX3JlZikge1xuICB2YXIgaSA9IF9yZWYuc3RhcnQsXG4gICAgdCA9IF9yZWYuZW5kLFxuICAgIGUgPSBfcmVmLmNvdW50LFxuICAgIHMgPSBfcmVmLmxvb3AsXG4gICAgbiA9IF9yZWYuc3R5bGU7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGkgJSBlLFxuICAgIGVuZDogdCAlIGUsXG4gICAgbG9vcDogcyAmJiAodCAtIGkgKyAxKSAlIGUgPT09IDAsXG4gICAgc3R5bGU6IG5cbiAgfTtcbn1cbmZ1bmN0aW9uIFhyKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBlLnByb3BlcnR5LFxuICAgIG4gPSBlLnN0YXJ0LFxuICAgIG8gPSBlLmVuZCxcbiAgICBfem4gPSB6bihzKSxcbiAgICByID0gX3puLmJldHdlZW4sXG4gICAgYSA9IF96bi5ub3JtYWxpemUsXG4gICAgbCA9IHQubGVuZ3RoO1xuICB2YXIgYyA9IGkuc3RhcnQsXG4gICAgaCA9IGkuZW5kLFxuICAgIGQgPSBpLmxvb3AsXG4gICAgdSxcbiAgICBmO1xuICBpZiAoZCkge1xuICAgIGZvciAoYyArPSBsLCBoICs9IGwsIHUgPSAwLCBmID0gbDsgdSA8IGYgJiYgcihhKHRbYyAlIGxdW3NdKSwgbiwgbyk7ICsrdSkgYy0tLCBoLS07XG4gICAgYyAlPSBsLCBoICU9IGw7XG4gIH1cbiAgcmV0dXJuIGggPCBjICYmIChoICs9IGwpLCB7XG4gICAgc3RhcnQ6IGMsXG4gICAgZW5kOiBoLFxuICAgIGxvb3A6IGQsXG4gICAgc3R5bGU6IGkuc3R5bGVcbiAgfTtcbn1cbmZ1bmN0aW9uIEJuKGksIHQsIGUpIHtcbiAgaWYgKCFlKSByZXR1cm4gW2ldO1xuICB2YXIgcyA9IGUucHJvcGVydHksXG4gICAgbiA9IGUuc3RhcnQsXG4gICAgbyA9IGUuZW5kLFxuICAgIHIgPSB0Lmxlbmd0aCxcbiAgICBfem4yID0gem4ocyksXG4gICAgYSA9IF96bjIuY29tcGFyZSxcbiAgICBsID0gX3puMi5iZXR3ZWVuLFxuICAgIGMgPSBfem4yLm5vcm1hbGl6ZSxcbiAgICBfWHIgPSBYcihpLCB0LCBlKSxcbiAgICBoID0gX1hyLnN0YXJ0LFxuICAgIGQgPSBfWHIuZW5kLFxuICAgIHUgPSBfWHIubG9vcCxcbiAgICBmID0gX1hyLnN0eWxlLFxuICAgIHAgPSBbXTtcbiAgdmFyIGcgPSAhMSxcbiAgICBtID0gbnVsbCxcbiAgICBiLFxuICAgIF8sXG4gICAgdjtcbiAgdmFyIHkgPSBmdW5jdGlvbiB5KCkge1xuICAgICAgcmV0dXJuIGwobiwgdiwgYikgJiYgYShuLCB2KSAhPT0gMDtcbiAgICB9LFxuICAgIHggPSBmdW5jdGlvbiB4KCkge1xuICAgICAgcmV0dXJuIGEobywgYikgPT09IDAgfHwgbChvLCB2LCBiKTtcbiAgICB9LFxuICAgIE0gPSBmdW5jdGlvbiBNKCkge1xuICAgICAgcmV0dXJuIGcgfHwgeSgpO1xuICAgIH0sXG4gICAgUyA9IGZ1bmN0aW9uIFMoKSB7XG4gICAgICByZXR1cm4gIWcgfHwgeCgpO1xuICAgIH07XG4gIGZvciAodmFyIGsgPSBoLCBQID0gaDsgayA8PSBkOyArK2spIF8gPSB0W2sgJSByXSwgIV8uc2tpcCAmJiAoYiA9IGMoX1tzXSksIGIgIT09IHYgJiYgKGcgPSBsKGIsIG4sIG8pLCBtID09PSBudWxsICYmIE0oKSAmJiAobSA9IGEoYiwgbikgPT09IDAgPyBrIDogUCksIG0gIT09IG51bGwgJiYgUygpICYmIChwLnB1c2goZ3Moe1xuICAgIHN0YXJ0OiBtLFxuICAgIGVuZDogayxcbiAgICBsb29wOiB1LFxuICAgIGNvdW50OiByLFxuICAgIHN0eWxlOiBmXG4gIH0pKSwgbSA9IG51bGwpLCBQID0gaywgdiA9IGIpKTtcbiAgcmV0dXJuIG0gIT09IG51bGwgJiYgcC5wdXNoKGdzKHtcbiAgICBzdGFydDogbSxcbiAgICBlbmQ6IGQsXG4gICAgbG9vcDogdSxcbiAgICBjb3VudDogcixcbiAgICBzdHlsZTogZlxuICB9KSksIHA7XG59XG5mdW5jdGlvbiBIbihpLCB0KSB7XG4gIHZhciBlID0gW10sXG4gICAgcyA9IGkuc2VnbWVudHM7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgcy5sZW5ndGg7IG4rKykge1xuICAgIHZhciBvID0gQm4oc1tuXSwgaS5wb2ludHMsIHQpO1xuICAgIG8ubGVuZ3RoICYmIGUucHVzaC5hcHBseShlLCBfdG9Db25zdW1hYmxlQXJyYXkobykpO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcXIoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IDAsXG4gICAgbyA9IHQgLSAxO1xuICBpZiAoZSAmJiAhcykgZm9yICg7IG4gPCB0ICYmICFpW25dLnNraXA7KSBuKys7XG4gIGZvciAoOyBuIDwgdCAmJiBpW25dLnNraXA7KSBuKys7XG4gIGZvciAobiAlPSB0LCBlICYmIChvICs9IG4pOyBvID4gbiAmJiBpW28gJSB0XS5za2lwOykgby0tO1xuICByZXR1cm4gbyAlPSB0LCB7XG4gICAgc3RhcnQ6IG4sXG4gICAgZW5kOiBvXG4gIH07XG59XG5mdW5jdGlvbiBLcihpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gaS5sZW5ndGgsXG4gICAgbyA9IFtdO1xuICB2YXIgciA9IHQsXG4gICAgYSA9IGlbdF0sXG4gICAgbDtcbiAgZm9yIChsID0gdCArIDE7IGwgPD0gZTsgKytsKSB7XG4gICAgdmFyIGMgPSBpW2wgJSBuXTtcbiAgICBjLnNraXAgfHwgYy5zdG9wID8gYS5za2lwIHx8IChzID0gITEsIG8ucHVzaCh7XG4gICAgICBzdGFydDogdCAlIG4sXG4gICAgICBlbmQ6IChsIC0gMSkgJSBuLFxuICAgICAgbG9vcDogc1xuICAgIH0pLCB0ID0gciA9IGMuc3RvcCA/IGwgOiBudWxsKSA6IChyID0gbCwgYS5za2lwICYmICh0ID0gbCkpLCBhID0gYztcbiAgfVxuICByZXR1cm4gciAhPT0gbnVsbCAmJiBvLnB1c2goe1xuICAgIHN0YXJ0OiB0ICUgbixcbiAgICBlbmQ6IHIgJSBuLFxuICAgIGxvb3A6IHNcbiAgfSksIG87XG59XG5mdW5jdGlvbiBHcihpLCB0KSB7XG4gIHZhciBlID0gaS5wb2ludHMsXG4gICAgcyA9IGkub3B0aW9ucy5zcGFuR2FwcyxcbiAgICBuID0gZS5sZW5ndGg7XG4gIGlmICghbikgcmV0dXJuIFtdO1xuICB2YXIgbyA9ICEhaS5fbG9vcCxcbiAgICBfcXIgPSBxcihlLCBuLCBvLCBzKSxcbiAgICByID0gX3FyLnN0YXJ0LFxuICAgIGEgPSBfcXIuZW5kO1xuICBpZiAocyA9PT0gITApIHJldHVybiBwcyhpLCBbe1xuICAgIHN0YXJ0OiByLFxuICAgIGVuZDogYSxcbiAgICBsb29wOiBvXG4gIH1dLCBlLCB0KTtcbiAgdmFyIGwgPSBhIDwgciA/IGEgKyBuIDogYSxcbiAgICBjID0gISFpLl9mdWxsTG9vcCAmJiByID09PSAwICYmIGEgPT09IG4gLSAxO1xuICByZXR1cm4gcHMoaSwgS3IoZSwgciwgbCwgYyksIGUsIHQpO1xufVxuZnVuY3Rpb24gcHMoaSwgdCwgZSwgcykge1xuICByZXR1cm4gIXMgfHwgIXMuc2V0Q29udGV4dCB8fCAhZSA/IHQgOiBKcihpLCB0LCBlLCBzKTtcbn1cbmZ1bmN0aW9uIEpyKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBpLl9jaGFydC5nZXRDb250ZXh0KCksXG4gICAgbyA9IG1zKGkub3B0aW9ucyksXG4gICAgciA9IGkuX2RhdGFzZXRJbmRleCxcbiAgICBhID0gaS5vcHRpb25zLnNwYW5HYXBzLFxuICAgIGwgPSBlLmxlbmd0aCxcbiAgICBjID0gW107XG4gIHZhciBoID0gbyxcbiAgICBkID0gdFswXS5zdGFydCxcbiAgICB1ID0gZDtcbiAgZnVuY3Rpb24gZihwLCBnLCBtLCBiKSB7XG4gICAgdmFyIF8gPSBhID8gLTEgOiAxO1xuICAgIGlmIChwICE9PSBnKSB7XG4gICAgICBmb3IgKHAgKz0gbDsgZVtwICUgbF0uc2tpcDspIHAgLT0gXztcbiAgICAgIGZvciAoOyBlW2cgJSBsXS5za2lwOykgZyArPSBfO1xuICAgICAgcCAlIGwgIT09IGcgJSBsICYmIChjLnB1c2goe1xuICAgICAgICBzdGFydDogcCAlIGwsXG4gICAgICAgIGVuZDogZyAlIGwsXG4gICAgICAgIGxvb3A6IG0sXG4gICAgICAgIHN0eWxlOiBiXG4gICAgICB9KSwgaCA9IGIsIGQgPSBnICUgbCk7XG4gICAgfVxuICB9XG4gIHZhciBfaXRlcmF0b3IxID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodCksXG4gICAgX3N0ZXAxO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMS5zKCk7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMS5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgcCA9IF9zdGVwMS52YWx1ZTtcbiAgICAgIGQgPSBhID8gZCA6IHAuc3RhcnQ7XG4gICAgICB2YXIgZyA9IGVbZCAlIGxdLFxuICAgICAgICBtID0gdm9pZCAwO1xuICAgICAgZm9yICh1ID0gZCArIDE7IHUgPD0gcC5lbmQ7IHUrKykge1xuICAgICAgICB2YXIgYiA9IGVbdSAlIGxdO1xuICAgICAgICBtID0gbXMocy5zZXRDb250ZXh0KEJ0KG4sIHtcbiAgICAgICAgICB0eXBlOiBcInNlZ21lbnRcIixcbiAgICAgICAgICBwMDogZyxcbiAgICAgICAgICBwMTogYixcbiAgICAgICAgICBwMERhdGFJbmRleDogKHUgLSAxKSAlIGwsXG4gICAgICAgICAgcDFEYXRhSW5kZXg6IHUgJSBsLFxuICAgICAgICAgIGRhdGFzZXRJbmRleDogclxuICAgICAgICB9KSkpLCBacihtLCBoKSAmJiBmKGQsIHUgLSAxLCBwLmxvb3AsIGgpLCBnID0gYiwgaCA9IG07XG4gICAgICB9XG4gICAgICBkIDwgdSAtIDEgJiYgZihkLCB1IC0gMSwgcC5sb29wLCBoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjEuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjEuZigpO1xuICB9XG4gIHJldHVybiBjO1xufVxuZnVuY3Rpb24gbXMoaSkge1xuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRDb2xvcjogaS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgYm9yZGVyQ2FwU3R5bGU6IGkuYm9yZGVyQ2FwU3R5bGUsXG4gICAgYm9yZGVyRGFzaDogaS5ib3JkZXJEYXNoLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IGkuYm9yZGVyRGFzaE9mZnNldCxcbiAgICBib3JkZXJKb2luU3R5bGU6IGkuYm9yZGVySm9pblN0eWxlLFxuICAgIGJvcmRlcldpZHRoOiBpLmJvcmRlcldpZHRoLFxuICAgIGJvcmRlckNvbG9yOiBpLmJvcmRlckNvbG9yXG4gIH07XG59XG5mdW5jdGlvbiBacihpLCB0KSB7XG4gIGlmICghdCkgcmV0dXJuICExO1xuICB2YXIgZSA9IFtdLFxuICAgIHMgPSBmdW5jdGlvbiBzKG4sIG8pIHtcbiAgICAgIHJldHVybiBCaShvKSA/IChlLmluY2x1ZGVzKG8pIHx8IGUucHVzaChvKSwgZS5pbmRleE9mKG8pKSA6IG87XG4gICAgfTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGksIHMpICE9PSBKU09OLnN0cmluZ2lmeSh0LCBzKTtcbn1cbmZ1bmN0aW9uIERlKGksIHQsIGUpIHtcbiAgcmV0dXJuIGkub3B0aW9ucy5jbGlwID8gaVtlXSA6IHRbZV07XG59XG5mdW5jdGlvbiBRcihpLCB0KSB7XG4gIHZhciBlID0gaS54U2NhbGUsXG4gICAgcyA9IGkueVNjYWxlO1xuICByZXR1cm4gZSAmJiBzID8ge1xuICAgIGxlZnQ6IERlKGUsIHQsIFwibGVmdFwiKSxcbiAgICByaWdodDogRGUoZSwgdCwgXCJyaWdodFwiKSxcbiAgICB0b3A6IERlKHMsIHQsIFwidG9wXCIpLFxuICAgIGJvdHRvbTogRGUocywgdCwgXCJib3R0b21cIilcbiAgfSA6IHQ7XG59XG5mdW5jdGlvbiBXbihpLCB0KSB7XG4gIHZhciBlID0gdC5fY2xpcDtcbiAgaWYgKGUuZGlzYWJsZWQpIHJldHVybiAhMTtcbiAgdmFyIHMgPSBRcih0LCBpLmNoYXJ0QXJlYSk7XG4gIHJldHVybiB7XG4gICAgbGVmdDogZS5sZWZ0ID09PSAhMSA/IDAgOiBzLmxlZnQgLSAoZS5sZWZ0ID09PSAhMCA/IDAgOiBlLmxlZnQpLFxuICAgIHJpZ2h0OiBlLnJpZ2h0ID09PSAhMSA/IGkud2lkdGggOiBzLnJpZ2h0ICsgKGUucmlnaHQgPT09ICEwID8gMCA6IGUucmlnaHQpLFxuICAgIHRvcDogZS50b3AgPT09ICExID8gMCA6IHMudG9wIC0gKGUudG9wID09PSAhMCA/IDAgOiBlLnRvcCksXG4gICAgYm90dG9tOiBlLmJvdHRvbSA9PT0gITEgPyBpLmhlaWdodCA6IHMuYm90dG9tICsgKGUuYm90dG9tID09PSAhMCA/IDAgOiBlLmJvdHRvbSlcbiAgfTtcbn1cbi8qIVxuICogQ2hhcnQuanMgdjQuNS4xXG4gKiBodHRwczovL3d3dy5jaGFydGpzLm9yZ1xuICogKGMpIDIwMjUgQ2hhcnQuanMgQ29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xudmFyIHRhID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gdGEoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIHRhKTtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbCwgdGhpcy5fY2hhcnRzID0gLyogQF9fUFVSRV9fICovbmV3IE1hcCgpLCB0aGlzLl9ydW5uaW5nID0gITEsIHRoaXMuX2xhc3REYXRlID0gdm9pZCAwO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3ModGEsIFt7XG4gICAga2V5OiBcIl9ub3RpZnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25vdGlmeSh0LCBlLCBzLCBuKSB7XG4gICAgICB2YXIgbyA9IGUubGlzdGVuZXJzW25dLFxuICAgICAgICByID0gZS5kdXJhdGlvbjtcbiAgICAgIG8uZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gYSh7XG4gICAgICAgICAgY2hhcnQ6IHQsXG4gICAgICAgICAgaW5pdGlhbDogZS5pbml0aWFsLFxuICAgICAgICAgIG51bVN0ZXBzOiByLFxuICAgICAgICAgIGN1cnJlbnRTdGVwOiBNYXRoLm1pbihzIC0gZS5zdGFydCwgcilcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZnJlc2goKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHRoaXMuX3JlcXVlc3QgfHwgKHRoaXMuX3J1bm5pbmcgPSAhMCwgdGhpcy5fcmVxdWVzdCA9IFNuLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5fdXBkYXRlKCksIF90aGlzMy5fcmVxdWVzdCA9IG51bGwsIF90aGlzMy5fcnVubmluZyAmJiBfdGhpczMuX3JlZnJlc2goKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogRGF0ZS5ub3coKTtcbiAgICAgIHZhciBlID0gMDtcbiAgICAgIHRoaXMuX2NoYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChzLCBuKSB7XG4gICAgICAgIGlmICghcy5ydW5uaW5nIHx8ICFzLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICB2YXIgbyA9IHMuaXRlbXM7XG4gICAgICAgIHZhciByID0gby5sZW5ndGggLSAxLFxuICAgICAgICAgIGEgPSAhMSxcbiAgICAgICAgICBsO1xuICAgICAgICBmb3IgKDsgciA+PSAwOyAtLXIpIGwgPSBvW3JdLCBsLl9hY3RpdmUgPyAobC5fdG90YWwgPiBzLmR1cmF0aW9uICYmIChzLmR1cmF0aW9uID0gbC5fdG90YWwpLCBsLnRpY2sodCksIGEgPSAhMCkgOiAob1tyXSA9IG9bby5sZW5ndGggLSAxXSwgby5wb3AoKSk7XG4gICAgICAgIGEgJiYgKG4uZHJhdygpLCBfdGhpczQuX25vdGlmeShuLCBzLCB0LCBcInByb2dyZXNzXCIpKSwgby5sZW5ndGggfHwgKHMucnVubmluZyA9ICExLCBfdGhpczQuX25vdGlmeShuLCBzLCB0LCBcImNvbXBsZXRlXCIpLCBzLmluaXRpYWwgPSAhMSksIGUgKz0gby5sZW5ndGg7XG4gICAgICB9KSwgdGhpcy5fbGFzdERhdGUgPSB0LCBlID09PSAwICYmICh0aGlzLl9ydW5uaW5nID0gITEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QW5pbXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEFuaW1zKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fY2hhcnRzO1xuICAgICAgdmFyIHMgPSBlLmdldCh0KTtcbiAgICAgIHJldHVybiBzIHx8IChzID0ge1xuICAgICAgICBydW5uaW5nOiAhMSxcbiAgICAgICAgaW5pdGlhbDogITAsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgY29tcGxldGU6IFtdLFxuICAgICAgICAgIHByb2dyZXNzOiBbXVxuICAgICAgICB9XG4gICAgICB9LCBlLnNldCh0LCBzKSksIHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpc3RlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW4odCwgZSwgcykge1xuICAgICAgdGhpcy5fZ2V0QW5pbXModCkubGlzdGVuZXJzW2VdLnB1c2gocyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQodCwgZSkge1xuICAgICAgdmFyIF90aGlzJF9nZXRBbmltcyRpdGVtcztcbiAgICAgICFlIHx8ICFlLmxlbmd0aCB8fCAoX3RoaXMkX2dldEFuaW1zJGl0ZW1zID0gdGhpcy5fZ2V0QW5pbXModCkuaXRlbXMpLnB1c2guYXBwbHkoX3RoaXMkX2dldEFuaW1zJGl0ZW1zLCBfdG9Db25zdW1hYmxlQXJyYXkoZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRBbmltcyh0KS5pdGVtcy5sZW5ndGggPiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2NoYXJ0cy5nZXQodCk7XG4gICAgICBlICYmIChlLnJ1bm5pbmcgPSAhMCwgZS5zdGFydCA9IERhdGUubm93KCksIGUuZHVyYXRpb24gPSBlLml0ZW1zLnJlZHVjZShmdW5jdGlvbiAocywgbikge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgocywgbi5fZHVyYXRpb24pO1xuICAgICAgfSwgMCksIHRoaXMuX3JlZnJlc2goKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJ1bm5pbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVubmluZyh0KSB7XG4gICAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHJldHVybiAhMTtcbiAgICAgIHZhciBlID0gdGhpcy5fY2hhcnRzLmdldCh0KTtcbiAgICAgIHJldHVybiAhKCFlIHx8ICFlLnJ1bm5pbmcgfHwgIWUuaXRlbXMubGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fY2hhcnRzLmdldCh0KTtcbiAgICAgIGlmICghZSB8fCAhZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgICAgIHZhciBzID0gZS5pdGVtcztcbiAgICAgIHZhciBuID0gcy5sZW5ndGggLSAxO1xuICAgICAgZm9yICg7IG4gPj0gMDsgLS1uKSBzW25dLmNhbmNlbCgpO1xuICAgICAgZS5pdGVtcyA9IFtdLCB0aGlzLl9ub3RpZnkodCwgZSwgRGF0ZS5ub3coKSwgXCJjb21wbGV0ZVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hhcnRzW1wiZGVsZXRlXCJdKHQpO1xuICAgIH1cbiAgfV0pO1xufSgpO1xudmFyIHV0ID0gLyogQF9fUFVSRV9fICovbmV3IHRhKCk7XG52YXIgYnMgPSBcInRyYW5zcGFyZW50XCIsXG4gIGVhID0ge1xuICAgIFwiYm9vbGVhblwiOiBmdW5jdGlvbiBib29sZWFuKGksIHQsIGUpIHtcbiAgICAgIHJldHVybiBlID4gMC41ID8gdCA6IGk7XG4gICAgfSxcbiAgICBjb2xvcjogZnVuY3Rpb24gY29sb3IoaSwgdCwgZSkge1xuICAgICAgdmFyIHMgPSBycyhpIHx8IGJzKSxcbiAgICAgICAgbiA9IHMudmFsaWQgJiYgcnModCB8fCBicyk7XG4gICAgICByZXR1cm4gbiAmJiBuLnZhbGlkID8gbi5taXgocywgZSkuaGV4U3RyaW5nKCkgOiB0O1xuICAgIH0sXG4gICAgbnVtYmVyOiBmdW5jdGlvbiBudW1iZXIoaSwgdCwgZSkge1xuICAgICAgcmV0dXJuIGkgKyAodCAtIGkpICogZTtcbiAgICB9XG4gIH07XG52YXIgaWEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBpYSh0LCBlLCBzLCBuKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIGlhKTtcbiAgICB2YXIgbyA9IGVbc107XG4gICAgbiA9IHdlKFt0LnRvLCBuLCBvLCB0LmZyb21dKTtcbiAgICB2YXIgciA9IHdlKFt0LmZyb20sIG8sIG5dKTtcbiAgICB0aGlzLl9hY3RpdmUgPSAhMCwgdGhpcy5fZm4gPSB0LmZuIHx8IGVhW3QudHlwZSB8fCBfdHlwZW9mKHIpXSwgdGhpcy5fZWFzaW5nID0gaGVbdC5lYXNpbmddIHx8IGhlLmxpbmVhciwgdGhpcy5fc3RhcnQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgKyAodC5kZWxheSB8fCAwKSksIHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWwgPSBNYXRoLmZsb29yKHQuZHVyYXRpb24pLCB0aGlzLl9sb29wID0gISF0Lmxvb3AsIHRoaXMuX3RhcmdldCA9IGUsIHRoaXMuX3Byb3AgPSBzLCB0aGlzLl9mcm9tID0gciwgdGhpcy5fdG8gPSBuLCB0aGlzLl9wcm9taXNlcyA9IHZvaWQgMDtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKGlhLCBbe1xuICAgIGtleTogXCJhY3RpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWN0aXZlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSh0LCBlLCBzKSB7XG4gICAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX25vdGlmeSghMSk7XG4gICAgICAgIHZhciBuID0gdGhpcy5fdGFyZ2V0W3RoaXMuX3Byb3BdLFxuICAgICAgICAgIG8gPSBzIC0gdGhpcy5fc3RhcnQsXG4gICAgICAgICAgciA9IHRoaXMuX2R1cmF0aW9uIC0gbztcbiAgICAgICAgdGhpcy5fc3RhcnQgPSBzLCB0aGlzLl9kdXJhdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5tYXgociwgdC5kdXJhdGlvbikpLCB0aGlzLl90b3RhbCArPSBvLCB0aGlzLl9sb29wID0gISF0Lmxvb3AsIHRoaXMuX3RvID0gd2UoW3QudG8sIGUsIG4sIHQuZnJvbV0pLCB0aGlzLl9mcm9tID0gd2UoW3QuZnJvbSwgbiwgZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5jZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgdGhpcy5fYWN0aXZlICYmICh0aGlzLnRpY2soRGF0ZS5ub3coKSksIHRoaXMuX2FjdGl2ZSA9ICExLCB0aGlzLl9ub3RpZnkoITEpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aWNrKHQpIHtcbiAgICAgIHZhciBlID0gdCAtIHRoaXMuX3N0YXJ0LFxuICAgICAgICBzID0gdGhpcy5fZHVyYXRpb24sXG4gICAgICAgIG4gPSB0aGlzLl9wcm9wLFxuICAgICAgICBvID0gdGhpcy5fZnJvbSxcbiAgICAgICAgciA9IHRoaXMuX2xvb3AsXG4gICAgICAgIGEgPSB0aGlzLl90bztcbiAgICAgIHZhciBsO1xuICAgICAgaWYgKHRoaXMuX2FjdGl2ZSA9IG8gIT09IGEgJiYgKHIgfHwgZSA8IHMpLCAhdGhpcy5fYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldFtuXSA9IGEsIHRoaXMuX25vdGlmeSghMCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlIDwgMCkge1xuICAgICAgICB0aGlzLl90YXJnZXRbbl0gPSBvO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsID0gZSAvIHMgJSAyLCBsID0gciAmJiBsID4gMSA/IDIgLSBsIDogbCwgbCA9IHRoaXMuX2Vhc2luZyhNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBsKSkpLCB0aGlzLl90YXJnZXRbbl0gPSB0aGlzLl9mbihvLCBhLCBsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2FpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3YWl0KCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9wcm9taXNlcyB8fCAodGhpcy5fcHJvbWlzZXMgPSBbXSk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGUsIHMpIHtcbiAgICAgICAgdC5wdXNoKHtcbiAgICAgICAgICByZXM6IGUsXG4gICAgICAgICAgcmVqOiBzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9ub3RpZnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25vdGlmeSh0KSB7XG4gICAgICB2YXIgZSA9IHQgPyBcInJlc1wiIDogXCJyZWpcIixcbiAgICAgICAgcyA9IHRoaXMuX3Byb21pc2VzIHx8IFtdO1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBzLmxlbmd0aDsgbisrKSBzW25dW2VdKCk7XG4gICAgfVxuICB9XSk7XG59KCk7XG52YXIgTm4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBObih0LCBlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5uKTtcbiAgICB0aGlzLl9jaGFydCA9IHQsIHRoaXMuX3Byb3BlcnRpZXMgPSAvKiBAX19QVVJFX18gKi9uZXcgTWFwKCksIHRoaXMuY29uZmlndXJlKGUpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoTm4sIFt7XG4gICAga2V5OiBcImNvbmZpZ3VyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25maWd1cmUodCkge1xuICAgICAgaWYgKCFUKHQpKSByZXR1cm47XG4gICAgICB2YXIgZSA9IE9iamVjdC5rZXlzKFcuYW5pbWF0aW9uKSxcbiAgICAgICAgcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0KS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHZhciBvID0gdFtuXTtcbiAgICAgICAgaWYgKCFUKG8pKSByZXR1cm47XG4gICAgICAgIHZhciByID0ge307XG4gICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9lMiA9IGU7IF9pMiA8IF9lMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgdmFyIGEgPSBfZTJbX2kyXTtcbiAgICAgICAgICByW2FdID0gb1thXTtcbiAgICAgICAgfVxuICAgICAgICAoTihvLnByb3BlcnRpZXMpICYmIG8ucHJvcGVydGllcyB8fCBbbl0pLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAoYSA9PT0gbiB8fCAhcy5oYXMoYSkpICYmIHMuc2V0KGEsIHIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfYW5pbWF0ZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FuaW1hdGVPcHRpb25zKHQsIGUpIHtcbiAgICAgIHZhciBzID0gZS5vcHRpb25zLFxuICAgICAgICBuID0gbmEodCwgcyk7XG4gICAgICBpZiAoIW4pIHJldHVybiBbXTtcbiAgICAgIHZhciBvID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyhuLCBzKTtcbiAgICAgIHJldHVybiBzLiRzaGFyZWQgJiYgc2EodC5vcHRpb25zLiRhbmltYXRpb25zLCBzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdC5vcHRpb25zID0gcztcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHt9KSwgbztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUFuaW1hdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUFuaW1hdGlvbnModCwgZSkge1xuICAgICAgdmFyIHMgPSB0aGlzLl9wcm9wZXJ0aWVzLFxuICAgICAgICBuID0gW10sXG4gICAgICAgIG8gPSB0LiRhbmltYXRpb25zIHx8ICh0LiRhbmltYXRpb25zID0ge30pLFxuICAgICAgICByID0gT2JqZWN0LmtleXMoZSksXG4gICAgICAgIGEgPSBEYXRlLm5vdygpO1xuICAgICAgdmFyIGw7XG4gICAgICBmb3IgKGwgPSByLmxlbmd0aCAtIDE7IGwgPj0gMDsgLS1sKSB7XG4gICAgICAgIHZhciBjID0gcltsXTtcbiAgICAgICAgaWYgKGMuY2hhckF0KDApID09PSBcIiRcIikgY29udGludWU7XG4gICAgICAgIGlmIChjID09PSBcIm9wdGlvbnNcIikge1xuICAgICAgICAgIG4ucHVzaC5hcHBseShuLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fYW5pbWF0ZU9wdGlvbnModCwgZSkpKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaCA9IGVbY107XG4gICAgICAgIHZhciBkID0gb1tjXTtcbiAgICAgICAgdmFyIHUgPSBzLmdldChjKTtcbiAgICAgICAgaWYgKGQpIGlmICh1ICYmIGQuYWN0aXZlKCkpIHtcbiAgICAgICAgICBkLnVwZGF0ZSh1LCBoLCBhKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGQuY2FuY2VsKCk7XG4gICAgICAgIGlmICghdSB8fCAhdS5kdXJhdGlvbikge1xuICAgICAgICAgIHRbY10gPSBoO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG9bY10gPSBkID0gbmV3IGlhKHUsIHQsIGMsIGgpLCBuLnB1c2goZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSh0LCBlKSB7XG4gICAgICBpZiAodGhpcy5fcHJvcGVydGllcy5zaXplID09PSAwKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odCwgZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyh0LCBlKTtcbiAgICAgIGlmIChzLmxlbmd0aCkgcmV0dXJuIHV0LmFkZCh0aGlzLl9jaGFydCwgcyksICEwO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuZnVuY3Rpb24gc2EoaSwgdCkge1xuICB2YXIgZSA9IFtdLFxuICAgIHMgPSBPYmplY3Qua2V5cyh0KTtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBzLmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIG8gPSBpW3Nbbl1dO1xuICAgIG8gJiYgby5hY3RpdmUoKSAmJiBlLnB1c2goby53YWl0KCkpO1xuICB9XG4gIHJldHVybiBQcm9taXNlLmFsbChlKTtcbn1cbmZ1bmN0aW9uIG5hKGksIHQpIHtcbiAgaWYgKCF0KSByZXR1cm47XG4gIHZhciBlID0gaS5vcHRpb25zO1xuICBpZiAoIWUpIHtcbiAgICBpLm9wdGlvbnMgPSB0O1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gZS4kc2hhcmVkICYmIChpLm9wdGlvbnMgPSBlID0gT2JqZWN0LmFzc2lnbih7fSwgZSwge1xuICAgICRzaGFyZWQ6ICExLFxuICAgICRhbmltYXRpb25zOiB7fVxuICB9KSksIGU7XG59XG5mdW5jdGlvbiBfcyhpLCB0KSB7XG4gIHZhciBlID0gaSAmJiBpLm9wdGlvbnMgfHwge30sXG4gICAgcyA9IGUucmV2ZXJzZSxcbiAgICBuID0gZS5taW4gPT09IHZvaWQgMCA/IHQgOiAwLFxuICAgIG8gPSBlLm1heCA9PT0gdm9pZCAwID8gdCA6IDA7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHMgPyBvIDogbixcbiAgICBlbmQ6IHMgPyBuIDogb1xuICB9O1xufVxuZnVuY3Rpb24gb2EoaSwgdCwgZSkge1xuICBpZiAoZSA9PT0gITEpIHJldHVybiAhMTtcbiAgdmFyIHMgPSBfcyhpLCBlKSxcbiAgICBuID0gX3ModCwgZSk7XG4gIHJldHVybiB7XG4gICAgdG9wOiBuLmVuZCxcbiAgICByaWdodDogcy5lbmQsXG4gICAgYm90dG9tOiBuLnN0YXJ0LFxuICAgIGxlZnQ6IHMuc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHJhKGkpIHtcbiAgdmFyIHQsIGUsIHMsIG47XG4gIHJldHVybiBUKGkpID8gKHQgPSBpLnRvcCwgZSA9IGkucmlnaHQsIHMgPSBpLmJvdHRvbSwgbiA9IGkubGVmdCkgOiB0ID0gZSA9IHMgPSBuID0gaSwge1xuICAgIHRvcDogdCxcbiAgICByaWdodDogZSxcbiAgICBib3R0b206IHMsXG4gICAgbGVmdDogbixcbiAgICBkaXNhYmxlZDogaSA9PT0gITFcbiAgfTtcbn1cbmZ1bmN0aW9uIFZuKGksIHQpIHtcbiAgdmFyIGUgPSBbXSxcbiAgICBzID0gaS5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKHQpO1xuICB2YXIgbiwgbztcbiAgZm9yIChuID0gMCwgbyA9IHMubGVuZ3RoOyBuIDwgbzsgKytuKSBlLnB1c2goc1tuXS5pbmRleCk7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24geHMoaSwgdCwgZSkge1xuICB2YXIgcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIHZhciBuID0gaS5rZXlzLFxuICAgIG8gPSBzLm1vZGUgPT09IFwic2luZ2xlXCI7XG4gIHZhciByLCBhLCBsLCBjO1xuICBpZiAodCA9PT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgaCA9ICExO1xuICBmb3IgKHIgPSAwLCBhID0gbi5sZW5ndGg7IHIgPCBhOyArK3IpIHtcbiAgICBpZiAobCA9ICtuW3JdLCBsID09PSBlKSB7XG4gICAgICBpZiAoaCA9ICEwLCBzLmFsbCkgY29udGludWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgYyA9IGkudmFsdWVzW2xdLCBxKGMpICYmIChvIHx8IHQgPT09IDAgfHwgbHQodCkgPT09IGx0KGMpKSAmJiAodCArPSBjKTtcbiAgfVxuICByZXR1cm4gIWggJiYgIXMuYWxsID8gMCA6IHQ7XG59XG5mdW5jdGlvbiBhYShpLCB0KSB7XG4gIHZhciBlID0gdC5pU2NhbGUsXG4gICAgcyA9IHQudlNjYWxlLFxuICAgIG4gPSBlLmF4aXMgPT09IFwieFwiID8gXCJ4XCIgOiBcInlcIixcbiAgICBvID0gcy5heGlzID09PSBcInhcIiA/IFwieFwiIDogXCJ5XCIsXG4gICAgciA9IE9iamVjdC5rZXlzKGkpLFxuICAgIGEgPSBuZXcgQXJyYXkoci5sZW5ndGgpO1xuICB2YXIgbCwgYywgaDtcbiAgZm9yIChsID0gMCwgYyA9IHIubGVuZ3RoOyBsIDwgYzsgKytsKSBoID0gcltsXSwgYVtsXSA9IF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoe30sIG4sIGgpLCBvLCBpW2hdKTtcbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiByaShpLCB0KSB7XG4gIHZhciBlID0gaSAmJiBpLm9wdGlvbnMuc3RhY2tlZDtcbiAgcmV0dXJuIGUgfHwgZSA9PT0gdm9pZCAwICYmIHQuc3RhY2sgIT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGxhKGksIHQsIGUpIHtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KGkuaWQsIFwiLlwiKS5jb25jYXQodC5pZCwgXCIuXCIpLmNvbmNhdChlLnN0YWNrIHx8IGUudHlwZSk7XG59XG5mdW5jdGlvbiBjYShpKSB7XG4gIHZhciBfaSRnZXRVc2VyQm91bmRzID0gaS5nZXRVc2VyQm91bmRzKCksXG4gICAgdCA9IF9pJGdldFVzZXJCb3VuZHMubWluLFxuICAgIGUgPSBfaSRnZXRVc2VyQm91bmRzLm1heCxcbiAgICBzID0gX2kkZ2V0VXNlckJvdW5kcy5taW5EZWZpbmVkLFxuICAgIG4gPSBfaSRnZXRVc2VyQm91bmRzLm1heERlZmluZWQ7XG4gIHJldHVybiB7XG4gICAgbWluOiBzID8gdCA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICBtYXg6IG4gPyBlIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gIH07XG59XG5mdW5jdGlvbiBoYShpLCB0LCBlKSB7XG4gIHZhciBzID0gaVt0XSB8fCAoaVt0XSA9IHt9KTtcbiAgcmV0dXJuIHNbZV0gfHwgKHNbZV0gPSB7fSk7XG59XG5mdW5jdGlvbiB5cyhpLCB0LCBlLCBzKSB7XG4gIHZhciBfaXRlcmF0b3IxMCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHQuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMocykucmV2ZXJzZSgpKSxcbiAgICBfc3RlcDEwO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMTAucygpOyAhKF9zdGVwMTAgPSBfaXRlcmF0b3IxMC5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgbiA9IF9zdGVwMTAudmFsdWU7XG4gICAgICB2YXIgbyA9IGlbbi5pbmRleF07XG4gICAgICBpZiAoZSAmJiBvID4gMCB8fCAhZSAmJiBvIDwgMCkgcmV0dXJuIG4uaW5kZXg7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IxMC5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMTAuZigpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdnMoaSwgdCkge1xuICB2YXIgZSA9IGkuY2hhcnQsXG4gICAgcyA9IGkuX2NhY2hlZE1ldGEsXG4gICAgbiA9IGUuX3N0YWNrcyB8fCAoZS5fc3RhY2tzID0ge30pLFxuICAgIG8gPSBzLmlTY2FsZSxcbiAgICByID0gcy52U2NhbGUsXG4gICAgYSA9IHMuaW5kZXgsXG4gICAgbCA9IG8uYXhpcyxcbiAgICBjID0gci5heGlzLFxuICAgIGggPSBsYShvLCByLCBzKSxcbiAgICBkID0gdC5sZW5ndGg7XG4gIHZhciB1O1xuICBmb3IgKHZhciBmID0gMDsgZiA8IGQ7ICsrZikge1xuICAgIHZhciBwID0gdFtmXSxcbiAgICAgIGcgPSBwW2xdLFxuICAgICAgbSA9IHBbY10sXG4gICAgICBiID0gcC5fc3RhY2tzIHx8IChwLl9zdGFja3MgPSB7fSk7XG4gICAgdSA9IGJbY10gPSBoYShuLCBoLCBnKSwgdVthXSA9IG0sIHUuX3RvcCA9IHlzKHUsIHIsICEwLCBzLnR5cGUpLCB1Ll9ib3R0b20gPSB5cyh1LCByLCAhMSwgcy50eXBlKTtcbiAgICB2YXIgXyA9IHUuX3Zpc3VhbFZhbHVlcyB8fCAodS5fdmlzdWFsVmFsdWVzID0ge30pO1xuICAgIF9bYV0gPSBtO1xuICB9XG59XG5mdW5jdGlvbiBhaShpLCB0KSB7XG4gIHZhciBlID0gaS5zY2FsZXM7XG4gIHJldHVybiBPYmplY3Qua2V5cyhlKS5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gZVtzXS5heGlzID09PSB0O1xuICB9KS5zaGlmdCgpO1xufVxuZnVuY3Rpb24gZGEoaSwgdCkge1xuICByZXR1cm4gQnQoaSwge1xuICAgIGFjdGl2ZTogITEsXG4gICAgZGF0YXNldDogdm9pZCAwLFxuICAgIGRhdGFzZXRJbmRleDogdCxcbiAgICBpbmRleDogdCxcbiAgICBtb2RlOiBcImRlZmF1bHRcIixcbiAgICB0eXBlOiBcImRhdGFzZXRcIlxuICB9KTtcbn1cbmZ1bmN0aW9uIHVhKGksIHQsIGUpIHtcbiAgcmV0dXJuIEJ0KGksIHtcbiAgICBhY3RpdmU6ICExLFxuICAgIGRhdGFJbmRleDogdCxcbiAgICBwYXJzZWQ6IHZvaWQgMCxcbiAgICByYXc6IHZvaWQgMCxcbiAgICBlbGVtZW50OiBlLFxuICAgIGluZGV4OiB0LFxuICAgIG1vZGU6IFwiZGVmYXVsdFwiLFxuICAgIHR5cGU6IFwiZGF0YVwiXG4gIH0pO1xufVxuZnVuY3Rpb24gUXQoaSwgdCkge1xuICB2YXIgZSA9IGkuY29udHJvbGxlci5pbmRleCxcbiAgICBzID0gaS52U2NhbGUgJiYgaS52U2NhbGUuYXhpcztcbiAgaWYgKHMpIHtcbiAgICB0ID0gdCB8fCBpLl9wYXJzZWQ7XG4gICAgdmFyIF9pdGVyYXRvcjExID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodCksXG4gICAgICBfc3RlcDExO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjExLnMoKTsgIShfc3RlcDExID0gX2l0ZXJhdG9yMTEubigpKS5kb25lOykge1xuICAgICAgICB2YXIgbiA9IF9zdGVwMTEudmFsdWU7XG4gICAgICAgIHZhciBvID0gbi5fc3RhY2tzO1xuICAgICAgICBpZiAoIW8gfHwgb1tzXSA9PT0gdm9pZCAwIHx8IG9bc11bZV0gPT09IHZvaWQgMCkgcmV0dXJuO1xuICAgICAgICBkZWxldGUgb1tzXVtlXSwgb1tzXS5fdmlzdWFsVmFsdWVzICE9PSB2b2lkIDAgJiYgb1tzXS5fdmlzdWFsVmFsdWVzW2VdICE9PSB2b2lkIDAgJiYgZGVsZXRlIG9bc10uX3Zpc3VhbFZhbHVlc1tlXTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjExLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMTEuZigpO1xuICAgIH1cbiAgfVxufVxudmFyIGxpID0gZnVuY3Rpb24gbGkoaSkge1xuICAgIHJldHVybiBpID09PSBcInJlc2V0XCIgfHwgaSA9PT0gXCJub25lXCI7XG4gIH0sXG4gIE1zID0gZnVuY3Rpb24gTXMoaSwgdCkge1xuICAgIHJldHVybiB0ID8gaSA6IE9iamVjdC5hc3NpZ24oe30sIGkpO1xuICB9LFxuICBmYSA9IGZ1bmN0aW9uIGZhKGksIHQsIGUpIHtcbiAgICByZXR1cm4gaSAmJiAhdC5oaWRkZW4gJiYgdC5fc3RhY2tlZCAmJiB7XG4gICAgICBrZXlzOiBWbihlLCAhMCksXG4gICAgICB2YWx1ZXM6IG51bGxcbiAgICB9O1xuICB9O1xudmFyIGt0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24ga3QodCwgZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBrdCk7XG4gICAgdGhpcy5jaGFydCA9IHQsIHRoaXMuX2N0eCA9IHQuY3R4LCB0aGlzLmluZGV4ID0gZSwgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fSwgdGhpcy5fY2FjaGVkTWV0YSA9IHRoaXMuZ2V0TWV0YSgpLCB0aGlzLl90eXBlID0gdGhpcy5fY2FjaGVkTWV0YS50eXBlLCB0aGlzLm9wdGlvbnMgPSB2b2lkIDAsIHRoaXMuX3BhcnNpbmcgPSAhMSwgdGhpcy5fZGF0YSA9IHZvaWQgMCwgdGhpcy5fb2JqZWN0RGF0YSA9IHZvaWQgMCwgdGhpcy5fc2hhcmVkT3B0aW9ucyA9IHZvaWQgMCwgdGhpcy5fZHJhd1N0YXJ0ID0gdm9pZCAwLCB0aGlzLl9kcmF3Q291bnQgPSB2b2lkIDAsIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9ICExLCB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9ICExLCB0aGlzLiRjb250ZXh0ID0gdm9pZCAwLCB0aGlzLl9zeW5jTGlzdCA9IFtdLCB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9ICh0aGlzIGluc3RhbmNlb2Yga3QgPyB0aGlzLmNvbnN0cnVjdG9yIDogdm9pZCAwKS5kYXRhc2V0RWxlbWVudFR5cGUsIHRoaXMuZGF0YUVsZW1lbnRUeXBlID0gKHRoaXMgaW5zdGFuY2VvZiBrdCA/IHRoaXMuY29uc3RydWN0b3IgOiB2b2lkIDApLmRhdGFFbGVtZW50VHlwZSwgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhrdCwgW3tcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgdGhpcy5jb25maWd1cmUoKSwgdGhpcy5saW5rU2NhbGVzKCksIHQuX3N0YWNrZWQgPSByaSh0LnZTY2FsZSwgdCksIHRoaXMuYWRkRWxlbWVudHMoKSwgdGhpcy5vcHRpb25zLmZpbGwgJiYgIXRoaXMuY2hhcnQuaXNQbHVnaW5FbmFibGVkKFwiZmlsbGVyXCIpICYmIGNvbnNvbGUud2FybihcIlRyaWVkIHRvIHVzZSB0aGUgJ2ZpbGwnIG9wdGlvbiB3aXRob3V0IHRoZSAnRmlsbGVyJyBwbHVnaW4gZW5hYmxlZC4gUGxlYXNlIGltcG9ydCBhbmQgcmVnaXN0ZXIgdGhlICdGaWxsZXInIHBsdWdpbiBhbmQgbWFrZSBzdXJlIGl0IGlzIG5vdCBkaXNhYmxlZCBpbiB0aGUgb3B0aW9uc1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlSW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlSW5kZXgodCkge1xuICAgICAgdGhpcy5pbmRleCAhPT0gdCAmJiBRdCh0aGlzLl9jYWNoZWRNZXRhKSwgdGhpcy5pbmRleCA9IHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpbmtTY2FsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlua1NjYWxlcygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5jaGFydCxcbiAgICAgICAgZSA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIHMgPSB0aGlzLmdldERhdGFzZXQoKSxcbiAgICAgICAgbiA9IGZ1bmN0aW9uIG4oZCwgdSwgZiwgcCkge1xuICAgICAgICAgIHJldHVybiBkID09PSBcInhcIiA/IHUgOiBkID09PSBcInJcIiA/IHAgOiBmO1xuICAgICAgICB9LFxuICAgICAgICBvID0gZS54QXhpc0lEID0gRChzLnhBeGlzSUQsIGFpKHQsIFwieFwiKSksXG4gICAgICAgIHIgPSBlLnlBeGlzSUQgPSBEKHMueUF4aXNJRCwgYWkodCwgXCJ5XCIpKSxcbiAgICAgICAgYSA9IGUuckF4aXNJRCA9IEQocy5yQXhpc0lELCBhaSh0LCBcInJcIikpLFxuICAgICAgICBsID0gZS5pbmRleEF4aXMsXG4gICAgICAgIGMgPSBlLmlBeGlzSUQgPSBuKGwsIG8sIHIsIGEpLFxuICAgICAgICBoID0gZS52QXhpc0lEID0gbihsLCByLCBvLCBhKTtcbiAgICAgIGUueFNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKG8pLCBlLnlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChyKSwgZS5yU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoYSksIGUuaVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKGMpLCBlLnZTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGF0YXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREYXRhc2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0aGlzLmluZGV4XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWV0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNZXRhKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEodGhpcy5pbmRleCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNjYWxlRm9ySWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2NhbGVGb3JJZCh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFydC5zY2FsZXNbdF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRPdGhlclNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRPdGhlclNjYWxlKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgIHJldHVybiB0ID09PSBlLmlTY2FsZSA/IGUudlNjYWxlIDogZS5pU2NhbGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5fdXBkYXRlKFwicmVzZXRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgdGhpcy5fZGF0YSAmJiBzcyh0aGlzLl9kYXRhLCB0aGlzKSwgdC5fc3RhY2tlZCAmJiBRdCh0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2RhdGFDaGVja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGF0YUNoZWNrKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLmdldERhdGFzZXQoKSxcbiAgICAgICAgZSA9IHQuZGF0YSB8fCAodC5kYXRhID0gW10pLFxuICAgICAgICBzID0gdGhpcy5fZGF0YTtcbiAgICAgIGlmIChUKGUpKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGFhKGUsIG4pO1xuICAgICAgfSBlbHNlIGlmIChzICE9PSBlKSB7XG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgc3MocywgdGhpcyk7XG4gICAgICAgICAgdmFyIF9uMiA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgICAgUXQoX24yKSwgX24yLl9wYXJzZWQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlICYmIE9iamVjdC5pc0V4dGVuc2libGUoZSkgJiYgSm8oZSwgdGhpcyksIHRoaXMuX3N5bmNMaXN0ID0gW10sIHRoaXMuX2RhdGEgPSBlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFbGVtZW50cygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgIHRoaXMuX2RhdGFDaGVjaygpLCB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSAmJiAodC5kYXRhc2V0ID0gbmV3IHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWlsZE9yVXBkYXRlRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fY2FjaGVkTWV0YSxcbiAgICAgICAgcyA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgICAgdmFyIG4gPSAhMTtcbiAgICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuICAgICAgdmFyIG8gPSBlLl9zdGFja2VkO1xuICAgICAgZS5fc3RhY2tlZCA9IHJpKGUudlNjYWxlLCBlKSwgZS5zdGFjayAhPT0gcy5zdGFjayAmJiAobiA9ICEwLCBRdChlKSwgZS5zdGFjayA9IHMuc3RhY2spLCB0aGlzLl9yZXN5bmNFbGVtZW50cyh0KSwgKG4gfHwgbyAhPT0gZS5fc3RhY2tlZCkgJiYgKHZzKHRoaXMsIGUuX3BhcnNlZCksIGUuX3N0YWNrZWQgPSByaShlLnZTY2FsZSwgZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25maWd1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uZmlndXJlKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLmNoYXJ0LmNvbmZpZyxcbiAgICAgICAgZSA9IHQuZGF0YXNldFNjb3BlS2V5cyh0aGlzLl90eXBlKSxcbiAgICAgICAgcyA9IHQuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBlLCAhMCk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB0LmNyZWF0ZVJlc29sdmVyKHMsIHRoaXMuZ2V0Q29udGV4dCgpKSwgdGhpcy5fcGFyc2luZyA9IHRoaXMub3B0aW9ucy5wYXJzaW5nLCB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZSh0LCBlKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIG4gPSB0aGlzLl9kYXRhLFxuICAgICAgICBvID0gcy5pU2NhbGUsXG4gICAgICAgIHIgPSBzLl9zdGFja2VkLFxuICAgICAgICBhID0gby5heGlzO1xuICAgICAgdmFyIGwgPSB0ID09PSAwICYmIGUgPT09IG4ubGVuZ3RoID8gITAgOiBzLl9zb3J0ZWQsXG4gICAgICAgIGMgPSB0ID4gMCAmJiBzLl9wYXJzZWRbdCAtIDFdLFxuICAgICAgICBoLFxuICAgICAgICBkLFxuICAgICAgICB1O1xuICAgICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09ICExKSBzLl9wYXJzZWQgPSBuLCBzLl9zb3J0ZWQgPSAhMCwgdSA9IG47ZWxzZSB7XG4gICAgICAgIE4oblt0XSkgPyB1ID0gdGhpcy5wYXJzZUFycmF5RGF0YShzLCBuLCB0LCBlKSA6IFQoblt0XSkgPyB1ID0gdGhpcy5wYXJzZU9iamVjdERhdGEocywgbiwgdCwgZSkgOiB1ID0gdGhpcy5wYXJzZVByaW1pdGl2ZURhdGEocywgbiwgdCwgZSk7XG4gICAgICAgIHZhciBmID0gZnVuY3Rpb24gZigpIHtcbiAgICAgICAgICByZXR1cm4gZFthXSA9PT0gbnVsbCB8fCBjICYmIGRbYV0gPCBjW2FdO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGggPSAwOyBoIDwgZTsgKytoKSBzLl9wYXJzZWRbaCArIHRdID0gZCA9IHVbaF0sIGwgJiYgKGYoKSAmJiAobCA9ICExKSwgYyA9IGQpO1xuICAgICAgICBzLl9zb3J0ZWQgPSBsO1xuICAgICAgfVxuICAgICAgciAmJiB2cyh0aGlzLCB1KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VQcmltaXRpdmVEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlUHJpbWl0aXZlRGF0YSh0LCBlLCBzLCBuKSB7XG4gICAgICB2YXIgbyA9IHQuaVNjYWxlLFxuICAgICAgICByID0gdC52U2NhbGUsXG4gICAgICAgIGEgPSBvLmF4aXMsXG4gICAgICAgIGwgPSByLmF4aXMsXG4gICAgICAgIGMgPSBvLmdldExhYmVscygpLFxuICAgICAgICBoID0gbyA9PT0gcixcbiAgICAgICAgZCA9IG5ldyBBcnJheShuKTtcbiAgICAgIHZhciB1LCBmLCBwO1xuICAgICAgZm9yICh1ID0gMCwgZiA9IG47IHUgPCBmOyArK3UpIHAgPSB1ICsgcywgZFt1XSA9IF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoe30sIGEsIGggfHwgby5wYXJzZShjW3BdLCBwKSksIGwsIHIucGFyc2UoZVtwXSwgcCkpO1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlQXJyYXlEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlQXJyYXlEYXRhKHQsIGUsIHMsIG4pIHtcbiAgICAgIHZhciBvID0gdC54U2NhbGUsXG4gICAgICAgIHIgPSB0LnlTY2FsZSxcbiAgICAgICAgYSA9IG5ldyBBcnJheShuKTtcbiAgICAgIHZhciBsLCBjLCBoLCBkO1xuICAgICAgZm9yIChsID0gMCwgYyA9IG47IGwgPCBjOyArK2wpIGggPSBsICsgcywgZCA9IGVbaF0sIGFbbF0gPSB7XG4gICAgICAgIHg6IG8ucGFyc2UoZFswXSwgaCksXG4gICAgICAgIHk6IHIucGFyc2UoZFsxXSwgaClcbiAgICAgIH07XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VPYmplY3REYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlT2JqZWN0RGF0YSh0LCBlLCBzLCBuKSB7XG4gICAgICB2YXIgbyA9IHQueFNjYWxlLFxuICAgICAgICByID0gdC55U2NhbGUsXG4gICAgICAgIF90aGlzJF9wYXJzaW5nID0gdGhpcy5fcGFyc2luZyxcbiAgICAgICAgX3RoaXMkX3BhcnNpbmckeEF4aXNLID0gX3RoaXMkX3BhcnNpbmcueEF4aXNLZXksXG4gICAgICAgIGEgPSBfdGhpcyRfcGFyc2luZyR4QXhpc0sgPT09IHZvaWQgMCA/IFwieFwiIDogX3RoaXMkX3BhcnNpbmckeEF4aXNLLFxuICAgICAgICBfdGhpcyRfcGFyc2luZyR5QXhpc0sgPSBfdGhpcyRfcGFyc2luZy55QXhpc0tleSxcbiAgICAgICAgbCA9IF90aGlzJF9wYXJzaW5nJHlBeGlzSyA9PT0gdm9pZCAwID8gXCJ5XCIgOiBfdGhpcyRfcGFyc2luZyR5QXhpc0ssXG4gICAgICAgIGMgPSBuZXcgQXJyYXkobik7XG4gICAgICB2YXIgaCwgZCwgdSwgZjtcbiAgICAgIGZvciAoaCA9IDAsIGQgPSBuOyBoIDwgZDsgKytoKSB1ID0gaCArIHMsIGYgPSBlW3VdLCBjW2hdID0ge1xuICAgICAgICB4OiBvLnBhcnNlKEl0KGYsIGEpLCB1KSxcbiAgICAgICAgeTogci5wYXJzZShJdChmLCBsKSwgdSlcbiAgICAgIH07XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGFyc2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhcnNlZCh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkW3RdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREYXRhRWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREYXRhRWxlbWVudCh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW3RdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseVN0YWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5U3RhY2sodCwgZSwgcykge1xuICAgICAgdmFyIG4gPSB0aGlzLmNoYXJ0LFxuICAgICAgICBvID0gdGhpcy5fY2FjaGVkTWV0YSxcbiAgICAgICAgciA9IGVbdC5heGlzXSxcbiAgICAgICAgYSA9IHtcbiAgICAgICAgICBrZXlzOiBWbihuLCAhMCksXG4gICAgICAgICAgdmFsdWVzOiBlLl9zdGFja3NbdC5heGlzXS5fdmlzdWFsVmFsdWVzXG4gICAgICAgIH07XG4gICAgICByZXR1cm4geHMoYSwgciwgby5pbmRleCwge1xuICAgICAgICBtb2RlOiBzXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlUmFuZ2VGcm9tUGFyc2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZCh0LCBlLCBzLCBuKSB7XG4gICAgICB2YXIgbyA9IHNbZS5heGlzXTtcbiAgICAgIHZhciByID0gbyA9PT0gbnVsbCA/IE5hTiA6IG87XG4gICAgICB2YXIgYSA9IG4gJiYgcy5fc3RhY2tzW2UuYXhpc107XG4gICAgICBuICYmIGEgJiYgKG4udmFsdWVzID0gYSwgciA9IHhzKG4sIG8sIHRoaXMuX2NhY2hlZE1ldGEuaW5kZXgpKSwgdC5taW4gPSBNYXRoLm1pbih0Lm1pbiwgciksIHQubWF4ID0gTWF0aC5tYXgodC5tYXgsIHIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNaW5NYXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWluTWF4KHQsIGUpIHtcbiAgICAgIHZhciBzID0gdGhpcy5fY2FjaGVkTWV0YSxcbiAgICAgICAgbiA9IHMuX3BhcnNlZCxcbiAgICAgICAgbyA9IHMuX3NvcnRlZCAmJiB0ID09PSBzLmlTY2FsZSxcbiAgICAgICAgciA9IG4ubGVuZ3RoLFxuICAgICAgICBhID0gdGhpcy5fZ2V0T3RoZXJTY2FsZSh0KSxcbiAgICAgICAgbCA9IGZhKGUsIHMsIHRoaXMuY2hhcnQpLFxuICAgICAgICBjID0ge1xuICAgICAgICAgIG1pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgIG1heDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgICAgIH0sXG4gICAgICAgIF9jYSA9IGNhKGEpLFxuICAgICAgICBoID0gX2NhLm1pbixcbiAgICAgICAgZCA9IF9jYS5tYXg7XG4gICAgICB2YXIgdSwgZjtcbiAgICAgIGZ1bmN0aW9uIHAoKSB7XG4gICAgICAgIGYgPSBuW3VdO1xuICAgICAgICB2YXIgZyA9IGZbYS5heGlzXTtcbiAgICAgICAgcmV0dXJuICFxKGZbdC5heGlzXSkgfHwgaCA+IGcgfHwgZCA8IGc7XG4gICAgICB9XG4gICAgICBmb3IgKHUgPSAwOyB1IDwgciAmJiAhKCFwKCkgJiYgKHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKGMsIHQsIGYsIGwpLCBvKSk7ICsrdSk7XG4gICAgICBpZiAobykge1xuICAgICAgICBmb3IgKHUgPSByIC0gMTsgdSA+PSAwOyAtLXUpIGlmICghcCgpKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVSYW5nZUZyb21QYXJzZWQoYywgdCwgZiwgbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBbGxQYXJzZWRWYWx1ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxsUGFyc2VkVmFsdWVzKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkLFxuICAgICAgICBzID0gW107XG4gICAgICB2YXIgbiwgbywgcjtcbiAgICAgIGZvciAobiA9IDAsIG8gPSBlLmxlbmd0aDsgbiA8IG87ICsrbikgciA9IGVbbl1bdC5heGlzXSwgcShyKSAmJiBzLnB1c2gocik7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWF4T3ZlcmZsb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsQW5kVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxBbmRWYWx1ZSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIHMgPSBlLmlTY2FsZSxcbiAgICAgICAgbiA9IGUudlNjYWxlLFxuICAgICAgICBvID0gdGhpcy5nZXRQYXJzZWQodCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYWJlbDogcyA/IFwiXCIgKyBzLmdldExhYmVsRm9yVmFsdWUob1tzLmF4aXNdKSA6IFwiXCIsXG4gICAgICAgIHZhbHVlOiBuID8gXCJcIiArIG4uZ2V0TGFiZWxGb3JWYWx1ZShvW24uYXhpc10pIDogXCJcIlxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgIHRoaXMudXBkYXRlKHQgfHwgXCJkZWZhdWx0XCIpLCBlLl9jbGlwID0gcmEoRCh0aGlzLm9wdGlvbnMuY2xpcCwgb2EoZS54U2NhbGUsIGUueVNjYWxlLCB0aGlzLmdldE1heE92ZXJmbG93KCkpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUodCkge31cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2N0eCxcbiAgICAgICAgZSA9IHRoaXMuY2hhcnQsXG4gICAgICAgIHMgPSB0aGlzLl9jYWNoZWRNZXRhLFxuICAgICAgICBuID0gcy5kYXRhIHx8IFtdLFxuICAgICAgICBvID0gZS5jaGFydEFyZWEsXG4gICAgICAgIHIgPSBbXSxcbiAgICAgICAgYSA9IHRoaXMuX2RyYXdTdGFydCB8fCAwLFxuICAgICAgICBsID0gdGhpcy5fZHJhd0NvdW50IHx8IG4ubGVuZ3RoIC0gYSxcbiAgICAgICAgYyA9IHRoaXMub3B0aW9ucy5kcmF3QWN0aXZlRWxlbWVudHNPblRvcDtcbiAgICAgIHZhciBoO1xuICAgICAgZm9yIChzLmRhdGFzZXQgJiYgcy5kYXRhc2V0LmRyYXcodCwgbywgYSwgbCksIGggPSBhOyBoIDwgYSArIGw7ICsraCkge1xuICAgICAgICB2YXIgZCA9IG5baF07XG4gICAgICAgIGQuaGlkZGVuIHx8IChkLmFjdGl2ZSAmJiBjID8gci5wdXNoKGQpIDogZC5kcmF3KHQsIG8pKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaCA9IDA7IGggPCByLmxlbmd0aDsgKytoKSByW2hdLmRyYXcodCwgbyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0eWxlKHQsIGUpIHtcbiAgICAgIHZhciBzID0gZSA/IFwiYWN0aXZlXCIgOiBcImRlZmF1bHRcIjtcbiAgICAgIHJldHVybiB0ID09PSB2b2lkIDAgJiYgdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0ID8gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKHMpIDogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHQgfHwgMCwgcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGV4dCh0LCBlLCBzKSB7XG4gICAgICB2YXIgbiA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgICAgdmFyIG87XG4gICAgICBpZiAodCA+PSAwICYmIHQgPCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW3RdO1xuICAgICAgICBvID0gci4kY29udGV4dCB8fCAoci4kY29udGV4dCA9IHVhKHRoaXMuZ2V0Q29udGV4dCgpLCB0LCByKSksIG8ucGFyc2VkID0gdGhpcy5nZXRQYXJzZWQodCksIG8ucmF3ID0gbi5kYXRhW3RdLCBvLmluZGV4ID0gby5kYXRhSW5kZXggPSB0O1xuICAgICAgfSBlbHNlIG8gPSB0aGlzLiRjb250ZXh0IHx8ICh0aGlzLiRjb250ZXh0ID0gZGEodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMuaW5kZXgpKSwgby5kYXRhc2V0ID0gbiwgby5pbmRleCA9IG8uZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIHJldHVybiBvLmFjdGl2ZSA9ICEhZSwgby5tb2RlID0gcywgbztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhc2V0RWxlbWVudFR5cGUuaWQsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnModCwgZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFFbGVtZW50VHlwZS5pZCwgZSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNvbHZlRWxlbWVudE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0KSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICAgIHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcImRlZmF1bHRcIjtcbiAgICAgIHZhciBzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbiA9IGUgPT09IFwiYWN0aXZlXCIsXG4gICAgICAgIG8gPSB0aGlzLl9jYWNoZWREYXRhT3B0cyxcbiAgICAgICAgciA9IHQgKyBcIi1cIiArIGUsXG4gICAgICAgIGEgPSBvW3JdLFxuICAgICAgICBsID0gdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nICYmIGdlKHMpO1xuICAgICAgaWYgKGEpIHJldHVybiBNcyhhLCBsKTtcbiAgICAgIHZhciBjID0gdGhpcy5jaGFydC5jb25maWcsXG4gICAgICAgIGggPSBjLmRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKHRoaXMuX3R5cGUsIHQpLFxuICAgICAgICBkID0gbiA/IFtcIlwiLmNvbmNhdCh0LCBcIkhvdmVyXCIpLCBcImhvdmVyXCIsIHQsIFwiXCJdIDogW3QsIFwiXCJdLFxuICAgICAgICB1ID0gYy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIGgpLFxuICAgICAgICBmID0gT2JqZWN0LmtleXMoVy5lbGVtZW50c1t0XSksXG4gICAgICAgIHAgPSBmdW5jdGlvbiBwKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczUuZ2V0Q29udGV4dChzLCBuLCBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZyA9IGMucmVzb2x2ZU5hbWVkT3B0aW9ucyh1LCBmLCBwLCBkKTtcbiAgICAgIHJldHVybiBnLiRzaGFyZWQgJiYgKGcuJHNoYXJlZCA9IGwsIG9bcl0gPSBPYmplY3QuZnJlZXplKE1zKGcsIGwpKSksIGc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNvbHZlQW5pbWF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzb2x2ZUFuaW1hdGlvbnModCwgZSwgcykge1xuICAgICAgdmFyIG4gPSB0aGlzLmNoYXJ0LFxuICAgICAgICBvID0gdGhpcy5fY2FjaGVkRGF0YU9wdHMsXG4gICAgICAgIHIgPSBcImFuaW1hdGlvbi1cIi5jb25jYXQoZSksXG4gICAgICAgIGEgPSBvW3JdO1xuICAgICAgaWYgKGEpIHJldHVybiBhO1xuICAgICAgdmFyIGw7XG4gICAgICBpZiAobi5vcHRpb25zLmFuaW1hdGlvbiAhPT0gITEpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLmNoYXJ0LmNvbmZpZyxcbiAgICAgICAgICBkID0gaC5kYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzKHRoaXMuX3R5cGUsIGUpLFxuICAgICAgICAgIHUgPSBoLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgZCk7XG4gICAgICAgIGwgPSBoLmNyZWF0ZVJlc29sdmVyKHUsIHRoaXMuZ2V0Q29udGV4dCh0LCBzLCBlKSk7XG4gICAgICB9XG4gICAgICB2YXIgYyA9IG5ldyBObihuLCBsICYmIGwuYW5pbWF0aW9ucyk7XG4gICAgICByZXR1cm4gbCAmJiBsLl9jYWNoZWFibGUgJiYgKG9bcl0gPSBPYmplY3QuZnJlZXplKGMpKSwgYztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2hhcmVkT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaGFyZWRPcHRpb25zKHQpIHtcbiAgICAgIGlmICh0LiRzaGFyZWQpIHJldHVybiB0aGlzLl9zaGFyZWRPcHRpb25zIHx8ICh0aGlzLl9zaGFyZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmNsdWRlT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmNsdWRlT3B0aW9ucyh0LCBlKSB7XG4gICAgICByZXR1cm4gIWUgfHwgbGkodCkgfHwgdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0U2hhcmVkT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U2hhcmVkT3B0aW9ucyh0LCBlKSB7XG4gICAgICB2YXIgcyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyh0LCBlKSxcbiAgICAgICAgbiA9IHRoaXMuX3NoYXJlZE9wdGlvbnMsXG4gICAgICAgIG8gPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMocyksXG4gICAgICAgIHIgPSB0aGlzLmluY2x1ZGVPcHRpb25zKGUsIG8pIHx8IG8gIT09IG47XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKG8sIGUsIHMpLCB7XG4gICAgICAgIHNoYXJlZE9wdGlvbnM6IG8sXG4gICAgICAgIGluY2x1ZGVPcHRpb25zOiByXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVFbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQodCwgZSwgcywgbikge1xuICAgICAgbGkobikgPyBPYmplY3QuYXNzaWduKHQsIHMpIDogdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoZSwgbikudXBkYXRlKHQsIHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTaGFyZWRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNoYXJlZE9wdGlvbnModCwgZSwgcykge1xuICAgICAgdCAmJiAhbGkoZSkgJiYgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnModm9pZCAwLCBlKS51cGRhdGUodCwgcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U3R5bGUodCwgZSwgcywgbikge1xuICAgICAgdC5hY3RpdmUgPSBuO1xuICAgICAgdmFyIG8gPSB0aGlzLmdldFN0eWxlKGUsIG4pO1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoZSwgcywgbikudXBkYXRlKHQsIHtcbiAgICAgICAgb3B0aW9uczogIW4gJiYgdGhpcy5nZXRTaGFyZWRPcHRpb25zKG8pIHx8IG9cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVIb3ZlclN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUhvdmVyU3R5bGUodCwgZSwgcykge1xuICAgICAgdGhpcy5fc2V0U3R5bGUodCwgcywgXCJhY3RpdmVcIiwgITEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRIb3ZlclN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEhvdmVyU3R5bGUodCwgZSwgcykge1xuICAgICAgdGhpcy5fc2V0U3R5bGUodCwgcywgXCJhY3RpdmVcIiwgITApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG4gICAgICB0ICYmIHRoaXMuX3NldFN0eWxlKHQsIHZvaWQgMCwgXCJhY3RpdmVcIiwgITEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0RGF0YXNldEhvdmVyU3R5bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldERhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG4gICAgICB0ICYmIHRoaXMuX3NldFN0eWxlKHQsIHZvaWQgMCwgXCJhY3RpdmVcIiwgITApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVzeW5jRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3luY0VsZW1lbnRzKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fZGF0YSxcbiAgICAgICAgcyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICAgIHZhciBfaXRlcmF0b3IxMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuX3N5bmNMaXN0KSxcbiAgICAgICAgX3N0ZXAxMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTIucygpOyAhKF9zdGVwMTIgPSBfaXRlcmF0b3IxMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwMTIkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDEyLnZhbHVlLCAzKSxcbiAgICAgICAgICAgIGEgPSBfc3RlcDEyJHZhbHVlWzBdLFxuICAgICAgICAgICAgbCA9IF9zdGVwMTIkdmFsdWVbMV0sXG4gICAgICAgICAgICBjID0gX3N0ZXAxMiR2YWx1ZVsyXTtcbiAgICAgICAgICB0aGlzW2FdKGwsIGMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMTIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMTIuZigpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICAgIHZhciBuID0gcy5sZW5ndGgsXG4gICAgICAgIG8gPSBlLmxlbmd0aCxcbiAgICAgICAgciA9IE1hdGgubWluKG8sIG4pO1xuICAgICAgciAmJiB0aGlzLnBhcnNlKDAsIHIpLCBvID4gbiA/IHRoaXMuX2luc2VydEVsZW1lbnRzKG4sIG8gLSBuLCB0KSA6IG8gPCBuICYmIHRoaXMuX3JlbW92ZUVsZW1lbnRzKG8sIG4gLSBvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2luc2VydEVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbnNlcnRFbGVtZW50cyh0LCBlKSB7XG4gICAgICB2YXIgcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogITA7XG4gICAgICB2YXIgbiA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIG8gPSBuLmRhdGEsXG4gICAgICAgIHIgPSB0ICsgZTtcbiAgICAgIHZhciBhO1xuICAgICAgdmFyIGwgPSBmdW5jdGlvbiBsKGMpIHtcbiAgICAgICAgZm9yIChjLmxlbmd0aCArPSBlLCBhID0gYy5sZW5ndGggLSAxOyBhID49IHI7IGEtLSkgY1thXSA9IGNbYSAtIGVdO1xuICAgICAgfTtcbiAgICAgIGZvciAobChvKSwgYSA9IHQ7IGEgPCByOyArK2EpIG9bYV0gPSBuZXcgdGhpcy5kYXRhRWxlbWVudFR5cGUoKTtcbiAgICAgIHRoaXMuX3BhcnNpbmcgJiYgbChuLl9wYXJzZWQpLCB0aGlzLnBhcnNlKHQsIGUpLCBzICYmIHRoaXMudXBkYXRlRWxlbWVudHMobywgdCwgZSwgXCJyZXNldFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRWxlbWVudHModCwgZSwgcywgbikge31cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUVsZW1lbnRzKHQsIGUpIHtcbiAgICAgIHZhciBzID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICAgIHZhciBuID0gcy5fcGFyc2VkLnNwbGljZSh0LCBlKTtcbiAgICAgICAgcy5fc3RhY2tlZCAmJiBRdChzLCBuKTtcbiAgICAgIH1cbiAgICAgIHMuZGF0YS5zcGxpY2UodCwgZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zeW5jXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zeW5jKHQpIHtcbiAgICAgIGlmICh0aGlzLl9wYXJzaW5nKSB0aGlzLl9zeW5jTGlzdC5wdXNoKHQpO2Vsc2Uge1xuICAgICAgICB2YXIgX3QyID0gX3NsaWNlZFRvQXJyYXkodCwgMyksXG4gICAgICAgICAgZSA9IF90MlswXSxcbiAgICAgICAgICBzID0gX3QyWzFdLFxuICAgICAgICAgIG4gPSBfdDJbMl07XG4gICAgICAgIHRoaXNbZV0ocywgbik7XG4gICAgICB9XG4gICAgICB0aGlzLmNoYXJ0Ll9kYXRhQ2hhbmdlcy5wdXNoKFt0aGlzLmluZGV4XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHQpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vbkRhdGFQdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRhdGFQdXNoKCkge1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdGhpcy5fc3luYyhbXCJfaW5zZXJ0RWxlbWVudHNcIiwgdGhpcy5nZXREYXRhc2V0KCkuZGF0YS5sZW5ndGggLSB0LCB0XSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vbkRhdGFQb3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRGF0YVBvcCgpIHtcbiAgICAgIHRoaXMuX3N5bmMoW1wiX3JlbW92ZUVsZW1lbnRzXCIsIHRoaXMuX2NhY2hlZE1ldGEuZGF0YS5sZW5ndGggLSAxLCAxXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vbkRhdGFTaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25EYXRhU2hpZnQoKSB7XG4gICAgICB0aGlzLl9zeW5jKFtcIl9yZW1vdmVFbGVtZW50c1wiLCAwLCAxXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vbkRhdGFTcGxpY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRGF0YVNwbGljZSh0LCBlKSB7XG4gICAgICBlICYmIHRoaXMuX3N5bmMoW1wiX3JlbW92ZUVsZW1lbnRzXCIsIHQsIGVdKTtcbiAgICAgIHZhciBzID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgICBzICYmIHRoaXMuX3N5bmMoW1wiX2luc2VydEVsZW1lbnRzXCIsIHQsIHNdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uRGF0YVVuc2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRGF0YVVuc2hpZnQoKSB7XG4gICAgICB0aGlzLl9zeW5jKFtcIl9pbnNlcnRFbGVtZW50c1wiLCAwLCBhcmd1bWVudHMubGVuZ3RoXSk7XG4gICAgfVxuICB9XSk7XG59KCk7XG53KGt0LCBcImRlZmF1bHRzXCIsIHt9KSwgdyhrdCwgXCJkYXRhc2V0RWxlbWVudFR5cGVcIiwgbnVsbCksIHcoa3QsIFwiZGF0YUVsZW1lbnRUeXBlXCIsIG51bGwpO1xuZnVuY3Rpb24gZ2EoaSwgdCkge1xuICBpZiAoIWkuX2NhY2hlLiRiYXIpIHtcbiAgICB2YXIgZSA9IGkuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModCk7XG4gICAgdmFyIHMgPSBbXTtcbiAgICBmb3IgKHZhciBuID0gMCwgbyA9IGUubGVuZ3RoOyBuIDwgbzsgbisrKSBzID0gcy5jb25jYXQoZVtuXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyhpKSk7XG4gICAgaS5fY2FjaGUuJGJhciA9IE1uKHMuc29ydChmdW5jdGlvbiAobiwgbykge1xuICAgICAgcmV0dXJuIG4gLSBvO1xuICAgIH0pKTtcbiAgfVxuICByZXR1cm4gaS5fY2FjaGUuJGJhcjtcbn1cbmZ1bmN0aW9uIHBhKGkpIHtcbiAgdmFyIHQgPSBpLmlTY2FsZSxcbiAgICBlID0gZ2EodCwgaS50eXBlKTtcbiAgdmFyIHMgPSB0Ll9sZW5ndGgsXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYTtcbiAgdmFyIGwgPSBmdW5jdGlvbiBsKCkge1xuICAgIHIgPT09IDMyNzY3IHx8IHIgPT09IC0zMjc2OCB8fCAoZ2UoYSkgJiYgKHMgPSBNYXRoLm1pbihzLCBNYXRoLmFicyhyIC0gYSkgfHwgcykpLCBhID0gcik7XG4gIH07XG4gIGZvciAobiA9IDAsIG8gPSBlLmxlbmd0aDsgbiA8IG87ICsrbikgciA9IHQuZ2V0UGl4ZWxGb3JWYWx1ZShlW25dKSwgbCgpO1xuICBmb3IgKGEgPSB2b2lkIDAsIG4gPSAwLCBvID0gdC50aWNrcy5sZW5ndGg7IG4gPCBvOyArK24pIHIgPSB0LmdldFBpeGVsRm9yVGljayhuKSwgbCgpO1xuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIG1hKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBlLmJhclRoaWNrbmVzcztcbiAgdmFyIG8sIHI7XG4gIHJldHVybiBSKG4pID8gKG8gPSB0Lm1pbiAqIGUuY2F0ZWdvcnlQZXJjZW50YWdlLCByID0gZS5iYXJQZXJjZW50YWdlKSA6IChvID0gbiAqIHMsIHIgPSAxKSwge1xuICAgIGNodW5rOiBvIC8gcyxcbiAgICByYXRpbzogcixcbiAgICBzdGFydDogdC5waXhlbHNbaV0gLSBvIC8gMlxuICB9O1xufVxuZnVuY3Rpb24gYmEoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IHQucGl4ZWxzLFxuICAgIG8gPSBuW2ldO1xuICB2YXIgciA9IGkgPiAwID8gbltpIC0gMV0gOiBudWxsLFxuICAgIGEgPSBpIDwgbi5sZW5ndGggLSAxID8gbltpICsgMV0gOiBudWxsO1xuICB2YXIgbCA9IGUuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICByID09PSBudWxsICYmIChyID0gbyAtIChhID09PSBudWxsID8gdC5lbmQgLSB0LnN0YXJ0IDogYSAtIG8pKSwgYSA9PT0gbnVsbCAmJiAoYSA9IG8gKyBvIC0gcik7XG4gIHZhciBjID0gbyAtIChvIC0gTWF0aC5taW4ociwgYSkpIC8gMiAqIGw7XG4gIHJldHVybiB7XG4gICAgY2h1bms6IE1hdGguYWJzKGEgLSByKSAvIDIgKiBsIC8gcyxcbiAgICByYXRpbzogZS5iYXJQZXJjZW50YWdlLFxuICAgIHN0YXJ0OiBjXG4gIH07XG59XG5mdW5jdGlvbiBfYShpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gZS5wYXJzZShpWzBdLCBzKSxcbiAgICBvID0gZS5wYXJzZShpWzFdLCBzKSxcbiAgICByID0gTWF0aC5taW4obiwgbyksXG4gICAgYSA9IE1hdGgubWF4KG4sIG8pO1xuICB2YXIgbCA9IHIsXG4gICAgYyA9IGE7XG4gIE1hdGguYWJzKHIpID4gTWF0aC5hYnMoYSkgJiYgKGwgPSBhLCBjID0gciksIHRbZS5heGlzXSA9IGMsIHQuX2N1c3RvbSA9IHtcbiAgICBiYXJTdGFydDogbCxcbiAgICBiYXJFbmQ6IGMsXG4gICAgc3RhcnQ6IG4sXG4gICAgZW5kOiBvLFxuICAgIG1pbjogcixcbiAgICBtYXg6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIGpuKGksIHQsIGUsIHMpIHtcbiAgcmV0dXJuIE4oaSkgPyBfYShpLCB0LCBlLCBzKSA6IHRbZS5heGlzXSA9IGUucGFyc2UoaSwgcyksIHQ7XG59XG5mdW5jdGlvbiBTcyhpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gaS5pU2NhbGUsXG4gICAgbyA9IGkudlNjYWxlLFxuICAgIHIgPSBuLmdldExhYmVscygpLFxuICAgIGEgPSBuID09PSBvLFxuICAgIGwgPSBbXTtcbiAgdmFyIGMsIGgsIGQsIHU7XG4gIGZvciAoYyA9IGUsIGggPSBlICsgczsgYyA8IGg7ICsrYykgdSA9IHRbY10sIGQgPSB7fSwgZFtuLmF4aXNdID0gYSB8fCBuLnBhcnNlKHJbY10sIGMpLCBsLnB1c2goam4odSwgZCwgbywgYykpO1xuICByZXR1cm4gbDtcbn1cbmZ1bmN0aW9uIGNpKGkpIHtcbiAgcmV0dXJuIGkgJiYgaS5iYXJTdGFydCAhPT0gdm9pZCAwICYmIGkuYmFyRW5kICE9PSB2b2lkIDA7XG59XG5mdW5jdGlvbiB4YShpLCB0LCBlKSB7XG4gIHJldHVybiBpICE9PSAwID8gbHQoaSkgOiAodC5pc0hvcml6b250YWwoKSA/IDEgOiAtMSkgKiAodC5taW4gPj0gZSA/IDEgOiAtMSk7XG59XG5mdW5jdGlvbiB5YShpKSB7XG4gIHZhciB0LCBlLCBzLCBuLCBvO1xuICByZXR1cm4gaS5ob3Jpem9udGFsID8gKHQgPSBpLmJhc2UgPiBpLngsIGUgPSBcImxlZnRcIiwgcyA9IFwicmlnaHRcIikgOiAodCA9IGkuYmFzZSA8IGkueSwgZSA9IFwiYm90dG9tXCIsIHMgPSBcInRvcFwiKSwgdCA/IChuID0gXCJlbmRcIiwgbyA9IFwic3RhcnRcIikgOiAobiA9IFwic3RhcnRcIiwgbyA9IFwiZW5kXCIpLCB7XG4gICAgc3RhcnQ6IGUsXG4gICAgZW5kOiBzLFxuICAgIHJldmVyc2U6IHQsXG4gICAgdG9wOiBuLFxuICAgIGJvdHRvbTogb1xuICB9O1xufVxuZnVuY3Rpb24gdmEoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IHQuYm9yZGVyU2tpcHBlZDtcbiAgdmFyIG8gPSB7fTtcbiAgaWYgKCFuKSB7XG4gICAgaS5ib3JkZXJTa2lwcGVkID0gbztcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG4gPT09ICEwKSB7XG4gICAgaS5ib3JkZXJTa2lwcGVkID0ge1xuICAgICAgdG9wOiAhMCxcbiAgICAgIHJpZ2h0OiAhMCxcbiAgICAgIGJvdHRvbTogITAsXG4gICAgICBsZWZ0OiAhMFxuICAgIH07XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBfeWEgPSB5YShpKSxcbiAgICByID0gX3lhLnN0YXJ0LFxuICAgIGEgPSBfeWEuZW5kLFxuICAgIGwgPSBfeWEucmV2ZXJzZSxcbiAgICBjID0gX3lhLnRvcCxcbiAgICBoID0gX3lhLmJvdHRvbTtcbiAgbiA9PT0gXCJtaWRkbGVcIiAmJiBlICYmIChpLmVuYWJsZUJvcmRlclJhZGl1cyA9ICEwLCAoZS5fdG9wIHx8IDApID09PSBzID8gbiA9IGMgOiAoZS5fYm90dG9tIHx8IDApID09PSBzID8gbiA9IGggOiAob1trcyhoLCByLCBhLCBsKV0gPSAhMCwgbiA9IGMpKSwgb1trcyhuLCByLCBhLCBsKV0gPSAhMCwgaS5ib3JkZXJTa2lwcGVkID0gbztcbn1cbmZ1bmN0aW9uIGtzKGksIHQsIGUsIHMpIHtcbiAgcmV0dXJuIHMgPyAoaSA9IE1hKGksIHQsIGUpLCBpID0gd3MoaSwgZSwgdCkpIDogaSA9IHdzKGksIHQsIGUpLCBpO1xufVxuZnVuY3Rpb24gTWEoaSwgdCwgZSkge1xuICByZXR1cm4gaSA9PT0gdCA/IGUgOiBpID09PSBlID8gdCA6IGk7XG59XG5mdW5jdGlvbiB3cyhpLCB0LCBlKSB7XG4gIHJldHVybiBpID09PSBcInN0YXJ0XCIgPyB0IDogaSA9PT0gXCJlbmRcIiA/IGUgOiBpO1xufVxuZnVuY3Rpb24gU2EoaSwgX3JlZjIsIGUpIHtcbiAgdmFyIHQgPSBfcmVmMi5pbmZsYXRlQW1vdW50O1xuICBpLmluZmxhdGVBbW91bnQgPSB0ID09PSBcImF1dG9cIiA/IGUgPT09IDEgPyAwLjMzIDogMCA6IHQ7XG59XG52YXIgRWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9rdCkge1xuICBmdW5jdGlvbiBFZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWUpO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEVlLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhFZSwgX2t0KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFZSwgW3tcbiAgICBrZXk6IFwicGFyc2VQcmltaXRpdmVEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlUHJpbWl0aXZlRGF0YSh0LCBlLCBzLCBuKSB7XG4gICAgICByZXR1cm4gU3ModCwgZSwgcywgbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlQXJyYXlEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlQXJyYXlEYXRhKHQsIGUsIHMsIG4pIHtcbiAgICAgIHJldHVybiBTcyh0LCBlLCBzLCBuKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VPYmplY3REYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlT2JqZWN0RGF0YSh0LCBlLCBzLCBuKSB7XG4gICAgICB2YXIgbyA9IHQuaVNjYWxlLFxuICAgICAgICByID0gdC52U2NhbGUsXG4gICAgICAgIF90aGlzJF9wYXJzaW5nMiA9IHRoaXMuX3BhcnNpbmcsXG4gICAgICAgIF90aGlzJF9wYXJzaW5nMiR4QXhpcyA9IF90aGlzJF9wYXJzaW5nMi54QXhpc0tleSxcbiAgICAgICAgYSA9IF90aGlzJF9wYXJzaW5nMiR4QXhpcyA9PT0gdm9pZCAwID8gXCJ4XCIgOiBfdGhpcyRfcGFyc2luZzIkeEF4aXMsXG4gICAgICAgIF90aGlzJF9wYXJzaW5nMiR5QXhpcyA9IF90aGlzJF9wYXJzaW5nMi55QXhpc0tleSxcbiAgICAgICAgbCA9IF90aGlzJF9wYXJzaW5nMiR5QXhpcyA9PT0gdm9pZCAwID8gXCJ5XCIgOiBfdGhpcyRfcGFyc2luZzIkeUF4aXMsXG4gICAgICAgIGMgPSBvLmF4aXMgPT09IFwieFwiID8gYSA6IGwsXG4gICAgICAgIGggPSByLmF4aXMgPT09IFwieFwiID8gYSA6IGwsXG4gICAgICAgIGQgPSBbXTtcbiAgICAgIHZhciB1LCBmLCBwLCBnO1xuICAgICAgZm9yICh1ID0gcywgZiA9IHMgKyBuOyB1IDwgZjsgKyt1KSBnID0gZVt1XSwgcCA9IHt9LCBwW28uYXhpc10gPSBvLnBhcnNlKEl0KGcsIGMpLCB1KSwgZC5wdXNoKGpuKEl0KGcsIGgpLCBwLCByLCB1KSk7XG4gICAgICByZXR1cm4gZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlUmFuZ2VGcm9tUGFyc2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZCh0LCBlLCBzLCBuKSB7XG4gICAgICBfc3VwZXJQcm9wR2V0KEVlLCBcInVwZGF0ZVJhbmdlRnJvbVBhcnNlZFwiLCB0aGlzLCAzKShbdCwgZSwgcywgbl0pO1xuICAgICAgdmFyIG8gPSBzLl9jdXN0b207XG4gICAgICBvICYmIGUgPT09IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlICYmICh0Lm1pbiA9IE1hdGgubWluKHQubWluLCBvLm1pbiksIHQubWF4ID0gTWF0aC5tYXgodC5tYXgsIG8ubWF4KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1heE92ZXJmbG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1heE92ZXJmbG93KCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsQW5kVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxBbmRWYWx1ZSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIHMgPSBlLmlTY2FsZSxcbiAgICAgICAgbiA9IGUudlNjYWxlLFxuICAgICAgICBvID0gdGhpcy5nZXRQYXJzZWQodCksXG4gICAgICAgIHIgPSBvLl9jdXN0b20sXG4gICAgICAgIGEgPSBjaShyKSA/IFwiW1wiICsgci5zdGFydCArIFwiLCBcIiArIHIuZW5kICsgXCJdXCIgOiBcIlwiICsgbi5nZXRMYWJlbEZvclZhbHVlKG9bbi5heGlzXSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYWJlbDogXCJcIiArIHMuZ2V0TGFiZWxGb3JWYWx1ZShvW3MuYXhpc10pLFxuICAgICAgICB2YWx1ZTogYVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gITAsIF9zdXBlclByb3BHZXQoRWUsIFwiaW5pdGlhbGl6ZVwiLCB0aGlzLCAzKShbXSk7XG4gICAgICB2YXIgdCA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICB0LnN0YWNrID0gdGhpcy5nZXREYXRhc2V0KCkuc3RhY2s7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50cyhlLmRhdGEsIDAsIGUuZGF0YS5sZW5ndGgsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVFbGVtZW50cyh0LCBlLCBzLCBuKSB7XG4gICAgICB2YXIgbyA9IG4gPT09IFwicmVzZXRcIixcbiAgICAgICAgciA9IHRoaXMuaW5kZXgsXG4gICAgICAgIGEgPSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZSxcbiAgICAgICAgbCA9IGEuZ2V0QmFzZVBpeGVsKCksXG4gICAgICAgIGMgPSBhLmlzSG9yaXpvbnRhbCgpLFxuICAgICAgICBoID0gdGhpcy5fZ2V0UnVsZXIoKSxcbiAgICAgICAgX3RoaXMkX2dldFNoYXJlZE9wdGlvID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhlLCBuKSxcbiAgICAgICAgZCA9IF90aGlzJF9nZXRTaGFyZWRPcHRpby5zaGFyZWRPcHRpb25zLFxuICAgICAgICB1ID0gX3RoaXMkX2dldFNoYXJlZE9wdGlvLmluY2x1ZGVPcHRpb25zO1xuICAgICAgZm9yICh2YXIgZiA9IGU7IGYgPCBlICsgczsgZisrKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5nZXRQYXJzZWQoZiksXG4gICAgICAgICAgZyA9IG8gfHwgUihwW2EuYXhpc10pID8ge1xuICAgICAgICAgICAgYmFzZTogbCxcbiAgICAgICAgICAgIGhlYWQ6IGxcbiAgICAgICAgICB9IDogdGhpcy5fY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoZiksXG4gICAgICAgICAgbSA9IHRoaXMuX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGYsIGgpLFxuICAgICAgICAgIGIgPSAocC5fc3RhY2tzIHx8IHt9KVthLmF4aXNdLFxuICAgICAgICAgIF8gPSB7XG4gICAgICAgICAgICBob3Jpem9udGFsOiBjLFxuICAgICAgICAgICAgYmFzZTogZy5iYXNlLFxuICAgICAgICAgICAgZW5hYmxlQm9yZGVyUmFkaXVzOiAhYiB8fCBjaShwLl9jdXN0b20pIHx8IHIgPT09IGIuX3RvcCB8fCByID09PSBiLl9ib3R0b20sXG4gICAgICAgICAgICB4OiBjID8gZy5oZWFkIDogbS5jZW50ZXIsXG4gICAgICAgICAgICB5OiBjID8gbS5jZW50ZXIgOiBnLmhlYWQsXG4gICAgICAgICAgICBoZWlnaHQ6IGMgPyBtLnNpemUgOiBNYXRoLmFicyhnLnNpemUpLFxuICAgICAgICAgICAgd2lkdGg6IGMgPyBNYXRoLmFicyhnLnNpemUpIDogbS5zaXplXG4gICAgICAgICAgfTtcbiAgICAgICAgdSAmJiAoXy5vcHRpb25zID0gZCB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZiwgdFtmXS5hY3RpdmUgPyBcImFjdGl2ZVwiIDogbikpO1xuICAgICAgICB2YXIgdiA9IF8ub3B0aW9ucyB8fCB0W2ZdLm9wdGlvbnM7XG4gICAgICAgIHZhKF8sIHYsIGIsIHIpLCBTYShfLCB2LCBoLnJhdGlvKSwgdGhpcy51cGRhdGVFbGVtZW50KHRbZl0sIGYsIF8sIG4pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0U3RhY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTdGFja3ModCwgZSkge1xuICAgICAgdmFyIHMgPSB0aGlzLl9jYWNoZWRNZXRhLmlTY2FsZSxcbiAgICAgICAgbiA9IHMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModGhpcy5fdHlwZSkuZmlsdGVyKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgcmV0dXJuIGguY29udHJvbGxlci5vcHRpb25zLmdyb3VwZWQ7XG4gICAgICAgIH0pLFxuICAgICAgICBvID0gcy5vcHRpb25zLnN0YWNrZWQsXG4gICAgICAgIHIgPSBbXSxcbiAgICAgICAgYSA9IHRoaXMuX2NhY2hlZE1ldGEuY29udHJvbGxlci5nZXRQYXJzZWQoZSksXG4gICAgICAgIGwgPSBhICYmIGFbcy5heGlzXSxcbiAgICAgICAgYyA9IGZ1bmN0aW9uIGMoaCkge1xuICAgICAgICAgIHZhciBkID0gaC5fcGFyc2VkLmZpbmQoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZbcy5heGlzXSA9PT0gbDtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdSA9IGQgJiYgZFtoLnZTY2FsZS5heGlzXTtcbiAgICAgICAgICBpZiAoUih1KSB8fCBpc05hTih1KSkgcmV0dXJuICEwO1xuICAgICAgICB9O1xuICAgICAgdmFyIF9pdGVyYXRvcjEzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobiksXG4gICAgICAgIF9zdGVwMTM7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjEzLnMoKTsgIShfc3RlcDEzID0gX2l0ZXJhdG9yMTMubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBoID0gX3N0ZXAxMy52YWx1ZTtcbiAgICAgICAgICBpZiAoIShlICE9PSB2b2lkIDAgJiYgYyhoKSkgJiYgKChvID09PSAhMSB8fCByLmluZGV4T2YoaC5zdGFjaykgPT09IC0xIHx8IG8gPT09IHZvaWQgMCAmJiBoLnN0YWNrID09PSB2b2lkIDApICYmIHIucHVzaChoLnN0YWNrKSwgaC5pbmRleCA9PT0gdCkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMTMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMTMuZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIubGVuZ3RoIHx8IHIucHVzaCh2b2lkIDApLCByO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0U3RhY2tDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RhY2tDb3VudCh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U3RhY2tzKHZvaWQgMCwgdCkubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QXhpc0NvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBeGlzQ291bnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0QXhpcygpLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rmlyc3RTY2FsZUlkRm9ySW5kZXhBeGlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpcnN0U2NhbGVJZEZvckluZGV4QXhpcygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5jaGFydC5zY2FsZXMsXG4gICAgICAgIGUgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMuaW5kZXhBeGlzO1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHQpLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdFtzXS5heGlzID09PSBlO1xuICAgICAgfSkuc2hpZnQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEF4aXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEF4aXMoKSB7XG4gICAgICB2YXIgdCA9IHt9LFxuICAgICAgICBlID0gdGhpcy5nZXRGaXJzdFNjYWxlSWRGb3JJbmRleEF4aXMoKTtcbiAgICAgIHZhciBfaXRlcmF0b3IxNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cyksXG4gICAgICAgIF9zdGVwMTQ7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjE0LnMoKTsgIShfc3RlcDE0ID0gX2l0ZXJhdG9yMTQubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBzID0gX3N0ZXAxNC52YWx1ZTtcbiAgICAgICAgICB0W0QodGhpcy5jaGFydC5vcHRpb25zLmluZGV4QXhpcyA9PT0gXCJ4XCIgPyBzLnhBeGlzSUQgOiBzLnlBeGlzSUQsIGUpXSA9ICEwO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMTQuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMTQuZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0U3RhY2tJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RhY2tJbmRleCh0LCBlLCBzKSB7XG4gICAgICB2YXIgbiA9IHRoaXMuX2dldFN0YWNrcyh0LCBzKSxcbiAgICAgICAgbyA9IGUgIT09IHZvaWQgMCA/IG4uaW5kZXhPZihlKSA6IC0xO1xuICAgICAgcmV0dXJuIG8gPT09IC0xID8gbi5sZW5ndGggLSAxIDogbztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFJ1bGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRSdWxlcigpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBlID0gdGhpcy5fY2FjaGVkTWV0YSxcbiAgICAgICAgcyA9IGUuaVNjYWxlLFxuICAgICAgICBuID0gW107XG4gICAgICB2YXIgbywgcjtcbiAgICAgIGZvciAobyA9IDAsIHIgPSBlLmRhdGEubGVuZ3RoOyBvIDwgcjsgKytvKSBuLnB1c2gocy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKG8pW3MuYXhpc10sIG8pKTtcbiAgICAgIHZhciBhID0gdC5iYXJUaGlja25lc3M7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW46IGEgfHwgcGEoZSksXG4gICAgICAgIHBpeGVsczogbixcbiAgICAgICAgc3RhcnQ6IHMuX3N0YXJ0UGl4ZWwsXG4gICAgICAgIGVuZDogcy5fZW5kUGl4ZWwsXG4gICAgICAgIHN0YWNrQ291bnQ6IHRoaXMuX2dldFN0YWNrQ291bnQoKSxcbiAgICAgICAgc2NhbGU6IHMsXG4gICAgICAgIGdyb3VwZWQ6IHQuZ3JvdXBlZCxcbiAgICAgICAgcmF0aW86IGEgPyAxIDogdC5jYXRlZ29yeVBlcmNlbnRhZ2UgKiB0LmJhclBlcmNlbnRhZ2VcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHModCkge1xuICAgICAgdmFyIF90aGlzJF9jYWNoZWRNZXRhID0gdGhpcy5fY2FjaGVkTWV0YSxcbiAgICAgICAgZSA9IF90aGlzJF9jYWNoZWRNZXRhLnZTY2FsZSxcbiAgICAgICAgcyA9IF90aGlzJF9jYWNoZWRNZXRhLl9zdGFja2VkLFxuICAgICAgICBuID0gX3RoaXMkX2NhY2hlZE1ldGEuaW5kZXgsXG4gICAgICAgIF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIG8gPSBfdGhpcyRvcHRpb25zLmJhc2UsXG4gICAgICAgIHIgPSBfdGhpcyRvcHRpb25zLm1pbkJhckxlbmd0aCxcbiAgICAgICAgYSA9IG8gfHwgMCxcbiAgICAgICAgbCA9IHRoaXMuZ2V0UGFyc2VkKHQpLFxuICAgICAgICBjID0gbC5fY3VzdG9tLFxuICAgICAgICBoID0gY2koYyk7XG4gICAgICB2YXIgZCA9IGxbZS5heGlzXSxcbiAgICAgICAgdSA9IDAsXG4gICAgICAgIGYgPSBzID8gdGhpcy5hcHBseVN0YWNrKGUsIGwsIHMpIDogZCxcbiAgICAgICAgcCxcbiAgICAgICAgZztcbiAgICAgIGYgIT09IGQgJiYgKHUgPSBmIC0gZCwgZiA9IGQpLCBoICYmIChkID0gYy5iYXJTdGFydCwgZiA9IGMuYmFyRW5kIC0gYy5iYXJTdGFydCwgZCAhPT0gMCAmJiBsdChkKSAhPT0gbHQoYy5iYXJFbmQpICYmICh1ID0gMCksIHUgKz0gZCk7XG4gICAgICB2YXIgbSA9ICFSKG8pICYmICFoID8gbyA6IHU7XG4gICAgICB2YXIgYiA9IGUuZ2V0UGl4ZWxGb3JWYWx1ZShtKTtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KHQpID8gcCA9IGUuZ2V0UGl4ZWxGb3JWYWx1ZSh1ICsgZikgOiBwID0gYiwgZyA9IHAgLSBiLCBNYXRoLmFicyhnKSA8IHIpIHtcbiAgICAgICAgZyA9IHhhKGcsIGUsIGEpICogciwgZCA9PT0gYSAmJiAoYiAtPSBnIC8gMik7XG4gICAgICAgIHZhciBfID0gZS5nZXRQaXhlbEZvckRlY2ltYWwoMCksXG4gICAgICAgICAgdiA9IGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDEpLFxuICAgICAgICAgIHkgPSBNYXRoLm1pbihfLCB2KSxcbiAgICAgICAgICB4ID0gTWF0aC5tYXgoXywgdik7XG4gICAgICAgIGIgPSBNYXRoLm1heChNYXRoLm1pbihiLCB4KSwgeSksIHAgPSBiICsgZywgcyAmJiAhaCAmJiAobC5fc3RhY2tzW2UuYXhpc10uX3Zpc3VhbFZhbHVlc1tuXSA9IGUuZ2V0VmFsdWVGb3JQaXhlbChwKSAtIGUuZ2V0VmFsdWVGb3JQaXhlbChiKSk7XG4gICAgICB9XG4gICAgICBpZiAoYiA9PT0gZS5nZXRQaXhlbEZvclZhbHVlKGEpKSB7XG4gICAgICAgIHZhciBfMiA9IGx0KGcpICogZS5nZXRMaW5lV2lkdGhGb3JWYWx1ZShhKSAvIDI7XG4gICAgICAgIGIgKz0gXzIsIGcgLT0gXzI7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaXplOiBnLFxuICAgICAgICBiYXNlOiBiLFxuICAgICAgICBoZWFkOiBwLFxuICAgICAgICBjZW50ZXI6IHAgKyBnIC8gMlxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyh0LCBlKSB7XG4gICAgICB2YXIgcyA9IGUuc2NhbGUsXG4gICAgICAgIG4gPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIG8gPSBuLnNraXBOdWxsLFxuICAgICAgICByID0gRChuLm1heEJhclRoaWNrbmVzcywgMSAvIDApO1xuICAgICAgdmFyIGEsIGw7XG4gICAgICB2YXIgYyA9IHRoaXMuX2dldEF4aXNDb3VudCgpO1xuICAgICAgaWYgKGUuZ3JvdXBlZCkge1xuICAgICAgICB2YXIgaCA9IG8gPyB0aGlzLl9nZXRTdGFja0NvdW50KHQpIDogZS5zdGFja0NvdW50LFxuICAgICAgICAgIGQgPSBuLmJhclRoaWNrbmVzcyA9PT0gXCJmbGV4XCIgPyBiYSh0LCBlLCBuLCBoICogYykgOiBtYSh0LCBlLCBuLCBoICogYyksXG4gICAgICAgICAgdSA9IHRoaXMuY2hhcnQub3B0aW9ucy5pbmRleEF4aXMgPT09IFwieFwiID8gdGhpcy5nZXREYXRhc2V0KCkueEF4aXNJRCA6IHRoaXMuZ2V0RGF0YXNldCgpLnlBeGlzSUQsXG4gICAgICAgICAgZiA9IHRoaXMuX2dldEF4aXMoKS5pbmRleE9mKEQodSwgdGhpcy5nZXRGaXJzdFNjYWxlSWRGb3JJbmRleEF4aXMoKSkpLFxuICAgICAgICAgIHAgPSB0aGlzLl9nZXRTdGFja0luZGV4KHRoaXMuaW5kZXgsIHRoaXMuX2NhY2hlZE1ldGEuc3RhY2ssIG8gPyB0IDogdm9pZCAwKSArIGY7XG4gICAgICAgIGEgPSBkLnN0YXJ0ICsgZC5jaHVuayAqIHAgKyBkLmNodW5rIC8gMiwgbCA9IE1hdGgubWluKHIsIGQuY2h1bmsgKiBkLnJhdGlvKTtcbiAgICAgIH0gZWxzZSBhID0gcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKHQpW3MuYXhpc10sIHQpLCBsID0gTWF0aC5taW4ociwgZS5taW4gKiBlLnJhdGlvKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2U6IGEgLSBsIC8gMixcbiAgICAgICAgaGVhZDogYSArIGwgLyAyLFxuICAgICAgICBjZW50ZXI6IGEsXG4gICAgICAgIHNpemU6IGxcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY2FjaGVkTWV0YSxcbiAgICAgICAgZSA9IHQudlNjYWxlLFxuICAgICAgICBzID0gdC5kYXRhLFxuICAgICAgICBuID0gcy5sZW5ndGg7XG4gICAgICB2YXIgbyA9IDA7XG4gICAgICBmb3IgKDsgbyA8IG47ICsrbykgdGhpcy5nZXRQYXJzZWQobylbZS5heGlzXSAhPT0gbnVsbCAmJiAhc1tvXS5oaWRkZW4gJiYgc1tvXS5kcmF3KHRoaXMuX2N0eCk7XG4gICAgfVxuICB9XSk7XG59KGt0KTtcbncoRWUsIFwiaWRcIiwgXCJiYXJcIiksIHcoRWUsIFwiZGVmYXVsdHNcIiwge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6ICExLFxuICBkYXRhRWxlbWVudFR5cGU6IFwiYmFyXCIsXG4gIGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxuICBiYXJQZXJjZW50YWdlOiAwLjksXG4gIGdyb3VwZWQ6ICEwLFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgIHByb3BlcnRpZXM6IFtcInhcIiwgXCJ5XCIsIFwiYmFzZVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCJdXG4gICAgfVxuICB9XG59KSwgdyhFZSwgXCJvdmVycmlkZXNcIiwge1xuICBzY2FsZXM6IHtcbiAgICBfaW5kZXhfOiB7XG4gICAgICB0eXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICBvZmZzZXQ6ICEwLFxuICAgICAgZ3JpZDoge1xuICAgICAgICBvZmZzZXQ6ICEwXG4gICAgICB9XG4gICAgfSxcbiAgICBfdmFsdWVfOiB7XG4gICAgICB0eXBlOiBcImxpbmVhclwiLFxuICAgICAgYmVnaW5BdFplcm86ICEwXG4gICAgfVxuICB9XG59KTtcbmZ1bmN0aW9uIGthKGksIHQsIGUpIHtcbiAgdmFyIHMgPSAxLFxuICAgIG4gPSAxLFxuICAgIG8gPSAwLFxuICAgIHIgPSAwO1xuICBpZiAodCA8IEIpIHtcbiAgICB2YXIgYSA9IGksXG4gICAgICBsID0gYSArIHQsXG4gICAgICBjID0gTWF0aC5jb3MoYSksXG4gICAgICBoID0gTWF0aC5zaW4oYSksXG4gICAgICBkID0gTWF0aC5jb3MobCksXG4gICAgICB1ID0gTWF0aC5zaW4obCksXG4gICAgICBmID0gZnVuY3Rpb24gZih2LCB5LCB4KSB7XG4gICAgICAgIHJldHVybiBwZSh2LCBhLCBsLCAhMCkgPyAxIDogTWF0aC5tYXgoeSwgeSAqIGUsIHgsIHggKiBlKTtcbiAgICAgIH0sXG4gICAgICBwID0gZnVuY3Rpb24gcCh2LCB5LCB4KSB7XG4gICAgICAgIHJldHVybiBwZSh2LCBhLCBsLCAhMCkgPyAtMSA6IE1hdGgubWluKHksIHkgKiBlLCB4LCB4ICogZSk7XG4gICAgICB9LFxuICAgICAgZyA9IGYoMCwgYywgZCksXG4gICAgICBtID0gZihWLCBoLCB1KSxcbiAgICAgIGIgPSBwKEUsIGMsIGQpLFxuICAgICAgXyA9IHAoRSArIFYsIGgsIHUpO1xuICAgIHMgPSAoZyAtIGIpIC8gMiwgbiA9IChtIC0gXykgLyAyLCBvID0gLShnICsgYikgLyAyLCByID0gLShtICsgXykgLyAyO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmF0aW9YOiBzLFxuICAgIHJhdGlvWTogbixcbiAgICBvZmZzZXRYOiBvLFxuICAgIG9mZnNldFk6IHJcbiAgfTtcbn1cbnZhciBqdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2t0Mikge1xuICBmdW5jdGlvbiBqdCh0LCBlKSB7XG4gICAgdmFyIF90aGlzNjtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywganQpO1xuICAgIF90aGlzNiA9IF9jYWxsU3VwZXIodGhpcywganQsIFt0LCBlXSksIF90aGlzNi5lbmFibGVPcHRpb25TaGFyaW5nID0gITAsIF90aGlzNi5pbm5lclJhZGl1cyA9IHZvaWQgMCwgX3RoaXM2Lm91dGVyUmFkaXVzID0gdm9pZCAwLCBfdGhpczYub2Zmc2V0WCA9IHZvaWQgMCwgX3RoaXM2Lm9mZnNldFkgPSB2b2lkIDA7XG4gICAgcmV0dXJuIF90aGlzNjtcbiAgfVxuICBfaW5oZXJpdHMoanQsIF9rdDIpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKGp0LCBbe1xuICAgIGtleTogXCJsaW5rU2NhbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmtTY2FsZXMoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKHQsIGUpIHtcbiAgICAgIHZhciBzID0gdGhpcy5nZXREYXRhc2V0KCkuZGF0YSxcbiAgICAgICAgbiA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gITEpIG4uX3BhcnNlZCA9IHM7ZWxzZSB7XG4gICAgICAgIHZhciBvID0gZnVuY3Rpb24gbyhsKSB7XG4gICAgICAgICAgcmV0dXJuICtzW2xdO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoVChzW3RdKSkge1xuICAgICAgICAgIHZhciBfdGhpcyRfcGFyc2luZyRrZXkgPSB0aGlzLl9wYXJzaW5nLmtleSxcbiAgICAgICAgICAgIGwgPSBfdGhpcyRfcGFyc2luZyRrZXkgPT09IHZvaWQgMCA/IFwidmFsdWVcIiA6IF90aGlzJF9wYXJzaW5nJGtleTtcbiAgICAgICAgICBvID0gZnVuY3Rpb24gbyhjKSB7XG4gICAgICAgICAgICByZXR1cm4gK0l0KHNbY10sIGwpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIsIGE7XG4gICAgICAgIGZvciAociA9IHQsIGEgPSB0ICsgZTsgciA8IGE7ICsrcikgbi5fcGFyc2VkW3JdID0gbyhyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFJvdGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRSb3RhdGlvbigpIHtcbiAgICAgIHJldHVybiBidCh0aGlzLm9wdGlvbnMucm90YXRpb24gLSA5MCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDaXJjdW1mZXJlbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDaXJjdW1mZXJlbmNlKCkge1xuICAgICAgcmV0dXJuIGJ0KHRoaXMub3B0aW9ucy5jaXJjdW1mZXJlbmNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFJvdGF0aW9uRXh0ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Um90YXRpb25FeHRlbnRzKCkge1xuICAgICAgdmFyIHQgPSBCLFxuICAgICAgICBlID0gLUI7XG4gICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7ICsrcykgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShzKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHMpLnR5cGUgPT09IHRoaXMuX3R5cGUpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHMpLmNvbnRyb2xsZXIsXG4gICAgICAgICAgbyA9IG4uX2dldFJvdGF0aW9uKCksXG4gICAgICAgICAgciA9IG4uX2dldENpcmN1bWZlcmVuY2UoKTtcbiAgICAgICAgdCA9IE1hdGgubWluKHQsIG8pLCBlID0gTWF0aC5tYXgoZSwgbyArIHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm90YXRpb246IHQsXG4gICAgICAgIGNpcmN1bWZlcmVuY2U6IGUgLSB0XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5jaGFydCxcbiAgICAgICAgcyA9IGUuY2hhcnRBcmVhLFxuICAgICAgICBuID0gdGhpcy5fY2FjaGVkTWV0YSxcbiAgICAgICAgbyA9IG4uZGF0YSxcbiAgICAgICAgciA9IHRoaXMuZ2V0TWF4Qm9yZGVyV2lkdGgoKSArIHRoaXMuZ2V0TWF4T2Zmc2V0KG8pICsgdGhpcy5vcHRpb25zLnNwYWNpbmcsXG4gICAgICAgIGEgPSBNYXRoLm1heCgoTWF0aC5taW4ocy53aWR0aCwgcy5oZWlnaHQpIC0gcikgLyAyLCAwKSxcbiAgICAgICAgbCA9IE1hdGgubWluKEVvKHRoaXMub3B0aW9ucy5jdXRvdXQsIGEpLCAxKSxcbiAgICAgICAgYyA9IHRoaXMuX2dldFJpbmdXZWlnaHQodGhpcy5pbmRleCksXG4gICAgICAgIF90aGlzJF9nZXRSb3RhdGlvbkV4dCA9IHRoaXMuX2dldFJvdGF0aW9uRXh0ZW50cygpLFxuICAgICAgICBoID0gX3RoaXMkX2dldFJvdGF0aW9uRXh0LmNpcmN1bWZlcmVuY2UsXG4gICAgICAgIGQgPSBfdGhpcyRfZ2V0Um90YXRpb25FeHQucm90YXRpb24sXG4gICAgICAgIF9rYSA9IGthKGQsIGgsIGwpLFxuICAgICAgICB1ID0gX2thLnJhdGlvWCxcbiAgICAgICAgZiA9IF9rYS5yYXRpb1ksXG4gICAgICAgIHAgPSBfa2Eub2Zmc2V0WCxcbiAgICAgICAgZyA9IF9rYS5vZmZzZXRZLFxuICAgICAgICBtID0gKHMud2lkdGggLSByKSAvIHUsXG4gICAgICAgIGIgPSAocy5oZWlnaHQgLSByKSAvIGYsXG4gICAgICAgIF8gPSBNYXRoLm1heChNYXRoLm1pbihtLCBiKSAvIDIsIDApLFxuICAgICAgICB2ID0gYm4odGhpcy5vcHRpb25zLnJhZGl1cywgXyksXG4gICAgICAgIHkgPSBNYXRoLm1heCh2ICogbCwgMCksXG4gICAgICAgIHggPSAodiAtIHkpIC8gdGhpcy5fZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpO1xuICAgICAgdGhpcy5vZmZzZXRYID0gcCAqIHYsIHRoaXMub2Zmc2V0WSA9IGcgKiB2LCBuLnRvdGFsID0gdGhpcy5jYWxjdWxhdGVUb3RhbCgpLCB0aGlzLm91dGVyUmFkaXVzID0gdiAtIHggKiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuaW5kZXgpLCB0aGlzLmlubmVyUmFkaXVzID0gTWF0aC5tYXgodGhpcy5vdXRlclJhZGl1cyAtIHggKiBjLCAwKSwgdGhpcy51cGRhdGVFbGVtZW50cyhvLCAwLCBvLmxlbmd0aCwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jaXJjdW1mZXJlbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaXJjdW1mZXJlbmNlKHQsIGUpIHtcbiAgICAgIHZhciBzID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBuID0gdGhpcy5fY2FjaGVkTWV0YSxcbiAgICAgICAgbyA9IHRoaXMuX2dldENpcmN1bWZlcmVuY2UoKTtcbiAgICAgIHJldHVybiBlICYmIHMuYW5pbWF0aW9uLmFuaW1hdGVSb3RhdGUgfHwgIXRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkodCkgfHwgbi5fcGFyc2VkW3RdID09PSBudWxsIHx8IG4uZGF0YVt0XS5oaWRkZW4gPyAwIDogdGhpcy5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKG4uX3BhcnNlZFt0XSAqIG8gLyBCKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRWxlbWVudHModCwgZSwgcywgbikge1xuICAgICAgdmFyIG8gPSBuID09PSBcInJlc2V0XCIsXG4gICAgICAgIHIgPSB0aGlzLmNoYXJ0LFxuICAgICAgICBhID0gci5jaGFydEFyZWEsXG4gICAgICAgIGMgPSByLm9wdGlvbnMuYW5pbWF0aW9uLFxuICAgICAgICBoID0gKGEubGVmdCArIGEucmlnaHQpIC8gMixcbiAgICAgICAgZCA9IChhLnRvcCArIGEuYm90dG9tKSAvIDIsXG4gICAgICAgIHUgPSBvICYmIGMuYW5pbWF0ZVNjYWxlLFxuICAgICAgICBmID0gdSA/IDAgOiB0aGlzLmlubmVyUmFkaXVzLFxuICAgICAgICBwID0gdSA/IDAgOiB0aGlzLm91dGVyUmFkaXVzLFxuICAgICAgICBfdGhpcyRfZ2V0U2hhcmVkT3B0aW8yID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhlLCBuKSxcbiAgICAgICAgZyA9IF90aGlzJF9nZXRTaGFyZWRPcHRpbzIuc2hhcmVkT3B0aW9ucyxcbiAgICAgICAgbSA9IF90aGlzJF9nZXRTaGFyZWRPcHRpbzIuaW5jbHVkZU9wdGlvbnM7XG4gICAgICB2YXIgYiA9IHRoaXMuX2dldFJvdGF0aW9uKCksXG4gICAgICAgIF87XG4gICAgICBmb3IgKF8gPSAwOyBfIDwgZTsgKytfKSBiICs9IHRoaXMuX2NpcmN1bWZlcmVuY2UoXywgbyk7XG4gICAgICBmb3IgKF8gPSBlOyBfIDwgZSArIHM7ICsrXykge1xuICAgICAgICB2YXIgdiA9IHRoaXMuX2NpcmN1bWZlcmVuY2UoXywgbyksXG4gICAgICAgICAgeSA9IHRbX10sXG4gICAgICAgICAgeCA9IHtcbiAgICAgICAgICAgIHg6IGggKyB0aGlzLm9mZnNldFgsXG4gICAgICAgICAgICB5OiBkICsgdGhpcy5vZmZzZXRZLFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogYixcbiAgICAgICAgICAgIGVuZEFuZ2xlOiBiICsgdixcbiAgICAgICAgICAgIGNpcmN1bWZlcmVuY2U6IHYsXG4gICAgICAgICAgICBvdXRlclJhZGl1czogcCxcbiAgICAgICAgICAgIGlubmVyUmFkaXVzOiBmXG4gICAgICAgICAgfTtcbiAgICAgICAgbSAmJiAoeC5vcHRpb25zID0gZyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoXywgeS5hY3RpdmUgPyBcImFjdGl2ZVwiIDogbikpLCBiICs9IHYsIHRoaXMudXBkYXRlRWxlbWVudCh5LCBfLCB4LCBuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY3VsYXRlVG90YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlVG90YWwoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIGUgPSB0LmRhdGE7XG4gICAgICB2YXIgcyA9IDAsXG4gICAgICAgIG47XG4gICAgICBmb3IgKG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgbyA9IHQuX3BhcnNlZFtuXTtcbiAgICAgICAgbyAhPT0gbnVsbCAmJiAhaXNOYU4obykgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShuKSAmJiAhZVtuXS5oaWRkZW4gJiYgKHMgKz0gTWF0aC5hYnMobykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGN1bGF0ZUNpcmN1bWZlcmVuY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2NhY2hlZE1ldGEudG90YWw7XG4gICAgICByZXR1cm4gZSA+IDAgJiYgIWlzTmFOKHQpID8gQiAqIChNYXRoLmFicyh0KSAvIGUpIDogMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGFiZWxBbmRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbEFuZFZhbHVlKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fY2FjaGVkTWV0YSxcbiAgICAgICAgcyA9IHRoaXMuY2hhcnQsXG4gICAgICAgIG4gPSBzLmRhdGEubGFiZWxzIHx8IFtdLFxuICAgICAgICBvID0gSGkoZS5fcGFyc2VkW3RdLCBzLm9wdGlvbnMubG9jYWxlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhYmVsOiBuW3RdIHx8IFwiXCIsXG4gICAgICAgIHZhbHVlOiBvXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXhCb3JkZXJXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhCb3JkZXJXaWR0aCh0KSB7XG4gICAgICB2YXIgZSA9IDA7XG4gICAgICB2YXIgcyA9IHRoaXMuY2hhcnQ7XG4gICAgICB2YXIgbiwgbywgciwgYSwgbDtcbiAgICAgIGlmICghdCkge1xuICAgICAgICBmb3IgKG4gPSAwLCBvID0gcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgbiA8IG87ICsrbikgaWYgKHMuaXNEYXRhc2V0VmlzaWJsZShuKSkge1xuICAgICAgICAgIHIgPSBzLmdldERhdGFzZXRNZXRhKG4pLCB0ID0gci5kYXRhLCBhID0gci5jb250cm9sbGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXQpIHJldHVybiAwO1xuICAgICAgZm9yIChuID0gMCwgbyA9IHQubGVuZ3RoOyBuIDwgbzsgKytuKSBsID0gYS5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKG4pLCBsLmJvcmRlckFsaWduICE9PSBcImlubmVyXCIgJiYgKGUgPSBNYXRoLm1heChlLCBsLmJvcmRlcldpZHRoIHx8IDAsIGwuaG92ZXJCb3JkZXJXaWR0aCB8fCAwKSk7XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWF4T2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1heE9mZnNldCh0KSB7XG4gICAgICB2YXIgZSA9IDA7XG4gICAgICBmb3IgKHZhciBzID0gMCwgbiA9IHQubGVuZ3RoOyBzIDwgbjsgKytzKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHMpO1xuICAgICAgICBlID0gTWF0aC5tYXgoZSwgby5vZmZzZXQgfHwgMCwgby5ob3Zlck9mZnNldCB8fCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0UmluZ1dlaWdodE9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0UmluZ1dlaWdodE9mZnNldCh0KSB7XG4gICAgICB2YXIgZSA9IDA7XG4gICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHQ7ICsrcykgdGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKHMpICYmIChlICs9IHRoaXMuX2dldFJpbmdXZWlnaHQocykpO1xuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRSaW5nV2VpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRSaW5nV2VpZ2h0KHQpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChEKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0XS53ZWlnaHQsIDEpLCAwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKSB8fCAxO1xuICAgIH1cbiAgfV0pO1xufShrdCk7XG53KGp0LCBcImlkXCIsIFwiZG91Z2hudXRcIiksIHcoanQsIFwiZGVmYXVsdHNcIiwge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6ICExLFxuICBkYXRhRWxlbWVudFR5cGU6IFwiYXJjXCIsXG4gIGFuaW1hdGlvbjoge1xuICAgIGFuaW1hdGVSb3RhdGU6ICEwLFxuICAgIGFuaW1hdGVTY2FsZTogITFcbiAgfSxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBwcm9wZXJ0aWVzOiBbXCJjaXJjdW1mZXJlbmNlXCIsIFwiZW5kQW5nbGVcIiwgXCJpbm5lclJhZGl1c1wiLCBcIm91dGVyUmFkaXVzXCIsIFwic3RhcnRBbmdsZVwiLCBcInhcIiwgXCJ5XCIsIFwib2Zmc2V0XCIsIFwiYm9yZGVyV2lkdGhcIiwgXCJzcGFjaW5nXCJdXG4gICAgfVxuICB9LFxuICBjdXRvdXQ6IFwiNTAlXCIsXG4gIHJvdGF0aW9uOiAwLFxuICBjaXJjdW1mZXJlbmNlOiAzNjAsXG4gIHJhZGl1czogXCIxMDAlXCIsXG4gIHNwYWNpbmc6IDAsXG4gIGluZGV4QXhpczogXCJyXCJcbn0pLCB3KGp0LCBcImRlc2NyaXB0b3JzXCIsIHtcbiAgX3NjcmlwdGFibGU6IGZ1bmN0aW9uIF9zY3JpcHRhYmxlKHQpIHtcbiAgICByZXR1cm4gdCAhPT0gXCJzcGFjaW5nXCI7XG4gIH0sXG4gIF9pbmRleGFibGU6IGZ1bmN0aW9uIF9pbmRleGFibGUodCkge1xuICAgIHJldHVybiB0ICE9PSBcInNwYWNpbmdcIiAmJiAhdC5zdGFydHNXaXRoKFwiYm9yZGVyRGFzaFwiKSAmJiAhdC5zdGFydHNXaXRoKFwiaG92ZXJCb3JkZXJEYXNoXCIpO1xuICB9XG59KSwgdyhqdCwgXCJvdmVycmlkZXNcIiwge1xuICBhc3BlY3RSYXRpbzogMSxcbiAgcGx1Z2luczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIGdlbmVyYXRlTGFiZWxzOiBmdW5jdGlvbiBnZW5lcmF0ZUxhYmVscyh0KSB7XG4gICAgICAgICAgdmFyIGUgPSB0LmRhdGEsXG4gICAgICAgICAgICBfdCRsZWdlbmQkb3B0aW9ucyRsYWIgPSB0LmxlZ2VuZC5vcHRpb25zLmxhYmVscyxcbiAgICAgICAgICAgIHMgPSBfdCRsZWdlbmQkb3B0aW9ucyRsYWIucG9pbnRTdHlsZSxcbiAgICAgICAgICAgIG4gPSBfdCRsZWdlbmQkb3B0aW9ucyRsYWIudGV4dEFsaWduLFxuICAgICAgICAgICAgbyA9IF90JGxlZ2VuZCRvcHRpb25zJGxhYi5jb2xvcixcbiAgICAgICAgICAgIHIgPSBfdCRsZWdlbmQkb3B0aW9ucyRsYWIudXNlQm9yZGVyUmFkaXVzLFxuICAgICAgICAgICAgYSA9IF90JGxlZ2VuZCRvcHRpb25zJGxhYi5ib3JkZXJSYWRpdXM7XG4gICAgICAgICAgcmV0dXJuIGUubGFiZWxzLmxlbmd0aCAmJiBlLmRhdGFzZXRzLmxlbmd0aCA/IGUubGFiZWxzLm1hcChmdW5jdGlvbiAobCwgYykge1xuICAgICAgICAgICAgdmFyIGQgPSB0LmdldERhdGFzZXRNZXRhKDApLmNvbnRyb2xsZXIuZ2V0U3R5bGUoYyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0ZXh0OiBsLFxuICAgICAgICAgICAgICBmaWxsU3R5bGU6IGQuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICBmb250Q29sb3I6IG8sXG4gICAgICAgICAgICAgIGhpZGRlbjogIXQuZ2V0RGF0YVZpc2liaWxpdHkoYyksXG4gICAgICAgICAgICAgIGxpbmVEYXNoOiBkLmJvcmRlckRhc2gsXG4gICAgICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBkLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgICAgIGxpbmVKb2luOiBkLmJvcmRlckpvaW5TdHlsZSxcbiAgICAgICAgICAgICAgbGluZVdpZHRoOiBkLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICBzdHJva2VTdHlsZTogZC5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgdGV4dEFsaWduOiBuLFxuICAgICAgICAgICAgICBwb2ludFN0eWxlOiBzLFxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IHIgJiYgKGEgfHwgZC5ib3JkZXJSYWRpdXMpLFxuICAgICAgICAgICAgICBpbmRleDogY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSA6IFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayh0LCBlLCBzKSB7XG4gICAgICAgIHMuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkoZS5pbmRleCksIHMuY2hhcnQudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbnZhciBGZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2t0Mykge1xuICBmdW5jdGlvbiBGZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmUpO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEZlLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhGZSwgX2t0Myk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRmUsIFt7XG4gICAga2V5OiBcImluaXRpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9ICEwLCB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9ICEwLCBfc3VwZXJQcm9wR2V0KEZlLCBcImluaXRpYWxpemVcIiwgdGhpcywgMykoW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fY2FjaGVkTWV0YSxcbiAgICAgICAgcyA9IGUuZGF0YXNldCxcbiAgICAgICAgX2UkZGF0YSA9IGUuZGF0YSxcbiAgICAgICAgbiA9IF9lJGRhdGEgPT09IHZvaWQgMCA/IFtdIDogX2UkZGF0YSxcbiAgICAgICAgbyA9IGUuX2RhdGFzZXQsXG4gICAgICAgIHIgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgICB2YXIgX3duID0gd24oZSwgbiwgciksXG4gICAgICAgIGEgPSBfd24uc3RhcnQsXG4gICAgICAgIGwgPSBfd24uY291bnQ7XG4gICAgICB0aGlzLl9kcmF3U3RhcnQgPSBhLCB0aGlzLl9kcmF3Q291bnQgPSBsLCBQbihlKSAmJiAoYSA9IDAsIGwgPSBuLmxlbmd0aCksIHMuX2NoYXJ0ID0gdGhpcy5jaGFydCwgcy5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleCwgcy5fZGVjaW1hdGVkID0gISFvLl9kZWNpbWF0ZWQsIHMucG9pbnRzID0gbjtcbiAgICAgIHZhciBjID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKHQpO1xuICAgICAgdGhpcy5vcHRpb25zLnNob3dMaW5lIHx8IChjLmJvcmRlcldpZHRoID0gMCksIGMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50LCB0aGlzLnVwZGF0ZUVsZW1lbnQocywgdm9pZCAwLCB7XG4gICAgICAgIGFuaW1hdGVkOiAhcixcbiAgICAgICAgb3B0aW9uczogY1xuICAgICAgfSwgdCksIHRoaXMudXBkYXRlRWxlbWVudHMobiwgYSwgbCwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnRzKHQsIGUsIHMsIG4pIHtcbiAgICAgIHZhciBvID0gbiA9PT0gXCJyZXNldFwiLFxuICAgICAgICBfdGhpcyRfY2FjaGVkTWV0YTIgPSB0aGlzLl9jYWNoZWRNZXRhLFxuICAgICAgICByID0gX3RoaXMkX2NhY2hlZE1ldGEyLmlTY2FsZSxcbiAgICAgICAgYSA9IF90aGlzJF9jYWNoZWRNZXRhMi52U2NhbGUsXG4gICAgICAgIGwgPSBfdGhpcyRfY2FjaGVkTWV0YTIuX3N0YWNrZWQsXG4gICAgICAgIGMgPSBfdGhpcyRfY2FjaGVkTWV0YTIuX2RhdGFzZXQsXG4gICAgICAgIF90aGlzJF9nZXRTaGFyZWRPcHRpbzMgPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKGUsIG4pLFxuICAgICAgICBoID0gX3RoaXMkX2dldFNoYXJlZE9wdGlvMy5zaGFyZWRPcHRpb25zLFxuICAgICAgICBkID0gX3RoaXMkX2dldFNoYXJlZE9wdGlvMy5pbmNsdWRlT3B0aW9ucyxcbiAgICAgICAgdSA9IHIuYXhpcyxcbiAgICAgICAgZiA9IGEuYXhpcyxcbiAgICAgICAgX3RoaXMkb3B0aW9uczIgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHAgPSBfdGhpcyRvcHRpb25zMi5zcGFuR2FwcyxcbiAgICAgICAgZyA9IF90aGlzJG9wdGlvbnMyLnNlZ21lbnQsXG4gICAgICAgIG0gPSBYdChwKSA/IHAgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgIGIgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgbyB8fCBuID09PSBcIm5vbmVcIixcbiAgICAgICAgXyA9IGUgKyBzLFxuICAgICAgICB2ID0gdC5sZW5ndGg7XG4gICAgICB2YXIgeSA9IGUgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKGUgLSAxKTtcbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdjsgKyt4KSB7XG4gICAgICAgIHZhciBNID0gdFt4XSxcbiAgICAgICAgICBTID0gYiA/IE0gOiB7fTtcbiAgICAgICAgaWYgKHggPCBlIHx8IHggPj0gXykge1xuICAgICAgICAgIFMuc2tpcCA9ICEwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrID0gdGhpcy5nZXRQYXJzZWQoeCksXG4gICAgICAgICAgUCA9IFIoa1tmXSksXG4gICAgICAgICAgQyA9IFNbdV0gPSByLmdldFBpeGVsRm9yVmFsdWUoa1t1XSwgeCksXG4gICAgICAgICAgTyA9IFNbZl0gPSBvIHx8IFAgPyBhLmdldEJhc2VQaXhlbCgpIDogYS5nZXRQaXhlbEZvclZhbHVlKGwgPyB0aGlzLmFwcGx5U3RhY2soYSwgaywgbCkgOiBrW2ZdLCB4KTtcbiAgICAgICAgUy5za2lwID0gaXNOYU4oQykgfHwgaXNOYU4oTykgfHwgUCwgUy5zdG9wID0geCA+IDAgJiYgTWF0aC5hYnMoa1t1XSAtIHlbdV0pID4gbSwgZyAmJiAoUy5wYXJzZWQgPSBrLCBTLnJhdyA9IGMuZGF0YVt4XSksIGQgJiYgKFMub3B0aW9ucyA9IGggfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHgsIE0uYWN0aXZlID8gXCJhY3RpdmVcIiA6IG4pKSwgYiB8fCB0aGlzLnVwZGF0ZUVsZW1lbnQoTSwgeCwgUywgbiksIHkgPSBrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXhPdmVyZmxvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY2FjaGVkTWV0YSxcbiAgICAgICAgZSA9IHQuZGF0YXNldCxcbiAgICAgICAgcyA9IGUub3B0aW9ucyAmJiBlLm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMCxcbiAgICAgICAgbiA9IHQuZGF0YSB8fCBbXTtcbiAgICAgIGlmICghbi5sZW5ndGgpIHJldHVybiBzO1xuICAgICAgdmFyIG8gPSBuWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKSxcbiAgICAgICAgciA9IG5bbi5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhuLmxlbmd0aCAtIDEpKTtcbiAgICAgIHJldHVybiBNYXRoLm1heChzLCBvLCByKSAvIDI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgIHQuZGF0YXNldC51cGRhdGVDb250cm9sUG9pbnRzKHRoaXMuY2hhcnQuY2hhcnRBcmVhLCB0LmlTY2FsZS5heGlzKSwgX3N1cGVyUHJvcEdldChGZSwgXCJkcmF3XCIsIHRoaXMsIDMpKFtdKTtcbiAgICB9XG4gIH1dKTtcbn0oa3QpO1xudyhGZSwgXCJpZFwiLCBcImxpbmVcIiksIHcoRmUsIFwiZGVmYXVsdHNcIiwge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IFwibGluZVwiLFxuICBkYXRhRWxlbWVudFR5cGU6IFwicG9pbnRcIixcbiAgc2hvd0xpbmU6ICEwLFxuICBzcGFuR2FwczogITFcbn0pLCB3KEZlLCBcIm92ZXJyaWRlc1wiLCB7XG4gIHNjYWxlczoge1xuICAgIF9pbmRleF86IHtcbiAgICAgIHR5cGU6IFwiY2F0ZWdvcnlcIlxuICAgIH0sXG4gICAgX3ZhbHVlXzoge1xuICAgICAgdHlwZTogXCJsaW5lYXJcIlxuICAgIH1cbiAgfVxufSk7XG52YXIga2kgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9qdCkge1xuICBmdW5jdGlvbiBraSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywga2kpO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIGtpLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhraSwgX2p0KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhraSk7XG59KGp0KTtcbncoa2ksIFwiaWRcIiwgXCJwaWVcIiksIHcoa2ksIFwiZGVmYXVsdHNcIiwge1xuICBjdXRvdXQ6IDAsXG4gIHJvdGF0aW9uOiAwLFxuICBjaXJjdW1mZXJlbmNlOiAzNjAsXG4gIHJhZGl1czogXCIxMDAlXCJcbn0pO1xudmFyIEllID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfa3Q0KSB7XG4gIGZ1bmN0aW9uIEllKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJZSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgSWUsIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2luaGVyaXRzKEllLCBfa3Q0KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhJZSwgW3tcbiAgICBrZXk6IFwiZ2V0TGFiZWxBbmRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbEFuZFZhbHVlKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fY2FjaGVkTWV0YSxcbiAgICAgICAgcyA9IHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMgfHwgW10sXG4gICAgICAgIG4gPSBlLnhTY2FsZSxcbiAgICAgICAgbyA9IGUueVNjYWxlLFxuICAgICAgICByID0gdGhpcy5nZXRQYXJzZWQodCksXG4gICAgICAgIGEgPSBuLmdldExhYmVsRm9yVmFsdWUoci54KSxcbiAgICAgICAgbCA9IG8uZ2V0TGFiZWxGb3JWYWx1ZShyLnkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFiZWw6IHNbdF0gfHwgXCJcIixcbiAgICAgICAgdmFsdWU6IFwiKFwiICsgYSArIFwiLCBcIiArIGwgKyBcIilcIlxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIF9lJGRhdGEyID0gZS5kYXRhLFxuICAgICAgICBzID0gX2UkZGF0YTIgPT09IHZvaWQgMCA/IFtdIDogX2UkZGF0YTIsXG4gICAgICAgIG4gPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgICB2YXIgX3duMiA9IHduKGUsIHMsIG4pLFxuICAgICAgICBvID0gX3duMi5zdGFydCxcbiAgICAgICAgciA9IF93bjIuY291bnQ7XG4gICAgICBpZiAodGhpcy5fZHJhd1N0YXJ0ID0gbywgdGhpcy5fZHJhd0NvdW50ID0gciwgUG4oZSkgJiYgKG8gPSAwLCByID0gcy5sZW5ndGgpLCB0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgfHwgdGhpcy5hZGRFbGVtZW50cygpO1xuICAgICAgICB2YXIgYSA9IGUuZGF0YXNldCxcbiAgICAgICAgICBsID0gZS5fZGF0YXNldDtcbiAgICAgICAgYS5fY2hhcnQgPSB0aGlzLmNoYXJ0LCBhLl9kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4LCBhLl9kZWNpbWF0ZWQgPSAhIWwuX2RlY2ltYXRlZCwgYS5wb2ludHMgPSBzO1xuICAgICAgICB2YXIgYyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyh0KTtcbiAgICAgICAgYy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQsIHRoaXMudXBkYXRlRWxlbWVudChhLCB2b2lkIDAsIHtcbiAgICAgICAgICBhbmltYXRlZDogIW4sXG4gICAgICAgICAgb3B0aW9uczogY1xuICAgICAgICB9LCB0KTtcbiAgICAgIH0gZWxzZSB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSAmJiAoZGVsZXRlIGUuZGF0YXNldCwgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSAhMSk7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHMsIG8sIHIsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFbGVtZW50cygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLnNob3dMaW5lO1xuICAgICAgIXRoaXMuZGF0YXNldEVsZW1lbnRUeXBlICYmIHQgJiYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlID0gdGhpcy5jaGFydC5yZWdpc3RyeS5nZXRFbGVtZW50KFwibGluZVwiKSksIF9zdXBlclByb3BHZXQoSWUsIFwiYWRkRWxlbWVudHNcIiwgdGhpcywgMykoW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVFbGVtZW50cyh0LCBlLCBzLCBuKSB7XG4gICAgICB2YXIgbyA9IG4gPT09IFwicmVzZXRcIixcbiAgICAgICAgX3RoaXMkX2NhY2hlZE1ldGEzID0gdGhpcy5fY2FjaGVkTWV0YSxcbiAgICAgICAgciA9IF90aGlzJF9jYWNoZWRNZXRhMy5pU2NhbGUsXG4gICAgICAgIGEgPSBfdGhpcyRfY2FjaGVkTWV0YTMudlNjYWxlLFxuICAgICAgICBsID0gX3RoaXMkX2NhY2hlZE1ldGEzLl9zdGFja2VkLFxuICAgICAgICBjID0gX3RoaXMkX2NhY2hlZE1ldGEzLl9kYXRhc2V0LFxuICAgICAgICBoID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGUsIG4pLFxuICAgICAgICBkID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKGgpLFxuICAgICAgICB1ID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhuLCBkKSxcbiAgICAgICAgZiA9IHIuYXhpcyxcbiAgICAgICAgcCA9IGEuYXhpcyxcbiAgICAgICAgX3RoaXMkb3B0aW9uczMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGcgPSBfdGhpcyRvcHRpb25zMy5zcGFuR2FwcyxcbiAgICAgICAgbSA9IF90aGlzJG9wdGlvbnMzLnNlZ21lbnQsXG4gICAgICAgIGIgPSBYdChnKSA/IGcgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgIF8gPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgbyB8fCBuID09PSBcIm5vbmVcIjtcbiAgICAgIHZhciB2ID0gZSA+IDAgJiYgdGhpcy5nZXRQYXJzZWQoZSAtIDEpO1xuICAgICAgZm9yICh2YXIgeSA9IGU7IHkgPCBlICsgczsgKyt5KSB7XG4gICAgICAgIHZhciB4ID0gdFt5XSxcbiAgICAgICAgICBNID0gdGhpcy5nZXRQYXJzZWQoeSksXG4gICAgICAgICAgUyA9IF8gPyB4IDoge30sXG4gICAgICAgICAgayA9IFIoTVtwXSksXG4gICAgICAgICAgUCA9IFNbZl0gPSByLmdldFBpeGVsRm9yVmFsdWUoTVtmXSwgeSksXG4gICAgICAgICAgQyA9IFNbcF0gPSBvIHx8IGsgPyBhLmdldEJhc2VQaXhlbCgpIDogYS5nZXRQaXhlbEZvclZhbHVlKGwgPyB0aGlzLmFwcGx5U3RhY2soYSwgTSwgbCkgOiBNW3BdLCB5KTtcbiAgICAgICAgUy5za2lwID0gaXNOYU4oUCkgfHwgaXNOYU4oQykgfHwgaywgUy5zdG9wID0geSA+IDAgJiYgTWF0aC5hYnMoTVtmXSAtIHZbZl0pID4gYiwgbSAmJiAoUy5wYXJzZWQgPSBNLCBTLnJhdyA9IGMuZGF0YVt5XSksIHUgJiYgKFMub3B0aW9ucyA9IGQgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHksIHguYWN0aXZlID8gXCJhY3RpdmVcIiA6IG4pKSwgXyB8fCB0aGlzLnVwZGF0ZUVsZW1lbnQoeCwgeSwgUywgbiksIHYgPSBNO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKGQsIG4sIGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXhPdmVyZmxvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY2FjaGVkTWV0YSxcbiAgICAgICAgZSA9IHQuZGF0YSB8fCBbXTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICAgIHZhciBhID0gMDtcbiAgICAgICAgZm9yICh2YXIgbCA9IGUubGVuZ3RoIC0gMTsgbCA+PSAwOyAtLWwpIGEgPSBNYXRoLm1heChhLCBlW2xdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGwpKSAvIDIpO1xuICAgICAgICByZXR1cm4gYSA+IDAgJiYgYTtcbiAgICAgIH1cbiAgICAgIHZhciBzID0gdC5kYXRhc2V0LFxuICAgICAgICBuID0gcy5vcHRpb25zICYmIHMub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgICAgaWYgKCFlLmxlbmd0aCkgcmV0dXJuIG47XG4gICAgICB2YXIgbyA9IGVbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpLFxuICAgICAgICByID0gZVtlLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGUubGVuZ3RoIC0gMSkpO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KG4sIG8sIHIpIC8gMjtcbiAgICB9XG4gIH1dKTtcbn0oa3QpO1xudyhJZSwgXCJpZFwiLCBcInNjYXR0ZXJcIiksIHcoSWUsIFwiZGVmYXVsdHNcIiwge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6ICExLFxuICBkYXRhRWxlbWVudFR5cGU6IFwicG9pbnRcIixcbiAgc2hvd0xpbmU6ICExLFxuICBmaWxsOiAhMVxufSksIHcoSWUsIFwib3ZlcnJpZGVzXCIsIHtcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBtb2RlOiBcInBvaW50XCJcbiAgfSxcbiAgc2NhbGVzOiB7XG4gICAgeDoge1xuICAgICAgdHlwZTogXCJsaW5lYXJcIlxuICAgIH0sXG4gICAgeToge1xuICAgICAgdHlwZTogXCJsaW5lYXJcIlxuICAgIH1cbiAgfVxufSk7XG5mdW5jdGlvbiBUdCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkOiBDaGVjayB0aGF0IGEgY29tcGxldGUgZGF0ZSBhZGFwdGVyIGlzIHByb3ZpZGVkLlwiKTtcbn1cbnZhciBVaSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFVpKHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVWkpO1xuICAgIHcodGhpcywgXCJvcHRpb25zXCIpO1xuICAgIHRoaXMub3B0aW9ucyA9IHQgfHwge307XG4gIH1cbiAgLyoqXG4gICogT3ZlcnJpZGUgZGVmYXVsdCBkYXRlIGFkYXB0ZXIgbWV0aG9kcy5cbiAgKiBBY2NlcHRzIHR5cGUgcGFyYW1ldGVyIHRvIGRlZmluZSBvcHRpb25zIHR5cGUuXG4gICogQGV4YW1wbGVcbiAgKiBDaGFydC5fYWRhcHRlcnMuX2RhdGUub3ZlcnJpZGU8e215QWRhcHRlck9wdGlvbjogc3RyaW5nfT4oe1xuICAqICAgaW5pdCgpIHtcbiAgKiAgICAgY29uc29sZS5sb2codGhpcy5vcHRpb25zLm15QWRhcHRlck9wdGlvbik7XG4gICogICB9XG4gICogfSlcbiAgKi9cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhVaSwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbiAgICBmdW5jdGlvbiBpbml0KCkge31cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoKSB7XG4gICAgICByZXR1cm4gVHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoKSB7XG4gICAgICByZXR1cm4gVHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdCgpIHtcbiAgICAgIHJldHVybiBUdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKCkge1xuICAgICAgcmV0dXJuIFR0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpZmZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlmZigpIHtcbiAgICAgIHJldHVybiBUdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydE9mXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0T2YoKSB7XG4gICAgICByZXR1cm4gVHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kT2ZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kT2YoKSB7XG4gICAgICByZXR1cm4gVHQoKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJvdmVycmlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdmVycmlkZSh0KSB7XG4gICAgICBPYmplY3QuYXNzaWduKFVpLnByb3RvdHlwZSwgdCk7XG4gICAgfVxuICB9XSk7XG59KCk7XG52YXIgd2EgPSB7XG4gIF9kYXRlOiBVaVxufTtcbmZ1bmN0aW9uIFBhKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBpLmNvbnRyb2xsZXIsXG4gICAgbyA9IGkuZGF0YSxcbiAgICByID0gaS5fc29ydGVkLFxuICAgIGEgPSBuLl9jYWNoZWRNZXRhLmlTY2FsZSxcbiAgICBsID0gaS5kYXRhc2V0ICYmIGkuZGF0YXNldC5vcHRpb25zID8gaS5kYXRhc2V0Lm9wdGlvbnMuc3BhbkdhcHMgOiBudWxsO1xuICBpZiAoYSAmJiB0ID09PSBhLmF4aXMgJiYgdCAhPT0gXCJyXCIgJiYgciAmJiBvLmxlbmd0aCkge1xuICAgIHZhciBjID0gYS5fcmV2ZXJzZVBpeGVscyA/IEtvIDogRXQ7XG4gICAgaWYgKHMpIHtcbiAgICAgIGlmIChuLl9zaGFyZWRPcHRpb25zKSB7XG4gICAgICAgIHZhciBoID0gb1swXSxcbiAgICAgICAgICBkID0gdHlwZW9mIGguZ2V0UmFuZ2UgPT0gXCJmdW5jdGlvblwiICYmIGguZ2V0UmFuZ2UodCk7XG4gICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgdmFyIHUgPSBjKG8sIHQsIGUgLSBkKSxcbiAgICAgICAgICAgIGYgPSBjKG8sIHQsIGUgKyBkKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG86IHUubG8sXG4gICAgICAgICAgICBoaTogZi5oaVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9oID0gYyhvLCB0LCBlKTtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIHZhciBfZCA9IG4uX2NhY2hlZE1ldGEudlNjYWxlLFxuICAgICAgICAgIF91ID0gaS5fcGFyc2VkLFxuICAgICAgICAgIF9mID0gX3Uuc2xpY2UoMCwgX2gubG8gKyAxKS5yZXZlcnNlKCkuZmluZEluZGV4KGZ1bmN0aW9uIChnKSB7XG4gICAgICAgICAgICByZXR1cm4gIVIoZ1tfZC5heGlzXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIF9oLmxvIC09IE1hdGgubWF4KDAsIF9mKTtcbiAgICAgICAgdmFyIHAgPSBfdS5zbGljZShfaC5oaSkuZmluZEluZGV4KGZ1bmN0aW9uIChnKSB7XG4gICAgICAgICAgcmV0dXJuICFSKGdbX2QuYXhpc10pO1xuICAgICAgICB9KTtcbiAgICAgICAgX2guaGkgKz0gTWF0aC5tYXgoMCwgcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2g7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbG86IDAsXG4gICAgaGk6IG8ubGVuZ3RoIC0gMVxuICB9O1xufVxuZnVuY3Rpb24gdGkoaSwgdCwgZSwgcywgbikge1xuICB2YXIgbyA9IGkuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLFxuICAgIHIgPSBlW3RdO1xuICBmb3IgKHZhciBhID0gMCwgbCA9IG8ubGVuZ3RoOyBhIDwgbDsgKythKSB7XG4gICAgdmFyIF9vJGEgPSBvW2FdLFxuICAgICAgYyA9IF9vJGEuaW5kZXgsXG4gICAgICBoID0gX28kYS5kYXRhLFxuICAgICAgX1BhID0gUGEob1thXSwgdCwgciwgbiksXG4gICAgICBkID0gX1BhLmxvLFxuICAgICAgdSA9IF9QYS5oaTtcbiAgICBmb3IgKHZhciBmID0gZDsgZiA8PSB1OyArK2YpIHtcbiAgICAgIHZhciBwID0gaFtmXTtcbiAgICAgIHAuc2tpcCB8fCBzKHAsIGMsIGYpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gRGEoaSkge1xuICB2YXIgdCA9IGkuaW5kZXhPZihcInhcIikgIT09IC0xLFxuICAgIGUgPSBpLmluZGV4T2YoXCJ5XCIpICE9PSAtMTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzLCBuKSB7XG4gICAgdmFyIG8gPSB0ID8gTWF0aC5hYnMocy54IC0gbi54KSA6IDAsXG4gICAgICByID0gZSA/IE1hdGguYWJzKHMueSAtIG4ueSkgOiAwO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cobywgMikgKyBNYXRoLnBvdyhyLCAyKSk7XG4gIH07XG59XG5mdW5jdGlvbiBoaShpLCB0LCBlLCBzLCBuKSB7XG4gIHZhciBvID0gW107XG4gIHJldHVybiAhbiAmJiAhaS5pc1BvaW50SW5BcmVhKHQpIHx8IHRpKGksIGUsIHQsIGZ1bmN0aW9uIChhLCBsLCBjKSB7XG4gICAgIW4gJiYgIW1lKGEsIGkuY2hhcnRBcmVhLCAwKSB8fCBhLmluUmFuZ2UodC54LCB0LnksIHMpICYmIG8ucHVzaCh7XG4gICAgICBlbGVtZW50OiBhLFxuICAgICAgZGF0YXNldEluZGV4OiBsLFxuICAgICAgaW5kZXg6IGNcbiAgICB9KTtcbiAgfSwgITApLCBvO1xufVxuZnVuY3Rpb24gQ2EoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IFtdO1xuICBmdW5jdGlvbiBvKHIsIGEsIGwpIHtcbiAgICB2YXIgX3IkZ2V0UHJvcHMgPSByLmdldFByb3BzKFtcInN0YXJ0QW5nbGVcIiwgXCJlbmRBbmdsZVwiXSwgcyksXG4gICAgICBjID0gX3IkZ2V0UHJvcHMuc3RhcnRBbmdsZSxcbiAgICAgIGggPSBfciRnZXRQcm9wcy5lbmRBbmdsZSxcbiAgICAgIF95biA9IHluKHIsIHtcbiAgICAgICAgeDogdC54LFxuICAgICAgICB5OiB0LnlcbiAgICAgIH0pLFxuICAgICAgZCA9IF95bi5hbmdsZTtcbiAgICBwZShkLCBjLCBoKSAmJiBuLnB1c2goe1xuICAgICAgZWxlbWVudDogcixcbiAgICAgIGRhdGFzZXRJbmRleDogYSxcbiAgICAgIGluZGV4OiBsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRpKGksIGUsIHQsIG8pLCBuO1xufVxuZnVuY3Rpb24gT2EoaSwgdCwgZSwgcywgbiwgbykge1xuICB2YXIgciA9IFtdO1xuICB2YXIgYSA9IERhKGUpO1xuICB2YXIgbCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgZnVuY3Rpb24gYyhoLCBkLCB1KSB7XG4gICAgdmFyIGYgPSBoLmluUmFuZ2UodC54LCB0LnksIG4pO1xuICAgIGlmIChzICYmICFmKSByZXR1cm47XG4gICAgdmFyIHAgPSBoLmdldENlbnRlclBvaW50KG4pO1xuICAgIGlmICghKCEhbyB8fCBpLmlzUG9pbnRJbkFyZWEocCkpICYmICFmKSByZXR1cm47XG4gICAgdmFyIG0gPSBhKHQsIHApO1xuICAgIG0gPCBsID8gKHIgPSBbe1xuICAgICAgZWxlbWVudDogaCxcbiAgICAgIGRhdGFzZXRJbmRleDogZCxcbiAgICAgIGluZGV4OiB1XG4gICAgfV0sIGwgPSBtKSA6IG0gPT09IGwgJiYgci5wdXNoKHtcbiAgICAgIGVsZW1lbnQ6IGgsXG4gICAgICBkYXRhc2V0SW5kZXg6IGQsXG4gICAgICBpbmRleDogdVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aShpLCBlLCB0LCBjKSwgcjtcbn1cbmZ1bmN0aW9uIGRpKGksIHQsIGUsIHMsIG4sIG8pIHtcbiAgcmV0dXJuICFvICYmICFpLmlzUG9pbnRJbkFyZWEodCkgPyBbXSA6IGUgPT09IFwiclwiICYmICFzID8gQ2EoaSwgdCwgZSwgbikgOiBPYShpLCB0LCBlLCBzLCBuLCBvKTtcbn1cbmZ1bmN0aW9uIFBzKGksIHQsIGUsIHMsIG4pIHtcbiAgdmFyIG8gPSBbXSxcbiAgICByID0gZSA9PT0gXCJ4XCIgPyBcImluWFJhbmdlXCIgOiBcImluWVJhbmdlXCI7XG4gIHZhciBhID0gITE7XG4gIHJldHVybiB0aShpLCBlLCB0LCBmdW5jdGlvbiAobCwgYywgaCkge1xuICAgIGxbcl0gJiYgbFtyXSh0W2VdLCBuKSAmJiAoby5wdXNoKHtcbiAgICAgIGVsZW1lbnQ6IGwsXG4gICAgICBkYXRhc2V0SW5kZXg6IGMsXG4gICAgICBpbmRleDogaFxuICAgIH0pLCBhID0gYSB8fCBsLmluUmFuZ2UodC54LCB0LnksIG4pKTtcbiAgfSksIHMgJiYgIWEgPyBbXSA6IG87XG59XG52YXIgVGEgPSB7XG4gIG1vZGVzOiB7XG4gICAgaW5kZXg6IGZ1bmN0aW9uIGluZGV4KGksIHQsIGUsIHMpIHtcbiAgICAgIHZhciBuID0gQXQodCwgaSksXG4gICAgICAgIG8gPSBlLmF4aXMgfHwgXCJ4XCIsXG4gICAgICAgIHIgPSBlLmluY2x1ZGVJbnZpc2libGUgfHwgITEsXG4gICAgICAgIGEgPSBlLmludGVyc2VjdCA/IGhpKGksIG4sIG8sIHMsIHIpIDogZGkoaSwgbiwgbywgITEsIHMsIHIpLFxuICAgICAgICBsID0gW107XG4gICAgICByZXR1cm4gYS5sZW5ndGggPyAoaS5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgaCA9IGFbMF0uaW5kZXgsXG4gICAgICAgICAgZCA9IGMuZGF0YVtoXTtcbiAgICAgICAgZCAmJiAhZC5za2lwICYmIGwucHVzaCh7XG4gICAgICAgICAgZWxlbWVudDogZCxcbiAgICAgICAgICBkYXRhc2V0SW5kZXg6IGMuaW5kZXgsXG4gICAgICAgICAgaW5kZXg6IGhcbiAgICAgICAgfSk7XG4gICAgICB9KSwgbCkgOiBbXTtcbiAgICB9LFxuICAgIGRhdGFzZXQ6IGZ1bmN0aW9uIGRhdGFzZXQoaSwgdCwgZSwgcykge1xuICAgICAgdmFyIG4gPSBBdCh0LCBpKSxcbiAgICAgICAgbyA9IGUuYXhpcyB8fCBcInh5XCIsXG4gICAgICAgIHIgPSBlLmluY2x1ZGVJbnZpc2libGUgfHwgITE7XG4gICAgICB2YXIgYSA9IGUuaW50ZXJzZWN0ID8gaGkoaSwgbiwgbywgcywgcikgOiBkaShpLCBuLCBvLCAhMSwgcywgcik7XG4gICAgICBpZiAoYS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBsID0gYVswXS5kYXRhc2V0SW5kZXgsXG4gICAgICAgICAgYyA9IGkuZ2V0RGF0YXNldE1ldGEobCkuZGF0YTtcbiAgICAgICAgYSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IGMubGVuZ3RoOyArK2gpIGEucHVzaCh7XG4gICAgICAgICAgZWxlbWVudDogY1toXSxcbiAgICAgICAgICBkYXRhc2V0SW5kZXg6IGwsXG4gICAgICAgICAgaW5kZXg6IGhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYTtcbiAgICB9LFxuICAgIHBvaW50OiBmdW5jdGlvbiBwb2ludChpLCB0LCBlLCBzKSB7XG4gICAgICB2YXIgbiA9IEF0KHQsIGkpLFxuICAgICAgICBvID0gZS5heGlzIHx8IFwieHlcIixcbiAgICAgICAgciA9IGUuaW5jbHVkZUludmlzaWJsZSB8fCAhMTtcbiAgICAgIHJldHVybiBoaShpLCBuLCBvLCBzLCByKTtcbiAgICB9LFxuICAgIG5lYXJlc3Q6IGZ1bmN0aW9uIG5lYXJlc3QoaSwgdCwgZSwgcykge1xuICAgICAgdmFyIG4gPSBBdCh0LCBpKSxcbiAgICAgICAgbyA9IGUuYXhpcyB8fCBcInh5XCIsXG4gICAgICAgIHIgPSBlLmluY2x1ZGVJbnZpc2libGUgfHwgITE7XG4gICAgICByZXR1cm4gZGkoaSwgbiwgbywgZS5pbnRlcnNlY3QsIHMsIHIpO1xuICAgIH0sXG4gICAgeDogZnVuY3Rpb24geChpLCB0LCBlLCBzKSB7XG4gICAgICB2YXIgbiA9IEF0KHQsIGkpO1xuICAgICAgcmV0dXJuIFBzKGksIG4sIFwieFwiLCBlLmludGVyc2VjdCwgcyk7XG4gICAgfSxcbiAgICB5OiBmdW5jdGlvbiB5KGksIHQsIGUsIHMpIHtcbiAgICAgIHZhciBuID0gQXQodCwgaSk7XG4gICAgICByZXR1cm4gUHMoaSwgbiwgXCJ5XCIsIGUuaW50ZXJzZWN0LCBzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgJG4gPSBbXCJsZWZ0XCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIl07XG5mdW5jdGlvbiB0ZShpLCB0KSB7XG4gIHJldHVybiBpLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlLnBvcyA9PT0gdDtcbiAgfSk7XG59XG5mdW5jdGlvbiBEcyhpLCB0KSB7XG4gIHJldHVybiBpLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiAkbi5pbmRleE9mKGUucG9zKSA9PT0gLTEgJiYgZS5ib3guYXhpcyA9PT0gdDtcbiAgfSk7XG59XG5mdW5jdGlvbiBlZShpLCB0KSB7XG4gIHJldHVybiBpLnNvcnQoZnVuY3Rpb24gKGUsIHMpIHtcbiAgICB2YXIgbiA9IHQgPyBzIDogZSxcbiAgICAgIG8gPSB0ID8gZSA6IHM7XG4gICAgcmV0dXJuIG4ud2VpZ2h0ID09PSBvLndlaWdodCA/IG4uaW5kZXggLSBvLmluZGV4IDogbi53ZWlnaHQgLSBvLndlaWdodDtcbiAgfSk7XG59XG5mdW5jdGlvbiBBYShpKSB7XG4gIHZhciB0ID0gW107XG4gIHZhciBlLCBzLCBuLCBvLCByLCBhO1xuICBmb3IgKGUgPSAwLCBzID0gKGkgfHwgW10pLmxlbmd0aDsgZSA8IHM7ICsrZSkge1xuICAgIHZhciBfbjMsIF9uMyRvcHRpb25zLCBfbjMkb3B0aW9ucyRzdGFja1dlaWc7XG4gICAgbiA9IGlbZV0sIF9uMyA9IG4sIG8gPSBfbjMucG9zaXRpb24sIF9uMyRvcHRpb25zID0gX24zLm9wdGlvbnMsIHIgPSBfbjMkb3B0aW9ucy5zdGFjaywgX24zJG9wdGlvbnMkc3RhY2tXZWlnID0gX24zJG9wdGlvbnMuc3RhY2tXZWlnaHQsIGEgPSBfbjMkb3B0aW9ucyRzdGFja1dlaWcgPT09IHZvaWQgMCA/IDEgOiBfbjMkb3B0aW9ucyRzdGFja1dlaWcsIHQucHVzaCh7XG4gICAgICBpbmRleDogZSxcbiAgICAgIGJveDogbixcbiAgICAgIHBvczogbyxcbiAgICAgIGhvcml6b250YWw6IG4uaXNIb3Jpem9udGFsKCksXG4gICAgICB3ZWlnaHQ6IG4ud2VpZ2h0LFxuICAgICAgc3RhY2s6IHIgJiYgbyArIHIsXG4gICAgICBzdGFja1dlaWdodDogYVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gUmEoaSkge1xuICB2YXIgdCA9IHt9O1xuICB2YXIgX2l0ZXJhdG9yMTUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpKSxcbiAgICBfc3RlcDE1O1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMTUucygpOyAhKF9zdGVwMTUgPSBfaXRlcmF0b3IxNS5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgZSA9IF9zdGVwMTUudmFsdWU7XG4gICAgICB2YXIgcyA9IGUuc3RhY2ssXG4gICAgICAgIG4gPSBlLnBvcyxcbiAgICAgICAgbyA9IGUuc3RhY2tXZWlnaHQ7XG4gICAgICBpZiAoIXMgfHwgISRuLmluY2x1ZGVzKG4pKSBjb250aW51ZTtcbiAgICAgIHZhciByID0gdFtzXSB8fCAodFtzXSA9IHtcbiAgICAgICAgY291bnQ6IDAsXG4gICAgICAgIHBsYWNlZDogMCxcbiAgICAgICAgd2VpZ2h0OiAwLFxuICAgICAgICBzaXplOiAwXG4gICAgICB9KTtcbiAgICAgIHIuY291bnQrKywgci53ZWlnaHQgKz0gbztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjE1LmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IxNS5mKCk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBMYShpLCB0KSB7XG4gIHZhciBlID0gUmEoaSksXG4gICAgcyA9IHQudkJveE1heFdpZHRoLFxuICAgIG4gPSB0LmhCb3hNYXhIZWlnaHQ7XG4gIHZhciBvLCByLCBhO1xuICBmb3IgKG8gPSAwLCByID0gaS5sZW5ndGg7IG8gPCByOyArK28pIHtcbiAgICBhID0gaVtvXTtcbiAgICB2YXIgbCA9IGEuYm94LmZ1bGxTaXplLFxuICAgICAgYyA9IGVbYS5zdGFja10sXG4gICAgICBoID0gYyAmJiBhLnN0YWNrV2VpZ2h0IC8gYy53ZWlnaHQ7XG4gICAgYS5ob3Jpem9udGFsID8gKGEud2lkdGggPSBoID8gaCAqIHMgOiBsICYmIHQuYXZhaWxhYmxlV2lkdGgsIGEuaGVpZ2h0ID0gbikgOiAoYS53aWR0aCA9IHMsIGEuaGVpZ2h0ID0gaCA/IGggKiBuIDogbCAmJiB0LmF2YWlsYWJsZUhlaWdodCk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBFYShpKSB7XG4gIHZhciB0ID0gQWEoaSksXG4gICAgZSA9IGVlKHQuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYy5ib3guZnVsbFNpemU7XG4gICAgfSksICEwKSxcbiAgICBzID0gZWUodGUodCwgXCJsZWZ0XCIpLCAhMCksXG4gICAgbiA9IGVlKHRlKHQsIFwicmlnaHRcIikpLFxuICAgIG8gPSBlZSh0ZSh0LCBcInRvcFwiKSwgITApLFxuICAgIHIgPSBlZSh0ZSh0LCBcImJvdHRvbVwiKSksXG4gICAgYSA9IERzKHQsIFwieFwiKSxcbiAgICBsID0gRHModCwgXCJ5XCIpO1xuICByZXR1cm4ge1xuICAgIGZ1bGxTaXplOiBlLFxuICAgIGxlZnRBbmRUb3A6IHMuY29uY2F0KG8pLFxuICAgIHJpZ2h0QW5kQm90dG9tOiBuLmNvbmNhdChsKS5jb25jYXQocikuY29uY2F0KGEpLFxuICAgIGNoYXJ0QXJlYTogdGUodCwgXCJjaGFydEFyZWFcIiksXG4gICAgdmVydGljYWw6IHMuY29uY2F0KG4pLmNvbmNhdChsKSxcbiAgICBob3Jpem9udGFsOiBvLmNvbmNhdChyKS5jb25jYXQoYSlcbiAgfTtcbn1cbmZ1bmN0aW9uIENzKGksIHQsIGUsIHMpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGlbZV0sIHRbZV0pICsgTWF0aC5tYXgoaVtzXSwgdFtzXSk7XG59XG5mdW5jdGlvbiBZbihpLCB0KSB7XG4gIGkudG9wID0gTWF0aC5tYXgoaS50b3AsIHQudG9wKSwgaS5sZWZ0ID0gTWF0aC5tYXgoaS5sZWZ0LCB0LmxlZnQpLCBpLmJvdHRvbSA9IE1hdGgubWF4KGkuYm90dG9tLCB0LmJvdHRvbSksIGkucmlnaHQgPSBNYXRoLm1heChpLnJpZ2h0LCB0LnJpZ2h0KTtcbn1cbmZ1bmN0aW9uIEZhKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBlLnBvcyxcbiAgICBvID0gZS5ib3gsXG4gICAgciA9IGkubWF4UGFkZGluZztcbiAgaWYgKCFUKG4pKSB7XG4gICAgZS5zaXplICYmIChpW25dIC09IGUuc2l6ZSk7XG4gICAgdmFyIGQgPSBzW2Uuc3RhY2tdIHx8IHtcbiAgICAgIHNpemU6IDAsXG4gICAgICBjb3VudDogMVxuICAgIH07XG4gICAgZC5zaXplID0gTWF0aC5tYXgoZC5zaXplLCBlLmhvcml6b250YWwgPyBvLmhlaWdodCA6IG8ud2lkdGgpLCBlLnNpemUgPSBkLnNpemUgLyBkLmNvdW50LCBpW25dICs9IGUuc2l6ZTtcbiAgfVxuICBvLmdldFBhZGRpbmcgJiYgWW4ociwgby5nZXRQYWRkaW5nKCkpO1xuICB2YXIgYSA9IE1hdGgubWF4KDAsIHQub3V0ZXJXaWR0aCAtIENzKHIsIGksIFwibGVmdFwiLCBcInJpZ2h0XCIpKSxcbiAgICBsID0gTWF0aC5tYXgoMCwgdC5vdXRlckhlaWdodCAtIENzKHIsIGksIFwidG9wXCIsIFwiYm90dG9tXCIpKSxcbiAgICBjID0gYSAhPT0gaS53LFxuICAgIGggPSBsICE9PSBpLmg7XG4gIHJldHVybiBpLncgPSBhLCBpLmggPSBsLCBlLmhvcml6b250YWwgPyB7XG4gICAgc2FtZTogYyxcbiAgICBvdGhlcjogaFxuICB9IDoge1xuICAgIHNhbWU6IGgsXG4gICAgb3RoZXI6IGNcbiAgfTtcbn1cbmZ1bmN0aW9uIElhKGkpIHtcbiAgdmFyIHQgPSBpLm1heFBhZGRpbmc7XG4gIGZ1bmN0aW9uIGUocykge1xuICAgIHZhciBuID0gTWF0aC5tYXgodFtzXSAtIGlbc10sIDApO1xuICAgIHJldHVybiBpW3NdICs9IG4sIG47XG4gIH1cbiAgaS55ICs9IGUoXCJ0b3BcIiksIGkueCArPSBlKFwibGVmdFwiKSwgZShcInJpZ2h0XCIpLCBlKFwiYm90dG9tXCIpO1xufVxuZnVuY3Rpb24gemEoaSwgdCkge1xuICB2YXIgZSA9IHQubWF4UGFkZGluZztcbiAgZnVuY3Rpb24gcyhuKSB7XG4gICAgdmFyIG8gPSB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9O1xuICAgIHJldHVybiBuLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIG9bcl0gPSBNYXRoLm1heCh0W3JdLCBlW3JdKTtcbiAgICB9KSwgbztcbiAgfVxuICByZXR1cm4gcyhpID8gW1wibGVmdFwiLCBcInJpZ2h0XCJdIDogW1widG9wXCIsIFwiYm90dG9tXCJdKTtcbn1cbmZ1bmN0aW9uIG9lKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBbXTtcbiAgdmFyIG8sIHIsIGEsIGwsIGMsIGg7XG4gIGZvciAobyA9IDAsIHIgPSBpLmxlbmd0aCwgYyA9IDA7IG8gPCByOyArK28pIHtcbiAgICBhID0gaVtvXSwgbCA9IGEuYm94LCBsLnVwZGF0ZShhLndpZHRoIHx8IHQudywgYS5oZWlnaHQgfHwgdC5oLCB6YShhLmhvcml6b250YWwsIHQpKTtcbiAgICB2YXIgX0ZhID0gRmEodCwgZSwgYSwgcyksXG4gICAgICBkID0gX0ZhLnNhbWUsXG4gICAgICB1ID0gX0ZhLm90aGVyO1xuICAgIGMgfD0gZCAmJiBuLmxlbmd0aCwgaCA9IGggfHwgdSwgbC5mdWxsU2l6ZSB8fCBuLnB1c2goYSk7XG4gIH1cbiAgcmV0dXJuIGMgJiYgb2UobiwgdCwgZSwgcykgfHwgaDtcbn1cbmZ1bmN0aW9uIENlKGksIHQsIGUsIHMsIG4pIHtcbiAgaS50b3AgPSBlLCBpLmxlZnQgPSB0LCBpLnJpZ2h0ID0gdCArIHMsIGkuYm90dG9tID0gZSArIG4sIGkud2lkdGggPSBzLCBpLmhlaWdodCA9IG47XG59XG5mdW5jdGlvbiBPcyhpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gZS5wYWRkaW5nO1xuICB2YXIgbyA9IHQueCxcbiAgICByID0gdC55O1xuICB2YXIgX2l0ZXJhdG9yMTYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpKSxcbiAgICBfc3RlcDE2O1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMTYucygpOyAhKF9zdGVwMTYgPSBfaXRlcmF0b3IxNi5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgYSA9IF9zdGVwMTYudmFsdWU7XG4gICAgICB2YXIgbCA9IGEuYm94LFxuICAgICAgICBjID0gc1thLnN0YWNrXSB8fCB7XG4gICAgICAgICAgcGxhY2VkOiAwLFxuICAgICAgICAgIHdlaWdodDogMVxuICAgICAgICB9LFxuICAgICAgICBoID0gYS5zdGFja1dlaWdodCAvIGMud2VpZ2h0IHx8IDE7XG4gICAgICBpZiAoYS5ob3Jpem9udGFsKSB7XG4gICAgICAgIHZhciBkID0gdC53ICogaCxcbiAgICAgICAgICB1ID0gYy5zaXplIHx8IGwuaGVpZ2h0O1xuICAgICAgICBnZShjLnN0YXJ0KSAmJiAociA9IGMuc3RhcnQpLCBsLmZ1bGxTaXplID8gQ2UobCwgbi5sZWZ0LCByLCBlLm91dGVyV2lkdGggLSBuLnJpZ2h0IC0gbi5sZWZ0LCB1KSA6IENlKGwsIHQubGVmdCArIGMucGxhY2VkLCByLCBkLCB1KSwgYy5zdGFydCA9IHIsIGMucGxhY2VkICs9IGQsIHIgPSBsLmJvdHRvbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfZDIgPSB0LmggKiBoLFxuICAgICAgICAgIF91MiA9IGMuc2l6ZSB8fCBsLndpZHRoO1xuICAgICAgICBnZShjLnN0YXJ0KSAmJiAobyA9IGMuc3RhcnQpLCBsLmZ1bGxTaXplID8gQ2UobCwgbywgbi50b3AsIF91MiwgZS5vdXRlckhlaWdodCAtIG4uYm90dG9tIC0gbi50b3ApIDogQ2UobCwgbywgdC50b3AgKyBjLnBsYWNlZCwgX3UyLCBfZDIpLCBjLnN0YXJ0ID0gbywgYy5wbGFjZWQgKz0gX2QyLCBvID0gbC5yaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjE2LmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IxNi5mKCk7XG4gIH1cbiAgdC54ID0gbywgdC55ID0gcjtcbn1cbnZhciB0dCA9IHtcbiAgYWRkQm94OiBmdW5jdGlvbiBhZGRCb3goaSwgdCkge1xuICAgIGkuYm94ZXMgfHwgKGkuYm94ZXMgPSBbXSksIHQuZnVsbFNpemUgPSB0LmZ1bGxTaXplIHx8ICExLCB0LnBvc2l0aW9uID0gdC5wb3NpdGlvbiB8fCBcInRvcFwiLCB0LndlaWdodCA9IHQud2VpZ2h0IHx8IDAsIHQuX2xheWVycyA9IHQuX2xheWVycyB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogMCxcbiAgICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhlKSB7XG4gICAgICAgICAgdC5kcmF3KGUpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9LCBpLmJveGVzLnB1c2godCk7XG4gIH0sXG4gIHJlbW92ZUJveDogZnVuY3Rpb24gcmVtb3ZlQm94KGksIHQpIHtcbiAgICB2YXIgZSA9IGkuYm94ZXMgPyBpLmJveGVzLmluZGV4T2YodCkgOiAtMTtcbiAgICBlICE9PSAtMSAmJiBpLmJveGVzLnNwbGljZShlLCAxKTtcbiAgfSxcbiAgY29uZmlndXJlOiBmdW5jdGlvbiBjb25maWd1cmUoaSwgdCwgZSkge1xuICAgIHQuZnVsbFNpemUgPSBlLmZ1bGxTaXplLCB0LnBvc2l0aW9uID0gZS5wb3NpdGlvbiwgdC53ZWlnaHQgPSBlLndlaWdodDtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoaSwgdCwgZSwgcykge1xuICAgIGlmICghaSkgcmV0dXJuO1xuICAgIHZhciBuID0gZXQoaS5vcHRpb25zLmxheW91dC5wYWRkaW5nKSxcbiAgICAgIG8gPSBNYXRoLm1heCh0IC0gbi53aWR0aCwgMCksXG4gICAgICByID0gTWF0aC5tYXgoZSAtIG4uaGVpZ2h0LCAwKSxcbiAgICAgIGEgPSBFYShpLmJveGVzKSxcbiAgICAgIGwgPSBhLnZlcnRpY2FsLFxuICAgICAgYyA9IGEuaG9yaXpvbnRhbDtcbiAgICBMKGkuYm94ZXMsIGZ1bmN0aW9uIChnKSB7XG4gICAgICB0eXBlb2YgZy5iZWZvcmVMYXlvdXQgPT0gXCJmdW5jdGlvblwiICYmIGcuYmVmb3JlTGF5b3V0KCk7XG4gICAgfSk7XG4gICAgdmFyIGggPSBsLnJlZHVjZShmdW5jdGlvbiAoZywgbSkge1xuICAgICAgICByZXR1cm4gbS5ib3gub3B0aW9ucyAmJiBtLmJveC5vcHRpb25zLmRpc3BsYXkgPT09ICExID8gZyA6IGcgKyAxO1xuICAgICAgfSwgMCkgfHwgMSxcbiAgICAgIGQgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgb3V0ZXJXaWR0aDogdCxcbiAgICAgICAgb3V0ZXJIZWlnaHQ6IGUsXG4gICAgICAgIHBhZGRpbmc6IG4sXG4gICAgICAgIGF2YWlsYWJsZVdpZHRoOiBvLFxuICAgICAgICBhdmFpbGFibGVIZWlnaHQ6IHIsXG4gICAgICAgIHZCb3hNYXhXaWR0aDogbyAvIDIgLyBoLFxuICAgICAgICBoQm94TWF4SGVpZ2h0OiByIC8gMlxuICAgICAgfSksXG4gICAgICB1ID0gT2JqZWN0LmFzc2lnbih7fSwgbik7XG4gICAgWW4odSwgZXQocykpO1xuICAgIHZhciBmID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIG1heFBhZGRpbmc6IHUsXG4gICAgICAgIHc6IG8sXG4gICAgICAgIGg6IHIsXG4gICAgICAgIHg6IG4ubGVmdCxcbiAgICAgICAgeTogbi50b3BcbiAgICAgIH0sIG4pLFxuICAgICAgcCA9IExhKGwuY29uY2F0KGMpLCBkKTtcbiAgICBvZShhLmZ1bGxTaXplLCBmLCBkLCBwKSwgb2UobCwgZiwgZCwgcCksIG9lKGMsIGYsIGQsIHApICYmIG9lKGwsIGYsIGQsIHApLCBJYShmKSwgT3MoYS5sZWZ0QW5kVG9wLCBmLCBkLCBwKSwgZi54ICs9IGYudywgZi55ICs9IGYuaCwgT3MoYS5yaWdodEFuZEJvdHRvbSwgZiwgZCwgcCksIGkuY2hhcnRBcmVhID0ge1xuICAgICAgbGVmdDogZi5sZWZ0LFxuICAgICAgdG9wOiBmLnRvcCxcbiAgICAgIHJpZ2h0OiBmLmxlZnQgKyBmLncsXG4gICAgICBib3R0b206IGYudG9wICsgZi5oLFxuICAgICAgaGVpZ2h0OiBmLmgsXG4gICAgICB3aWR0aDogZi53XG4gICAgfSwgTChhLmNoYXJ0QXJlYSwgZnVuY3Rpb24gKGcpIHtcbiAgICAgIHZhciBtID0gZy5ib3g7XG4gICAgICBPYmplY3QuYXNzaWduKG0sIGkuY2hhcnRBcmVhKSwgbS51cGRhdGUoZi53LCBmLmgsIHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm90dG9tOiAwXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBVbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFVuKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVbik7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhVbiwgW3tcbiAgICBrZXk6IFwiYWNxdWlyZUNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNxdWlyZUNvbnRleHQodCwgZSkge31cbiAgfSwge1xuICAgIGtleTogXCJyZWxlYXNlQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWxlYXNlQ29udGV4dCh0KSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0LCBlLCBzKSB7fVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcih0LCBlLCBzKSB7fVxuICB9LCB7XG4gICAga2V5OiBcImdldERldmljZVBpeGVsUmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXhpbXVtU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhpbXVtU2l6ZSh0LCBlLCBzLCBuKSB7XG4gICAgICByZXR1cm4gZSA9IE1hdGgubWF4KDAsIGUgfHwgdC53aWR0aCksIHMgPSBzIHx8IHQuaGVpZ2h0LCB7XG4gICAgICAgIHdpZHRoOiBlLFxuICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIG4gPyBNYXRoLmZsb29yKGUgLyBuKSA6IHMpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0F0dGFjaGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQXR0YWNoZWQodCkge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVDb25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQ29uZmlnKHQpIHt9XG4gIH1dKTtcbn0oKTtcbnZhciBCYSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1VuKSB7XG4gIGZ1bmN0aW9uIEJhKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgQmEsIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2luaGVyaXRzKEJhLCBfVW4pO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEJhLCBbe1xuICAgIGtleTogXCJhY3F1aXJlQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY3F1aXJlQ29udGV4dCh0KSB7XG4gICAgICByZXR1cm4gdCAmJiB0LmdldENvbnRleHQgJiYgdC5nZXRDb250ZXh0KFwiMmRcIikgfHwgbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQ29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUNvbmZpZyh0KSB7XG4gICAgICB0Lm9wdGlvbnMuYW5pbWF0aW9uID0gITE7XG4gICAgfVxuICB9XSk7XG59KFVuKTtcbnZhciB6ZSA9IFwiJGNoYXJ0anNcIixcbiAgSGEgPSB7XG4gICAgdG91Y2hzdGFydDogXCJtb3VzZWRvd25cIixcbiAgICB0b3VjaG1vdmU6IFwibW91c2Vtb3ZlXCIsXG4gICAgdG91Y2hlbmQ6IFwibW91c2V1cFwiLFxuICAgIHBvaW50ZXJlbnRlcjogXCJtb3VzZWVudGVyXCIsXG4gICAgcG9pbnRlcmRvd246IFwibW91c2Vkb3duXCIsXG4gICAgcG9pbnRlcm1vdmU6IFwibW91c2Vtb3ZlXCIsXG4gICAgcG9pbnRlcnVwOiBcIm1vdXNldXBcIixcbiAgICBwb2ludGVybGVhdmU6IFwibW91c2VvdXRcIixcbiAgICBwb2ludGVyb3V0OiBcIm1vdXNlb3V0XCJcbiAgfSxcbiAgVHMgPSBmdW5jdGlvbiBUcyhpKSB7XG4gICAgcmV0dXJuIGkgPT09IG51bGwgfHwgaSA9PT0gXCJcIjtcbiAgfTtcbmZ1bmN0aW9uIFdhKGksIHQpIHtcbiAgdmFyIGUgPSBpLnN0eWxlLFxuICAgIHMgPSBpLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKSxcbiAgICBuID0gaS5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKTtcbiAgaWYgKGlbemVdID0ge1xuICAgIGluaXRpYWw6IHtcbiAgICAgIGhlaWdodDogcyxcbiAgICAgIHdpZHRoOiBuLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogZS5kaXNwbGF5LFxuICAgICAgICBoZWlnaHQ6IGUuaGVpZ2h0LFxuICAgICAgICB3aWR0aDogZS53aWR0aFxuICAgICAgfVxuICAgIH1cbiAgfSwgZS5kaXNwbGF5ID0gZS5kaXNwbGF5IHx8IFwiYmxvY2tcIiwgZS5ib3hTaXppbmcgPSBlLmJveFNpemluZyB8fCBcImJvcmRlci1ib3hcIiwgVHMobikpIHtcbiAgICB2YXIgbyA9IGZzKGksIFwid2lkdGhcIik7XG4gICAgbyAhPT0gdm9pZCAwICYmIChpLndpZHRoID0gbyk7XG4gIH1cbiAgaWYgKFRzKHMpKSBpZiAoaS5zdHlsZS5oZWlnaHQgPT09IFwiXCIpIGkuaGVpZ2h0ID0gaS53aWR0aCAvICh0IHx8IDIpO2Vsc2Uge1xuICAgIHZhciBfbzIgPSBmcyhpLCBcImhlaWdodFwiKTtcbiAgICBfbzIgIT09IHZvaWQgMCAmJiAoaS5oZWlnaHQgPSBfbzIpO1xuICB9XG4gIHJldHVybiBpO1xufVxudmFyIFhuID0gVnIgPyB7XG4gIHBhc3NpdmU6ICEwXG59IDogITE7XG5mdW5jdGlvbiBOYShpLCB0LCBlKSB7XG4gIGkgJiYgaS5hZGRFdmVudExpc3RlbmVyKHQsIGUsIFhuKTtcbn1cbmZ1bmN0aW9uIFZhKGksIHQsIGUpIHtcbiAgaSAmJiBpLmNhbnZhcyAmJiBpLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKHQsIGUsIFhuKTtcbn1cbmZ1bmN0aW9uIGphKGksIHQpIHtcbiAgdmFyIGUgPSBIYVtpLnR5cGVdIHx8IGkudHlwZSxcbiAgICBfQXQgPSBBdChpLCB0KSxcbiAgICBzID0gX0F0LngsXG4gICAgbiA9IF9BdC55O1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGUsXG4gICAgY2hhcnQ6IHQsXG4gICAgXCJuYXRpdmVcIjogaSxcbiAgICB4OiBzICE9PSB2b2lkIDAgPyBzIDogbnVsbCxcbiAgICB5OiBuICE9PSB2b2lkIDAgPyBuIDogbnVsbFxuICB9O1xufVxuZnVuY3Rpb24gcWUoaSwgdCkge1xuICB2YXIgX2l0ZXJhdG9yMTcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpKSxcbiAgICBfc3RlcDE3O1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMTcucygpOyAhKF9zdGVwMTcgPSBfaXRlcmF0b3IxNy5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgZSA9IF9zdGVwMTcudmFsdWU7XG4gICAgICBpZiAoZSA9PT0gdCB8fCBlLmNvbnRhaW5zKHQpKSByZXR1cm4gITA7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IxNy5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMTcuZigpO1xuICB9XG59XG5mdW5jdGlvbiAkYShpLCB0LCBlKSB7XG4gIHZhciBzID0gaS5jYW52YXMsXG4gICAgbiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgciA9ICExO1xuICAgICAgdmFyIF9pdGVyYXRvcjE4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobyksXG4gICAgICAgIF9zdGVwMTg7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjE4LnMoKTsgIShfc3RlcDE4ID0gX2l0ZXJhdG9yMTgubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBhID0gX3N0ZXAxOC52YWx1ZTtcbiAgICAgICAgICByID0gciB8fCBxZShhLmFkZGVkTm9kZXMsIHMpLCByID0gciAmJiAhcWUoYS5yZW1vdmVkTm9kZXMsIHMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMTguZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMTguZigpO1xuICAgICAgfVxuICAgICAgciAmJiBlKCk7XG4gICAgfSk7XG4gIHJldHVybiBuLm9ic2VydmUoZG9jdW1lbnQsIHtcbiAgICBjaGlsZExpc3Q6ICEwLFxuICAgIHN1YnRyZWU6ICEwXG4gIH0pLCBuO1xufVxuZnVuY3Rpb24gWWEoaSwgdCwgZSkge1xuICB2YXIgcyA9IGkuY2FudmFzLFxuICAgIG4gPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHIgPSAhMTtcbiAgICAgIHZhciBfaXRlcmF0b3IxOSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8pLFxuICAgICAgICBfc3RlcDE5O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IxOS5zKCk7ICEoX3N0ZXAxOSA9IF9pdGVyYXRvcjE5Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgYSA9IF9zdGVwMTkudmFsdWU7XG4gICAgICAgICAgciA9IHIgfHwgcWUoYS5yZW1vdmVkTm9kZXMsIHMpLCByID0gciAmJiAhcWUoYS5hZGRlZE5vZGVzLCBzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjE5LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjE5LmYoKTtcbiAgICAgIH1cbiAgICAgIHIgJiYgZSgpO1xuICAgIH0pO1xuICByZXR1cm4gbi5vYnNlcnZlKGRvY3VtZW50LCB7XG4gICAgY2hpbGRMaXN0OiAhMCxcbiAgICBzdWJ0cmVlOiAhMFxuICB9KSwgbjtcbn1cbnZhciBfZSA9IC8qIEBfX1BVUkVfXyAqL25ldyBNYXAoKTtcbnZhciBBcyA9IDA7XG5mdW5jdGlvbiBxbigpIHtcbiAgdmFyIGkgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgaSAhPT0gQXMgJiYgKEFzID0gaSwgX2UuZm9yRWFjaChmdW5jdGlvbiAodCwgZSkge1xuICAgIGUuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IGkgJiYgdCgpO1xuICB9KSk7XG59XG5mdW5jdGlvbiBVYShpLCB0KSB7XG4gIF9lLnNpemUgfHwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcW4pLCBfZS5zZXQoaSwgdCk7XG59XG5mdW5jdGlvbiBYYShpKSB7XG4gIF9lW1wiZGVsZXRlXCJdKGkpLCBfZS5zaXplIHx8IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHFuKTtcbn1cbmZ1bmN0aW9uIHFhKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBpLmNhbnZhcyxcbiAgICBuID0gcyAmJiBZaShzKTtcbiAgaWYgKCFuKSByZXR1cm47XG4gIHZhciBvID0ga24oZnVuY3Rpb24gKGEsIGwpIHtcbiAgICAgIHZhciBjID0gbi5jbGllbnRXaWR0aDtcbiAgICAgIGUoYSwgbCksIGMgPCBuLmNsaWVudFdpZHRoICYmIGUoKTtcbiAgICB9LCB3aW5kb3cpLFxuICAgIHIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgIHZhciBsID0gYVswXSxcbiAgICAgICAgYyA9IGwuY29udGVudFJlY3Qud2lkdGgsXG4gICAgICAgIGggPSBsLmNvbnRlbnRSZWN0LmhlaWdodDtcbiAgICAgIGMgPT09IDAgJiYgaCA9PT0gMCB8fCBvKGMsIGgpO1xuICAgIH0pO1xuICByZXR1cm4gci5vYnNlcnZlKG4pLCBVYShpLCBvKSwgcjtcbn1cbmZ1bmN0aW9uIHVpKGksIHQsIGUpIHtcbiAgZSAmJiBlLmRpc2Nvbm5lY3QoKSwgdCA9PT0gXCJyZXNpemVcIiAmJiBYYShpKTtcbn1cbmZ1bmN0aW9uIEthKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBpLmNhbnZhcyxcbiAgICBuID0ga24oZnVuY3Rpb24gKG8pIHtcbiAgICAgIGkuY3R4ICE9PSBudWxsICYmIGUoamEobywgaSkpO1xuICAgIH0sIGkpO1xuICByZXR1cm4gTmEocywgdCwgbiksIG47XG59XG52YXIgR2EgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9VbjIpIHtcbiAgZnVuY3Rpb24gR2EoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdhKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBHYSwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoR2EsIF9VbjIpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEdhLCBbe1xuICAgIGtleTogXCJhY3F1aXJlQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY3F1aXJlQ29udGV4dCh0LCBlKSB7XG4gICAgICB2YXIgcyA9IHQgJiYgdC5nZXRDb250ZXh0ICYmIHQuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgcmV0dXJuIHMgJiYgcy5jYW52YXMgPT09IHQgPyAoV2EodCwgZSksIHMpIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVsZWFzZUNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVsZWFzZUNvbnRleHQodCkge1xuICAgICAgdmFyIGUgPSB0LmNhbnZhcztcbiAgICAgIGlmICghZVt6ZV0pIHJldHVybiAhMTtcbiAgICAgIHZhciBzID0gZVt6ZV0uaW5pdGlhbDtcbiAgICAgIFtcImhlaWdodFwiLCBcIndpZHRoXCJdLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHIgPSBzW29dO1xuICAgICAgICBSKHIpID8gZS5yZW1vdmVBdHRyaWJ1dGUobykgOiBlLnNldEF0dHJpYnV0ZShvLCByKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG4gPSBzLnN0eWxlIHx8IHt9O1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgZS5zdHlsZVtvXSA9IG5bb107XG4gICAgICB9KSwgZS53aWR0aCA9IGUud2lkdGgsIGRlbGV0ZSBlW3plXSwgITA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0LCBlLCBzKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgZSk7XG4gICAgICB2YXIgbiA9IHQuJHByb3hpZXMgfHwgKHQuJHByb3hpZXMgPSB7fSksXG4gICAgICAgIHIgPSB7XG4gICAgICAgICAgYXR0YWNoOiAkYSxcbiAgICAgICAgICBkZXRhY2g6IFlhLFxuICAgICAgICAgIHJlc2l6ZTogcWFcbiAgICAgICAgfVtlXSB8fCBLYTtcbiAgICAgIG5bZV0gPSByKHQsIGUsIHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVFdmVudExpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodCwgZSkge1xuICAgICAgdmFyIHMgPSB0LiRwcm94aWVzIHx8ICh0LiRwcm94aWVzID0ge30pLFxuICAgICAgICBuID0gc1tlXTtcbiAgICAgIGlmICghbikgcmV0dXJuO1xuICAgICAgKHtcbiAgICAgICAgYXR0YWNoOiB1aSxcbiAgICAgICAgZGV0YWNoOiB1aSxcbiAgICAgICAgcmVzaXplOiB1aVxuICAgICAgfVtlXSB8fCBWYSkodCwgZSwgbiksIHNbZV0gPSB2b2lkIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERldmljZVBpeGVsUmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWF4aW11bVNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWF4aW11bVNpemUodCwgZSwgcywgbikge1xuICAgICAgcmV0dXJuIE5yKHQsIGUsIHMsIG4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0F0dGFjaGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQXR0YWNoZWQodCkge1xuICAgICAgdmFyIGUgPSB0ICYmIFlpKHQpO1xuICAgICAgcmV0dXJuICEhKGUgJiYgZS5pc0Nvbm5lY3RlZCk7XG4gICAgfVxuICB9XSk7XG59KFVuKTtcbmZ1bmN0aW9uIEphKGkpIHtcbiAgcmV0dXJuICEkaSgpIHx8ICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoT2Zmc2NyZWVuQ2FudmFzKSkgPCBcInVcIiAmJiBpIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzID8gQmEgOiBHYTtcbn1cbnZhciBzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBzdCk7XG4gICAgdyh0aGlzLCBcInhcIik7XG4gICAgdyh0aGlzLCBcInlcIik7XG4gICAgdyh0aGlzLCBcImFjdGl2ZVwiLCAhMSk7XG4gICAgdyh0aGlzLCBcIm9wdGlvbnNcIik7XG4gICAgdyh0aGlzLCBcIiRhbmltYXRpb25zXCIpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3Moc3QsIFt7XG4gICAga2V5OiBcInRvb2x0aXBQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b29sdGlwUG9zaXRpb24odCkge1xuICAgICAgdmFyIF90aGlzJGdldFByb3BzID0gdGhpcy5nZXRQcm9wcyhbXCJ4XCIsIFwieVwiXSwgdCksXG4gICAgICAgIGUgPSBfdGhpcyRnZXRQcm9wcy54LFxuICAgICAgICBzID0gX3RoaXMkZ2V0UHJvcHMueTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGUsXG4gICAgICAgIHk6IHNcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1ZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc1ZhbHVlKCkge1xuICAgICAgcmV0dXJuIFh0KHRoaXMueCkgJiYgWHQodGhpcy55KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJvcHModCwgZSkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG4gICAgICB2YXIgcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgICBpZiAoIWUgfHwgIXMpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIG4gPSB7fTtcbiAgICAgIHJldHVybiB0LmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgbltvXSA9IHNbb10gJiYgc1tvXS5hY3RpdmUoKSA/IHNbb10uX3RvIDogX3RoaXM3W29dO1xuICAgICAgfSksIG47XG4gICAgfVxuICB9XSk7XG59KCk7XG53KHN0LCBcImRlZmF1bHRzXCIsIHt9KSwgdyhzdCwgXCJkZWZhdWx0Um91dGVzXCIpO1xuZnVuY3Rpb24gWmEoaSwgdCkge1xuICB2YXIgZSA9IGkub3B0aW9ucy50aWNrcyxcbiAgICBzID0gUWEoaSksXG4gICAgbiA9IE1hdGgubWluKGUubWF4VGlja3NMaW1pdCB8fCBzLCBzKSxcbiAgICBvID0gZS5tYWpvci5lbmFibGVkID8gZWwodCkgOiBbXSxcbiAgICByID0gby5sZW5ndGgsXG4gICAgYSA9IG9bMF0sXG4gICAgbCA9IG9bciAtIDFdLFxuICAgIGMgPSBbXTtcbiAgaWYgKHIgPiBuKSByZXR1cm4gaWwodCwgYywgbywgciAvIG4pLCBjO1xuICB2YXIgaCA9IHRsKG8sIHQsIG4pO1xuICBpZiAociA+IDApIHtcbiAgICB2YXIgZCwgdTtcbiAgICB2YXIgZiA9IHIgPiAxID8gTWF0aC5yb3VuZCgobCAtIGEpIC8gKHIgLSAxKSkgOiBudWxsO1xuICAgIGZvciAoT2UodCwgYywgaCwgUihmKSA/IDAgOiBhIC0gZiwgYSksIGQgPSAwLCB1ID0gciAtIDE7IGQgPCB1OyBkKyspIE9lKHQsIGMsIGgsIG9bZF0sIG9bZCArIDFdKTtcbiAgICByZXR1cm4gT2UodCwgYywgaCwgbCwgUihmKSA/IHQubGVuZ3RoIDogbCArIGYpLCBjO1xuICB9XG4gIHJldHVybiBPZSh0LCBjLCBoKSwgYztcbn1cbmZ1bmN0aW9uIFFhKGkpIHtcbiAgdmFyIHQgPSBpLm9wdGlvbnMub2Zmc2V0LFxuICAgIGUgPSBpLl90aWNrU2l6ZSgpLFxuICAgIHMgPSBpLl9sZW5ndGggLyBlICsgKHQgPyAwIDogMSksXG4gICAgbiA9IGkuX21heExlbmd0aCAvIGU7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWluKHMsIG4pKTtcbn1cbmZ1bmN0aW9uIHRsKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBzbChpKSxcbiAgICBuID0gdC5sZW5ndGggLyBlO1xuICBpZiAoIXMpIHJldHVybiBNYXRoLm1heChuLCAxKTtcbiAgdmFyIG8gPSBWbyhzKTtcbiAgZm9yICh2YXIgciA9IDAsIGEgPSBvLmxlbmd0aCAtIDE7IHIgPCBhOyByKyspIHtcbiAgICB2YXIgbCA9IG9bcl07XG4gICAgaWYgKGwgPiBuKSByZXR1cm4gbDtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgobiwgMSk7XG59XG5mdW5jdGlvbiBlbChpKSB7XG4gIHZhciB0ID0gW107XG4gIHZhciBlLCBzO1xuICBmb3IgKGUgPSAwLCBzID0gaS5sZW5ndGg7IGUgPCBzOyBlKyspIGlbZV0ubWFqb3IgJiYgdC5wdXNoKGUpO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIGlsKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSAwLFxuICAgIG8gPSBlWzBdLFxuICAgIHI7XG4gIGZvciAocyA9IE1hdGguY2VpbChzKSwgciA9IDA7IHIgPCBpLmxlbmd0aDsgcisrKSByID09PSBvICYmICh0LnB1c2goaVtyXSksIG4rKywgbyA9IGVbbiAqIHNdKTtcbn1cbmZ1bmN0aW9uIE9lKGksIHQsIGUsIHMsIG4pIHtcbiAgdmFyIG8gPSBEKHMsIDApLFxuICAgIHIgPSBNYXRoLm1pbihEKG4sIGkubGVuZ3RoKSwgaS5sZW5ndGgpO1xuICB2YXIgYSA9IDAsXG4gICAgbCxcbiAgICBjLFxuICAgIGg7XG4gIGZvciAoZSA9IE1hdGguY2VpbChlKSwgbiAmJiAobCA9IG4gLSBzLCBlID0gbCAvIE1hdGguZmxvb3IobCAvIGUpKSwgaCA9IG87IGggPCAwOykgYSsrLCBoID0gTWF0aC5yb3VuZChvICsgYSAqIGUpO1xuICBmb3IgKGMgPSBNYXRoLm1heChvLCAwKTsgYyA8IHI7IGMrKykgYyA9PT0gaCAmJiAodC5wdXNoKGlbY10pLCBhKyssIGggPSBNYXRoLnJvdW5kKG8gKyBhICogZSkpO1xufVxuZnVuY3Rpb24gc2woaSkge1xuICB2YXIgdCA9IGkubGVuZ3RoO1xuICB2YXIgZSwgcztcbiAgaWYgKHQgPCAyKSByZXR1cm4gITE7XG4gIGZvciAocyA9IGlbMF0sIGUgPSAxOyBlIDwgdDsgKytlKSBpZiAoaVtlXSAtIGlbZSAtIDFdICE9PSBzKSByZXR1cm4gITE7XG4gIHJldHVybiBzO1xufVxudmFyIG5sID0gZnVuY3Rpb24gbmwoaSkge1xuICAgIHJldHVybiBpID09PSBcImxlZnRcIiA/IFwicmlnaHRcIiA6IGkgPT09IFwicmlnaHRcIiA/IFwibGVmdFwiIDogaTtcbiAgfSxcbiAgUnMgPSBmdW5jdGlvbiBScyhpLCB0LCBlKSB7XG4gICAgcmV0dXJuIHQgPT09IFwidG9wXCIgfHwgdCA9PT0gXCJsZWZ0XCIgPyBpW3RdICsgZSA6IGlbdF0gLSBlO1xuICB9LFxuICBMcyA9IGZ1bmN0aW9uIExzKGksIHQpIHtcbiAgICByZXR1cm4gTWF0aC5taW4odCB8fCBpLCBpKTtcbiAgfTtcbmZ1bmN0aW9uIEVzKGksIHQpIHtcbiAgdmFyIGUgPSBbXSxcbiAgICBzID0gaS5sZW5ndGggLyB0LFxuICAgIG4gPSBpLmxlbmd0aDtcbiAgdmFyIG8gPSAwO1xuICBmb3IgKDsgbyA8IG47IG8gKz0gcykgZS5wdXNoKGlbTWF0aC5mbG9vcihvKV0pO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIG9sKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBpLnRpY2tzLmxlbmd0aCxcbiAgICBuID0gTWF0aC5taW4odCwgcyAtIDEpLFxuICAgIG8gPSBpLl9zdGFydFBpeGVsLFxuICAgIHIgPSBpLl9lbmRQaXhlbCxcbiAgICBhID0gMWUtNjtcbiAgdmFyIGwgPSBpLmdldFBpeGVsRm9yVGljayhuKSxcbiAgICBjO1xuICBpZiAoIShlICYmIChzID09PSAxID8gYyA9IE1hdGgubWF4KGwgLSBvLCByIC0gbCkgOiB0ID09PSAwID8gYyA9IChpLmdldFBpeGVsRm9yVGljaygxKSAtIGwpIC8gMiA6IGMgPSAobCAtIGkuZ2V0UGl4ZWxGb3JUaWNrKG4gLSAxKSkgLyAyLCBsICs9IG4gPCB0ID8gYyA6IC1jLCBsIDwgbyAtIGEgfHwgbCA+IHIgKyBhKSkpIHJldHVybiBsO1xufVxuZnVuY3Rpb24gcmwoaSwgdCkge1xuICBMKGksIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHMgPSBlLmdjLFxuICAgICAgbiA9IHMubGVuZ3RoIC8gMjtcbiAgICB2YXIgbztcbiAgICBpZiAobiA+IHQpIHtcbiAgICAgIGZvciAobyA9IDA7IG8gPCBuOyArK28pIGRlbGV0ZSBlLmRhdGFbc1tvXV07XG4gICAgICBzLnNwbGljZSgwLCBuKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaWUoaSkge1xuICByZXR1cm4gaS5kcmF3VGlja3MgPyBpLnRpY2tMZW5ndGggOiAwO1xufVxuZnVuY3Rpb24gRnMoaSwgdCkge1xuICBpZiAoIWkuZGlzcGxheSkgcmV0dXJuIDA7XG4gIHZhciBlID0gWChpLmZvbnQsIHQpLFxuICAgIHMgPSBldChpLnBhZGRpbmcpO1xuICByZXR1cm4gKE4oaS50ZXh0KSA/IGkudGV4dC5sZW5ndGggOiAxKSAqIGUubGluZUhlaWdodCArIHMuaGVpZ2h0O1xufVxuZnVuY3Rpb24gYWwoaSwgdCkge1xuICByZXR1cm4gQnQoaSwge1xuICAgIHNjYWxlOiB0LFxuICAgIHR5cGU6IFwic2NhbGVcIlxuICB9KTtcbn1cbmZ1bmN0aW9uIGxsKGksIHQsIGUpIHtcbiAgcmV0dXJuIEJ0KGksIHtcbiAgICB0aWNrOiBlLFxuICAgIGluZGV4OiB0LFxuICAgIHR5cGU6IFwidGlja1wiXG4gIH0pO1xufVxuZnVuY3Rpb24gY2woaSwgdCwgZSkge1xuICB2YXIgcyA9IHppKGkpO1xuICByZXR1cm4gKGUgJiYgdCAhPT0gXCJyaWdodFwiIHx8ICFlICYmIHQgPT09IFwicmlnaHRcIikgJiYgKHMgPSBubChzKSksIHM7XG59XG5mdW5jdGlvbiBobChpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gaS50b3AsXG4gICAgbyA9IGkubGVmdCxcbiAgICByID0gaS5ib3R0b20sXG4gICAgYSA9IGkucmlnaHQsXG4gICAgbCA9IGkuY2hhcnQsXG4gICAgYyA9IGwuY2hhcnRBcmVhLFxuICAgIGggPSBsLnNjYWxlcztcbiAgdmFyIGQgPSAwLFxuICAgIHUsXG4gICAgZixcbiAgICBwO1xuICB2YXIgZyA9IHIgLSBuLFxuICAgIG0gPSBhIC0gbztcbiAgaWYgKGkuaXNIb3Jpem9udGFsKCkpIHtcbiAgICBpZiAoZiA9IFkocywgbywgYSksIFQoZSkpIHtcbiAgICAgIHZhciBiID0gT2JqZWN0LmtleXMoZSlbMF0sXG4gICAgICAgIF8gPSBlW2JdO1xuICAgICAgcCA9IGhbYl0uZ2V0UGl4ZWxGb3JWYWx1ZShfKSArIGcgLSB0O1xuICAgIH0gZWxzZSBlID09PSBcImNlbnRlclwiID8gcCA9IChjLmJvdHRvbSArIGMudG9wKSAvIDIgKyBnIC0gdCA6IHAgPSBScyhpLCBlLCB0KTtcbiAgICB1ID0gYSAtIG87XG4gIH0gZWxzZSB7XG4gICAgaWYgKFQoZSkpIHtcbiAgICAgIHZhciBfYiA9IE9iamVjdC5rZXlzKGUpWzBdLFxuICAgICAgICBfMyA9IGVbX2JdO1xuICAgICAgZiA9IGhbX2JdLmdldFBpeGVsRm9yVmFsdWUoXzMpIC0gbSArIHQ7XG4gICAgfSBlbHNlIGUgPT09IFwiY2VudGVyXCIgPyBmID0gKGMubGVmdCArIGMucmlnaHQpIC8gMiAtIG0gKyB0IDogZiA9IFJzKGksIGUsIHQpO1xuICAgIHAgPSBZKHMsIHIsIG4pLCBkID0gZSA9PT0gXCJsZWZ0XCIgPyAtViA6IFY7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0aXRsZVg6IGYsXG4gICAgdGl0bGVZOiBwLFxuICAgIG1heFdpZHRoOiB1LFxuICAgIHJvdGF0aW9uOiBkXG4gIH07XG59XG52YXIgR3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdCkge1xuICBmdW5jdGlvbiBHdCh0KSB7XG4gICAgdmFyIF90aGlzODtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3QpO1xuICAgIF90aGlzOCA9IF9jYWxsU3VwZXIodGhpcywgR3QpLCBfdGhpczguaWQgPSB0LmlkLCBfdGhpczgudHlwZSA9IHQudHlwZSwgX3RoaXM4Lm9wdGlvbnMgPSB2b2lkIDAsIF90aGlzOC5jdHggPSB0LmN0eCwgX3RoaXM4LmNoYXJ0ID0gdC5jaGFydCwgX3RoaXM4LnRvcCA9IHZvaWQgMCwgX3RoaXM4LmJvdHRvbSA9IHZvaWQgMCwgX3RoaXM4LmxlZnQgPSB2b2lkIDAsIF90aGlzOC5yaWdodCA9IHZvaWQgMCwgX3RoaXM4LndpZHRoID0gdm9pZCAwLCBfdGhpczguaGVpZ2h0ID0gdm9pZCAwLCBfdGhpczguX21hcmdpbnMgPSB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9LCBfdGhpczgubWF4V2lkdGggPSB2b2lkIDAsIF90aGlzOC5tYXhIZWlnaHQgPSB2b2lkIDAsIF90aGlzOC5wYWRkaW5nVG9wID0gdm9pZCAwLCBfdGhpczgucGFkZGluZ0JvdHRvbSA9IHZvaWQgMCwgX3RoaXM4LnBhZGRpbmdMZWZ0ID0gdm9pZCAwLCBfdGhpczgucGFkZGluZ1JpZ2h0ID0gdm9pZCAwLCBfdGhpczguYXhpcyA9IHZvaWQgMCwgX3RoaXM4LmxhYmVsUm90YXRpb24gPSB2b2lkIDAsIF90aGlzOC5taW4gPSB2b2lkIDAsIF90aGlzOC5tYXggPSB2b2lkIDAsIF90aGlzOC5fcmFuZ2UgPSB2b2lkIDAsIF90aGlzOC50aWNrcyA9IFtdLCBfdGhpczguX2dyaWRMaW5lSXRlbXMgPSBudWxsLCBfdGhpczguX2xhYmVsSXRlbXMgPSBudWxsLCBfdGhpczguX2xhYmVsU2l6ZXMgPSBudWxsLCBfdGhpczguX2xlbmd0aCA9IDAsIF90aGlzOC5fbWF4TGVuZ3RoID0gMCwgX3RoaXM4Ll9sb25nZXN0VGV4dENhY2hlID0ge30sIF90aGlzOC5fc3RhcnRQaXhlbCA9IHZvaWQgMCwgX3RoaXM4Ll9lbmRQaXhlbCA9IHZvaWQgMCwgX3RoaXM4Ll9yZXZlcnNlUGl4ZWxzID0gITEsIF90aGlzOC5fdXNlck1heCA9IHZvaWQgMCwgX3RoaXM4Ll91c2VyTWluID0gdm9pZCAwLCBfdGhpczguX3N1Z2dlc3RlZE1heCA9IHZvaWQgMCwgX3RoaXM4Ll9zdWdnZXN0ZWRNaW4gPSB2b2lkIDAsIF90aGlzOC5fdGlja3NMZW5ndGggPSAwLCBfdGhpczguX2JvcmRlclZhbHVlID0gMCwgX3RoaXM4Ll9jYWNoZSA9IHt9LCBfdGhpczguX2RhdGFMaW1pdHNDYWNoZWQgPSAhMSwgX3RoaXM4LiRjb250ZXh0ID0gdm9pZCAwO1xuICAgIHJldHVybiBfdGhpczg7XG4gIH1cbiAgX2luaGVyaXRzKEd0LCBfc3QpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEd0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQodCkge1xuICAgICAgdGhpcy5vcHRpb25zID0gdC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKSwgdGhpcy5heGlzID0gdC5heGlzLCB0aGlzLl91c2VyTWluID0gdGhpcy5wYXJzZSh0Lm1pbiksIHRoaXMuX3VzZXJNYXggPSB0aGlzLnBhcnNlKHQubWF4KSwgdGhpcy5fc3VnZ2VzdGVkTWluID0gdGhpcy5wYXJzZSh0LnN1Z2dlc3RlZE1pbiksIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHRoaXMucGFyc2UodC5zdWdnZXN0ZWRNYXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZSh0LCBlKSB7XG4gICAgICByZXR1cm4gdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VXNlckJvdW5kc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVc2VyQm91bmRzKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl91c2VyTWluLFxuICAgICAgICBlID0gdGhpcy5fdXNlck1heCxcbiAgICAgICAgcyA9IHRoaXMuX3N1Z2dlc3RlZE1pbixcbiAgICAgICAgbiA9IHRoaXMuX3N1Z2dlc3RlZE1heDtcbiAgICAgIHJldHVybiB0ID0gb3QodCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSwgZSA9IG90KGUsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSksIHMgPSBvdChzLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpLCBuID0gb3QobiwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSwge1xuICAgICAgICBtaW46IG90KHQsIHMpLFxuICAgICAgICBtYXg6IG90KGUsIG4pLFxuICAgICAgICBtaW5EZWZpbmVkOiBxKHQpLFxuICAgICAgICBtYXhEZWZpbmVkOiBxKGUpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNaW5NYXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWluTWF4KHQpIHtcbiAgICAgIHZhciBfdGhpcyRnZXRVc2VyQm91bmRzID0gdGhpcy5nZXRVc2VyQm91bmRzKCksXG4gICAgICAgIGUgPSBfdGhpcyRnZXRVc2VyQm91bmRzLm1pbixcbiAgICAgICAgcyA9IF90aGlzJGdldFVzZXJCb3VuZHMubWF4LFxuICAgICAgICBuID0gX3RoaXMkZ2V0VXNlckJvdW5kcy5taW5EZWZpbmVkLFxuICAgICAgICBvID0gX3RoaXMkZ2V0VXNlckJvdW5kcy5tYXhEZWZpbmVkLFxuICAgICAgICByO1xuICAgICAgaWYgKG4gJiYgbykgcmV0dXJuIHtcbiAgICAgICAgbWluOiBlLFxuICAgICAgICBtYXg6IHNcbiAgICAgIH07XG4gICAgICB2YXIgYSA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICAgIGZvciAodmFyIGwgPSAwLCBjID0gYS5sZW5ndGg7IGwgPCBjOyArK2wpIHIgPSBhW2xdLmNvbnRyb2xsZXIuZ2V0TWluTWF4KHRoaXMsIHQpLCBuIHx8IChlID0gTWF0aC5taW4oZSwgci5taW4pKSwgbyB8fCAocyA9IE1hdGgubWF4KHMsIHIubWF4KSk7XG4gICAgICByZXR1cm4gZSA9IG8gJiYgZSA+IHMgPyBzIDogZSwgcyA9IG4gJiYgZSA+IHMgPyBlIDogcywge1xuICAgICAgICBtaW46IG90KGUsIG90KHMsIGUpKSxcbiAgICAgICAgbWF4OiBvdChzLCBvdChlLCBzKSlcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBhZGRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFkZGluZygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHRoaXMucGFkZGluZ0xlZnQgfHwgMCxcbiAgICAgICAgdG9wOiB0aGlzLnBhZGRpbmdUb3AgfHwgMCxcbiAgICAgICAgcmlnaHQ6IHRoaXMucGFkZGluZ1JpZ2h0IHx8IDAsXG4gICAgICAgIGJvdHRvbTogdGhpcy5wYWRkaW5nQm90dG9tIHx8IDBcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRpY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRpY2tzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGlja3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbHMoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGFiZWxzIHx8ICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdC54TGFiZWxzIDogdC55TGFiZWxzKSB8fCB0LmxhYmVscyB8fCBbXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGFiZWxJdGVtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbEl0ZW1zKCkge1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuY2hhcnQuY2hhcnRBcmVhO1xuICAgICAgcmV0dXJuIHRoaXMuX2xhYmVsSXRlbXMgfHwgKHRoaXMuX2xhYmVsSXRlbXMgPSB0aGlzLl9jb21wdXRlTGFiZWxJdGVtcyh0KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJlZm9yZUxheW91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmVMYXlvdXQoKSB7XG4gICAgICB0aGlzLl9jYWNoZSA9IHt9LCB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gITE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJlZm9yZVVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUoKSB7XG4gICAgICBJKHRoaXMub3B0aW9ucy5iZWZvcmVVcGRhdGUsIFt0aGlzXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUodCwgZSwgcykge1xuICAgICAgdmFyIF90aGlzJG9wdGlvbnM0ID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBuID0gX3RoaXMkb3B0aW9uczQuYmVnaW5BdFplcm8sXG4gICAgICAgIG8gPSBfdGhpcyRvcHRpb25zNC5ncmFjZSxcbiAgICAgICAgciA9IF90aGlzJG9wdGlvbnM0LnRpY2tzLFxuICAgICAgICBhID0gci5zYW1wbGVTaXplO1xuICAgICAgdGhpcy5iZWZvcmVVcGRhdGUoKSwgdGhpcy5tYXhXaWR0aCA9IHQsIHRoaXMubWF4SGVpZ2h0ID0gZSwgdGhpcy5fbWFyZ2lucyA9IHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgYm90dG9tOiAwXG4gICAgICB9LCBzKSwgdGhpcy50aWNrcyA9IG51bGwsIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsLCB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbCwgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGwsIHRoaXMuYmVmb3JlU2V0RGltZW5zaW9ucygpLCB0aGlzLnNldERpbWVuc2lvbnMoKSwgdGhpcy5hZnRlclNldERpbWVuc2lvbnMoKSwgdGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggKyBzLmxlZnQgKyBzLnJpZ2h0IDogdGhpcy5oZWlnaHQgKyBzLnRvcCArIHMuYm90dG9tLCB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkIHx8ICh0aGlzLmJlZm9yZURhdGFMaW1pdHMoKSwgdGhpcy5kZXRlcm1pbmVEYXRhTGltaXRzKCksIHRoaXMuYWZ0ZXJEYXRhTGltaXRzKCksIHRoaXMuX3JhbmdlID0geHIodGhpcywgbywgbiksIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSAhMCksIHRoaXMuYmVmb3JlQnVpbGRUaWNrcygpLCB0aGlzLnRpY2tzID0gdGhpcy5idWlsZFRpY2tzKCkgfHwgW10sIHRoaXMuYWZ0ZXJCdWlsZFRpY2tzKCk7XG4gICAgICB2YXIgbCA9IGEgPCB0aGlzLnRpY2tzLmxlbmd0aDtcbiAgICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKGwgPyBFcyh0aGlzLnRpY2tzLCBhKSA6IHRoaXMudGlja3MpLCB0aGlzLmNvbmZpZ3VyZSgpLCB0aGlzLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSwgdGhpcy5jYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCksIHRoaXMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCksIHIuZGlzcGxheSAmJiAoci5hdXRvU2tpcCB8fCByLnNvdXJjZSA9PT0gXCJhdXRvXCIpICYmICh0aGlzLnRpY2tzID0gWmEodGhpcywgdGhpcy50aWNrcyksIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsLCB0aGlzLmFmdGVyQXV0b1NraXAoKSksIGwgJiYgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHModGhpcy50aWNrcyksIHRoaXMuYmVmb3JlRml0KCksIHRoaXMuZml0KCksIHRoaXMuYWZ0ZXJGaXQoKSwgdGhpcy5hZnRlclVwZGF0ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25maWd1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uZmlndXJlKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMucmV2ZXJzZSxcbiAgICAgICAgZSxcbiAgICAgICAgcztcbiAgICAgIHRoaXMuaXNIb3Jpem9udGFsKCkgPyAoZSA9IHRoaXMubGVmdCwgcyA9IHRoaXMucmlnaHQpIDogKGUgPSB0aGlzLnRvcCwgcyA9IHRoaXMuYm90dG9tLCB0ID0gIXQpLCB0aGlzLl9zdGFydFBpeGVsID0gZSwgdGhpcy5fZW5kUGl4ZWwgPSBzLCB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gdCwgdGhpcy5fbGVuZ3RoID0gcyAtIGUsIHRoaXMuX2FsaWduVG9QaXhlbHMgPSB0aGlzLm9wdGlvbnMuYWxpZ25Ub1BpeGVscztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWZ0ZXJVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWZ0ZXJVcGRhdGUoKSB7XG4gICAgICBJKHRoaXMub3B0aW9ucy5hZnRlclVwZGF0ZSwgW3RoaXNdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmVmb3JlU2V0RGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmVTZXREaW1lbnNpb25zKCkge1xuICAgICAgSSh0aGlzLm9wdGlvbnMuYmVmb3JlU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREaW1lbnNpb25zKCkge1xuICAgICAgdGhpcy5pc0hvcml6b250YWwoKSA/ICh0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aCwgdGhpcy5sZWZ0ID0gMCwgdGhpcy5yaWdodCA9IHRoaXMud2lkdGgpIDogKHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQsIHRoaXMudG9wID0gMCwgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodCksIHRoaXMucGFkZGluZ0xlZnQgPSAwLCB0aGlzLnBhZGRpbmdUb3AgPSAwLCB0aGlzLnBhZGRpbmdSaWdodCA9IDAsIHRoaXMucGFkZGluZ0JvdHRvbSA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFmdGVyU2V0RGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZnRlclNldERpbWVuc2lvbnMoKSB7XG4gICAgICBJKHRoaXMub3B0aW9ucy5hZnRlclNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jYWxsSG9va3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGxIb29rcyh0KSB7XG4gICAgICB0aGlzLmNoYXJ0Lm5vdGlmeVBsdWdpbnModCwgdGhpcy5nZXRDb250ZXh0KCkpLCBJKHRoaXMub3B0aW9uc1t0XSwgW3RoaXNdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmVmb3JlRGF0YUxpbWl0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmVEYXRhTGltaXRzKCkge1xuICAgICAgdGhpcy5fY2FsbEhvb2tzKFwiYmVmb3JlRGF0YUxpbWl0c1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGV0ZXJtaW5lRGF0YUxpbWl0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRlcm1pbmVEYXRhTGltaXRzKCkge31cbiAgfSwge1xuICAgIGtleTogXCJhZnRlckRhdGFMaW1pdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWZ0ZXJEYXRhTGltaXRzKCkge1xuICAgICAgdGhpcy5fY2FsbEhvb2tzKFwiYWZ0ZXJEYXRhTGltaXRzXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiZWZvcmVCdWlsZFRpY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZm9yZUJ1aWxkVGlja3MoKSB7XG4gICAgICB0aGlzLl9jYWxsSG9va3MoXCJiZWZvcmVCdWlsZFRpY2tzXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWlsZFRpY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkVGlja3MoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFmdGVyQnVpbGRUaWNrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZnRlckJ1aWxkVGlja3MoKSB7XG4gICAgICB0aGlzLl9jYWxsSG9va3MoXCJhZnRlckJ1aWxkVGlja3NcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgICBJKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlVGlja0xhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZVRpY2tMYWJlbHModCkge1xuICAgICAgdmFyIGUgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgICB2YXIgcywgbiwgbztcbiAgICAgIGZvciAocyA9IDAsIG4gPSB0Lmxlbmd0aDsgcyA8IG47IHMrKykgbyA9IHRbc10sIG8ubGFiZWwgPSBJKGUuY2FsbGJhY2ssIFtvLnZhbHVlLCBzLCB0XSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgICAgSSh0aGlzLm9wdGlvbnMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICAgIEkodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGN1bGF0ZUxhYmVsUm90YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBlID0gdC50aWNrcyxcbiAgICAgICAgcyA9IExzKHRoaXMudGlja3MubGVuZ3RoLCB0LnRpY2tzLm1heFRpY2tzTGltaXQpLFxuICAgICAgICBuID0gZS5taW5Sb3RhdGlvbiB8fCAwLFxuICAgICAgICBvID0gZS5tYXhSb3RhdGlvbjtcbiAgICAgIHZhciByID0gbixcbiAgICAgICAgYSxcbiAgICAgICAgbCxcbiAgICAgICAgYztcbiAgICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIWUuZGlzcGxheSB8fCBuID49IG8gfHwgcyA8PSAxIHx8ICF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IG47XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpLFxuICAgICAgICBkID0gaC53aWRlc3Qud2lkdGgsXG4gICAgICAgIHUgPSBoLmhpZ2hlc3QuaGVpZ2h0LFxuICAgICAgICBmID0gVSh0aGlzLmNoYXJ0LndpZHRoIC0gZCwgMCwgdGhpcy5tYXhXaWR0aCk7XG4gICAgICBhID0gdC5vZmZzZXQgPyB0aGlzLm1heFdpZHRoIC8gcyA6IGYgLyAocyAtIDEpLCBkICsgNiA+IGEgJiYgKGEgPSBmIC8gKHMgLSAodC5vZmZzZXQgPyAwLjUgOiAxKSksIGwgPSB0aGlzLm1heEhlaWdodCAtIGllKHQuZ3JpZCkgLSBlLnBhZGRpbmcgLSBGcyh0LnRpdGxlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMuZm9udCksIGMgPSBNYXRoLnNxcnQoZCAqIGQgKyB1ICogdSksIHIgPSBVbyhNYXRoLm1pbihNYXRoLmFzaW4oVSgoaC5oaWdoZXN0LmhlaWdodCArIDYpIC8gYSwgLTEsIDEpKSwgTWF0aC5hc2luKFUobCAvIGMsIC0xLCAxKSkgLSBNYXRoLmFzaW4oVSh1IC8gYywgLTEsIDEpKSkpLCByID0gTWF0aC5tYXgobiwgTWF0aC5taW4obywgcikpKSwgdGhpcy5sYWJlbFJvdGF0aW9uID0gcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICAgIEkodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWZ0ZXJBdXRvU2tpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZnRlckF1dG9Ta2lwKCkge31cbiAgfSwge1xuICAgIGtleTogXCJiZWZvcmVGaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlRml0KCkge1xuICAgICAgSSh0aGlzLm9wdGlvbnMuYmVmb3JlRml0LCBbdGhpc10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml0KCkge1xuICAgICAgdmFyIHQgPSB7XG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGUgPSB0aGlzLmNoYXJ0LFxuICAgICAgICBfdGhpcyRvcHRpb25zNSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgcyA9IF90aGlzJG9wdGlvbnM1LnRpY2tzLFxuICAgICAgICBuID0gX3RoaXMkb3B0aW9uczUudGl0bGUsXG4gICAgICAgIG8gPSBfdGhpcyRvcHRpb25zNS5ncmlkLFxuICAgICAgICByID0gdGhpcy5faXNWaXNpYmxlKCksXG4gICAgICAgIGEgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgICAgaWYgKHIpIHtcbiAgICAgICAgdmFyIGwgPSBGcyhuLCBlLm9wdGlvbnMuZm9udCk7XG4gICAgICAgIGlmIChhID8gKHQud2lkdGggPSB0aGlzLm1heFdpZHRoLCB0LmhlaWdodCA9IGllKG8pICsgbCkgOiAodC5oZWlnaHQgPSB0aGlzLm1heEhlaWdodCwgdC53aWR0aCA9IGllKG8pICsgbCksIHMuZGlzcGxheSAmJiB0aGlzLnRpY2tzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBfdGhpcyRfZ2V0TGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKSxcbiAgICAgICAgICAgIGMgPSBfdGhpcyRfZ2V0TGFiZWxTaXplcy5maXJzdCxcbiAgICAgICAgICAgIGggPSBfdGhpcyRfZ2V0TGFiZWxTaXplcy5sYXN0LFxuICAgICAgICAgICAgZCA9IF90aGlzJF9nZXRMYWJlbFNpemVzLndpZGVzdCxcbiAgICAgICAgICAgIHUgPSBfdGhpcyRfZ2V0TGFiZWxTaXplcy5oaWdoZXN0LFxuICAgICAgICAgICAgZiA9IHMucGFkZGluZyAqIDIsXG4gICAgICAgICAgICBwID0gYnQodGhpcy5sYWJlbFJvdGF0aW9uKSxcbiAgICAgICAgICAgIGcgPSBNYXRoLmNvcyhwKSxcbiAgICAgICAgICAgIG0gPSBNYXRoLnNpbihwKTtcbiAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgdmFyIGIgPSBzLm1pcnJvciA/IDAgOiBtICogZC53aWR0aCArIGcgKiB1LmhlaWdodDtcbiAgICAgICAgICAgIHQuaGVpZ2h0ID0gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIHQuaGVpZ2h0ICsgYiArIGYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX2IyID0gcy5taXJyb3IgPyAwIDogZyAqIGQud2lkdGggKyBtICogdS5oZWlnaHQ7XG4gICAgICAgICAgICB0LndpZHRoID0gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgdC53aWR0aCArIF9iMiArIGYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVQYWRkaW5nKGMsIGgsIG0sIGcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9oYW5kbGVNYXJnaW5zKCksIGEgPyAodGhpcy53aWR0aCA9IHRoaXMuX2xlbmd0aCA9IGUud2lkdGggLSB0aGlzLl9tYXJnaW5zLmxlZnQgLSB0aGlzLl9tYXJnaW5zLnJpZ2h0LCB0aGlzLmhlaWdodCA9IHQuaGVpZ2h0KSA6ICh0aGlzLndpZHRoID0gdC53aWR0aCwgdGhpcy5oZWlnaHQgPSB0aGlzLl9sZW5ndGggPSBlLmhlaWdodCAtIHRoaXMuX21hcmdpbnMudG9wIC0gdGhpcy5fbWFyZ2lucy5ib3R0b20pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FsY3VsYXRlUGFkZGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlUGFkZGluZyh0LCBlLCBzLCBuKSB7XG4gICAgICB2YXIgX3RoaXMkb3B0aW9uczYgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIF90aGlzJG9wdGlvbnM2JHRpY2tzID0gX3RoaXMkb3B0aW9uczYudGlja3MsXG4gICAgICAgIG8gPSBfdGhpcyRvcHRpb25zNiR0aWNrcy5hbGlnbixcbiAgICAgICAgciA9IF90aGlzJG9wdGlvbnM2JHRpY2tzLnBhZGRpbmcsXG4gICAgICAgIGEgPSBfdGhpcyRvcHRpb25zNi5wb3NpdGlvbixcbiAgICAgICAgbCA9IHRoaXMubGFiZWxSb3RhdGlvbiAhPT0gMCxcbiAgICAgICAgYyA9IGEgIT09IFwidG9wXCIgJiYgdGhpcy5heGlzID09PSBcInhcIjtcbiAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgIHZhciBoID0gdGhpcy5nZXRQaXhlbEZvclRpY2soMCkgLSB0aGlzLmxlZnQsXG4gICAgICAgICAgZCA9IHRoaXMucmlnaHQgLSB0aGlzLmdldFBpeGVsRm9yVGljayh0aGlzLnRpY2tzLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgdSA9IDAsXG4gICAgICAgICAgZiA9IDA7XG4gICAgICAgIGwgPyBjID8gKHUgPSBuICogdC53aWR0aCwgZiA9IHMgKiBlLmhlaWdodCkgOiAodSA9IHMgKiB0LmhlaWdodCwgZiA9IG4gKiBlLndpZHRoKSA6IG8gPT09IFwic3RhcnRcIiA/IGYgPSBlLndpZHRoIDogbyA9PT0gXCJlbmRcIiA/IHUgPSB0LndpZHRoIDogbyAhPT0gXCJpbm5lclwiICYmICh1ID0gdC53aWR0aCAvIDIsIGYgPSBlLndpZHRoIC8gMiksIHRoaXMucGFkZGluZ0xlZnQgPSBNYXRoLm1heCgodSAtIGggKyByKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIGgpLCAwKSwgdGhpcy5wYWRkaW5nUmlnaHQgPSBNYXRoLm1heCgoZiAtIGQgKyByKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIGQpLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfaDIgPSBlLmhlaWdodCAvIDIsXG4gICAgICAgICAgX2QzID0gdC5oZWlnaHQgLyAyO1xuICAgICAgICBvID09PSBcInN0YXJ0XCIgPyAoX2gyID0gMCwgX2QzID0gdC5oZWlnaHQpIDogbyA9PT0gXCJlbmRcIiAmJiAoX2gyID0gZS5oZWlnaHQsIF9kMyA9IDApLCB0aGlzLnBhZGRpbmdUb3AgPSBfaDIgKyByLCB0aGlzLnBhZGRpbmdCb3R0b20gPSBfZDMgKyByO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlTWFyZ2luc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlTWFyZ2lucygpIHtcbiAgICAgIHRoaXMuX21hcmdpbnMgJiYgKHRoaXMuX21hcmdpbnMubGVmdCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0xlZnQsIHRoaXMuX21hcmdpbnMubGVmdCksIHRoaXMuX21hcmdpbnMudG9wID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nVG9wLCB0aGlzLl9tYXJnaW5zLnRvcCksIHRoaXMuX21hcmdpbnMucmlnaHQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdSaWdodCwgdGhpcy5fbWFyZ2lucy5yaWdodCksIHRoaXMuX21hcmdpbnMuYm90dG9tID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nQm90dG9tLCB0aGlzLl9tYXJnaW5zLmJvdHRvbSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZnRlckZpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZnRlckZpdCgpIHtcbiAgICAgIEkodGhpcy5vcHRpb25zLmFmdGVyRml0LCBbdGhpc10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0hvcml6b250YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNIb3Jpem9udGFsKCkge1xuICAgICAgdmFyIF90aGlzJG9wdGlvbnM3ID0gdGhpcy5vcHRpb25zLFxuICAgICAgICB0ID0gX3RoaXMkb3B0aW9uczcuYXhpcyxcbiAgICAgICAgZSA9IF90aGlzJG9wdGlvbnM3LnBvc2l0aW9uO1xuICAgICAgcmV0dXJuIGUgPT09IFwidG9wXCIgfHwgZSA9PT0gXCJib3R0b21cIiB8fCB0ID09PSBcInhcIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNGdWxsU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Z1bGxTaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mdWxsU2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbnZlcnRUaWNrc1RvTGFiZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb252ZXJ0VGlja3NUb0xhYmVscyh0KSB7XG4gICAgICB0aGlzLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpLCB0aGlzLmdlbmVyYXRlVGlja0xhYmVscyh0KTtcbiAgICAgIHZhciBlLCBzO1xuICAgICAgZm9yIChlID0gMCwgcyA9IHQubGVuZ3RoOyBlIDwgczsgZSsrKSBSKHRbZV0ubGFiZWwpICYmICh0LnNwbGljZShlLCAxKSwgcy0tLCBlLS0pO1xuICAgICAgdGhpcy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0TGFiZWxTaXplc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TGFiZWxTaXplcygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fbGFiZWxTaXplcztcbiAgICAgIGlmICghdCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMub3B0aW9ucy50aWNrcy5zYW1wbGVTaXplO1xuICAgICAgICB2YXIgcyA9IHRoaXMudGlja3M7XG4gICAgICAgIGUgPCBzLmxlbmd0aCAmJiAocyA9IEVzKHMsIGUpKSwgdGhpcy5fbGFiZWxTaXplcyA9IHQgPSB0aGlzLl9jb21wdXRlTGFiZWxTaXplcyhzLCBzLmxlbmd0aCwgdGhpcy5vcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jb21wdXRlTGFiZWxTaXplc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29tcHV0ZUxhYmVsU2l6ZXModCwgZSwgcykge1xuICAgICAgdmFyIG4gPSB0aGlzLmN0eCxcbiAgICAgICAgbyA9IHRoaXMuX2xvbmdlc3RUZXh0Q2FjaGUsXG4gICAgICAgIHIgPSBbXSxcbiAgICAgICAgYSA9IFtdLFxuICAgICAgICBsID0gTWF0aC5mbG9vcihlIC8gTHMoZSwgcykpO1xuICAgICAgdmFyIGMgPSAwLFxuICAgICAgICBoID0gMCxcbiAgICAgICAgZCxcbiAgICAgICAgdSxcbiAgICAgICAgZixcbiAgICAgICAgcCxcbiAgICAgICAgZyxcbiAgICAgICAgbSxcbiAgICAgICAgYixcbiAgICAgICAgXyxcbiAgICAgICAgdixcbiAgICAgICAgeSxcbiAgICAgICAgeDtcbiAgICAgIGZvciAoZCA9IDA7IGQgPCBlOyBkICs9IGwpIHtcbiAgICAgICAgaWYgKHAgPSB0W2RdLmxhYmVsLCBnID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhkKSwgbi5mb250ID0gbSA9IGcuc3RyaW5nLCBiID0gb1ttXSA9IG9bbV0gfHwge1xuICAgICAgICAgIGRhdGE6IHt9LFxuICAgICAgICAgIGdjOiBbXVxuICAgICAgICB9LCBfID0gZy5saW5lSGVpZ2h0LCB2ID0geSA9IDAsICFSKHApICYmICFOKHApKSB2ID0gbHMobiwgYi5kYXRhLCBiLmdjLCB2LCBwKSwgeSA9IF87ZWxzZSBpZiAoTihwKSkgZm9yICh1ID0gMCwgZiA9IHAubGVuZ3RoOyB1IDwgZjsgKyt1KSB4ID0gcFt1XSwgIVIoeCkgJiYgIU4oeCkgJiYgKHYgPSBscyhuLCBiLmRhdGEsIGIuZ2MsIHYsIHgpLCB5ICs9IF8pO1xuICAgICAgICByLnB1c2godiksIGEucHVzaCh5KSwgYyA9IE1hdGgubWF4KHYsIGMpLCBoID0gTWF0aC5tYXgoeSwgaCk7XG4gICAgICB9XG4gICAgICBybChvLCBlKTtcbiAgICAgIHZhciBNID0gci5pbmRleE9mKGMpLFxuICAgICAgICBTID0gYS5pbmRleE9mKGgpLFxuICAgICAgICBrID0gZnVuY3Rpb24gayhQKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiByW1BdIHx8IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IGFbUF0gfHwgMFxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmaXJzdDogaygwKSxcbiAgICAgICAgbGFzdDogayhlIC0gMSksXG4gICAgICAgIHdpZGVzdDogayhNKSxcbiAgICAgICAgaGlnaGVzdDogayhTKSxcbiAgICAgICAgd2lkdGhzOiByLFxuICAgICAgICBoZWlnaHRzOiBhXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMYWJlbEZvclZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhYmVsRm9yVmFsdWUodCkge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBpeGVsRm9yVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGl4ZWxGb3JWYWx1ZSh0LCBlKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWYWx1ZUZvclBpeGVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlRm9yUGl4ZWwodCkge31cbiAgfSwge1xuICAgIGtleTogXCJnZXRQaXhlbEZvclRpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGl4ZWxGb3JUaWNrKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy50aWNrcztcbiAgICAgIHJldHVybiB0IDwgMCB8fCB0ID4gZS5sZW5ndGggLSAxID8gbnVsbCA6IHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZShlW3RdLnZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGl4ZWxGb3JEZWNpbWFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBpeGVsRm9yRGVjaW1hbCh0KSB7XG4gICAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzICYmICh0ID0gMSAtIHQpO1xuICAgICAgdmFyIGUgPSB0aGlzLl9zdGFydFBpeGVsICsgdCAqIHRoaXMuX2xlbmd0aDtcbiAgICAgIHJldHVybiBxbyh0aGlzLl9hbGlnblRvUGl4ZWxzID8gT3QodGhpcy5jaGFydCwgZSwgMCkgOiBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGVjaW1hbEZvclBpeGVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlY2ltYWxGb3JQaXhlbCh0KSB7XG4gICAgICB2YXIgZSA9ICh0IC0gdGhpcy5fc3RhcnRQaXhlbCkgLyB0aGlzLl9sZW5ndGg7XG4gICAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZVBpeGVscyA/IDEgLSBlIDogZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmFzZVBpeGVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2VQaXhlbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJhc2VWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXNlVmFsdWUoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMubWluLFxuICAgICAgICBlID0gdGhpcy5tYXg7XG4gICAgICByZXR1cm4gdCA8IDAgJiYgZSA8IDAgPyBlIDogdCA+IDAgJiYgZSA+IDAgPyB0IDogMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250ZXh0KHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy50aWNrcyB8fCBbXTtcbiAgICAgIGlmICh0ID49IDAgJiYgdCA8IGUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBzID0gZVt0XTtcbiAgICAgICAgcmV0dXJuIHMuJGNvbnRleHQgfHwgKHMuJGNvbnRleHQgPSBsbCh0aGlzLmdldENvbnRleHQoKSwgdCwgcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSBhbCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdGlja1NpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RpY2tTaXplKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMudGlja3MsXG4gICAgICAgIGUgPSBidCh0aGlzLmxhYmVsUm90YXRpb24pLFxuICAgICAgICBzID0gTWF0aC5hYnMoTWF0aC5jb3MoZSkpLFxuICAgICAgICBuID0gTWF0aC5hYnMoTWF0aC5zaW4oZSkpLFxuICAgICAgICBvID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpLFxuICAgICAgICByID0gdC5hdXRvU2tpcFBhZGRpbmcgfHwgMCxcbiAgICAgICAgYSA9IG8gPyBvLndpZGVzdC53aWR0aCArIHIgOiAwLFxuICAgICAgICBsID0gbyA/IG8uaGlnaGVzdC5oZWlnaHQgKyByIDogMDtcbiAgICAgIHJldHVybiB0aGlzLmlzSG9yaXpvbnRhbCgpID8gbCAqIHMgPiBhICogbiA/IGEgLyBzIDogbCAvIG4gOiBsICogbiA8IGEgKiBzID8gbCAvIHMgOiBhIC8gbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzVmlzaWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNWaXNpYmxlKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMuZGlzcGxheTtcbiAgICAgIHJldHVybiB0ICE9PSBcImF1dG9cIiA/ICEhdCA6IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKS5sZW5ndGggPiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY29tcHV0ZUdyaWRMaW5lSXRlbXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXB1dGVHcmlkTGluZUl0ZW1zKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5heGlzLFxuICAgICAgICBzID0gdGhpcy5jaGFydCxcbiAgICAgICAgbiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgbyA9IG4uZ3JpZCxcbiAgICAgICAgciA9IG4ucG9zaXRpb24sXG4gICAgICAgIGEgPSBuLmJvcmRlcixcbiAgICAgICAgbCA9IG8ub2Zmc2V0LFxuICAgICAgICBjID0gdGhpcy5pc0hvcml6b250YWwoKSxcbiAgICAgICAgZCA9IHRoaXMudGlja3MubGVuZ3RoICsgKGwgPyAxIDogMCksXG4gICAgICAgIHUgPSBpZShvKSxcbiAgICAgICAgZiA9IFtdLFxuICAgICAgICBwID0gYS5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKSxcbiAgICAgICAgZyA9IHAuZGlzcGxheSA/IHAud2lkdGggOiAwLFxuICAgICAgICBtID0gZyAvIDIsXG4gICAgICAgIGIgPSBmdW5jdGlvbiBiKHopIHtcbiAgICAgICAgICByZXR1cm4gT3QocywgeiwgZyk7XG4gICAgICAgIH07XG4gICAgICB2YXIgXywgdiwgeSwgeCwgTSwgUywgaywgUCwgQywgTywgQSwgajtcbiAgICAgIGlmIChyID09PSBcInRvcFwiKSBfID0gYih0aGlzLmJvdHRvbSksIFMgPSB0aGlzLmJvdHRvbSAtIHUsIFAgPSBfIC0gbSwgTyA9IGIodC50b3ApICsgbSwgaiA9IHQuYm90dG9tO2Vsc2UgaWYgKHIgPT09IFwiYm90dG9tXCIpIF8gPSBiKHRoaXMudG9wKSwgTyA9IHQudG9wLCBqID0gYih0LmJvdHRvbSkgLSBtLCBTID0gXyArIG0sIFAgPSB0aGlzLnRvcCArIHU7ZWxzZSBpZiAociA9PT0gXCJsZWZ0XCIpIF8gPSBiKHRoaXMucmlnaHQpLCBNID0gdGhpcy5yaWdodCAtIHUsIGsgPSBfIC0gbSwgQyA9IGIodC5sZWZ0KSArIG0sIEEgPSB0LnJpZ2h0O2Vsc2UgaWYgKHIgPT09IFwicmlnaHRcIikgXyA9IGIodGhpcy5sZWZ0KSwgQyA9IHQubGVmdCwgQSA9IGIodC5yaWdodCkgLSBtLCBNID0gXyArIG0sIGsgPSB0aGlzLmxlZnQgKyB1O2Vsc2UgaWYgKGUgPT09IFwieFwiKSB7XG4gICAgICAgIGlmIChyID09PSBcImNlbnRlclwiKSBfID0gYigodC50b3AgKyB0LmJvdHRvbSkgLyAyICsgMC41KTtlbHNlIGlmIChUKHIpKSB7XG4gICAgICAgICAgdmFyIHogPSBPYmplY3Qua2V5cyhyKVswXSxcbiAgICAgICAgICAgIEggPSByW3pdO1xuICAgICAgICAgIF8gPSBiKHRoaXMuY2hhcnQuc2NhbGVzW3pdLmdldFBpeGVsRm9yVmFsdWUoSCkpO1xuICAgICAgICB9XG4gICAgICAgIE8gPSB0LnRvcCwgaiA9IHQuYm90dG9tLCBTID0gXyArIG0sIFAgPSBTICsgdTtcbiAgICAgIH0gZWxzZSBpZiAoZSA9PT0gXCJ5XCIpIHtcbiAgICAgICAgaWYgKHIgPT09IFwiY2VudGVyXCIpIF8gPSBiKCh0LmxlZnQgKyB0LnJpZ2h0KSAvIDIpO2Vsc2UgaWYgKFQocikpIHtcbiAgICAgICAgICB2YXIgX3ogPSBPYmplY3Qua2V5cyhyKVswXSxcbiAgICAgICAgICAgIF9IID0gcltfel07XG4gICAgICAgICAgXyA9IGIodGhpcy5jaGFydC5zY2FsZXNbX3pdLmdldFBpeGVsRm9yVmFsdWUoX0gpKTtcbiAgICAgICAgfVxuICAgICAgICBNID0gXyAtIG0sIGsgPSBNIC0gdSwgQyA9IHQubGVmdCwgQSA9IHQucmlnaHQ7XG4gICAgICB9XG4gICAgICB2YXIgSiA9IEQobi50aWNrcy5tYXhUaWNrc0xpbWl0LCBkKSxcbiAgICAgICAgRiA9IE1hdGgubWF4KDEsIE1hdGguY2VpbChkIC8gSikpO1xuICAgICAgZm9yICh2ID0gMDsgdiA8IGQ7IHYgKz0gRikge1xuICAgICAgICB2YXIgX3oyID0gdGhpcy5nZXRDb250ZXh0KHYpLFxuICAgICAgICAgIF9IMiA9IG8uc2V0Q29udGV4dChfejIpLFxuICAgICAgICAgIGl0ID0gYS5zZXRDb250ZXh0KF96MiksXG4gICAgICAgICAgJCA9IF9IMi5saW5lV2lkdGgsXG4gICAgICAgICAgSHQgPSBfSDIuY29sb3IsXG4gICAgICAgICAgeWUgPSBpdC5kYXNoIHx8IFtdLFxuICAgICAgICAgIFd0ID0gaXQuZGFzaE9mZnNldCxcbiAgICAgICAgICBKdCA9IF9IMi50aWNrV2lkdGgsXG4gICAgICAgICAgUHQgPSBfSDIudGlja0NvbG9yLFxuICAgICAgICAgIFp0ID0gX0gyLnRpY2tCb3JkZXJEYXNoIHx8IFtdLFxuICAgICAgICAgIER0ID0gX0gyLnRpY2tCb3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgICB5ID0gb2wodGhpcywgdiwgbCksIHkgIT09IHZvaWQgMCAmJiAoeCA9IE90KHMsIHksICQpLCBjID8gTSA9IGsgPSBDID0gQSA9IHggOiBTID0gUCA9IE8gPSBqID0geCwgZi5wdXNoKHtcbiAgICAgICAgICB0eDE6IE0sXG4gICAgICAgICAgdHkxOiBTLFxuICAgICAgICAgIHR4MjogayxcbiAgICAgICAgICB0eTI6IFAsXG4gICAgICAgICAgeDE6IEMsXG4gICAgICAgICAgeTE6IE8sXG4gICAgICAgICAgeDI6IEEsXG4gICAgICAgICAgeTI6IGosXG4gICAgICAgICAgd2lkdGg6ICQsXG4gICAgICAgICAgY29sb3I6IEh0LFxuICAgICAgICAgIGJvcmRlckRhc2g6IHllLFxuICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IFd0LFxuICAgICAgICAgIHRpY2tXaWR0aDogSnQsXG4gICAgICAgICAgdGlja0NvbG9yOiBQdCxcbiAgICAgICAgICB0aWNrQm9yZGVyRGFzaDogWnQsXG4gICAgICAgICAgdGlja0JvcmRlckRhc2hPZmZzZXQ6IER0XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl90aWNrc0xlbmd0aCA9IGQsIHRoaXMuX2JvcmRlclZhbHVlID0gXywgZjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbXB1dGVMYWJlbEl0ZW1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21wdXRlTGFiZWxJdGVtcyh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuYXhpcyxcbiAgICAgICAgcyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgbiA9IHMucG9zaXRpb24sXG4gICAgICAgIG8gPSBzLnRpY2tzLFxuICAgICAgICByID0gdGhpcy5pc0hvcml6b250YWwoKSxcbiAgICAgICAgYSA9IHRoaXMudGlja3MsXG4gICAgICAgIGwgPSBvLmFsaWduLFxuICAgICAgICBjID0gby5jcm9zc0FsaWduLFxuICAgICAgICBoID0gby5wYWRkaW5nLFxuICAgICAgICBkID0gby5taXJyb3IsXG4gICAgICAgIHUgPSBpZShzLmdyaWQpLFxuICAgICAgICBmID0gdSArIGgsXG4gICAgICAgIHAgPSBkID8gLWggOiBmLFxuICAgICAgICBnID0gLWJ0KHRoaXMubGFiZWxSb3RhdGlvbiksXG4gICAgICAgIG0gPSBbXTtcbiAgICAgIHZhciBiLFxuICAgICAgICBfLFxuICAgICAgICB2LFxuICAgICAgICB5LFxuICAgICAgICB4LFxuICAgICAgICBNLFxuICAgICAgICBTLFxuICAgICAgICBrLFxuICAgICAgICBQLFxuICAgICAgICBDLFxuICAgICAgICBPLFxuICAgICAgICBBLFxuICAgICAgICBqID0gXCJtaWRkbGVcIjtcbiAgICAgIGlmIChuID09PSBcInRvcFwiKSBNID0gdGhpcy5ib3R0b20gLSBwLCBTID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO2Vsc2UgaWYgKG4gPT09IFwiYm90dG9tXCIpIE0gPSB0aGlzLnRvcCArIHAsIFMgPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7ZWxzZSBpZiAobiA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgdmFyIEYgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHUpO1xuICAgICAgICBTID0gRi50ZXh0QWxpZ24sIHggPSBGLng7XG4gICAgICB9IGVsc2UgaWYgKG4gPT09IFwicmlnaHRcIikge1xuICAgICAgICB2YXIgX0YgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHUpO1xuICAgICAgICBTID0gX0YudGV4dEFsaWduLCB4ID0gX0YueDtcbiAgICAgIH0gZWxzZSBpZiAoZSA9PT0gXCJ4XCIpIHtcbiAgICAgICAgaWYgKG4gPT09IFwiY2VudGVyXCIpIE0gPSAodC50b3AgKyB0LmJvdHRvbSkgLyAyICsgZjtlbHNlIGlmIChUKG4pKSB7XG4gICAgICAgICAgdmFyIF9GMiA9IE9iamVjdC5rZXlzKG4pWzBdLFxuICAgICAgICAgICAgeiA9IG5bX0YyXTtcbiAgICAgICAgICBNID0gdGhpcy5jaGFydC5zY2FsZXNbX0YyXS5nZXRQaXhlbEZvclZhbHVlKHopICsgZjtcbiAgICAgICAgfVxuICAgICAgICBTID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgICAgfSBlbHNlIGlmIChlID09PSBcInlcIikge1xuICAgICAgICBpZiAobiA9PT0gXCJjZW50ZXJcIikgeCA9ICh0LmxlZnQgKyB0LnJpZ2h0KSAvIDIgLSBmO2Vsc2UgaWYgKFQobikpIHtcbiAgICAgICAgICB2YXIgX0YzID0gT2JqZWN0LmtleXMobilbMF0sXG4gICAgICAgICAgICBfejMgPSBuW19GM107XG4gICAgICAgICAgeCA9IHRoaXMuY2hhcnQuc2NhbGVzW19GM10uZ2V0UGl4ZWxGb3JWYWx1ZShfejMpO1xuICAgICAgICB9XG4gICAgICAgIFMgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHUpLnRleHRBbGlnbjtcbiAgICAgIH1cbiAgICAgIGUgPT09IFwieVwiICYmIChsID09PSBcInN0YXJ0XCIgPyBqID0gXCJ0b3BcIiA6IGwgPT09IFwiZW5kXCIgJiYgKGogPSBcImJvdHRvbVwiKSk7XG4gICAgICB2YXIgSiA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICAgIGZvciAoYiA9IDAsIF8gPSBhLmxlbmd0aDsgYiA8IF87ICsrYikge1xuICAgICAgICB2ID0gYVtiXSwgeSA9IHYubGFiZWw7XG4gICAgICAgIHZhciBfRjQgPSBvLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGIpKTtcbiAgICAgICAgayA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKGIpICsgby5sYWJlbE9mZnNldCwgUCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoYiksIEMgPSBQLmxpbmVIZWlnaHQsIE8gPSBOKHkpID8geS5sZW5ndGggOiAxO1xuICAgICAgICB2YXIgX3o0ID0gTyAvIDIsXG4gICAgICAgICAgSCA9IF9GNC5jb2xvcixcbiAgICAgICAgICBpdCA9IF9GNC50ZXh0U3Ryb2tlQ29sb3IsXG4gICAgICAgICAgJCA9IF9GNC50ZXh0U3Ryb2tlV2lkdGg7XG4gICAgICAgIHZhciBIdCA9IFM7XG4gICAgICAgIHIgPyAoeCA9IGssIFMgPT09IFwiaW5uZXJcIiAmJiAoYiA9PT0gXyAtIDEgPyBIdCA9IHRoaXMub3B0aW9ucy5yZXZlcnNlID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIgOiBiID09PSAwID8gSHQgPSB0aGlzLm9wdGlvbnMucmV2ZXJzZSA/IFwicmlnaHRcIiA6IFwibGVmdFwiIDogSHQgPSBcImNlbnRlclwiKSwgbiA9PT0gXCJ0b3BcIiA/IGMgPT09IFwibmVhclwiIHx8IGcgIT09IDAgPyBBID0gLU8gKiBDICsgQyAvIDIgOiBjID09PSBcImNlbnRlclwiID8gQSA9IC1KLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIF96NCAqIEMgKyBDIDogQSA9IC1KLmhpZ2hlc3QuaGVpZ2h0ICsgQyAvIDIgOiBjID09PSBcIm5lYXJcIiB8fCBnICE9PSAwID8gQSA9IEMgLyAyIDogYyA9PT0gXCJjZW50ZXJcIiA/IEEgPSBKLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIF96NCAqIEMgOiBBID0gSi5oaWdoZXN0LmhlaWdodCAtIE8gKiBDLCBkICYmIChBICo9IC0xKSwgZyAhPT0gMCAmJiAhX0Y0LnNob3dMYWJlbEJhY2tkcm9wICYmICh4ICs9IEMgLyAyICogTWF0aC5zaW4oZykpKSA6IChNID0gaywgQSA9ICgxIC0gTykgKiBDIC8gMik7XG4gICAgICAgIHZhciB5ZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKF9GNC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICAgIHZhciBXdCA9IGV0KF9GNC5iYWNrZHJvcFBhZGRpbmcpLFxuICAgICAgICAgICAgSnQgPSBKLmhlaWdodHNbYl0sXG4gICAgICAgICAgICBQdCA9IEoud2lkdGhzW2JdO1xuICAgICAgICAgIHZhciBadCA9IEEgLSBXdC50b3AsXG4gICAgICAgICAgICBEdCA9IDAgLSBXdC5sZWZ0O1xuICAgICAgICAgIHN3aXRjaCAoaikge1xuICAgICAgICAgICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgICAgICAgICAgICBadCAtPSBKdCAvIDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgICAgICBadCAtPSBKdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAoUykge1xuICAgICAgICAgICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgICAgICAgICBEdCAtPSBQdCAvIDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgIER0IC09IFB0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbm5lclwiOlxuICAgICAgICAgICAgICBiID09PSBfIC0gMSA/IER0IC09IFB0IDogYiA+IDAgJiYgKER0IC09IFB0IC8gMik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB5ZSA9IHtcbiAgICAgICAgICAgIGxlZnQ6IER0LFxuICAgICAgICAgICAgdG9wOiBadCxcbiAgICAgICAgICAgIHdpZHRoOiBQdCArIFd0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBKdCArIFd0LmhlaWdodCxcbiAgICAgICAgICAgIGNvbG9yOiBfRjQuYmFja2Ryb3BDb2xvclxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbS5wdXNoKHtcbiAgICAgICAgICBsYWJlbDogeSxcbiAgICAgICAgICBmb250OiBQLFxuICAgICAgICAgIHRleHRPZmZzZXQ6IEEsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgcm90YXRpb246IGcsXG4gICAgICAgICAgICBjb2xvcjogSCxcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBpdCxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAkLFxuICAgICAgICAgICAgdGV4dEFsaWduOiBIdCxcbiAgICAgICAgICAgIHRleHRCYXNlbGluZTogaixcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uOiBbeCwgTV0sXG4gICAgICAgICAgICBiYWNrZHJvcDogeWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCkge1xuICAgICAgdmFyIF90aGlzJG9wdGlvbnM4ID0gdGhpcy5vcHRpb25zLFxuICAgICAgICB0ID0gX3RoaXMkb3B0aW9uczgucG9zaXRpb24sXG4gICAgICAgIGUgPSBfdGhpcyRvcHRpb25zOC50aWNrcztcbiAgICAgIGlmICgtYnQodGhpcy5sYWJlbFJvdGF0aW9uKSkgcmV0dXJuIHQgPT09IFwidG9wXCIgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbiAgICAgIHZhciBuID0gXCJjZW50ZXJcIjtcbiAgICAgIHJldHVybiBlLmFsaWduID09PSBcInN0YXJ0XCIgPyBuID0gXCJsZWZ0XCIgOiBlLmFsaWduID09PSBcImVuZFwiID8gbiA9IFwicmlnaHRcIiA6IGUuYWxpZ24gPT09IFwiaW5uZXJcIiAmJiAobiA9IFwiaW5uZXJcIiksIG47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHQpIHtcbiAgICAgIHZhciBfdGhpcyRvcHRpb25zOSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZSA9IF90aGlzJG9wdGlvbnM5LnBvc2l0aW9uLFxuICAgICAgICBfdGhpcyRvcHRpb25zOSR0aWNrcyA9IF90aGlzJG9wdGlvbnM5LnRpY2tzLFxuICAgICAgICBzID0gX3RoaXMkb3B0aW9uczkkdGlja3MuY3Jvc3NBbGlnbixcbiAgICAgICAgbiA9IF90aGlzJG9wdGlvbnM5JHRpY2tzLm1pcnJvcixcbiAgICAgICAgbyA9IF90aGlzJG9wdGlvbnM5JHRpY2tzLnBhZGRpbmcsXG4gICAgICAgIHIgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCksXG4gICAgICAgIGEgPSB0ICsgbyxcbiAgICAgICAgbCA9IHIud2lkZXN0LndpZHRoO1xuICAgICAgdmFyIGMsIGg7XG4gICAgICByZXR1cm4gZSA9PT0gXCJsZWZ0XCIgPyBuID8gKGggPSB0aGlzLnJpZ2h0ICsgbywgcyA9PT0gXCJuZWFyXCIgPyBjID0gXCJsZWZ0XCIgOiBzID09PSBcImNlbnRlclwiID8gKGMgPSBcImNlbnRlclwiLCBoICs9IGwgLyAyKSA6IChjID0gXCJyaWdodFwiLCBoICs9IGwpKSA6IChoID0gdGhpcy5yaWdodCAtIGEsIHMgPT09IFwibmVhclwiID8gYyA9IFwicmlnaHRcIiA6IHMgPT09IFwiY2VudGVyXCIgPyAoYyA9IFwiY2VudGVyXCIsIGggLT0gbCAvIDIpIDogKGMgPSBcImxlZnRcIiwgaCA9IHRoaXMubGVmdCkpIDogZSA9PT0gXCJyaWdodFwiID8gbiA/IChoID0gdGhpcy5sZWZ0ICsgbywgcyA9PT0gXCJuZWFyXCIgPyBjID0gXCJyaWdodFwiIDogcyA9PT0gXCJjZW50ZXJcIiA/IChjID0gXCJjZW50ZXJcIiwgaCAtPSBsIC8gMikgOiAoYyA9IFwibGVmdFwiLCBoIC09IGwpKSA6IChoID0gdGhpcy5sZWZ0ICsgYSwgcyA9PT0gXCJuZWFyXCIgPyBjID0gXCJsZWZ0XCIgOiBzID09PSBcImNlbnRlclwiID8gKGMgPSBcImNlbnRlclwiLCBoICs9IGwgLyAyKSA6IChjID0gXCJyaWdodFwiLCBoID0gdGhpcy5yaWdodCkpIDogYyA9IFwicmlnaHRcIiwge1xuICAgICAgICB0ZXh0QWxpZ246IGMsXG4gICAgICAgIHg6IGhcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jb21wdXRlTGFiZWxBcmVhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21wdXRlTGFiZWxBcmVhKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy50aWNrcy5taXJyb3IpIHJldHVybjtcbiAgICAgIHZhciB0ID0gdGhpcy5jaGFydCxcbiAgICAgICAgZSA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICAgIGlmIChlID09PSBcImxlZnRcIiB8fCBlID09PSBcInJpZ2h0XCIpIHJldHVybiB7XG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogdGhpcy5sZWZ0LFxuICAgICAgICBib3R0b206IHQuaGVpZ2h0LFxuICAgICAgICByaWdodDogdGhpcy5yaWdodFxuICAgICAgfTtcbiAgICAgIGlmIChlID09PSBcInRvcFwiIHx8IGUgPT09IFwiYm90dG9tXCIpIHJldHVybiB7XG4gICAgICAgIHRvcDogdGhpcy50b3AsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGJvdHRvbTogdGhpcy5ib3R0b20sXG4gICAgICAgIHJpZ2h0OiB0LndpZHRoXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3QmFja2dyb3VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5jdHgsXG4gICAgICAgIGUgPSB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICBzID0gdGhpcy5sZWZ0LFxuICAgICAgICBuID0gdGhpcy50b3AsXG4gICAgICAgIG8gPSB0aGlzLndpZHRoLFxuICAgICAgICByID0gdGhpcy5oZWlnaHQ7XG4gICAgICBlICYmICh0LnNhdmUoKSwgdC5maWxsU3R5bGUgPSBlLCB0LmZpbGxSZWN0KHMsIG4sIG8sIHIpLCB0LnJlc3RvcmUoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExpbmVXaWR0aEZvclZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExpbmVXaWR0aEZvclZhbHVlKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICFlLmRpc3BsYXkpIHJldHVybiAwO1xuICAgICAgdmFyIG4gPSB0aGlzLnRpY2tzLmZpbmRJbmRleChmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gby52YWx1ZSA9PT0gdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG4gPj0gMCA/IGUuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQobikpLmxpbmVXaWR0aCA6IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdHcmlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdHcmlkKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5vcHRpb25zLmdyaWQsXG4gICAgICAgIHMgPSB0aGlzLmN0eCxcbiAgICAgICAgbiA9IHRoaXMuX2dyaWRMaW5lSXRlbXMgfHwgKHRoaXMuX2dyaWRMaW5lSXRlbXMgPSB0aGlzLl9jb21wdXRlR3JpZExpbmVJdGVtcyh0KSk7XG4gICAgICB2YXIgbywgcjtcbiAgICAgIHZhciBhID0gZnVuY3Rpb24gYShsLCBjLCBoKSB7XG4gICAgICAgICFoLndpZHRoIHx8ICFoLmNvbG9yIHx8IChzLnNhdmUoKSwgcy5saW5lV2lkdGggPSBoLndpZHRoLCBzLnN0cm9rZVN0eWxlID0gaC5jb2xvciwgcy5zZXRMaW5lRGFzaChoLmJvcmRlckRhc2ggfHwgW10pLCBzLmxpbmVEYXNoT2Zmc2V0ID0gaC5ib3JkZXJEYXNoT2Zmc2V0LCBzLmJlZ2luUGF0aCgpLCBzLm1vdmVUbyhsLngsIGwueSksIHMubGluZVRvKGMueCwgYy55KSwgcy5zdHJva2UoKSwgcy5yZXN0b3JlKCkpO1xuICAgICAgfTtcbiAgICAgIGlmIChlLmRpc3BsYXkpIGZvciAobyA9IDAsIHIgPSBuLmxlbmd0aDsgbyA8IHI7ICsrbykge1xuICAgICAgICB2YXIgbCA9IG5bb107XG4gICAgICAgIGUuZHJhd09uQ2hhcnRBcmVhICYmIGEoe1xuICAgICAgICAgIHg6IGwueDEsXG4gICAgICAgICAgeTogbC55MVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogbC54MixcbiAgICAgICAgICB5OiBsLnkyXG4gICAgICAgIH0sIGwpLCBlLmRyYXdUaWNrcyAmJiBhKHtcbiAgICAgICAgICB4OiBsLnR4MSxcbiAgICAgICAgICB5OiBsLnR5MVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogbC50eDIsXG4gICAgICAgICAgeTogbC50eTJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNvbG9yOiBsLnRpY2tDb2xvcixcbiAgICAgICAgICB3aWR0aDogbC50aWNrV2lkdGgsXG4gICAgICAgICAgYm9yZGVyRGFzaDogbC50aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBsLnRpY2tCb3JkZXJEYXNoT2Zmc2V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Qm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdCb3JkZXIoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuY2hhcnQsXG4gICAgICAgIGUgPSB0aGlzLmN0eCxcbiAgICAgICAgX3RoaXMkb3B0aW9uczAgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHMgPSBfdGhpcyRvcHRpb25zMC5ib3JkZXIsXG4gICAgICAgIG4gPSBfdGhpcyRvcHRpb25zMC5ncmlkLFxuICAgICAgICBvID0gcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKSxcbiAgICAgICAgciA9IHMuZGlzcGxheSA/IG8ud2lkdGggOiAwO1xuICAgICAgaWYgKCFyKSByZXR1cm47XG4gICAgICB2YXIgYSA9IG4uc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoMCkpLmxpbmVXaWR0aCxcbiAgICAgICAgbCA9IHRoaXMuX2JvcmRlclZhbHVlO1xuICAgICAgdmFyIGMsIGgsIGQsIHU7XG4gICAgICB0aGlzLmlzSG9yaXpvbnRhbCgpID8gKGMgPSBPdCh0LCB0aGlzLmxlZnQsIHIpIC0gciAvIDIsIGggPSBPdCh0LCB0aGlzLnJpZ2h0LCBhKSArIGEgLyAyLCBkID0gdSA9IGwpIDogKGQgPSBPdCh0LCB0aGlzLnRvcCwgcikgLSByIC8gMiwgdSA9IE90KHQsIHRoaXMuYm90dG9tLCBhKSArIGEgLyAyLCBjID0gaCA9IGwpLCBlLnNhdmUoKSwgZS5saW5lV2lkdGggPSBvLndpZHRoLCBlLnN0cm9rZVN0eWxlID0gby5jb2xvciwgZS5iZWdpblBhdGgoKSwgZS5tb3ZlVG8oYywgZCksIGUubGluZVRvKGgsIHUpLCBlLnN0cm9rZSgpLCBlLnJlc3RvcmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0xhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3TGFiZWxzKHQpIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnRpY2tzLmRpc3BsYXkpIHJldHVybjtcbiAgICAgIHZhciBzID0gdGhpcy5jdHgsXG4gICAgICAgIG4gPSB0aGlzLl9jb21wdXRlTGFiZWxBcmVhKCk7XG4gICAgICBuICYmIEplKHMsIG4pO1xuICAgICAgdmFyIG8gPSB0aGlzLmdldExhYmVsSXRlbXModCk7XG4gICAgICB2YXIgX2l0ZXJhdG9yMjAgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvKSxcbiAgICAgICAgX3N0ZXAyMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMjAucygpOyAhKF9zdGVwMjAgPSBfaXRlcmF0b3IyMC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHIgPSBfc3RlcDIwLnZhbHVlO1xuICAgICAgICAgIHZhciBhID0gci5vcHRpb25zLFxuICAgICAgICAgICAgbCA9IHIuZm9udCxcbiAgICAgICAgICAgIGMgPSByLmxhYmVsLFxuICAgICAgICAgICAgaCA9IHIudGV4dE9mZnNldDtcbiAgICAgICAgICBiZShzLCBjLCAwLCBoLCBsLCBhKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIwLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIwLmYoKTtcbiAgICAgIH1cbiAgICAgIG4gJiYgWmUocyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdUaXRsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3VGl0bGUoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuY3R4LFxuICAgICAgICBfdGhpcyRvcHRpb25zMSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZSA9IF90aGlzJG9wdGlvbnMxLnBvc2l0aW9uLFxuICAgICAgICBzID0gX3RoaXMkb3B0aW9uczEudGl0bGUsXG4gICAgICAgIG4gPSBfdGhpcyRvcHRpb25zMS5yZXZlcnNlO1xuICAgICAgaWYgKCFzLmRpc3BsYXkpIHJldHVybjtcbiAgICAgIHZhciBvID0gWChzLmZvbnQpLFxuICAgICAgICByID0gZXQocy5wYWRkaW5nKSxcbiAgICAgICAgYSA9IHMuYWxpZ247XG4gICAgICB2YXIgbCA9IG8ubGluZUhlaWdodCAvIDI7XG4gICAgICBlID09PSBcImJvdHRvbVwiIHx8IGUgPT09IFwiY2VudGVyXCIgfHwgVChlKSA/IChsICs9IHIuYm90dG9tLCBOKHMudGV4dCkgJiYgKGwgKz0gby5saW5lSGVpZ2h0ICogKHMudGV4dC5sZW5ndGggLSAxKSkpIDogbCArPSByLnRvcDtcbiAgICAgIHZhciBfaGwgPSBobCh0aGlzLCBsLCBlLCBhKSxcbiAgICAgICAgYyA9IF9obC50aXRsZVgsXG4gICAgICAgIGggPSBfaGwudGl0bGVZLFxuICAgICAgICBkID0gX2hsLm1heFdpZHRoLFxuICAgICAgICB1ID0gX2hsLnJvdGF0aW9uO1xuICAgICAgYmUodCwgcy50ZXh0LCAwLCAwLCBvLCB7XG4gICAgICAgIGNvbG9yOiBzLmNvbG9yLFxuICAgICAgICBtYXhXaWR0aDogZCxcbiAgICAgICAgcm90YXRpb246IHUsXG4gICAgICAgIHRleHRBbGlnbjogY2woYSwgZSwgbiksXG4gICAgICAgIHRleHRCYXNlbGluZTogXCJtaWRkbGVcIixcbiAgICAgICAgdHJhbnNsYXRpb246IFtjLCBoXVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyh0KSB7XG4gICAgICB0aGlzLl9pc1Zpc2libGUoKSAmJiAodGhpcy5kcmF3QmFja2dyb3VuZCgpLCB0aGlzLmRyYXdHcmlkKHQpLCB0aGlzLmRyYXdCb3JkZXIoKSwgdGhpcy5kcmF3VGl0bGUoKSwgdGhpcy5kcmF3TGFiZWxzKHQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2xheWVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbGF5ZXJzKCkge1xuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG4gICAgICB2YXIgdCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZSA9IHQudGlja3MgJiYgdC50aWNrcy56IHx8IDAsXG4gICAgICAgIHMgPSBEKHQuZ3JpZCAmJiB0LmdyaWQueiwgLTEpLFxuICAgICAgICBuID0gRCh0LmJvcmRlciAmJiB0LmJvcmRlci56LCAwKTtcbiAgICAgIHJldHVybiAhdGhpcy5faXNWaXNpYmxlKCkgfHwgdGhpcy5kcmF3ICE9PSBHdC5wcm90b3R5cGUuZHJhdyA/IFt7XG4gICAgICAgIHo6IGUsXG4gICAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcobykge1xuICAgICAgICAgIF90aGlzOS5kcmF3KG8pO1xuICAgICAgICB9XG4gICAgICB9XSA6IFt7XG4gICAgICAgIHo6IHMsXG4gICAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcobykge1xuICAgICAgICAgIF90aGlzOS5kcmF3QmFja2dyb3VuZCgpLCBfdGhpczkuZHJhd0dyaWQobyksIF90aGlzOS5kcmF3VGl0bGUoKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB6OiBuLFxuICAgICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KCkge1xuICAgICAgICAgIF90aGlzOS5kcmF3Qm9yZGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgejogZSxcbiAgICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhvKSB7XG4gICAgICAgICAgX3RoaXM5LmRyYXdMYWJlbHMobyk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXRjaGluZ1Zpc2libGVNZXRhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLFxuICAgICAgICBzID0gdGhpcy5heGlzICsgXCJBeGlzSURcIixcbiAgICAgICAgbiA9IFtdO1xuICAgICAgdmFyIG8sIHI7XG4gICAgICBmb3IgKG8gPSAwLCByID0gZS5sZW5ndGg7IG8gPCByOyArK28pIHtcbiAgICAgICAgdmFyIGEgPSBlW29dO1xuICAgICAgICBhW3NdID09PSB0aGlzLmlkICYmICghdCB8fCBhLnR5cGUgPT09IHQpICYmIG4ucHVzaChhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVzb2x2ZVRpY2tGb250T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMub3B0aW9ucy50aWNrcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCh0KSk7XG4gICAgICByZXR1cm4gWChlLmZvbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbWF4RGlnaXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYXhEaWdpdHMoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkubGluZUhlaWdodDtcbiAgICAgIHJldHVybiAodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodCkgLyB0O1xuICAgIH1cbiAgfV0pO1xufShzdCk7XG52YXIgVGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUZSh0LCBlLCBzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRlKTtcbiAgICB0aGlzLnR5cGUgPSB0LCB0aGlzLnNjb3BlID0gZSwgdGhpcy5vdmVycmlkZSA9IHMsIHRoaXMuaXRlbXMgPSAvKiBAX19QVVJFX18gKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVGUsIFt7XG4gICAga2V5OiBcImlzRm9yVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ZvclR5cGUodCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKHRoaXMudHlwZS5wcm90b3R5cGUsIHQucHJvdG90eXBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVnaXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIodCkge1xuICAgICAgdmFyIGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7XG4gICAgICB2YXIgcztcbiAgICAgIGZsKGUpICYmIChzID0gdGhpcy5yZWdpc3RlcihlKSk7XG4gICAgICB2YXIgbiA9IHRoaXMuaXRlbXMsXG4gICAgICAgIG8gPSB0LmlkLFxuICAgICAgICByID0gdGhpcy5zY29wZSArIFwiLlwiICsgbztcbiAgICAgIGlmICghbykgdGhyb3cgbmV3IEVycm9yKFwiY2xhc3MgZG9lcyBub3QgaGF2ZSBpZDogXCIgKyB0KTtcbiAgICAgIHJldHVybiBvIGluIG4gfHwgKG5bb10gPSB0LCBkbCh0LCByLCBzKSwgdGhpcy5vdmVycmlkZSAmJiBXLm92ZXJyaWRlKHQuaWQsIHQub3ZlcnJpZGVzKSksIHI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQodCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbdF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVucmVnaXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5yZWdpc3Rlcih0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuaXRlbXMsXG4gICAgICAgIHMgPSB0LmlkLFxuICAgICAgICBuID0gdGhpcy5zY29wZTtcbiAgICAgIHMgaW4gZSAmJiBkZWxldGUgZVtzXSwgbiAmJiBzIGluIFdbbl0gJiYgKGRlbGV0ZSBXW25dW3NdLCB0aGlzLm92ZXJyaWRlICYmIGRlbGV0ZSB6dFtzXSk7XG4gICAgfVxuICB9XSk7XG59KCk7XG5mdW5jdGlvbiBkbChpLCB0LCBlKSB7XG4gIHZhciBzID0gZmUoLyogQF9fUFVSRV9fICovT2JqZWN0LmNyZWF0ZShudWxsKSwgW2UgPyBXLmdldChlKSA6IHt9LCBXLmdldCh0KSwgaS5kZWZhdWx0c10pO1xuICBXLnNldCh0LCBzKSwgaS5kZWZhdWx0Um91dGVzICYmIHVsKHQsIGkuZGVmYXVsdFJvdXRlcyksIGkuZGVzY3JpcHRvcnMgJiYgVy5kZXNjcmliZSh0LCBpLmRlc2NyaXB0b3JzKTtcbn1cbmZ1bmN0aW9uIHVsKGksIHQpIHtcbiAgT2JqZWN0LmtleXModCkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzID0gZS5zcGxpdChcIi5cIiksXG4gICAgICBuID0gcy5wb3AoKSxcbiAgICAgIG8gPSBbaV0uY29uY2F0KHMpLmpvaW4oXCIuXCIpLFxuICAgICAgciA9IHRbZV0uc3BsaXQoXCIuXCIpLFxuICAgICAgYSA9IHIucG9wKCksXG4gICAgICBsID0gci5qb2luKFwiLlwiKTtcbiAgICBXLnJvdXRlKG8sIG4sIGwsIGEpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGZsKGkpIHtcbiAgcmV0dXJuIFwiaWRcIiBpbiBpICYmIFwiZGVmYXVsdHNcIiBpbiBpO1xufVxudmFyIGdsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZ2woKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIGdsKTtcbiAgICB0aGlzLmNvbnRyb2xsZXJzID0gbmV3IFRlKGt0LCBcImRhdGFzZXRzXCIsICEwKSwgdGhpcy5lbGVtZW50cyA9IG5ldyBUZShzdCwgXCJlbGVtZW50c1wiKSwgdGhpcy5wbHVnaW5zID0gbmV3IFRlKE9iamVjdCwgXCJwbHVnaW5zXCIpLCB0aGlzLnNjYWxlcyA9IG5ldyBUZShHdCwgXCJzY2FsZXNcIiksIHRoaXMuX3R5cGVkUmVnaXN0cmllcyA9IFt0aGlzLmNvbnRyb2xsZXJzLCB0aGlzLnNjYWxlcywgdGhpcy5lbGVtZW50c107XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhnbCwgW3tcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgICB0W19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG4gICAgICB0aGlzLl9lYWNoKFwicmVnaXN0ZXJcIiwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgICAgdFtfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWFjaChcInVucmVnaXN0ZXJcIiwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZENvbnRyb2xsZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENvbnRyb2xsZXJzKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgICAgIHRbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VhY2goXCJyZWdpc3RlclwiLCB0LCB0aGlzLmNvbnRyb2xsZXJzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWxlbWVudHMoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNyA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoX2xlbjcpLCBfa2V5NyA9IDA7IF9rZXk3IDwgX2xlbjc7IF9rZXk3KyspIHtcbiAgICAgICAgdFtfa2V5N10gPSBhcmd1bWVudHNbX2tleTddO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWFjaChcInJlZ2lzdGVyXCIsIHQsIHRoaXMuZWxlbWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRQbHVnaW5zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFBsdWdpbnMoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuOCA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoX2xlbjgpLCBfa2V5OCA9IDA7IF9rZXk4IDwgX2xlbjg7IF9rZXk4KyspIHtcbiAgICAgICAgdFtfa2V5OF0gPSBhcmd1bWVudHNbX2tleThdO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWFjaChcInJlZ2lzdGVyXCIsIHQsIHRoaXMucGx1Z2lucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFNjYWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTY2FsZXMoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuOSA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoX2xlbjkpLCBfa2V5OSA9IDA7IF9rZXk5IDwgX2xlbjk7IF9rZXk5KyspIHtcbiAgICAgICAgdFtfa2V5OV0gPSBhcmd1bWVudHNbX2tleTldO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWFjaChcInJlZ2lzdGVyXCIsIHQsIHRoaXMuc2NhbGVzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29udHJvbGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250cm9sbGVyKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXQodCwgdGhpcy5jb250cm9sbGVycywgXCJjb250cm9sbGVyXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnQodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldCh0LCB0aGlzLmVsZW1lbnRzLCBcImVsZW1lbnRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBsdWdpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQbHVnaW4odCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldCh0LCB0aGlzLnBsdWdpbnMsIFwicGx1Z2luXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY2FsZSh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0KHQsIHRoaXMuc2NhbGVzLCBcInNjYWxlXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVDb250cm9sbGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDb250cm9sbGVycygpIHtcbiAgICAgIGZvciAodmFyIF9sZW4wID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShfbGVuMCksIF9rZXkwID0gMDsgX2tleTAgPCBfbGVuMDsgX2tleTArKykge1xuICAgICAgICB0W19rZXkwXSA9IGFyZ3VtZW50c1tfa2V5MF07XG4gICAgICB9XG4gICAgICB0aGlzLl9lYWNoKFwidW5yZWdpc3RlclwiLCB0LCB0aGlzLmNvbnRyb2xsZXJzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRWxlbWVudHMoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMSA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoX2xlbjEpLCBfa2V5MSA9IDA7IF9rZXkxIDwgX2xlbjE7IF9rZXkxKyspIHtcbiAgICAgICAgdFtfa2V5MV0gPSBhcmd1bWVudHNbX2tleTFdO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWFjaChcInVucmVnaXN0ZXJcIiwgdCwgdGhpcy5lbGVtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVBsdWdpbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlUGx1Z2lucygpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xMCA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoX2xlbjEwKSwgX2tleTEwID0gMDsgX2tleTEwIDwgX2xlbjEwOyBfa2V5MTArKykge1xuICAgICAgICB0W19rZXkxMF0gPSBhcmd1bWVudHNbX2tleTEwXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VhY2goXCJ1bnJlZ2lzdGVyXCIsIHQsIHRoaXMucGx1Z2lucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVNjYWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVTY2FsZXMoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTEgPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KF9sZW4xMSksIF9rZXkxMSA9IDA7IF9rZXkxMSA8IF9sZW4xMTsgX2tleTExKyspIHtcbiAgICAgICAgdFtfa2V5MTFdID0gYXJndW1lbnRzW19rZXkxMV07XG4gICAgICB9XG4gICAgICB0aGlzLl9lYWNoKFwidW5yZWdpc3RlclwiLCB0LCB0aGlzLnNjYWxlcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9lYWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lYWNoKHQsIGUsIHMpIHtcbiAgICAgIHZhciBfdGhpczAgPSB0aGlzO1xuICAgICAgX3RvQ29uc3VtYWJsZUFycmF5KGUpLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdmFyIG8gPSBzIHx8IF90aGlzMC5fZ2V0UmVnaXN0cnlGb3JUeXBlKG4pO1xuICAgICAgICBzIHx8IG8uaXNGb3JUeXBlKG4pIHx8IG8gPT09IF90aGlzMC5wbHVnaW5zICYmIG4uaWQgPyBfdGhpczAuX2V4ZWModCwgbywgbikgOiBMKG4sIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgdmFyIGEgPSBzIHx8IF90aGlzMC5fZ2V0UmVnaXN0cnlGb3JUeXBlKHIpO1xuICAgICAgICAgIF90aGlzMC5fZXhlYyh0LCBhLCByKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2V4ZWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V4ZWModCwgZSwgcykge1xuICAgICAgdmFyIG4gPSBGaSh0KTtcbiAgICAgIEkoc1tcImJlZm9yZVwiICsgbl0sIFtdLCBzKSwgZVt0XShzKSwgSShzW1wiYWZ0ZXJcIiArIG5dLCBbXSwgcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRSZWdpc3RyeUZvclR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFJlZ2lzdHJ5Rm9yVHlwZSh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMuX3R5cGVkUmVnaXN0cmllcy5sZW5ndGg7IGUrKykge1xuICAgICAgICB2YXIgcyA9IHRoaXMuX3R5cGVkUmVnaXN0cmllc1tlXTtcbiAgICAgICAgaWYgKHMuaXNGb3JUeXBlKHQpKSByZXR1cm4gcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBsdWdpbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldCh0LCBlLCBzKSB7XG4gICAgICB2YXIgbiA9IGUuZ2V0KHQpO1xuICAgICAgaWYgKG4gPT09IHZvaWQgMCkgdGhyb3cgbmV3IEVycm9yKCdcIicgKyB0ICsgJ1wiIGlzIG5vdCBhIHJlZ2lzdGVyZWQgJyArIHMgKyBcIi5cIik7XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbnZhciBhdCA9IC8qIEBfX1BVUkVfXyAqL25ldyBnbCgpO1xudmFyIHBsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gcGwoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIHBsKTtcbiAgICB0aGlzLl9pbml0ID0gdm9pZCAwO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MocGwsIFt7XG4gICAga2V5OiBcIm5vdGlmeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3RpZnkodCwgZSwgcywgbikge1xuICAgICAgaWYgKGUgPT09IFwiYmVmb3JlSW5pdFwiICYmICh0aGlzLl9pbml0ID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnModCwgITApLCB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgdCwgXCJpbnN0YWxsXCIpKSwgdGhpcy5faW5pdCA9PT0gdm9pZCAwKSByZXR1cm47XG4gICAgICB2YXIgbyA9IG4gPyB0aGlzLl9kZXNjcmlwdG9ycyh0KS5maWx0ZXIobikgOiB0aGlzLl9kZXNjcmlwdG9ycyh0KSxcbiAgICAgICAgciA9IHRoaXMuX25vdGlmeShvLCB0LCBlLCBzKTtcbiAgICAgIHJldHVybiBlID09PSBcImFmdGVyRGVzdHJveVwiICYmICh0aGlzLl9ub3RpZnkobywgdCwgXCJzdG9wXCIpLCB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgdCwgXCJ1bmluc3RhbGxcIiksIHRoaXMuX2luaXQgPSB2b2lkIDApLCByO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbm90aWZ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ub3RpZnkodCwgZSwgcywgbikge1xuICAgICAgbiA9IG4gfHwge307XG4gICAgICB2YXIgX2l0ZXJhdG9yMjEgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0KSxcbiAgICAgICAgX3N0ZXAyMTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMjEucygpOyAhKF9zdGVwMjEgPSBfaXRlcmF0b3IyMS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIG8gPSBfc3RlcDIxLnZhbHVlO1xuICAgICAgICAgIHZhciByID0gby5wbHVnaW4sXG4gICAgICAgICAgICBhID0gcltzXSxcbiAgICAgICAgICAgIGwgPSBbZSwgbiwgby5vcHRpb25zXTtcbiAgICAgICAgICBpZiAoSShhLCBsLCByKSA9PT0gITEgJiYgbi5jYW5jZWxhYmxlKSByZXR1cm4gITE7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyMS5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyMS5mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludmFsaWRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICAgIFIodGhpcy5fY2FjaGUpIHx8ICh0aGlzLl9vbGRDYWNoZSA9IHRoaXMuX2NhY2hlLCB0aGlzLl9jYWNoZSA9IHZvaWQgMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZXNjcmlwdG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzY3JpcHRvcnModCkge1xuICAgICAgaWYgKHRoaXMuX2NhY2hlKSByZXR1cm4gdGhpcy5fY2FjaGU7XG4gICAgICB2YXIgZSA9IHRoaXMuX2NhY2hlID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnModCk7XG4gICAgICByZXR1cm4gdGhpcy5fbm90aWZ5U3RhdGVDaGFuZ2VzKHQpLCBlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlRGVzY3JpcHRvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZURlc2NyaXB0b3JzKHQsIGUpIHtcbiAgICAgIHZhciBzID0gdCAmJiB0LmNvbmZpZyxcbiAgICAgICAgbiA9IEQocy5vcHRpb25zICYmIHMub3B0aW9ucy5wbHVnaW5zLCB7fSksXG4gICAgICAgIG8gPSBtbChzKTtcbiAgICAgIHJldHVybiBuID09PSAhMSAmJiAhZSA/IFtdIDogX2wodCwgbywgbiwgZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9ub3RpZnlTdGF0ZUNoYW5nZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25vdGlmeVN0YXRlQ2hhbmdlcyh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX29sZENhY2hlIHx8IFtdLFxuICAgICAgICBzID0gdGhpcy5fY2FjaGUsXG4gICAgICAgIG4gPSBmdW5jdGlvbiBuKG8sIHIpIHtcbiAgICAgICAgICByZXR1cm4gby5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiAhci5zb21lKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhLnBsdWdpbi5pZCA9PT0gbC5wbHVnaW4uaWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIHRoaXMuX25vdGlmeShuKGUsIHMpLCB0LCBcInN0b3BcIiksIHRoaXMuX25vdGlmeShuKHMsIGUpLCB0LCBcInN0YXJ0XCIpO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuZnVuY3Rpb24gbWwoaSkge1xuICB2YXIgdCA9IHt9LFxuICAgIGUgPSBbXSxcbiAgICBzID0gT2JqZWN0LmtleXMoYXQucGx1Z2lucy5pdGVtcyk7XG4gIGZvciAodmFyIG8gPSAwOyBvIDwgcy5sZW5ndGg7IG8rKykgZS5wdXNoKGF0LmdldFBsdWdpbihzW29dKSk7XG4gIHZhciBuID0gaS5wbHVnaW5zIHx8IFtdO1xuICBmb3IgKHZhciBfbzMgPSAwOyBfbzMgPCBuLmxlbmd0aDsgX28zKyspIHtcbiAgICB2YXIgciA9IG5bX28zXTtcbiAgICBlLmluZGV4T2YocikgPT09IC0xICYmIChlLnB1c2gociksIHRbci5pZF0gPSAhMCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwbHVnaW5zOiBlLFxuICAgIGxvY2FsSWRzOiB0XG4gIH07XG59XG5mdW5jdGlvbiBibChpLCB0KSB7XG4gIHJldHVybiAhdCAmJiBpID09PSAhMSA/IG51bGwgOiBpID09PSAhMCA/IHt9IDogaTtcbn1cbmZ1bmN0aW9uIF9sKGksIF9yZWYzLCBzLCBuKSB7XG4gIHZhciB0ID0gX3JlZjMucGx1Z2lucyxcbiAgICBlID0gX3JlZjMubG9jYWxJZHM7XG4gIHZhciBvID0gW10sXG4gICAgciA9IGkuZ2V0Q29udGV4dCgpO1xuICB2YXIgX2l0ZXJhdG9yMjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0KSxcbiAgICBfc3RlcDIyO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMjIucygpOyAhKF9zdGVwMjIgPSBfaXRlcmF0b3IyMi5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgYSA9IF9zdGVwMjIudmFsdWU7XG4gICAgICB2YXIgbCA9IGEuaWQsXG4gICAgICAgIGMgPSBibChzW2xdLCBuKTtcbiAgICAgIGMgIT09IG51bGwgJiYgby5wdXNoKHtcbiAgICAgICAgcGx1Z2luOiBhLFxuICAgICAgICBvcHRpb25zOiB4bChpLmNvbmZpZywge1xuICAgICAgICAgIHBsdWdpbjogYSxcbiAgICAgICAgICBsb2NhbDogZVtsXVxuICAgICAgICB9LCBjLCByKVxuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IyMi5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMjIuZigpO1xuICB9XG4gIHJldHVybiBvO1xufVxuZnVuY3Rpb24geGwoaSwgX3JlZjQsIHMsIG4pIHtcbiAgdmFyIHQgPSBfcmVmNC5wbHVnaW4sXG4gICAgZSA9IF9yZWY0LmxvY2FsO1xuICB2YXIgbyA9IGkucGx1Z2luU2NvcGVLZXlzKHQpLFxuICAgIHIgPSBpLmdldE9wdGlvblNjb3BlcyhzLCBvKTtcbiAgcmV0dXJuIGUgJiYgdC5kZWZhdWx0cyAmJiByLnB1c2godC5kZWZhdWx0cyksIGkuY3JlYXRlUmVzb2x2ZXIociwgbiwgW1wiXCJdLCB7XG4gICAgc2NyaXB0YWJsZTogITEsXG4gICAgaW5kZXhhYmxlOiAhMSxcbiAgICBhbGxLZXlzOiAhMFxuICB9KTtcbn1cbmZ1bmN0aW9uIHdpKGksIHQpIHtcbiAgdmFyIGUgPSBXLmRhdGFzZXRzW2ldIHx8IHt9O1xuICByZXR1cm4gKCh0LmRhdGFzZXRzIHx8IHt9KVtpXSB8fCB7fSkuaW5kZXhBeGlzIHx8IHQuaW5kZXhBeGlzIHx8IGUuaW5kZXhBeGlzIHx8IFwieFwiO1xufVxuZnVuY3Rpb24geWwoaSwgdCkge1xuICB2YXIgZSA9IGk7XG4gIHJldHVybiBpID09PSBcIl9pbmRleF9cIiA/IGUgPSB0IDogaSA9PT0gXCJfdmFsdWVfXCIgJiYgKGUgPSB0ID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCIpLCBlO1xufVxuZnVuY3Rpb24gdmwoaSwgdCkge1xuICByZXR1cm4gaSA9PT0gdCA/IFwiX2luZGV4X1wiIDogXCJfdmFsdWVfXCI7XG59XG5mdW5jdGlvbiBJcyhpKSB7XG4gIGlmIChpID09PSBcInhcIiB8fCBpID09PSBcInlcIiB8fCBpID09PSBcInJcIikgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBNbChpKSB7XG4gIGlmIChpID09PSBcInRvcFwiIHx8IGkgPT09IFwiYm90dG9tXCIpIHJldHVybiBcInhcIjtcbiAgaWYgKGkgPT09IFwibGVmdFwiIHx8IGkgPT09IFwicmlnaHRcIikgcmV0dXJuIFwieVwiO1xufVxuZnVuY3Rpb24gUGkoaSkge1xuICBpZiAoSXMoaSkpIHJldHVybiBpO1xuICBmb3IgKHZhciBfbGVuMTIgPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KF9sZW4xMiA+IDEgPyBfbGVuMTIgLSAxIDogMCksIF9rZXkxMiA9IDE7IF9rZXkxMiA8IF9sZW4xMjsgX2tleTEyKyspIHtcbiAgICB0W19rZXkxMiAtIDFdID0gYXJndW1lbnRzW19rZXkxMl07XG4gIH1cbiAgZm9yICh2YXIgX2kzID0gMCwgX3QzID0gdDsgX2kzIDwgX3QzLmxlbmd0aDsgX2kzKyspIHtcbiAgICB2YXIgZSA9IF90M1tfaTNdO1xuICAgIHZhciBzID0gZS5heGlzIHx8IE1sKGUucG9zaXRpb24pIHx8IGkubGVuZ3RoID4gMSAmJiBJcyhpWzBdLnRvTG93ZXJDYXNlKCkpO1xuICAgIGlmIChzKSByZXR1cm4gcztcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGV0ZXJtaW5lIHR5cGUgb2YgJ1wiLmNvbmNhdChpLCBcIicgYXhpcy4gUGxlYXNlIHByb3ZpZGUgJ2F4aXMnIG9yICdwb3NpdGlvbicgb3B0aW9uLlwiKSk7XG59XG5mdW5jdGlvbiB6cyhpLCB0LCBlKSB7XG4gIGlmIChlW3QgKyBcIkF4aXNJRFwiXSA9PT0gaSkgcmV0dXJuIHtcbiAgICBheGlzOiB0XG4gIH07XG59XG5mdW5jdGlvbiBTbChpLCB0KSB7XG4gIGlmICh0LmRhdGEgJiYgdC5kYXRhLmRhdGFzZXRzKSB7XG4gICAgdmFyIGUgPSB0LmRhdGEuZGF0YXNldHMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcy54QXhpc0lEID09PSBpIHx8IHMueUF4aXNJRCA9PT0gaTtcbiAgICB9KTtcbiAgICBpZiAoZS5sZW5ndGgpIHJldHVybiB6cyhpLCBcInhcIiwgZVswXSkgfHwgenMoaSwgXCJ5XCIsIGVbMF0pO1xuICB9XG4gIHJldHVybiB7fTtcbn1cbmZ1bmN0aW9uIGtsKGksIHQpIHtcbiAgdmFyIGUgPSB6dFtpLnR5cGVdIHx8IHtcbiAgICAgIHNjYWxlczoge31cbiAgICB9LFxuICAgIHMgPSB0LnNjYWxlcyB8fCB7fSxcbiAgICBuID0gd2koaS50eXBlLCB0KSxcbiAgICBvID0gLyogQF9fUFVSRV9fICovT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHMpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICB2YXIgYSA9IHNbcl07XG4gICAgaWYgKCFUKGEpKSByZXR1cm4gY29uc29sZS5lcnJvcihcIkludmFsaWQgc2NhbGUgY29uZmlndXJhdGlvbiBmb3Igc2NhbGU6IFwiLmNvbmNhdChyKSk7XG4gICAgaWYgKGEuX3Byb3h5KSByZXR1cm4gY29uc29sZS53YXJuKFwiSWdub3JpbmcgcmVzb2x2ZXIgcGFzc2VkIGFzIG9wdGlvbnMgZm9yIHNjYWxlOiBcIi5jb25jYXQocikpO1xuICAgIHZhciBsID0gUGkociwgYSwgU2wociwgaSksIFcuc2NhbGVzW2EudHlwZV0pLFxuICAgICAgYyA9IHZsKGwsIG4pLFxuICAgICAgaCA9IGUuc2NhbGVzIHx8IHt9O1xuICAgIG9bcl0gPSBsZSgvKiBAX19QVVJFX18gKi9PYmplY3QuY3JlYXRlKG51bGwpLCBbe1xuICAgICAgYXhpczogbFxuICAgIH0sIGEsIGhbbF0sIGhbY11dKTtcbiAgfSksIGkuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgdmFyIGEgPSByLnR5cGUgfHwgaS50eXBlLFxuICAgICAgbCA9IHIuaW5kZXhBeGlzIHx8IHdpKGEsIHQpLFxuICAgICAgaCA9ICh6dFthXSB8fCB7fSkuc2NhbGVzIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKGgpLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciB1ID0geWwoZCwgbCksXG4gICAgICAgIGYgPSByW3UgKyBcIkF4aXNJRFwiXSB8fCB1O1xuICAgICAgb1tmXSA9IG9bZl0gfHwgLyogQF9fUFVSRV9fICovT2JqZWN0LmNyZWF0ZShudWxsKSwgbGUob1tmXSwgW3tcbiAgICAgICAgYXhpczogdVxuICAgICAgfSwgc1tmXSwgaFtkXV0pO1xuICAgIH0pO1xuICB9KSwgT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgIHZhciBhID0gb1tyXTtcbiAgICBsZShhLCBbVy5zY2FsZXNbYS50eXBlXSwgVy5zY2FsZV0pO1xuICB9KSwgbztcbn1cbmZ1bmN0aW9uIEtuKGkpIHtcbiAgdmFyIHQgPSBpLm9wdGlvbnMgfHwgKGkub3B0aW9ucyA9IHt9KTtcbiAgdC5wbHVnaW5zID0gRCh0LnBsdWdpbnMsIHt9KSwgdC5zY2FsZXMgPSBrbChpLCB0KTtcbn1cbmZ1bmN0aW9uIEduKGkpIHtcbiAgcmV0dXJuIGkgPSBpIHx8IHt9LCBpLmRhdGFzZXRzID0gaS5kYXRhc2V0cyB8fCBbXSwgaS5sYWJlbHMgPSBpLmxhYmVscyB8fCBbXSwgaTtcbn1cbmZ1bmN0aW9uIHdsKGkpIHtcbiAgcmV0dXJuIGkgPSBpIHx8IHt9LCBpLmRhdGEgPSBHbihpLmRhdGEpLCBLbihpKSwgaTtcbn1cbnZhciBCcyA9IC8qIEBfX1BVUkVfXyAqL25ldyBNYXAoKSxcbiAgSm4gPSAvKiBAX19QVVJFX18gKi9uZXcgU2V0KCk7XG5mdW5jdGlvbiBBZShpLCB0KSB7XG4gIHZhciBlID0gQnMuZ2V0KGkpO1xuICByZXR1cm4gZSB8fCAoZSA9IHQoKSwgQnMuc2V0KGksIGUpLCBKbi5hZGQoZSkpLCBlO1xufVxudmFyIHNlID0gZnVuY3Rpb24gc2UoaSwgdCwgZSkge1xuICB2YXIgcyA9IEl0KHQsIGUpO1xuICBzICE9PSB2b2lkIDAgJiYgaS5hZGQocyk7XG59O1xudmFyIFBsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGwodCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbCk7XG4gICAgdGhpcy5fY29uZmlnID0gd2wodCksIHRoaXMuX3Njb3BlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi9uZXcgTWFwKCksIHRoaXMuX3Jlc29sdmVyQ2FjaGUgPSAvKiBAX19QVVJFX18gKi9uZXcgTWFwKCk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhQbCwgW3tcbiAgICBrZXk6IFwicGxhdGZvcm1cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb25maWcucGxhdGZvcm07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb25maWcudHlwZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHQpIHtcbiAgICAgIHRoaXMuX2NvbmZpZy50eXBlID0gdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0YVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5kYXRhO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodCkge1xuICAgICAgdGhpcy5fY29uZmlnLmRhdGEgPSBHbih0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5vcHRpb25zO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodCkge1xuICAgICAgdGhpcy5fY29uZmlnLm9wdGlvbnMgPSB0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwbHVnaW5zXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsdWdpbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2NvbmZpZztcbiAgICAgIHRoaXMuY2xlYXJDYWNoZSgpLCBLbih0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJDYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICAgICAgdGhpcy5fc2NvcGVDYWNoZS5jbGVhcigpLCB0aGlzLl9yZXNvbHZlckNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhdGFzZXRTY29wZUtleXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF0YXNldFNjb3BlS2V5cyh0KSB7XG4gICAgICByZXR1cm4gQWUodCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1tcImRhdGFzZXRzLlwiLmNvbmNhdCh0KSwgXCJcIl1dO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhdGFzZXRBbmltYXRpb25TY29wZUtleXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyh0LCBlKSB7XG4gICAgICByZXR1cm4gQWUoXCJcIi5jb25jYXQodCwgXCIudHJhbnNpdGlvbi5cIikuY29uY2F0KGUpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbW1wiZGF0YXNldHMuXCIuY29uY2F0KHQsIFwiLnRyYW5zaXRpb25zLlwiKS5jb25jYXQoZSksIFwidHJhbnNpdGlvbnMuXCIuY29uY2F0KGUpXSwgW1wiZGF0YXNldHMuXCIuY29uY2F0KHQpLCBcIlwiXV07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0YXNldEVsZW1lbnRTY29wZUtleXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF0YXNldEVsZW1lbnRTY29wZUtleXModCwgZSkge1xuICAgICAgcmV0dXJuIEFlKFwiXCIuY29uY2F0KHQsIFwiLVwiKS5jb25jYXQoZSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtbXCJkYXRhc2V0cy5cIi5jb25jYXQodCwgXCIuZWxlbWVudHMuXCIpLmNvbmNhdChlKSwgXCJkYXRhc2V0cy5cIi5jb25jYXQodCksIFwiZWxlbWVudHMuXCIuY29uY2F0KGUpLCBcIlwiXV07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGx1Z2luU2NvcGVLZXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsdWdpblNjb3BlS2V5cyh0KSB7XG4gICAgICB2YXIgZSA9IHQuaWQsXG4gICAgICAgIHMgPSB0aGlzLnR5cGU7XG4gICAgICByZXR1cm4gQWUoXCJcIi5jb25jYXQocywgXCItcGx1Z2luLVwiKS5jb25jYXQoZSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtbXCJwbHVnaW5zLlwiLmNvbmNhdChlKV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0LmFkZGl0aW9uYWxPcHRpb25TY29wZXMgfHwgW10pKV07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhY2hlZFNjb3Blc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FjaGVkU2NvcGVzKHQsIGUpIHtcbiAgICAgIHZhciBzID0gdGhpcy5fc2NvcGVDYWNoZTtcbiAgICAgIHZhciBuID0gcy5nZXQodCk7XG4gICAgICByZXR1cm4gKCFuIHx8IGUpICYmIChuID0gLyogQF9fUFVSRV9fICovbmV3IE1hcCgpLCBzLnNldCh0LCBuKSksIG47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9wdGlvblNjb3Blc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcHRpb25TY29wZXModCwgZSwgcykge1xuICAgICAgdmFyIG4gPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIG8gPSB0aGlzLnR5cGUsXG4gICAgICAgIHIgPSB0aGlzLl9jYWNoZWRTY29wZXModCwgcyksXG4gICAgICAgIGEgPSByLmdldChlKTtcbiAgICAgIGlmIChhKSByZXR1cm4gYTtcbiAgICAgIHZhciBsID0gLyogQF9fUFVSRV9fICovbmV3IFNldCgpO1xuICAgICAgZS5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHQgJiYgKGwuYWRkKHQpLCBoLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gc2UobCwgdCwgZCk7XG4gICAgICAgIH0pKSwgaC5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIHNlKGwsIG4sIGQpO1xuICAgICAgICB9KSwgaC5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIHNlKGwsIHp0W29dIHx8IHt9LCBkKTtcbiAgICAgICAgfSksIGguZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBzZShsLCBXLCBkKTtcbiAgICAgICAgfSksIGguZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBzZShsLCBNaSwgZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB2YXIgYyA9IEFycmF5LmZyb20obCk7XG4gICAgICByZXR1cm4gYy5sZW5ndGggPT09IDAgJiYgYy5wdXNoKC8qIEBfX1BVUkVfXyAqL09iamVjdC5jcmVhdGUobnVsbCkpLCBKbi5oYXMoZSkgJiYgci5zZXQoZSwgYyksIGM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoYXJ0T3B0aW9uU2NvcGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoYXJ0T3B0aW9uU2NvcGVzKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGUgPSB0aGlzLnR5cGU7XG4gICAgICByZXR1cm4gW3QsIHp0W2VdIHx8IHt9LCBXLmRhdGFzZXRzW2VdIHx8IHt9LCB7XG4gICAgICAgIHR5cGU6IGVcbiAgICAgIH0sIFcsIE1pXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZU5hbWVkT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlTmFtZWRPcHRpb25zKHQsIGUsIHMpIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBbXCJcIl07XG4gICAgICB2YXIgbyA9IHtcbiAgICAgICAgICAkc2hhcmVkOiAhMFxuICAgICAgICB9LFxuICAgICAgICBfSHMgPSBIcyh0aGlzLl9yZXNvbHZlckNhY2hlLCB0LCBuKSxcbiAgICAgICAgciA9IF9Icy5yZXNvbHZlcixcbiAgICAgICAgYSA9IF9Icy5zdWJQcmVmaXhlcztcbiAgICAgIHZhciBsID0gcjtcbiAgICAgIGlmIChDbChyLCBlKSkge1xuICAgICAgICBvLiRzaGFyZWQgPSAhMSwgcyA9IHd0KHMpID8gcygpIDogcztcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZVJlc29sdmVyKHQsIHMsIGEpO1xuICAgICAgICBsID0gcXQociwgcywgYyk7XG4gICAgICB9XG4gICAgICB2YXIgX2l0ZXJhdG9yMjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihlKSxcbiAgICAgICAgX3N0ZXAyMztcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMjMucygpOyAhKF9zdGVwMjMgPSBfaXRlcmF0b3IyMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9jMiA9IF9zdGVwMjMudmFsdWU7XG4gICAgICAgICAgb1tfYzJdID0gbFtfYzJdO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMjMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMjMuZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVJlc29sdmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVJlc29sdmVyKHQsIGUpIHtcbiAgICAgIHZhciBzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXCJcIl07XG4gICAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIF9IczIgPSBIcyh0aGlzLl9yZXNvbHZlckNhY2hlLCB0LCBzKSxcbiAgICAgICAgbyA9IF9IczIucmVzb2x2ZXI7XG4gICAgICByZXR1cm4gVChlKSA/IHF0KG8sIGUsIHZvaWQgMCwgbikgOiBvO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuZnVuY3Rpb24gSHMoaSwgdCwgZSkge1xuICB2YXIgcyA9IGkuZ2V0KHQpO1xuICBzIHx8IChzID0gLyogQF9fUFVSRV9fICovbmV3IE1hcCgpLCBpLnNldCh0LCBzKSk7XG4gIHZhciBuID0gZS5qb2luKCk7XG4gIHZhciBvID0gcy5nZXQobik7XG4gIHJldHVybiBvIHx8IChvID0ge1xuICAgIHJlc29sdmVyOiBOaSh0LCBlKSxcbiAgICBzdWJQcmVmaXhlczogZS5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiAhYS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiaG92ZXJcIik7XG4gICAgfSlcbiAgfSwgcy5zZXQobiwgbykpLCBvO1xufVxudmFyIERsID0gZnVuY3Rpb24gRGwoaSkge1xuICByZXR1cm4gVChpKSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpKS5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHd0KGlbdF0pO1xuICB9KTtcbn07XG5mdW5jdGlvbiBDbChpLCB0KSB7XG4gIHZhciBfVG4gPSBUbihpKSxcbiAgICBlID0gX1RuLmlzU2NyaXB0YWJsZSxcbiAgICBzID0gX1RuLmlzSW5kZXhhYmxlO1xuICB2YXIgX2l0ZXJhdG9yMjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0KSxcbiAgICBfc3RlcDI0O1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMjQucygpOyAhKF9zdGVwMjQgPSBfaXRlcmF0b3IyNC5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgbiA9IF9zdGVwMjQudmFsdWU7XG4gICAgICB2YXIgbyA9IGUobiksXG4gICAgICAgIHIgPSBzKG4pLFxuICAgICAgICBhID0gKHIgfHwgbykgJiYgaVtuXTtcbiAgICAgIGlmIChvICYmICh3dChhKSB8fCBEbChhKSkgfHwgciAmJiBOKGEpKSByZXR1cm4gITA7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IyNC5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMjQuZigpO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbnZhciBPbCA9IFwiNC41LjFcIjtcbnZhciBUbCA9IFtcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcImNoYXJ0QXJlYVwiXTtcbmZ1bmN0aW9uIFdzKGksIHQpIHtcbiAgcmV0dXJuIGkgPT09IFwidG9wXCIgfHwgaSA9PT0gXCJib3R0b21cIiB8fCBUbC5pbmRleE9mKGkpID09PSAtMSAmJiB0ID09PSBcInhcIjtcbn1cbmZ1bmN0aW9uIE5zKGksIHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlLCBzKSB7XG4gICAgcmV0dXJuIGVbaV0gPT09IHNbaV0gPyBlW3RdIC0gc1t0XSA6IGVbaV0gLSBzW2ldO1xuICB9O1xufVxuZnVuY3Rpb24gVnMoaSkge1xuICB2YXIgdCA9IGkuY2hhcnQsXG4gICAgZSA9IHQub3B0aW9ucy5hbmltYXRpb247XG4gIHQubm90aWZ5UGx1Z2lucyhcImFmdGVyUmVuZGVyXCIpLCBJKGUgJiYgZS5vbkNvbXBsZXRlLCBbaV0sIHQpO1xufVxuZnVuY3Rpb24gQWwoaSkge1xuICB2YXIgdCA9IGkuY2hhcnQsXG4gICAgZSA9IHQub3B0aW9ucy5hbmltYXRpb247XG4gIEkoZSAmJiBlLm9uUHJvZ3Jlc3MsIFtpXSwgdCk7XG59XG5mdW5jdGlvbiBabihpKSB7XG4gIHJldHVybiAkaSgpICYmIHR5cGVvZiBpID09IFwic3RyaW5nXCIgPyBpID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaSkgOiBpICYmIGkubGVuZ3RoICYmIChpID0gaVswXSksIGkgJiYgaS5jYW52YXMgJiYgKGkgPSBpLmNhbnZhcyksIGk7XG59XG52YXIgQmUgPSB7fSxcbiAganMgPSBmdW5jdGlvbiBqcyhpKSB7XG4gICAgdmFyIHQgPSBabihpKTtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhCZSkuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZS5jYW52YXMgPT09IHQ7XG4gICAgfSkucG9wKCk7XG4gIH07XG5mdW5jdGlvbiBSbChpLCB0LCBlKSB7XG4gIHZhciBzID0gT2JqZWN0LmtleXMoaSk7XG4gIGZvciAodmFyIF9pNCA9IDAsIF9zMiA9IHM7IF9pNCA8IF9zMi5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIG4gPSBfczJbX2k0XTtcbiAgICB2YXIgbyA9ICtuO1xuICAgIGlmIChvID49IHQpIHtcbiAgICAgIHZhciByID0gaVtuXTtcbiAgICAgIGRlbGV0ZSBpW25dLCAoZSA+IDAgfHwgbyA+IHQpICYmIChpW28gKyBlXSA9IHIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gTGwoaSwgdCwgZSwgcykge1xuICByZXR1cm4gIWUgfHwgaS50eXBlID09PSBcIm1vdXNlb3V0XCIgPyBudWxsIDogcyA/IHQgOiBpO1xufVxudmFyIG10ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gbXQodCwgZSkge1xuICAgIHZhciBfdGhpczEgPSB0aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBtdCk7XG4gICAgdmFyIHMgPSB0aGlzLmNvbmZpZyA9IG5ldyBQbChlKSxcbiAgICAgIG4gPSBabih0KSxcbiAgICAgIG8gPSBqcyhuKTtcbiAgICBpZiAobykgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIGFscmVhZHkgaW4gdXNlLiBDaGFydCB3aXRoIElEICdcIiArIG8uaWQgKyBcIicgbXVzdCBiZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjYW52YXMgd2l0aCBJRCAnXCIgKyBvLmNhbnZhcy5pZCArIFwiJyBjYW4gYmUgcmV1c2VkLlwiKTtcbiAgICB2YXIgciA9IHMuY3JlYXRlUmVzb2x2ZXIocy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5wbGF0Zm9ybSA9IG5ldyAocy5wbGF0Zm9ybSB8fCBKYShuKSkoKSwgdGhpcy5wbGF0Zm9ybS51cGRhdGVDb25maWcocyk7XG4gICAgdmFyIGEgPSB0aGlzLnBsYXRmb3JtLmFjcXVpcmVDb250ZXh0KG4sIHIuYXNwZWN0UmF0aW8pLFxuICAgICAgbCA9IGEgJiYgYS5jYW52YXMsXG4gICAgICBjID0gbCAmJiBsLmhlaWdodCxcbiAgICAgIGggPSBsICYmIGwud2lkdGg7XG4gICAgaWYgKHRoaXMuaWQgPSBMbygpLCB0aGlzLmN0eCA9IGEsIHRoaXMuY2FudmFzID0gbCwgdGhpcy53aWR0aCA9IGgsIHRoaXMuaGVpZ2h0ID0gYywgdGhpcy5fb3B0aW9ucyA9IHIsIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbywgdGhpcy5fbGF5ZXJzID0gW10sIHRoaXMuX21ldGFzZXRzID0gW10sIHRoaXMuX3N0YWNrcyA9IHZvaWQgMCwgdGhpcy5ib3hlcyA9IFtdLCB0aGlzLmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gdm9pZCAwLCB0aGlzLmNoYXJ0QXJlYSA9IHZvaWQgMCwgdGhpcy5fYWN0aXZlID0gW10sIHRoaXMuX2xhc3RFdmVudCA9IHZvaWQgMCwgdGhpcy5fbGlzdGVuZXJzID0ge30sIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB2b2lkIDAsIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gW10sIHRoaXMuc2NhbGVzID0ge30sIHRoaXMuX3BsdWdpbnMgPSBuZXcgcGwoKSwgdGhpcy4kcHJveGllcyA9IHt9LCB0aGlzLl9oaWRkZW5JbmRpY2VzID0ge30sIHRoaXMuYXR0YWNoZWQgPSAhMSwgdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gdm9pZCAwLCB0aGlzLiRjb250ZXh0ID0gdm9pZCAwLCB0aGlzLl9kb1Jlc2l6ZSA9IFpvKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gX3RoaXMxLnVwZGF0ZShkKTtcbiAgICB9LCByLnJlc2l6ZURlbGF5IHx8IDApLCB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdLCBCZVt0aGlzLmlkXSA9IHRoaXMsICFhIHx8ICFsKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFydDogY2FuJ3QgYWNxdWlyZSBjb250ZXh0IGZyb20gdGhlIGdpdmVuIGl0ZW1cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHV0Lmxpc3Rlbih0aGlzLCBcImNvbXBsZXRlXCIsIFZzKSwgdXQubGlzdGVuKHRoaXMsIFwicHJvZ3Jlc3NcIiwgQWwpLCB0aGlzLl9pbml0aWFsaXplKCksIHRoaXMuYXR0YWNoZWQgJiYgdGhpcy51cGRhdGUoKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKG10LCBbe1xuICAgIGtleTogXCJhc3BlY3RSYXRpb1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF90aGlzJG9wdGlvbnMxMCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgdCA9IF90aGlzJG9wdGlvbnMxMC5hc3BlY3RSYXRpbyxcbiAgICAgICAgZSA9IF90aGlzJG9wdGlvbnMxMC5tYWludGFpbkFzcGVjdFJhdGlvLFxuICAgICAgICBzID0gdGhpcy53aWR0aCxcbiAgICAgICAgbiA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICBvID0gdGhpcy5fYXNwZWN0UmF0aW87XG4gICAgICByZXR1cm4gUih0KSA/IGUgJiYgbyA/IG8gOiBuID8gcyAvIG4gOiBudWxsIDogdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0YVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGE7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0KSB7XG4gICAgICB0aGlzLmNvbmZpZy5kYXRhID0gdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0KSB7XG4gICAgICB0aGlzLmNvbmZpZy5vcHRpb25zID0gdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVnaXN0cnlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBhdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRpYWxpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RpZnlQbHVnaW5zKFwiYmVmb3JlSW5pdFwiKSwgdGhpcy5vcHRpb25zLnJlc3BvbnNpdmUgPyB0aGlzLnJlc2l6ZSgpIDogdXModGhpcywgdGhpcy5vcHRpb25zLmRldmljZVBpeGVsUmF0aW8pLCB0aGlzLmJpbmRFdmVudHMoKSwgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYWZ0ZXJJbml0XCIpLCB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHJldHVybiBjcyh0aGlzLmNhbnZhcywgdGhpcy5jdHgpLCB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICByZXR1cm4gdXQuc3RvcCh0aGlzKSwgdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZSh0LCBlKSB7XG4gICAgICB1dC5ydW5uaW5nKHRoaXMpID8gdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IHtcbiAgICAgICAgd2lkdGg6IHQsXG4gICAgICAgIGhlaWdodDogZVxuICAgICAgfSA6IHRoaXMuX3Jlc2l6ZSh0LCBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKHQsIGUpIHtcbiAgICAgIHZhciBzID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBuID0gdGhpcy5jYW52YXMsXG4gICAgICAgIG8gPSBzLm1haW50YWluQXNwZWN0UmF0aW8gJiYgdGhpcy5hc3BlY3RSYXRpbyxcbiAgICAgICAgciA9IHRoaXMucGxhdGZvcm0uZ2V0TWF4aW11bVNpemUobiwgdCwgZSwgbyksXG4gICAgICAgIGEgPSBzLmRldmljZVBpeGVsUmF0aW8gfHwgdGhpcy5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCksXG4gICAgICAgIGwgPSB0aGlzLndpZHRoID8gXCJyZXNpemVcIiA6IFwiYXR0YWNoXCI7XG4gICAgICB0aGlzLndpZHRoID0gci53aWR0aCwgdGhpcy5oZWlnaHQgPSByLmhlaWdodCwgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvLCB1cyh0aGlzLCBhLCAhMCkgJiYgKHRoaXMubm90aWZ5UGx1Z2lucyhcInJlc2l6ZVwiLCB7XG4gICAgICAgIHNpemU6IHJcbiAgICAgIH0pLCBJKHMub25SZXNpemUsIFt0aGlzLCByXSwgdGhpcyksIHRoaXMuYXR0YWNoZWQgJiYgdGhpcy5fZG9SZXNpemUobCkgJiYgdGhpcy5yZW5kZXIoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuc3VyZVNjYWxlc0hhdmVJRHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5zdXJlU2NhbGVzSGF2ZUlEcygpIHtcbiAgICAgIHZhciBlID0gdGhpcy5vcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgICAgIEwoZSwgZnVuY3Rpb24gKHMsIG4pIHtcbiAgICAgICAgcy5pZCA9IG47XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRPclVwZGF0ZVNjYWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZE9yVXBkYXRlU2NhbGVzKCkge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGUgPSB0LnNjYWxlcyxcbiAgICAgICAgcyA9IHRoaXMuc2NhbGVzLFxuICAgICAgICBuID0gT2JqZWN0LmtleXMocykucmVkdWNlKGZ1bmN0aW9uIChyLCBhKSB7XG4gICAgICAgICAgcmV0dXJuIHJbYV0gPSAhMSwgcjtcbiAgICAgICAgfSwge30pO1xuICAgICAgdmFyIG8gPSBbXTtcbiAgICAgIGUgJiYgKG8gPSBvLmNvbmNhdChPYmplY3Qua2V5cyhlKS5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgdmFyIGEgPSBlW3JdLFxuICAgICAgICAgIGwgPSBQaShyLCBhKSxcbiAgICAgICAgICBjID0gbCA9PT0gXCJyXCIsXG4gICAgICAgICAgaCA9IGwgPT09IFwieFwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9wdGlvbnM6IGEsXG4gICAgICAgICAgZHBvc2l0aW9uOiBjID8gXCJjaGFydEFyZWFcIiA6IGggPyBcImJvdHRvbVwiIDogXCJsZWZ0XCIsXG4gICAgICAgICAgZHR5cGU6IGMgPyBcInJhZGlhbExpbmVhclwiIDogaCA/IFwiY2F0ZWdvcnlcIiA6IFwibGluZWFyXCJcbiAgICAgICAgfTtcbiAgICAgIH0pKSksIEwobywgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgdmFyIGEgPSByLm9wdGlvbnMsXG4gICAgICAgICAgbCA9IGEuaWQsXG4gICAgICAgICAgYyA9IFBpKGwsIGEpLFxuICAgICAgICAgIGggPSBEKGEudHlwZSwgci5kdHlwZSk7XG4gICAgICAgIChhLnBvc2l0aW9uID09PSB2b2lkIDAgfHwgV3MoYS5wb3NpdGlvbiwgYykgIT09IFdzKHIuZHBvc2l0aW9uKSkgJiYgKGEucG9zaXRpb24gPSByLmRwb3NpdGlvbiksIG5bbF0gPSAhMDtcbiAgICAgICAgdmFyIGQgPSBudWxsO1xuICAgICAgICBpZiAobCBpbiBzICYmIHNbbF0udHlwZSA9PT0gaCkgZCA9IHNbbF07ZWxzZSB7XG4gICAgICAgICAgdmFyIHUgPSBhdC5nZXRTY2FsZShoKTtcbiAgICAgICAgICBkID0gbmV3IHUoe1xuICAgICAgICAgICAgaWQ6IGwsXG4gICAgICAgICAgICB0eXBlOiBoLFxuICAgICAgICAgICAgY3R4OiBfdGhpczEwLmN0eCxcbiAgICAgICAgICAgIGNoYXJ0OiBfdGhpczEwXG4gICAgICAgICAgfSksIHNbZC5pZF0gPSBkO1xuICAgICAgICB9XG4gICAgICAgIGQuaW5pdChhLCB0KTtcbiAgICAgIH0pLCBMKG4sIGZ1bmN0aW9uIChyLCBhKSB7XG4gICAgICAgIHIgfHwgZGVsZXRlIHNbYV07XG4gICAgICB9KSwgTChzLCBmdW5jdGlvbiAocikge1xuICAgICAgICB0dC5jb25maWd1cmUoX3RoaXMxMCwgciwgci5vcHRpb25zKSwgdHQuYWRkQm94KF90aGlzMTAsIHIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVNZXRhc2V0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlTWV0YXNldHMoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX21ldGFzZXRzLFxuICAgICAgICBlID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aCxcbiAgICAgICAgcyA9IHQubGVuZ3RoO1xuICAgICAgaWYgKHQuc29ydChmdW5jdGlvbiAobiwgbykge1xuICAgICAgICByZXR1cm4gbi5pbmRleCAtIG8uaW5kZXg7XG4gICAgICB9KSwgcyA+IGUpIHtcbiAgICAgICAgZm9yICh2YXIgbiA9IGU7IG4gPCBzOyArK24pIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShuKTtcbiAgICAgICAgdC5zcGxpY2UoZSwgcyAtIGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSB0LnNsaWNlKDApLnNvcnQoTnMoXCJvcmRlclwiLCBcImluZGV4XCIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpIHtcbiAgICAgIHZhciBfdGhpczExID0gdGhpcztcbiAgICAgIHZhciB0ID0gdGhpcy5fbWV0YXNldHMsXG4gICAgICAgIGUgPSB0aGlzLmRhdGEuZGF0YXNldHM7XG4gICAgICB0Lmxlbmd0aCA+IGUubGVuZ3RoICYmIGRlbGV0ZSB0aGlzLl9zdGFja3MsIHQuZm9yRWFjaChmdW5jdGlvbiAocywgbikge1xuICAgICAgICBlLmZpbHRlcihmdW5jdGlvbiAobykge1xuICAgICAgICAgIHJldHVybiBvID09PSBzLl9kYXRhc2V0O1xuICAgICAgICB9KS5sZW5ndGggPT09IDAgJiYgX3RoaXMxMS5fZGVzdHJveURhdGFzZXRNZXRhKG4pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkT3JVcGRhdGVDb250cm9sbGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKSB7XG4gICAgICB2YXIgdCA9IFtdLFxuICAgICAgICBlID0gdGhpcy5kYXRhLmRhdGFzZXRzO1xuICAgICAgdmFyIHMsIG47XG4gICAgICBmb3IgKHRoaXMuX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCksIHMgPSAwLCBuID0gZS5sZW5ndGg7IHMgPCBuOyBzKyspIHtcbiAgICAgICAgdmFyIG8gPSBlW3NdO1xuICAgICAgICB2YXIgciA9IHRoaXMuZ2V0RGF0YXNldE1ldGEocyk7XG4gICAgICAgIHZhciBhID0gby50eXBlIHx8IHRoaXMuY29uZmlnLnR5cGU7XG4gICAgICAgIGlmIChyLnR5cGUgJiYgci50eXBlICE9PSBhICYmICh0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEocyksIHIgPSB0aGlzLmdldERhdGFzZXRNZXRhKHMpKSwgci50eXBlID0gYSwgci5pbmRleEF4aXMgPSBvLmluZGV4QXhpcyB8fCB3aShhLCB0aGlzLm9wdGlvbnMpLCByLm9yZGVyID0gby5vcmRlciB8fCAwLCByLmluZGV4ID0gcywgci5sYWJlbCA9IFwiXCIgKyBvLmxhYmVsLCByLnZpc2libGUgPSB0aGlzLmlzRGF0YXNldFZpc2libGUocyksIHIuY29udHJvbGxlcikgci5jb250cm9sbGVyLnVwZGF0ZUluZGV4KHMpLCByLmNvbnRyb2xsZXIubGlua1NjYWxlcygpO2Vsc2Uge1xuICAgICAgICAgIHZhciBsID0gYXQuZ2V0Q29udHJvbGxlcihhKSxcbiAgICAgICAgICAgIF9XJGRhdGFzZXRzJGEgPSBXLmRhdGFzZXRzW2FdLFxuICAgICAgICAgICAgYyA9IF9XJGRhdGFzZXRzJGEuZGF0YXNldEVsZW1lbnRUeXBlLFxuICAgICAgICAgICAgaCA9IF9XJGRhdGFzZXRzJGEuZGF0YUVsZW1lbnRUeXBlO1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24obCwge1xuICAgICAgICAgICAgZGF0YUVsZW1lbnRUeXBlOiBhdC5nZXRFbGVtZW50KGgpLFxuICAgICAgICAgICAgZGF0YXNldEVsZW1lbnRUeXBlOiBjICYmIGF0LmdldEVsZW1lbnQoYylcbiAgICAgICAgICB9KSwgci5jb250cm9sbGVyID0gbmV3IGwodGhpcywgcyksIHQucHVzaChyLmNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fdXBkYXRlTWV0YXNldHMoKSwgdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2V0RWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2V0RWxlbWVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMxMiA9IHRoaXM7XG4gICAgICBMKHRoaXMuZGF0YS5kYXRhc2V0cywgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgX3RoaXMxMi5nZXREYXRhc2V0TWV0YShlKS5jb250cm9sbGVyLnJlc2V0KCk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLl9yZXNldEVsZW1lbnRzKCksIHRoaXMubm90aWZ5UGx1Z2lucyhcInJlc2V0XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5jb25maWc7XG4gICAgICBlLnVwZGF0ZSgpO1xuICAgICAgdmFyIHMgPSB0aGlzLl9vcHRpb25zID0gZS5jcmVhdGVSZXNvbHZlcihlLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKSxcbiAgICAgICAgbiA9IHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9ICFzLmFuaW1hdGlvbjtcbiAgICAgIGlmICh0aGlzLl91cGRhdGVTY2FsZXMoKSwgdGhpcy5fY2hlY2tFdmVudEJpbmRpbmdzKCksIHRoaXMuX3VwZGF0ZUhpZGRlbkluZGljZXMoKSwgdGhpcy5fcGx1Z2lucy5pbnZhbGlkYXRlKCksIHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZVVwZGF0ZVwiLCB7XG4gICAgICAgIG1vZGU6IHQsXG4gICAgICAgIGNhbmNlbGFibGU6ICEwXG4gICAgICB9KSA9PT0gITEpIHJldHVybjtcbiAgICAgIHZhciBvID0gdGhpcy5idWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKTtcbiAgICAgIHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZUVsZW1lbnRzVXBkYXRlXCIpO1xuICAgICAgdmFyIHIgPSAwO1xuICAgICAgZm9yICh2YXIgYyA9IDAsIGggPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBjIDwgaDsgYysrKSB7XG4gICAgICAgIHZhciBfdGhpcyRnZXREYXRhc2V0TWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoYyksXG4gICAgICAgICAgZCA9IF90aGlzJGdldERhdGFzZXRNZXRhLmNvbnRyb2xsZXIsXG4gICAgICAgICAgdSA9ICFuICYmIG8uaW5kZXhPZihkKSA9PT0gLTE7XG4gICAgICAgIGQuYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHUpLCByID0gTWF0aC5tYXgoK2QuZ2V0TWF4T3ZlcmZsb3coKSwgcik7XG4gICAgICB9XG4gICAgICByID0gdGhpcy5fbWluUGFkZGluZyA9IHMubGF5b3V0LmF1dG9QYWRkaW5nID8gciA6IDAsIHRoaXMuX3VwZGF0ZUxheW91dChyKSwgbiB8fCBMKG8sIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGMucmVzZXQoKTtcbiAgICAgIH0pLCB0aGlzLl91cGRhdGVEYXRhc2V0cyh0KSwgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYWZ0ZXJVcGRhdGVcIiwge1xuICAgICAgICBtb2RlOiB0XG4gICAgICB9KSwgdGhpcy5fbGF5ZXJzLnNvcnQoTnMoXCJ6XCIsIFwiX2lkeFwiKSk7XG4gICAgICB2YXIgYSA9IHRoaXMuX2FjdGl2ZSxcbiAgICAgICAgbCA9IHRoaXMuX2xhc3RFdmVudDtcbiAgICAgIGwgPyB0aGlzLl9ldmVudEhhbmRsZXIobCwgITApIDogYS5sZW5ndGggJiYgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYSwgYSwgITApLCB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlU2NhbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVTY2FsZXMoKSB7XG4gICAgICB2YXIgX3RoaXMxMyA9IHRoaXM7XG4gICAgICBMKHRoaXMuc2NhbGVzLCBmdW5jdGlvbiAodCkge1xuICAgICAgICB0dC5yZW1vdmVCb3goX3RoaXMxMywgdCk7XG4gICAgICB9KSwgdGhpcy5lbnN1cmVTY2FsZXNIYXZlSURzKCksIHRoaXMuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2hlY2tFdmVudEJpbmRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja0V2ZW50QmluZGluZ3MoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZSA9IG5ldyBTZXQoT2JqZWN0LmtleXModGhpcy5fbGlzdGVuZXJzKSksXG4gICAgICAgIHMgPSBuZXcgU2V0KHQuZXZlbnRzKTtcbiAgICAgICghUWkoZSwgcykgfHwgISF0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzICE9PSB0LnJlc3BvbnNpdmUpICYmICh0aGlzLnVuYmluZEV2ZW50cygpLCB0aGlzLmJpbmRFdmVudHMoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVIaWRkZW5JbmRpY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVIaWRkZW5JbmRpY2VzKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9oaWRkZW5JbmRpY2VzLFxuICAgICAgICBlID0gdGhpcy5fZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkgfHwgW107XG4gICAgICB2YXIgX2l0ZXJhdG9yMjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihlKSxcbiAgICAgICAgX3N0ZXAyNTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMjUucygpOyAhKF9zdGVwMjUgPSBfaXRlcmF0b3IyNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwMjUkdmFsdWUgPSBfc3RlcDI1LnZhbHVlLFxuICAgICAgICAgICAgcyA9IF9zdGVwMjUkdmFsdWUubWV0aG9kLFxuICAgICAgICAgICAgbiA9IF9zdGVwMjUkdmFsdWUuc3RhcnQsXG4gICAgICAgICAgICBvID0gX3N0ZXAyNSR2YWx1ZS5jb3VudDtcbiAgICAgICAgICB2YXIgciA9IHMgPT09IFwiX3JlbW92ZUVsZW1lbnRzXCIgPyAtbyA6IG87XG4gICAgICAgICAgUmwodCwgbiwgcik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyNS5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyNS5mKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRVbmlmb3JtRGF0YUNoYW5nZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fZGF0YUNoYW5nZXM7XG4gICAgICBpZiAoIXQgfHwgIXQubGVuZ3RoKSByZXR1cm47XG4gICAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuICAgICAgdmFyIGUgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoLFxuICAgICAgICBzID0gZnVuY3Rpb24gcyhvKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXQodC5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHJldHVybiByWzBdID09PSBvO1xuICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAociwgYSkge1xuICAgICAgICAgICAgcmV0dXJuIGEgKyBcIixcIiArIHIuc3BsaWNlKDEpLmpvaW4oXCIsXCIpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgbiA9IHMoMCk7XG4gICAgICBmb3IgKHZhciBvID0gMTsgbyA8IGU7IG8rKykgaWYgKCFRaShuLCBzKG8pKSkgcmV0dXJuO1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20obikubWFwKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBvLnNwbGl0KFwiLFwiKTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1ldGhvZDogb1sxXSxcbiAgICAgICAgICBzdGFydDogK29bMl0sXG4gICAgICAgICAgY291bnQ6ICtvWzNdXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZUxheW91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlTGF5b3V0KHQpIHtcbiAgICAgIHZhciBfdGhpczE0ID0gdGhpcztcbiAgICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoXCJiZWZvcmVMYXlvdXRcIiwge1xuICAgICAgICBjYW5jZWxhYmxlOiAhMFxuICAgICAgfSkgPT09ICExKSByZXR1cm47XG4gICAgICB0dC51cGRhdGUodGhpcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHQpO1xuICAgICAgdmFyIGUgPSB0aGlzLmNoYXJ0QXJlYSxcbiAgICAgICAgcyA9IGUud2lkdGggPD0gMCB8fCBlLmhlaWdodCA8PSAwO1xuICAgICAgdGhpcy5fbGF5ZXJzID0gW10sIEwodGhpcy5ib3hlcywgZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdmFyIF90aGlzMTQkX2xheWVycztcbiAgICAgICAgcyAmJiBuLnBvc2l0aW9uID09PSBcImNoYXJ0QXJlYVwiIHx8IChuLmNvbmZpZ3VyZSAmJiBuLmNvbmZpZ3VyZSgpLCAoX3RoaXMxNCRfbGF5ZXJzID0gX3RoaXMxNC5fbGF5ZXJzKS5wdXNoLmFwcGx5KF90aGlzMTQkX2xheWVycywgX3RvQ29uc3VtYWJsZUFycmF5KG4uX2xheWVycygpKSkpO1xuICAgICAgfSwgdGhpcyksIHRoaXMuX2xheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChuLCBvKSB7XG4gICAgICAgIG4uX2lkeCA9IG87XG4gICAgICB9KSwgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYWZ0ZXJMYXlvdXRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVEYXRhc2V0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlRGF0YXNldHModCkge1xuICAgICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZURhdGFzZXRzVXBkYXRlXCIsIHtcbiAgICAgICAgbW9kZTogdCxcbiAgICAgICAgY2FuY2VsYWJsZTogITBcbiAgICAgIH0pICE9PSAhMSkge1xuICAgICAgICBmb3IgKHZhciBlID0gMCwgcyA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGUgPCBzOyArK2UpIHRoaXMuZ2V0RGF0YXNldE1ldGEoZSkuY29udHJvbGxlci5jb25maWd1cmUoKTtcbiAgICAgICAgZm9yICh2YXIgX2UzID0gMCwgX3MzID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgX2UzIDwgX3MzOyArK19lMykgdGhpcy5fdXBkYXRlRGF0YXNldChfZTMsIHd0KHQpID8gdCh7XG4gICAgICAgICAgZGF0YXNldEluZGV4OiBfZTNcbiAgICAgICAgfSkgOiB0KTtcbiAgICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYWZ0ZXJEYXRhc2V0c1VwZGF0ZVwiLCB7XG4gICAgICAgICAgbW9kZTogdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZURhdGFzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZURhdGFzZXQodCwgZSkge1xuICAgICAgdmFyIHMgPSB0aGlzLmdldERhdGFzZXRNZXRhKHQpLFxuICAgICAgICBuID0ge1xuICAgICAgICAgIG1ldGE6IHMsXG4gICAgICAgICAgaW5kZXg6IHQsXG4gICAgICAgICAgbW9kZTogZSxcbiAgICAgICAgICBjYW5jZWxhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYmVmb3JlRGF0YXNldFVwZGF0ZVwiLCBuKSAhPT0gITEgJiYgKHMuY29udHJvbGxlci5fdXBkYXRlKGUpLCBuLmNhbmNlbGFibGUgPSAhMSwgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYWZ0ZXJEYXRhc2V0VXBkYXRlXCIsIG4pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZVJlbmRlclwiLCB7XG4gICAgICAgIGNhbmNlbGFibGU6ICEwXG4gICAgICB9KSAhPT0gITEgJiYgKHV0Lmhhcyh0aGlzKSA/IHRoaXMuYXR0YWNoZWQgJiYgIXV0LnJ1bm5pbmcodGhpcykgJiYgdXQuc3RhcnQodGhpcykgOiAodGhpcy5kcmF3KCksIFZzKHtcbiAgICAgICAgY2hhcnQ6IHRoaXNcbiAgICAgIH0pKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgIHZhciB0O1xuICAgICAgaWYgKHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcpIHtcbiAgICAgICAgdmFyIF90aGlzJF9yZXNpemVCZWZvcmVEciA9IHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcsXG4gICAgICAgICAgcyA9IF90aGlzJF9yZXNpemVCZWZvcmVEci53aWR0aCxcbiAgICAgICAgICBuID0gX3RoaXMkX3Jlc2l6ZUJlZm9yZURyLmhlaWdodDtcbiAgICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IG51bGwsIHRoaXMuX3Jlc2l6ZShzLCBuKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNsZWFyKCksIHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwIHx8IHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZURyYXdcIiwge1xuICAgICAgICBjYW5jZWxhYmxlOiAhMFxuICAgICAgfSkgPT09ICExKSByZXR1cm47XG4gICAgICB2YXIgZSA9IHRoaXMuX2xheWVycztcbiAgICAgIGZvciAodCA9IDA7IHQgPCBlLmxlbmd0aCAmJiBlW3RdLnogPD0gMDsgKyt0KSBlW3RdLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgICAgZm9yICh0aGlzLl9kcmF3RGF0YXNldHMoKTsgdCA8IGUubGVuZ3RoOyArK3QpIGVbdF0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoXCJhZnRlckRyYXdcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRTb3J0ZWREYXRhc2V0TWV0YXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX3NvcnRlZE1ldGFzZXRzLFxuICAgICAgICBzID0gW107XG4gICAgICB2YXIgbiwgbztcbiAgICAgIGZvciAobiA9IDAsIG8gPSBlLmxlbmd0aDsgbiA8IG87ICsrbikge1xuICAgICAgICB2YXIgciA9IGVbbl07XG4gICAgICAgICghdCB8fCByLnZpc2libGUpICYmIHMucHVzaChyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKCEwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdEYXRhc2V0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0RhdGFzZXRzKCkge1xuICAgICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZURhdGFzZXRzRHJhd1wiLCB7XG4gICAgICAgIGNhbmNlbGFibGU6ICEwXG4gICAgICB9KSA9PT0gITEpIHJldHVybjtcbiAgICAgIHZhciB0ID0gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgICBmb3IgKHZhciBlID0gdC5sZW5ndGggLSAxOyBlID49IDA7IC0tZSkgdGhpcy5fZHJhd0RhdGFzZXQodFtlXSk7XG4gICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoXCJhZnRlckRhdGFzZXRzRHJhd1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdEYXRhc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3RGF0YXNldCh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuY3R4LFxuICAgICAgICBzID0ge1xuICAgICAgICAgIG1ldGE6IHQsXG4gICAgICAgICAgaW5kZXg6IHQuaW5kZXgsXG4gICAgICAgICAgY2FuY2VsYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgbiA9IFduKHRoaXMsIHQpO1xuICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYmVmb3JlRGF0YXNldERyYXdcIiwgcykgIT09ICExICYmIChuICYmIEplKGUsIG4pLCB0LmNvbnRyb2xsZXIuZHJhdygpLCBuICYmIFplKGUpLCBzLmNhbmNlbGFibGUgPSAhMSwgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYWZ0ZXJEYXRhc2V0RHJhd1wiLCBzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUG9pbnRJbkFyZWFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNQb2ludEluQXJlYSh0KSB7XG4gICAgICByZXR1cm4gbWUodCwgdGhpcy5jaGFydEFyZWEsIHRoaXMuX21pblBhZGRpbmcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUodCwgZSwgcywgbikge1xuICAgICAgdmFyIG8gPSBUYS5tb2Rlc1tlXTtcbiAgICAgIHJldHVybiB0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIgPyBvKHRoaXMsIHQsIHMsIG4pIDogW107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERhdGFzZXRNZXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERhdGFzZXRNZXRhKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5kYXRhLmRhdGFzZXRzW3RdLFxuICAgICAgICBzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgICB2YXIgbiA9IHMuZmlsdGVyKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBvICYmIG8uX2RhdGFzZXQgPT09IGU7XG4gICAgICB9KS5wb3AoKTtcbiAgICAgIHJldHVybiBuIHx8IChuID0ge1xuICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgZGF0YXNldDogbnVsbCxcbiAgICAgICAgY29udHJvbGxlcjogbnVsbCxcbiAgICAgICAgaGlkZGVuOiBudWxsLFxuICAgICAgICB4QXhpc0lEOiBudWxsLFxuICAgICAgICB5QXhpc0lEOiBudWxsLFxuICAgICAgICBvcmRlcjogZSAmJiBlLm9yZGVyIHx8IDAsXG4gICAgICAgIGluZGV4OiB0LFxuICAgICAgICBfZGF0YXNldDogZSxcbiAgICAgICAgX3BhcnNlZDogW10sXG4gICAgICAgIF9zb3J0ZWQ6ICExXG4gICAgICB9LCBzLnB1c2gobikpLCBuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fCAodGhpcy4kY29udGV4dCA9IEJ0KG51bGwsIHtcbiAgICAgICAgY2hhcnQ6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiY2hhcnRcIlxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaXNpYmxlRGF0YXNldENvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpc2libGVEYXRhc2V0Q291bnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0RhdGFzZXRWaXNpYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRGF0YXNldFZpc2libGUodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmRhdGEuZGF0YXNldHNbdF07XG4gICAgICBpZiAoIWUpIHJldHVybiAhMTtcbiAgICAgIHZhciBzID0gdGhpcy5nZXREYXRhc2V0TWV0YSh0KTtcbiAgICAgIHJldHVybiB0eXBlb2Ygcy5oaWRkZW4gPT0gXCJib29sZWFuXCIgPyAhcy5oaWRkZW4gOiAhZS5oaWRkZW47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldERhdGFzZXRWaXNpYmlsaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGFzZXRWaXNpYmlsaXR5KHQsIGUpIHtcbiAgICAgIHZhciBzID0gdGhpcy5nZXREYXRhc2V0TWV0YSh0KTtcbiAgICAgIHMuaGlkZGVuID0gIWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZURhdGFWaXNpYmlsaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZURhdGFWaXNpYmlsaXR5KHQpIHtcbiAgICAgIHRoaXMuX2hpZGRlbkluZGljZXNbdF0gPSAhdGhpcy5faGlkZGVuSW5kaWNlc1t0XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGF0YVZpc2liaWxpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGF0YVZpc2liaWxpdHkodCkge1xuICAgICAgcmV0dXJuICF0aGlzLl9oaWRkZW5JbmRpY2VzW3RdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlVmlzaWJpbGl0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlVmlzaWJpbGl0eSh0LCBlLCBzKSB7XG4gICAgICB2YXIgbiA9IHMgPyBcInNob3dcIiA6IFwiaGlkZVwiLFxuICAgICAgICBvID0gdGhpcy5nZXREYXRhc2V0TWV0YSh0KSxcbiAgICAgICAgciA9IG8uY29udHJvbGxlci5fcmVzb2x2ZUFuaW1hdGlvbnModm9pZCAwLCBuKTtcbiAgICAgIGdlKGUpID8gKG8uZGF0YVtlXS5oaWRkZW4gPSAhcywgdGhpcy51cGRhdGUoKSkgOiAodGhpcy5zZXREYXRhc2V0VmlzaWJpbGl0eSh0LCBzKSwgci51cGRhdGUobywge1xuICAgICAgICB2aXNpYmxlOiBzXG4gICAgICB9KSwgdGhpcy51cGRhdGUoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGEuZGF0YXNldEluZGV4ID09PSB0ID8gbiA6IHZvaWQgMDtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKHQsIGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkodCwgZSwgITEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3codCwgZSkge1xuICAgICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eSh0LCBlLCAhMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZXN0cm95RGF0YXNldE1ldGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3lEYXRhc2V0TWV0YSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX21ldGFzZXRzW3RdO1xuICAgICAgZSAmJiBlLmNvbnRyb2xsZXIgJiYgZS5jb250cm9sbGVyLl9kZXN0cm95KCksIGRlbGV0ZSB0aGlzLl9tZXRhc2V0c1t0XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0b3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0b3AoKSB7XG4gICAgICB2YXIgdCwgZTtcbiAgICAgIGZvciAodGhpcy5zdG9wKCksIHV0LnJlbW92ZSh0aGlzKSwgdCA9IDAsIGUgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyB0IDwgZTsgKyt0KSB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZURlc3Ryb3lcIik7XG4gICAgICB2YXIgdCA9IHRoaXMuY2FudmFzLFxuICAgICAgICBlID0gdGhpcy5jdHg7XG4gICAgICB0aGlzLl9zdG9wKCksIHRoaXMuY29uZmlnLmNsZWFyQ2FjaGUoKSwgdCAmJiAodGhpcy51bmJpbmRFdmVudHMoKSwgY3ModCwgZSksIHRoaXMucGxhdGZvcm0ucmVsZWFzZUNvbnRleHQoZSksIHRoaXMuY2FudmFzID0gbnVsbCwgdGhpcy5jdHggPSBudWxsKSwgZGVsZXRlIEJlW3RoaXMuaWRdLCB0aGlzLm5vdGlmeVBsdWdpbnMoXCJhZnRlckRlc3Ryb3lcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvQmFzZTY0SW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9CYXNlNjRJbWFnZSgpIHtcbiAgICAgIHZhciBfdGhpcyRjYW52YXM7XG4gICAgICByZXR1cm4gKF90aGlzJGNhbnZhcyA9IHRoaXMuY2FudmFzKS50b0RhdGFVUkwuYXBwbHkoX3RoaXMkY2FudmFzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiaW5kRXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudHMoKSB7XG4gICAgICB0aGlzLmJpbmRVc2VyRXZlbnRzKCksIHRoaXMub3B0aW9ucy5yZXNwb25zaXZlID8gdGhpcy5iaW5kUmVzcG9uc2l2ZUV2ZW50cygpIDogdGhpcy5hdHRhY2hlZCA9ICEwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiaW5kVXNlckV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kVXNlckV2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpczE1ID0gdGhpcztcbiAgICAgIHZhciB0ID0gdGhpcy5fbGlzdGVuZXJzLFxuICAgICAgICBlID0gdGhpcy5wbGF0Zm9ybSxcbiAgICAgICAgcyA9IGZ1bmN0aW9uIHMobywgcikge1xuICAgICAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcihfdGhpczE1LCBvLCByKSwgdFtvXSA9IHI7XG4gICAgICAgIH0sXG4gICAgICAgIG4gPSBmdW5jdGlvbiBuKG8sIHIsIGEpIHtcbiAgICAgICAgICBvLm9mZnNldFggPSByLCBvLm9mZnNldFkgPSBhLCBfdGhpczE1Ll9ldmVudEhhbmRsZXIobyk7XG4gICAgICAgIH07XG4gICAgICBMKHRoaXMub3B0aW9ucy5ldmVudHMsIGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBzKG8sIG4pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJpbmRSZXNwb25zaXZlRXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRSZXNwb25zaXZlRXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzMTYgPSB0aGlzO1xuICAgICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyB8fCAodGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHt9KTtcbiAgICAgIHZhciB0ID0gdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyxcbiAgICAgICAgZSA9IHRoaXMucGxhdGZvcm0sXG4gICAgICAgIHMgPSBmdW5jdGlvbiBzKGwsIGMpIHtcbiAgICAgICAgICBlLmFkZEV2ZW50TGlzdGVuZXIoX3RoaXMxNiwgbCwgYyksIHRbbF0gPSBjO1xuICAgICAgICB9LFxuICAgICAgICBuID0gZnVuY3Rpb24gbihsLCBjKSB7XG4gICAgICAgICAgdFtsXSAmJiAoZS5yZW1vdmVFdmVudExpc3RlbmVyKF90aGlzMTYsIGwsIGMpLCBkZWxldGUgdFtsXSk7XG4gICAgICAgIH0sXG4gICAgICAgIG8gPSBmdW5jdGlvbiBvKGwsIGMpIHtcbiAgICAgICAgICBfdGhpczE2LmNhbnZhcyAmJiBfdGhpczE2LnJlc2l6ZShsLCBjKTtcbiAgICAgICAgfTtcbiAgICAgIHZhciByO1xuICAgICAgdmFyIF9hMiA9IGZ1bmN0aW9uIGEoKSB7XG4gICAgICAgIG4oXCJhdHRhY2hcIiwgX2EyKSwgX3RoaXMxNi5hdHRhY2hlZCA9ICEwLCBfdGhpczE2LnJlc2l6ZSgpLCBzKFwicmVzaXplXCIsIG8pLCBzKFwiZGV0YWNoXCIsIHIpO1xuICAgICAgfTtcbiAgICAgIHIgPSBmdW5jdGlvbiByKCkge1xuICAgICAgICBfdGhpczE2LmF0dGFjaGVkID0gITEsIG4oXCJyZXNpemVcIiwgbyksIF90aGlzMTYuX3N0b3AoKSwgX3RoaXMxNi5fcmVzaXplKDAsIDApLCBzKFwiYXR0YWNoXCIsIF9hMik7XG4gICAgICB9LCBlLmlzQXR0YWNoZWQodGhpcy5jYW52YXMpID8gX2EyKCkgOiByKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuYmluZEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRFdmVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMxNyA9IHRoaXM7XG4gICAgICBMKHRoaXMuX2xpc3RlbmVycywgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgX3RoaXMxNy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKF90aGlzMTcsIGUsIHQpO1xuICAgICAgfSksIHRoaXMuX2xpc3RlbmVycyA9IHt9LCBMKHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMsIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIF90aGlzMTcucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihfdGhpczE3LCBlLCB0KTtcbiAgICAgIH0pLCB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVIb3ZlclN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUhvdmVyU3R5bGUodCwgZSwgcykge1xuICAgICAgdmFyIG4gPSBzID8gXCJzZXRcIiA6IFwicmVtb3ZlXCI7XG4gICAgICB2YXIgbywgciwgYSwgbDtcbiAgICAgIGZvciAoZSA9PT0gXCJkYXRhc2V0XCIgJiYgKG8gPSB0aGlzLmdldERhdGFzZXRNZXRhKHRbMF0uZGF0YXNldEluZGV4KSwgby5jb250cm9sbGVyW1wiX1wiICsgbiArIFwiRGF0YXNldEhvdmVyU3R5bGVcIl0oKSksIGEgPSAwLCBsID0gdC5sZW5ndGg7IGEgPCBsOyArK2EpIHtcbiAgICAgICAgciA9IHRbYV07XG4gICAgICAgIHZhciBjID0gciAmJiB0aGlzLmdldERhdGFzZXRNZXRhKHIuZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICAgICAgICBjICYmIGNbbiArIFwiSG92ZXJTdHlsZVwiXShyLmVsZW1lbnQsIHIuZGF0YXNldEluZGV4LCByLmluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QWN0aXZlRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRBY3RpdmVFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBY3RpdmVFbGVtZW50cyh0KSB7XG4gICAgICB2YXIgX3RoaXMxOCA9IHRoaXM7XG4gICAgICB2YXIgZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXSxcbiAgICAgICAgcyA9IHQubWFwKGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgICAgIHZhciBvID0gX3JlZjUuZGF0YXNldEluZGV4LFxuICAgICAgICAgICAgciA9IF9yZWY1LmluZGV4O1xuICAgICAgICAgIHZhciBhID0gX3RoaXMxOC5nZXREYXRhc2V0TWV0YShvKTtcbiAgICAgICAgICBpZiAoIWEpIHRocm93IG5ldyBFcnJvcihcIk5vIGRhdGFzZXQgZm91bmQgYXQgaW5kZXggXCIgKyBvKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YXNldEluZGV4OiBvLFxuICAgICAgICAgICAgZWxlbWVudDogYS5kYXRhW3JdLFxuICAgICAgICAgICAgaW5kZXg6IHJcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICFqZShzLCBlKSAmJiAodGhpcy5fYWN0aXZlID0gcywgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbCwgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMocywgZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub3RpZnlQbHVnaW5zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vdGlmeVBsdWdpbnModCwgZSwgcykge1xuICAgICAgcmV0dXJuIHRoaXMuX3BsdWdpbnMubm90aWZ5KHRoaXMsIHQsIGUsIHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1BsdWdpbkVuYWJsZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNQbHVnaW5FbmFibGVkKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLl9jYWNoZS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUucGx1Z2luLmlkID09PSB0O1xuICAgICAgfSkubGVuZ3RoID09PSAxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlSG92ZXJTdHlsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUhvdmVyU3R5bGVzKHQsIGUsIHMpIHtcbiAgICAgIHZhciBuID0gdGhpcy5vcHRpb25zLmhvdmVyLFxuICAgICAgICBvID0gZnVuY3Rpb24gbyhsLCBjKSB7XG4gICAgICAgICAgcmV0dXJuIGwuZmlsdGVyKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICByZXR1cm4gIWMuc29tZShmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICByZXR1cm4gaC5kYXRhc2V0SW5kZXggPT09IGQuZGF0YXNldEluZGV4ICYmIGguaW5kZXggPT09IGQuaW5kZXg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgciA9IG8oZSwgdCksXG4gICAgICAgIGEgPSBzID8gdCA6IG8odCwgZSk7XG4gICAgICByLmxlbmd0aCAmJiB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUociwgbi5tb2RlLCAhMSksIGEubGVuZ3RoICYmIG4ubW9kZSAmJiB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoYSwgbi5tb2RlLCAhMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudEhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50SGFuZGxlcih0LCBlKSB7XG4gICAgICB2YXIgX3RoaXMxOSA9IHRoaXM7XG4gICAgICB2YXIgcyA9IHtcbiAgICAgICAgICBldmVudDogdCxcbiAgICAgICAgICByZXBsYXk6IGUsXG4gICAgICAgICAgY2FuY2VsYWJsZTogITAsXG4gICAgICAgICAgaW5DaGFydEFyZWE6IHRoaXMuaXNQb2ludEluQXJlYSh0KVxuICAgICAgICB9LFxuICAgICAgICBuID0gZnVuY3Rpb24gbihyKSB7XG4gICAgICAgICAgcmV0dXJuIChyLm9wdGlvbnMuZXZlbnRzIHx8IF90aGlzMTkub3B0aW9ucy5ldmVudHMpLmluY2x1ZGVzKHRbXCJuYXRpdmVcIl0udHlwZSk7XG4gICAgICAgIH07XG4gICAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKFwiYmVmb3JlRXZlbnRcIiwgcywgbikgPT09ICExKSByZXR1cm47XG4gICAgICB2YXIgbyA9IHRoaXMuX2hhbmRsZUV2ZW50KHQsIGUsIHMuaW5DaGFydEFyZWEpO1xuICAgICAgcmV0dXJuIHMuY2FuY2VsYWJsZSA9ICExLCB0aGlzLm5vdGlmeVBsdWdpbnMoXCJhZnRlckV2ZW50XCIsIHMsIG4pLCAobyB8fCBzLmNoYW5nZWQpICYmIHRoaXMucmVuZGVyKCksIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRXZlbnQodCwgZSwgcykge1xuICAgICAgdmFyIF90aGlzJF9hY3RpdmUgPSB0aGlzLl9hY3RpdmUsXG4gICAgICAgIG4gPSBfdGhpcyRfYWN0aXZlID09PSB2b2lkIDAgPyBbXSA6IF90aGlzJF9hY3RpdmUsXG4gICAgICAgIG8gPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHIgPSBlLFxuICAgICAgICBhID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHModCwgbiwgcywgciksXG4gICAgICAgIGwgPSBIbyh0KSxcbiAgICAgICAgYyA9IExsKHQsIHRoaXMuX2xhc3RFdmVudCwgcywgbCk7XG4gICAgICBzICYmICh0aGlzLl9sYXN0RXZlbnQgPSBudWxsLCBJKG8ub25Ib3ZlciwgW3QsIGEsIHRoaXNdLCB0aGlzKSwgbCAmJiBJKG8ub25DbGljaywgW3QsIGEsIHRoaXNdLCB0aGlzKSk7XG4gICAgICB2YXIgaCA9ICFqZShhLCBuKTtcbiAgICAgIHJldHVybiAoaCB8fCBlKSAmJiAodGhpcy5fYWN0aXZlID0gYSwgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYSwgbiwgZSkpLCB0aGlzLl9sYXN0RXZlbnQgPSBjLCBoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QWN0aXZlRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEFjdGl2ZUVsZW1lbnRzKHQsIGUsIHMsIG4pIHtcbiAgICAgIGlmICh0LnR5cGUgPT09IFwibW91c2VvdXRcIikgcmV0dXJuIFtdO1xuICAgICAgaWYgKCFzKSByZXR1cm4gZTtcbiAgICAgIHZhciBvID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSh0LCBvLm1vZGUsIG8sIG4pO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInJlZ2lzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKCkge1xuICAgICAgYXQuYWRkLmFwcGx5KGF0LCBhcmd1bWVudHMpLCAkcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnJlZ2lzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVucmVnaXN0ZXIoKSB7XG4gICAgICBhdC5yZW1vdmUuYXBwbHkoYXQsIGFyZ3VtZW50cyksICRzKCk7XG4gICAgfVxuICB9XSk7XG59KCk7XG53KG10LCBcImRlZmF1bHRzXCIsIFcpLCB3KG10LCBcImluc3RhbmNlc1wiLCBCZSksIHcobXQsIFwib3ZlcnJpZGVzXCIsIHp0KSwgdyhtdCwgXCJyZWdpc3RyeVwiLCBhdCksIHcobXQsIFwidmVyc2lvblwiLCBPbCksIHcobXQsIFwiZ2V0Q2hhcnRcIiwganMpO1xuZnVuY3Rpb24gJHMoKSB7XG4gIHJldHVybiBMKG10Lmluc3RhbmNlcywgZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gaS5fcGx1Z2lucy5pbnZhbGlkYXRlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gRWwoaSwgdCwgZSkge1xuICB2YXIgcyA9IHQuc3RhcnRBbmdsZSxcbiAgICBuID0gdC54LFxuICAgIG8gPSB0LnksXG4gICAgciA9IHQub3V0ZXJSYWRpdXMsXG4gICAgYSA9IHQuaW5uZXJSYWRpdXMsXG4gICAgbCA9IHQub3B0aW9ucyxcbiAgICBjID0gbC5ib3JkZXJXaWR0aCxcbiAgICBoID0gbC5ib3JkZXJKb2luU3R5bGUsXG4gICAgZCA9IE1hdGgubWluKGMgLyByLCBaKHMgLSBlKSk7XG4gIGlmIChpLmJlZ2luUGF0aCgpLCBpLmFyYyhuLCBvLCByIC0gYyAvIDIsIHMgKyBkIC8gMiwgZSAtIGQgLyAyKSwgYSA+IDApIHtcbiAgICB2YXIgdSA9IE1hdGgubWluKGMgLyBhLCBaKHMgLSBlKSk7XG4gICAgaS5hcmMobiwgbywgYSArIGMgLyAyLCBlIC0gdSAvIDIsIHMgKyB1IC8gMiwgITApO1xuICB9IGVsc2Uge1xuICAgIHZhciBfdTMgPSBNYXRoLm1pbihjIC8gMiwgciAqIFoocyAtIGUpKTtcbiAgICBpZiAoaCA9PT0gXCJyb3VuZFwiKSBpLmFyYyhuLCBvLCBfdTMsIGUgLSBFIC8gMiwgcyArIEUgLyAyLCAhMCk7ZWxzZSBpZiAoaCA9PT0gXCJiZXZlbFwiKSB7XG4gICAgICB2YXIgZiA9IDIgKiBfdTMgKiBfdTMsXG4gICAgICAgIHAgPSAtZiAqIE1hdGguY29zKGUgKyBFIC8gMikgKyBuLFxuICAgICAgICBnID0gLWYgKiBNYXRoLnNpbihlICsgRSAvIDIpICsgbyxcbiAgICAgICAgbSA9IGYgKiBNYXRoLmNvcyhzICsgRSAvIDIpICsgbixcbiAgICAgICAgYiA9IGYgKiBNYXRoLnNpbihzICsgRSAvIDIpICsgbztcbiAgICAgIGkubGluZVRvKHAsIGcpLCBpLmxpbmVUbyhtLCBiKTtcbiAgICB9XG4gIH1cbiAgaS5jbG9zZVBhdGgoKSwgaS5tb3ZlVG8oMCwgMCksIGkucmVjdCgwLCAwLCBpLmNhbnZhcy53aWR0aCwgaS5jYW52YXMuaGVpZ2h0KSwgaS5jbGlwKFwiZXZlbm9kZFwiKTtcbn1cbmZ1bmN0aW9uIEZsKGksIHQsIGUpIHtcbiAgdmFyIHMgPSB0LnN0YXJ0QW5nbGUsXG4gICAgbiA9IHQucGl4ZWxNYXJnaW4sXG4gICAgbyA9IHQueCxcbiAgICByID0gdC55LFxuICAgIGEgPSB0Lm91dGVyUmFkaXVzLFxuICAgIGwgPSB0LmlubmVyUmFkaXVzO1xuICB2YXIgYyA9IG4gLyBhO1xuICBpLmJlZ2luUGF0aCgpLCBpLmFyYyhvLCByLCBhLCBzIC0gYywgZSArIGMpLCBsID4gbiA/IChjID0gbiAvIGwsIGkuYXJjKG8sIHIsIGwsIGUgKyBjLCBzIC0gYywgITApKSA6IGkuYXJjKG8sIHIsIG4sIGUgKyBWLCBzIC0gViksIGkuY2xvc2VQYXRoKCksIGkuY2xpcCgpO1xufVxuZnVuY3Rpb24gSWwoaSkge1xuICByZXR1cm4gV2koaSwgW1wib3V0ZXJTdGFydFwiLCBcIm91dGVyRW5kXCIsIFwiaW5uZXJTdGFydFwiLCBcImlubmVyRW5kXCJdKTtcbn1cbmZ1bmN0aW9uIHpsKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBJbChpLm9wdGlvbnMuYm9yZGVyUmFkaXVzKSxcbiAgICBvID0gKGUgLSB0KSAvIDIsXG4gICAgciA9IE1hdGgubWluKG8sIHMgKiB0IC8gMiksXG4gICAgYSA9IGZ1bmN0aW9uIGEobCkge1xuICAgICAgdmFyIGMgPSAoZSAtIE1hdGgubWluKG8sIGwpKSAqIHMgLyAyO1xuICAgICAgcmV0dXJuIFUobCwgMCwgTWF0aC5taW4obywgYykpO1xuICAgIH07XG4gIHJldHVybiB7XG4gICAgb3V0ZXJTdGFydDogYShuLm91dGVyU3RhcnQpLFxuICAgIG91dGVyRW5kOiBhKG4ub3V0ZXJFbmQpLFxuICAgIGlubmVyU3RhcnQ6IFUobi5pbm5lclN0YXJ0LCAwLCByKSxcbiAgICBpbm5lckVuZDogVShuLmlubmVyRW5kLCAwLCByKVxuICB9O1xufVxuZnVuY3Rpb24gVnQoaSwgdCwgZSwgcykge1xuICByZXR1cm4ge1xuICAgIHg6IGUgKyBpICogTWF0aC5jb3ModCksXG4gICAgeTogcyArIGkgKiBNYXRoLnNpbih0KVxuICB9O1xufVxuZnVuY3Rpb24gS2UoaSwgdCwgZSwgcywgbiwgbykge1xuICB2YXIgciA9IHQueCxcbiAgICBhID0gdC55LFxuICAgIGwgPSB0LnN0YXJ0QW5nbGUsXG4gICAgYyA9IHQucGl4ZWxNYXJnaW4sXG4gICAgaCA9IHQuaW5uZXJSYWRpdXMsXG4gICAgZCA9IE1hdGgubWF4KHQub3V0ZXJSYWRpdXMgKyBzICsgZSAtIGMsIDApLFxuICAgIHUgPSBoID4gMCA/IGggKyBzICsgZSArIGMgOiAwO1xuICB2YXIgZiA9IDA7XG4gIHZhciBwID0gbiAtIGw7XG4gIGlmIChzKSB7XG4gICAgdmFyIEYgPSBoID4gMCA/IGggLSBzIDogMCxcbiAgICAgIHogPSBkID4gMCA/IGQgLSBzIDogMCxcbiAgICAgIEggPSAoRiArIHopIC8gMixcbiAgICAgIGl0ID0gSCAhPT0gMCA/IHAgKiBIIC8gKEggKyBzKSA6IHA7XG4gICAgZiA9IChwIC0gaXQpIC8gMjtcbiAgfVxuICB2YXIgZyA9IE1hdGgubWF4KDFlLTMsIHAgKiBkIC0gZSAvIEUpIC8gZCxcbiAgICBtID0gKHAgLSBnKSAvIDIsXG4gICAgYiA9IGwgKyBtICsgZixcbiAgICBfID0gbiAtIG0gLSBmLFxuICAgIF96bCA9IHpsKHQsIHUsIGQsIF8gLSBiKSxcbiAgICB2ID0gX3psLm91dGVyU3RhcnQsXG4gICAgeSA9IF96bC5vdXRlckVuZCxcbiAgICB4ID0gX3psLmlubmVyU3RhcnQsXG4gICAgTSA9IF96bC5pbm5lckVuZCxcbiAgICBTID0gZCAtIHYsXG4gICAgayA9IGQgLSB5LFxuICAgIFAgPSBiICsgdiAvIFMsXG4gICAgQyA9IF8gLSB5IC8gayxcbiAgICBPID0gdSArIHgsXG4gICAgQSA9IHUgKyBNLFxuICAgIGogPSBiICsgeCAvIE8sXG4gICAgSiA9IF8gLSBNIC8gQTtcbiAgaWYgKGkuYmVnaW5QYXRoKCksIG8pIHtcbiAgICB2YXIgX0Y1ID0gKFAgKyBDKSAvIDI7XG4gICAgaWYgKGkuYXJjKHIsIGEsIGQsIFAsIF9GNSksIGkuYXJjKHIsIGEsIGQsIF9GNSwgQyksIHkgPiAwKSB7XG4gICAgICB2YXIgJCA9IFZ0KGssIEMsIHIsIGEpO1xuICAgICAgaS5hcmMoJC54LCAkLnksIHksIEMsIF8gKyBWKTtcbiAgICB9XG4gICAgdmFyIF96NSA9IFZ0KEEsIF8sIHIsIGEpO1xuICAgIGlmIChpLmxpbmVUbyhfejUueCwgX3o1LnkpLCBNID4gMCkge1xuICAgICAgdmFyIF8kID0gVnQoQSwgSiwgciwgYSk7XG4gICAgICBpLmFyYyhfJC54LCBfJC55LCBNLCBfICsgViwgSiArIE1hdGguUEkpO1xuICAgIH1cbiAgICB2YXIgX0gzID0gKF8gLSBNIC8gdSArIChiICsgeCAvIHUpKSAvIDI7XG4gICAgaWYgKGkuYXJjKHIsIGEsIHUsIF8gLSBNIC8gdSwgX0gzLCAhMCksIGkuYXJjKHIsIGEsIHUsIF9IMywgYiArIHggLyB1LCAhMCksIHggPiAwKSB7XG4gICAgICB2YXIgXyQyID0gVnQoTywgaiwgciwgYSk7XG4gICAgICBpLmFyYyhfJDIueCwgXyQyLnksIHgsIGogKyBNYXRoLlBJLCBiIC0gVik7XG4gICAgfVxuICAgIHZhciBfaXQgPSBWdChTLCBiLCByLCBhKTtcbiAgICBpZiAoaS5saW5lVG8oX2l0LngsIF9pdC55KSwgdiA+IDApIHtcbiAgICAgIHZhciBfJDMgPSBWdChTLCBQLCByLCBhKTtcbiAgICAgIGkuYXJjKF8kMy54LCBfJDMueSwgdiwgYiAtIFYsIFApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpLm1vdmVUbyhyLCBhKTtcbiAgICB2YXIgX0Y2ID0gTWF0aC5jb3MoUCkgKiBkICsgcixcbiAgICAgIF96NiA9IE1hdGguc2luKFApICogZCArIGE7XG4gICAgaS5saW5lVG8oX0Y2LCBfejYpO1xuICAgIHZhciBfSDQgPSBNYXRoLmNvcyhDKSAqIGQgKyByLFxuICAgICAgX2l0MiA9IE1hdGguc2luKEMpICogZCArIGE7XG4gICAgaS5saW5lVG8oX0g0LCBfaXQyKTtcbiAgfVxuICBpLmNsb3NlUGF0aCgpO1xufVxuZnVuY3Rpb24gQmwoaSwgdCwgZSwgcywgbikge1xuICB2YXIgbyA9IHQuZnVsbENpcmNsZXMsXG4gICAgciA9IHQuc3RhcnRBbmdsZSxcbiAgICBhID0gdC5jaXJjdW1mZXJlbmNlO1xuICB2YXIgbCA9IHQuZW5kQW5nbGU7XG4gIGlmIChvKSB7XG4gICAgS2UoaSwgdCwgZSwgcywgbCwgbik7XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBvOyArK2MpIGkuZmlsbCgpO1xuICAgIGlzTmFOKGEpIHx8IChsID0gciArIChhICUgQiB8fCBCKSk7XG4gIH1cbiAgcmV0dXJuIEtlKGksIHQsIGUsIHMsIGwsIG4pLCBpLmZpbGwoKSwgbDtcbn1cbmZ1bmN0aW9uIEhsKGksIHQsIGUsIHMsIG4pIHtcbiAgdmFyIG8gPSB0LmZ1bGxDaXJjbGVzLFxuICAgIHIgPSB0LnN0YXJ0QW5nbGUsXG4gICAgYSA9IHQuY2lyY3VtZmVyZW5jZSxcbiAgICBsID0gdC5vcHRpb25zLFxuICAgIGMgPSBsLmJvcmRlcldpZHRoLFxuICAgIGggPSBsLmJvcmRlckpvaW5TdHlsZSxcbiAgICBkID0gbC5ib3JkZXJEYXNoLFxuICAgIHUgPSBsLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgZiA9IGwuYm9yZGVyUmFkaXVzLFxuICAgIHAgPSBsLmJvcmRlckFsaWduID09PSBcImlubmVyXCI7XG4gIGlmICghYykgcmV0dXJuO1xuICBpLnNldExpbmVEYXNoKGQgfHwgW10pLCBpLmxpbmVEYXNoT2Zmc2V0ID0gdSwgcCA/IChpLmxpbmVXaWR0aCA9IGMgKiAyLCBpLmxpbmVKb2luID0gaCB8fCBcInJvdW5kXCIpIDogKGkubGluZVdpZHRoID0gYywgaS5saW5lSm9pbiA9IGggfHwgXCJiZXZlbFwiKTtcbiAgdmFyIGcgPSB0LmVuZEFuZ2xlO1xuICBpZiAobykge1xuICAgIEtlKGksIHQsIGUsIHMsIGcsIG4pO1xuICAgIGZvciAodmFyIG0gPSAwOyBtIDwgbzsgKyttKSBpLnN0cm9rZSgpO1xuICAgIGlzTmFOKGEpIHx8IChnID0gciArIChhICUgQiB8fCBCKSk7XG4gIH1cbiAgcCAmJiBGbChpLCB0LCBnKSwgbC5zZWxmSm9pbiAmJiBnIC0gciA+PSBFICYmIGYgPT09IDAgJiYgaCAhPT0gXCJtaXRlclwiICYmIEVsKGksIHQsIGcpLCBvIHx8IChLZShpLCB0LCBlLCBzLCBnLCBuKSwgaS5zdHJva2UoKSk7XG59XG52YXIgcmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdDIpIHtcbiAgZnVuY3Rpb24gcmUoZSkge1xuICAgIHZhciBfdGhpczIwO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCByZSk7XG4gICAgX3RoaXMyMCA9IF9jYWxsU3VwZXIodGhpcywgcmUpO1xuICAgIHcoX3RoaXMyMCwgXCJjaXJjdW1mZXJlbmNlXCIpO1xuICAgIHcoX3RoaXMyMCwgXCJlbmRBbmdsZVwiKTtcbiAgICB3KF90aGlzMjAsIFwiZnVsbENpcmNsZXNcIik7XG4gICAgdyhfdGhpczIwLCBcImlubmVyUmFkaXVzXCIpO1xuICAgIHcoX3RoaXMyMCwgXCJvdXRlclJhZGl1c1wiKTtcbiAgICB3KF90aGlzMjAsIFwicGl4ZWxNYXJnaW5cIik7XG4gICAgdyhfdGhpczIwLCBcInN0YXJ0QW5nbGVcIik7XG4gICAgX3RoaXMyMC5vcHRpb25zID0gdm9pZCAwLCBfdGhpczIwLmNpcmN1bWZlcmVuY2UgPSB2b2lkIDAsIF90aGlzMjAuc3RhcnRBbmdsZSA9IHZvaWQgMCwgX3RoaXMyMC5lbmRBbmdsZSA9IHZvaWQgMCwgX3RoaXMyMC5pbm5lclJhZGl1cyA9IHZvaWQgMCwgX3RoaXMyMC5vdXRlclJhZGl1cyA9IHZvaWQgMCwgX3RoaXMyMC5waXhlbE1hcmdpbiA9IDAsIF90aGlzMjAuZnVsbENpcmNsZXMgPSAwLCBlICYmIE9iamVjdC5hc3NpZ24oX3RoaXMyMCwgZSk7XG4gICAgcmV0dXJuIF90aGlzMjA7XG4gIH1cbiAgX2luaGVyaXRzKHJlLCBfc3QyKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhyZSwgW3tcbiAgICBrZXk6IFwiaW5SYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpblJhbmdlKGUsIHMsIG4pIHtcbiAgICAgIHZhciBvID0gdGhpcy5nZXRQcm9wcyhbXCJ4XCIsIFwieVwiXSwgbiksXG4gICAgICAgIF95bjIgPSB5bihvLCB7XG4gICAgICAgICAgeDogZSxcbiAgICAgICAgICB5OiBzXG4gICAgICAgIH0pLFxuICAgICAgICByID0gX3luMi5hbmdsZSxcbiAgICAgICAgYSA9IF95bjIuZGlzdGFuY2UsXG4gICAgICAgIF90aGlzJGdldFByb3BzMiA9IHRoaXMuZ2V0UHJvcHMoW1wic3RhcnRBbmdsZVwiLCBcImVuZEFuZ2xlXCIsIFwiaW5uZXJSYWRpdXNcIiwgXCJvdXRlclJhZGl1c1wiLCBcImNpcmN1bWZlcmVuY2VcIl0sIG4pLFxuICAgICAgICBsID0gX3RoaXMkZ2V0UHJvcHMyLnN0YXJ0QW5nbGUsXG4gICAgICAgIGMgPSBfdGhpcyRnZXRQcm9wczIuZW5kQW5nbGUsXG4gICAgICAgIGggPSBfdGhpcyRnZXRQcm9wczIuaW5uZXJSYWRpdXMsXG4gICAgICAgIGQgPSBfdGhpcyRnZXRQcm9wczIub3V0ZXJSYWRpdXMsXG4gICAgICAgIHUgPSBfdGhpcyRnZXRQcm9wczIuY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgZiA9ICh0aGlzLm9wdGlvbnMuc3BhY2luZyArIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aCkgLyAyLFxuICAgICAgICBwID0gRCh1LCBjIC0gbCksXG4gICAgICAgIGcgPSBwZShyLCBsLCBjKSAmJiBsICE9PSBjLFxuICAgICAgICBtID0gcCA+PSBCIHx8IGcsXG4gICAgICAgIGIgPSBfdChhLCBoICsgZiwgZCArIGYpO1xuICAgICAgcmV0dXJuIG0gJiYgYjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2VudGVyUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2VudGVyUG9pbnQoZSkge1xuICAgICAgdmFyIF90aGlzJGdldFByb3BzMyA9IHRoaXMuZ2V0UHJvcHMoW1wieFwiLCBcInlcIiwgXCJzdGFydEFuZ2xlXCIsIFwiZW5kQW5nbGVcIiwgXCJpbm5lclJhZGl1c1wiLCBcIm91dGVyUmFkaXVzXCJdLCBlKSxcbiAgICAgICAgcyA9IF90aGlzJGdldFByb3BzMy54LFxuICAgICAgICBuID0gX3RoaXMkZ2V0UHJvcHMzLnksXG4gICAgICAgIG8gPSBfdGhpcyRnZXRQcm9wczMuc3RhcnRBbmdsZSxcbiAgICAgICAgciA9IF90aGlzJGdldFByb3BzMy5lbmRBbmdsZSxcbiAgICAgICAgYSA9IF90aGlzJGdldFByb3BzMy5pbm5lclJhZGl1cyxcbiAgICAgICAgbCA9IF90aGlzJGdldFByb3BzMy5vdXRlclJhZGl1cyxcbiAgICAgICAgX3RoaXMkb3B0aW9uczExID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBjID0gX3RoaXMkb3B0aW9uczExLm9mZnNldCxcbiAgICAgICAgaCA9IF90aGlzJG9wdGlvbnMxMS5zcGFjaW5nLFxuICAgICAgICBkID0gKG8gKyByKSAvIDIsXG4gICAgICAgIHUgPSAoYSArIGwgKyBoICsgYykgLyAyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcyArIE1hdGguY29zKGQpICogdSxcbiAgICAgICAgeTogbiArIE1hdGguc2luKGQpICogdVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9vbHRpcFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvb2x0aXBQb3NpdGlvbihlKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDZW50ZXJQb2ludChlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGUpIHtcbiAgICAgIHZhciBzID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBuID0gdGhpcy5jaXJjdW1mZXJlbmNlLFxuICAgICAgICBvID0gKHMub2Zmc2V0IHx8IDApIC8gNCxcbiAgICAgICAgciA9IChzLnNwYWNpbmcgfHwgMCkgLyAyLFxuICAgICAgICBhID0gcy5jaXJjdWxhcjtcbiAgICAgIGlmICh0aGlzLnBpeGVsTWFyZ2luID0gcy5ib3JkZXJBbGlnbiA9PT0gXCJpbm5lclwiID8gMC4zMyA6IDAsIHRoaXMuZnVsbENpcmNsZXMgPSBuID4gQiA/IE1hdGguZmxvb3IobiAvIEIpIDogMCwgbiA9PT0gMCB8fCB0aGlzLmlubmVyUmFkaXVzIDwgMCB8fCB0aGlzLm91dGVyUmFkaXVzIDwgMCkgcmV0dXJuO1xuICAgICAgZS5zYXZlKCk7XG4gICAgICB2YXIgbCA9ICh0aGlzLnN0YXJ0QW5nbGUgKyB0aGlzLmVuZEFuZ2xlKSAvIDI7XG4gICAgICBlLnRyYW5zbGF0ZShNYXRoLmNvcyhsKSAqIG8sIE1hdGguc2luKGwpICogbyk7XG4gICAgICB2YXIgYyA9IDEgLSBNYXRoLnNpbihNYXRoLm1pbihFLCBuIHx8IDApKSxcbiAgICAgICAgaCA9IG8gKiBjO1xuICAgICAgZS5maWxsU3R5bGUgPSBzLmJhY2tncm91bmRDb2xvciwgZS5zdHJva2VTdHlsZSA9IHMuYm9yZGVyQ29sb3IsIEJsKGUsIHRoaXMsIGgsIHIsIGEpLCBIbChlLCB0aGlzLCBoLCByLCBhKSwgZS5yZXN0b3JlKCk7XG4gICAgfVxuICB9XSk7XG59KHN0KTtcbncocmUsIFwiaWRcIiwgXCJhcmNcIiksIHcocmUsIFwiZGVmYXVsdHNcIiwge1xuICBib3JkZXJBbGlnbjogXCJjZW50ZXJcIixcbiAgYm9yZGVyQ29sb3I6IFwiI2ZmZlwiLFxuICBib3JkZXJEYXNoOiBbXSxcbiAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgYm9yZGVySm9pblN0eWxlOiB2b2lkIDAsXG4gIGJvcmRlclJhZGl1czogMCxcbiAgYm9yZGVyV2lkdGg6IDIsXG4gIG9mZnNldDogMCxcbiAgc3BhY2luZzogMCxcbiAgYW5nbGU6IHZvaWQgMCxcbiAgY2lyY3VsYXI6ICEwLFxuICBzZWxmSm9pbjogITFcbn0pLCB3KHJlLCBcImRlZmF1bHRSb3V0ZXNcIiwge1xuICBiYWNrZ3JvdW5kQ29sb3I6IFwiYmFja2dyb3VuZENvbG9yXCJcbn0pLCB3KHJlLCBcImRlc2NyaXB0b3JzXCIsIHtcbiAgX3NjcmlwdGFibGU6ICEwLFxuICBfaW5kZXhhYmxlOiBmdW5jdGlvbiBfaW5kZXhhYmxlKGUpIHtcbiAgICByZXR1cm4gZSAhPT0gXCJib3JkZXJEYXNoXCI7XG4gIH1cbn0pO1xuZnVuY3Rpb24gUW4oaSwgdCkge1xuICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdDtcbiAgaS5saW5lQ2FwID0gRChlLmJvcmRlckNhcFN0eWxlLCB0LmJvcmRlckNhcFN0eWxlKSwgaS5zZXRMaW5lRGFzaChEKGUuYm9yZGVyRGFzaCwgdC5ib3JkZXJEYXNoKSksIGkubGluZURhc2hPZmZzZXQgPSBEKGUuYm9yZGVyRGFzaE9mZnNldCwgdC5ib3JkZXJEYXNoT2Zmc2V0KSwgaS5saW5lSm9pbiA9IEQoZS5ib3JkZXJKb2luU3R5bGUsIHQuYm9yZGVySm9pblN0eWxlKSwgaS5saW5lV2lkdGggPSBEKGUuYm9yZGVyV2lkdGgsIHQuYm9yZGVyV2lkdGgpLCBpLnN0cm9rZVN0eWxlID0gRChlLmJvcmRlckNvbG9yLCB0LmJvcmRlckNvbG9yKTtcbn1cbmZ1bmN0aW9uIFdsKGksIHQsIGUpIHtcbiAgaS5saW5lVG8oZS54LCBlLnkpO1xufVxuZnVuY3Rpb24gTmwoaSkge1xuICByZXR1cm4gaS5zdGVwcGVkID8gaHIgOiBpLnRlbnNpb24gfHwgaS5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSBcIm1vbm90b25lXCIgPyBkciA6IFdsO1xufVxuZnVuY3Rpb24gdG8oaSwgdCkge1xuICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBzID0gaS5sZW5ndGgsXG4gICAgX2Ukc3RhcnQgPSBlLnN0YXJ0LFxuICAgIG4gPSBfZSRzdGFydCA9PT0gdm9pZCAwID8gMCA6IF9lJHN0YXJ0LFxuICAgIF9lJGVuZCA9IGUuZW5kLFxuICAgIG8gPSBfZSRlbmQgPT09IHZvaWQgMCA/IHMgLSAxIDogX2UkZW5kLFxuICAgIHIgPSB0LnN0YXJ0LFxuICAgIGEgPSB0LmVuZCxcbiAgICBsID0gTWF0aC5tYXgobiwgciksXG4gICAgYyA9IE1hdGgubWluKG8sIGEpLFxuICAgIGggPSBuIDwgciAmJiBvIDwgciB8fCBuID4gYSAmJiBvID4gYTtcbiAgcmV0dXJuIHtcbiAgICBjb3VudDogcyxcbiAgICBzdGFydDogbCxcbiAgICBsb29wOiB0Lmxvb3AsXG4gICAgaWxlbjogYyA8IGwgJiYgIWggPyBzICsgYyAtIGwgOiBjIC0gbFxuICB9O1xufVxuZnVuY3Rpb24gVmwoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IHQucG9pbnRzLFxuICAgIG8gPSB0Lm9wdGlvbnMsXG4gICAgX3RvID0gdG8obiwgZSwgcyksXG4gICAgciA9IF90by5jb3VudCxcbiAgICBhID0gX3RvLnN0YXJ0LFxuICAgIGwgPSBfdG8ubG9vcCxcbiAgICBjID0gX3RvLmlsZW4sXG4gICAgaCA9IE5sKG8pO1xuICB2YXIgX3JlZjYgPSBzIHx8IHt9LFxuICAgIF9yZWY2JG1vdmUgPSBfcmVmNi5tb3ZlLFxuICAgIGQgPSBfcmVmNiRtb3ZlID09PSB2b2lkIDAgPyAhMCA6IF9yZWY2JG1vdmUsXG4gICAgdSA9IF9yZWY2LnJldmVyc2UsXG4gICAgZixcbiAgICBwLFxuICAgIGc7XG4gIGZvciAoZiA9IDA7IGYgPD0gYzsgKytmKSBwID0gblsoYSArICh1ID8gYyAtIGYgOiBmKSkgJSByXSwgIXAuc2tpcCAmJiAoZCA/IChpLm1vdmVUbyhwLngsIHAueSksIGQgPSAhMSkgOiBoKGksIGcsIHAsIHUsIG8uc3RlcHBlZCksIGcgPSBwKTtcbiAgcmV0dXJuIGwgJiYgKHAgPSBuWyhhICsgKHUgPyBjIDogMCkpICUgcl0sIGgoaSwgZywgcCwgdSwgby5zdGVwcGVkKSksICEhbDtcbn1cbmZ1bmN0aW9uIGpsKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSB0LnBvaW50cyxcbiAgICBfdG8yID0gdG8obiwgZSwgcyksXG4gICAgbyA9IF90bzIuY291bnQsXG4gICAgciA9IF90bzIuc3RhcnQsXG4gICAgYSA9IF90bzIuaWxlbixcbiAgICBfcmVmNyA9IHMgfHwge30sXG4gICAgX3JlZjckbW92ZSA9IF9yZWY3Lm1vdmUsXG4gICAgbCA9IF9yZWY3JG1vdmUgPT09IHZvaWQgMCA/ICEwIDogX3JlZjckbW92ZSxcbiAgICBjID0gX3JlZjcucmV2ZXJzZTtcbiAgdmFyIGggPSAwLFxuICAgIGQgPSAwLFxuICAgIHUsXG4gICAgZixcbiAgICBwLFxuICAgIGcsXG4gICAgbSxcbiAgICBiO1xuICB2YXIgXyA9IGZ1bmN0aW9uIF8oeSkge1xuICAgICAgcmV0dXJuIChyICsgKGMgPyBhIC0geSA6IHkpKSAlIG87XG4gICAgfSxcbiAgICB2ID0gZnVuY3Rpb24gdigpIHtcbiAgICAgIGcgIT09IG0gJiYgKGkubGluZVRvKGgsIG0pLCBpLmxpbmVUbyhoLCBnKSwgaS5saW5lVG8oaCwgYikpO1xuICAgIH07XG4gIGZvciAobCAmJiAoZiA9IG5bXygwKV0sIGkubW92ZVRvKGYueCwgZi55KSksIHUgPSAwOyB1IDw9IGE7ICsrdSkge1xuICAgIGlmIChmID0gbltfKHUpXSwgZi5za2lwKSBjb250aW51ZTtcbiAgICB2YXIgeSA9IGYueCxcbiAgICAgIHggPSBmLnksXG4gICAgICBNID0geSB8IDA7XG4gICAgTSA9PT0gcCA/ICh4IDwgZyA/IGcgPSB4IDogeCA+IG0gJiYgKG0gPSB4KSwgaCA9IChkICogaCArIHkpIC8gKytkKSA6ICh2KCksIGkubGluZVRvKHksIHgpLCBwID0gTSwgZCA9IDAsIGcgPSBtID0geCksIGIgPSB4O1xuICB9XG4gIHYoKTtcbn1cbmZ1bmN0aW9uIERpKGkpIHtcbiAgdmFyIHQgPSBpLm9wdGlvbnMsXG4gICAgZSA9IHQuYm9yZGVyRGFzaCAmJiB0LmJvcmRlckRhc2gubGVuZ3RoO1xuICByZXR1cm4gIWkuX2RlY2ltYXRlZCAmJiAhaS5fbG9vcCAmJiAhdC50ZW5zaW9uICYmIHQuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSAhPT0gXCJtb25vdG9uZVwiICYmICF0LnN0ZXBwZWQgJiYgIWUgPyBqbCA6IFZsO1xufVxuZnVuY3Rpb24gJGwoaSkge1xuICByZXR1cm4gaS5zdGVwcGVkID8ganIgOiBpLnRlbnNpb24gfHwgaS5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSBcIm1vbm90b25lXCIgPyAkciA6IFJ0O1xufVxuZnVuY3Rpb24gWWwoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IHQuX3BhdGg7XG4gIG4gfHwgKG4gPSB0Ll9wYXRoID0gbmV3IFBhdGgyRCgpLCB0LnBhdGgobiwgZSwgcykgJiYgbi5jbG9zZVBhdGgoKSksIFFuKGksIHQub3B0aW9ucyksIGkuc3Ryb2tlKG4pO1xufVxuZnVuY3Rpb24gVWwoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IHQuc2VnbWVudHMsXG4gICAgbyA9IHQub3B0aW9ucyxcbiAgICByID0gRGkodCk7XG4gIHZhciBfaXRlcmF0b3IyNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG4pLFxuICAgIF9zdGVwMjY7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IyNi5zKCk7ICEoX3N0ZXAyNiA9IF9pdGVyYXRvcjI2Lm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBhID0gX3N0ZXAyNi52YWx1ZTtcbiAgICAgIFFuKGksIG8sIGEuc3R5bGUpLCBpLmJlZ2luUGF0aCgpLCByKGksIHQsIGEsIHtcbiAgICAgICAgc3RhcnQ6IGUsXG4gICAgICAgIGVuZDogZSArIHMgLSAxXG4gICAgICB9KSAmJiBpLmNsb3NlUGF0aCgpLCBpLnN0cm9rZSgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMjYuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjI2LmYoKTtcbiAgfVxufVxudmFyIFhsID0gdHlwZW9mIFBhdGgyRCA9PSBcImZ1bmN0aW9uXCI7XG5mdW5jdGlvbiBxbChpLCB0LCBlLCBzKSB7XG4gIFhsICYmICF0Lm9wdGlvbnMuc2VnbWVudCA/IFlsKGksIHQsIGUsIHMpIDogVWwoaSwgdCwgZSwgcyk7XG59XG52YXIgdnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdDMpIHtcbiAgZnVuY3Rpb24gdnQodCkge1xuICAgIHZhciBfdGhpczIxO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCB2dCk7XG4gICAgX3RoaXMyMSA9IF9jYWxsU3VwZXIodGhpcywgdnQpLCBfdGhpczIxLmFuaW1hdGVkID0gITAsIF90aGlzMjEub3B0aW9ucyA9IHZvaWQgMCwgX3RoaXMyMS5fY2hhcnQgPSB2b2lkIDAsIF90aGlzMjEuX2xvb3AgPSB2b2lkIDAsIF90aGlzMjEuX2Z1bGxMb29wID0gdm9pZCAwLCBfdGhpczIxLl9wYXRoID0gdm9pZCAwLCBfdGhpczIxLl9wb2ludHMgPSB2b2lkIDAsIF90aGlzMjEuX3NlZ21lbnRzID0gdm9pZCAwLCBfdGhpczIxLl9kZWNpbWF0ZWQgPSAhMSwgX3RoaXMyMS5fcG9pbnRzVXBkYXRlZCA9ICExLCBfdGhpczIxLl9kYXRhc2V0SW5kZXggPSB2b2lkIDAsIHQgJiYgT2JqZWN0LmFzc2lnbihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMjEpLCB0KTtcbiAgICByZXR1cm4gX3RoaXMyMTtcbiAgfVxuICBfaW5oZXJpdHModnQsIF9zdDMpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKHZ0LCBbe1xuICAgIGtleTogXCJ1cGRhdGVDb250cm9sUG9pbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUNvbnRyb2xQb2ludHModCwgZSkge1xuICAgICAgdmFyIHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAoKHMudGVuc2lvbiB8fCBzLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09IFwibW9ub3RvbmVcIikgJiYgIXMuc3RlcHBlZCAmJiAhdGhpcy5fcG9pbnRzVXBkYXRlZCkge1xuICAgICAgICB2YXIgbiA9IHMuc3BhbkdhcHMgPyB0aGlzLl9sb29wIDogdGhpcy5fZnVsbExvb3A7XG4gICAgICAgIEZyKHRoaXMuX3BvaW50cywgcywgdCwgbiwgZSksIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSAhMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9pbnRzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodCkge1xuICAgICAgdGhpcy5fcG9pbnRzID0gdCwgZGVsZXRlIHRoaXMuX3NlZ21lbnRzLCBkZWxldGUgdGhpcy5fcGF0aCwgdGhpcy5fcG9pbnRzVXBkYXRlZCA9ICExO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWdtZW50c1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRzIHx8ICh0aGlzLl9zZWdtZW50cyA9IEdyKHRoaXMsIHRoaXMub3B0aW9ucy5zZWdtZW50KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgICAgdmFyIHQgPSB0aGlzLnNlZ21lbnRzLFxuICAgICAgICBlID0gdGhpcy5wb2ludHM7XG4gICAgICByZXR1cm4gdC5sZW5ndGggJiYgZVt0WzBdLnN0YXJ0XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGFzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsYXN0KCkge1xuICAgICAgdmFyIHQgPSB0aGlzLnNlZ21lbnRzLFxuICAgICAgICBlID0gdGhpcy5wb2ludHMsXG4gICAgICAgIHMgPSB0Lmxlbmd0aDtcbiAgICAgIHJldHVybiBzICYmIGVbdFtzIC0gMV0uZW5kXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJwb2xhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGUodCwgZSkge1xuICAgICAgdmFyIHMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIG4gPSB0W2VdLFxuICAgICAgICBvID0gdGhpcy5wb2ludHMsXG4gICAgICAgIHIgPSBIbih0aGlzLCB7XG4gICAgICAgICAgcHJvcGVydHk6IGUsXG4gICAgICAgICAgc3RhcnQ6IG4sXG4gICAgICAgICAgZW5kOiBuXG4gICAgICAgIH0pO1xuICAgICAgaWYgKCFyLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgdmFyIGEgPSBbXSxcbiAgICAgICAgbCA9ICRsKHMpO1xuICAgICAgdmFyIGMsIGg7XG4gICAgICBmb3IgKGMgPSAwLCBoID0gci5sZW5ndGg7IGMgPCBoOyArK2MpIHtcbiAgICAgICAgdmFyIF9yJGMgPSByW2NdLFxuICAgICAgICAgIGQgPSBfciRjLnN0YXJ0LFxuICAgICAgICAgIHUgPSBfciRjLmVuZCxcbiAgICAgICAgICBmID0gb1tkXSxcbiAgICAgICAgICBwID0gb1t1XTtcbiAgICAgICAgaWYgKGYgPT09IHApIHtcbiAgICAgICAgICBhLnB1c2goZik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGcgPSBNYXRoLmFicygobiAtIGZbZV0pIC8gKHBbZV0gLSBmW2VdKSksXG4gICAgICAgICAgbSA9IGwoZiwgcCwgZywgcy5zdGVwcGVkKTtcbiAgICAgICAgbVtlXSA9IHRbZV0sIGEucHVzaChtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gMSA/IGFbMF0gOiBhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoU2VnbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoU2VnbWVudCh0LCBlLCBzKSB7XG4gICAgICByZXR1cm4gRGkodGhpcykodCwgdGhpcywgZSwgcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aCh0LCBlLCBzKSB7XG4gICAgICB2YXIgbiA9IHRoaXMuc2VnbWVudHMsXG4gICAgICAgIG8gPSBEaSh0aGlzKTtcbiAgICAgIHZhciByID0gdGhpcy5fbG9vcDtcbiAgICAgIGUgPSBlIHx8IDAsIHMgPSBzIHx8IHRoaXMucG9pbnRzLmxlbmd0aCAtIGU7XG4gICAgICB2YXIgX2l0ZXJhdG9yMjcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihuKSxcbiAgICAgICAgX3N0ZXAyNztcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMjcucygpOyAhKF9zdGVwMjcgPSBfaXRlcmF0b3IyNy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGEgPSBfc3RlcDI3LnZhbHVlO1xuICAgICAgICAgIHIgJj0gbyh0LCB0aGlzLCBhLCB7XG4gICAgICAgICAgICBzdGFydDogZSxcbiAgICAgICAgICAgIGVuZDogZSArIHMgLSAxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyNy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyNy5mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gISFyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcodCwgZSwgcywgbikge1xuICAgICAgdmFyIG8gPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgICAodGhpcy5wb2ludHMgfHwgW10pLmxlbmd0aCAmJiBvLmJvcmRlcldpZHRoICYmICh0LnNhdmUoKSwgcWwodCwgdGhpcywgcywgbiksIHQucmVzdG9yZSgpKSwgdGhpcy5hbmltYXRlZCAmJiAodGhpcy5fcG9pbnRzVXBkYXRlZCA9ICExLCB0aGlzLl9wYXRoID0gdm9pZCAwKTtcbiAgICB9XG4gIH1dKTtcbn0oc3QpO1xudyh2dCwgXCJpZFwiLCBcImxpbmVcIiksIHcodnQsIFwiZGVmYXVsdHNcIiwge1xuICBib3JkZXJDYXBTdHlsZTogXCJidXR0XCIsXG4gIGJvcmRlckRhc2g6IFtdLFxuICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICBib3JkZXJKb2luU3R5bGU6IFwibWl0ZXJcIixcbiAgYm9yZGVyV2lkdGg6IDMsXG4gIGNhcEJlemllclBvaW50czogITAsXG4gIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6IFwiZGVmYXVsdFwiLFxuICBmaWxsOiAhMSxcbiAgc3BhbkdhcHM6ICExLFxuICBzdGVwcGVkOiAhMSxcbiAgdGVuc2lvbjogMFxufSksIHcodnQsIFwiZGVmYXVsdFJvdXRlc1wiLCB7XG4gIGJhY2tncm91bmRDb2xvcjogXCJiYWNrZ3JvdW5kQ29sb3JcIixcbiAgYm9yZGVyQ29sb3I6IFwiYm9yZGVyQ29sb3JcIlxufSksIHcodnQsIFwiZGVzY3JpcHRvcnNcIiwge1xuICBfc2NyaXB0YWJsZTogITAsXG4gIF9pbmRleGFibGU6IGZ1bmN0aW9uIF9pbmRleGFibGUodCkge1xuICAgIHJldHVybiB0ICE9PSBcImJvcmRlckRhc2hcIiAmJiB0ICE9PSBcImZpbGxcIjtcbiAgfVxufSk7XG5mdW5jdGlvbiBZcyhpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gaS5vcHRpb25zLFxuICAgIF9pJGdldFByb3BzID0gaS5nZXRQcm9wcyhbZV0sIHMpLFxuICAgIG8gPSBfaSRnZXRQcm9wc1tlXTtcbiAgcmV0dXJuIE1hdGguYWJzKHQgLSBvKSA8IG4ucmFkaXVzICsgbi5oaXRSYWRpdXM7XG59XG52YXIgSGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdDQpIHtcbiAgZnVuY3Rpb24gSGUoZSkge1xuICAgIHZhciBfdGhpczIyO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIZSk7XG4gICAgX3RoaXMyMiA9IF9jYWxsU3VwZXIodGhpcywgSGUpO1xuICAgIHcoX3RoaXMyMiwgXCJwYXJzZWRcIik7XG4gICAgdyhfdGhpczIyLCBcInNraXBcIik7XG4gICAgdyhfdGhpczIyLCBcInN0b3BcIik7XG4gICAgX3RoaXMyMi5vcHRpb25zID0gdm9pZCAwLCBfdGhpczIyLnBhcnNlZCA9IHZvaWQgMCwgX3RoaXMyMi5za2lwID0gdm9pZCAwLCBfdGhpczIyLnN0b3AgPSB2b2lkIDAsIGUgJiYgT2JqZWN0LmFzc2lnbihfdGhpczIyLCBlKTtcbiAgICByZXR1cm4gX3RoaXMyMjtcbiAgfVxuICBfaW5oZXJpdHMoSGUsIF9zdDQpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEhlLCBbe1xuICAgIGtleTogXCJpblJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluUmFuZ2UoZSwgcywgbikge1xuICAgICAgdmFyIG8gPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIF90aGlzJGdldFByb3BzNCA9IHRoaXMuZ2V0UHJvcHMoW1wieFwiLCBcInlcIl0sIG4pLFxuICAgICAgICByID0gX3RoaXMkZ2V0UHJvcHM0LngsXG4gICAgICAgIGEgPSBfdGhpcyRnZXRQcm9wczQueTtcbiAgICAgIHJldHVybiBNYXRoLnBvdyhlIC0gciwgMikgKyBNYXRoLnBvdyhzIC0gYSwgMikgPCBNYXRoLnBvdyhvLmhpdFJhZGl1cyArIG8ucmFkaXVzLCAyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5YUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5YUmFuZ2UoZSwgcykge1xuICAgICAgcmV0dXJuIFlzKHRoaXMsIGUsIFwieFwiLCBzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5ZUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5ZUmFuZ2UoZSwgcykge1xuICAgICAgcmV0dXJuIFlzKHRoaXMsIGUsIFwieVwiLCBzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2VudGVyUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2VudGVyUG9pbnQoZSkge1xuICAgICAgdmFyIF90aGlzJGdldFByb3BzNSA9IHRoaXMuZ2V0UHJvcHMoW1wieFwiLCBcInlcIl0sIGUpLFxuICAgICAgICBzID0gX3RoaXMkZ2V0UHJvcHM1LngsXG4gICAgICAgIG4gPSBfdGhpcyRnZXRQcm9wczUueTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHMsXG4gICAgICAgIHk6IG5cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2l6ZShlKSB7XG4gICAgICBlID0gZSB8fCB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgICB2YXIgcyA9IGUucmFkaXVzIHx8IDA7XG4gICAgICBzID0gTWF0aC5tYXgocywgcyAmJiBlLmhvdmVyUmFkaXVzIHx8IDApO1xuICAgICAgdmFyIG4gPSBzICYmIGUuYm9yZGVyV2lkdGggfHwgMDtcbiAgICAgIHJldHVybiAocyArIG4pICogMjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGUsIHMpIHtcbiAgICAgIHZhciBuID0gdGhpcy5vcHRpb25zO1xuICAgICAgdGhpcy5za2lwIHx8IG4ucmFkaXVzIDwgMC4xIHx8ICFtZSh0aGlzLCBzLCB0aGlzLnNpemUobikgLyAyKSB8fCAoZS5zdHJva2VTdHlsZSA9IG4uYm9yZGVyQ29sb3IsIGUubGluZVdpZHRoID0gbi5ib3JkZXJXaWR0aCwgZS5maWxsU3R5bGUgPSBuLmJhY2tncm91bmRDb2xvciwgU2koZSwgbiwgdGhpcy54LCB0aGlzLnkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2UoKSB7XG4gICAgICB2YXIgZSA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICAgIHJldHVybiBlLnJhZGl1cyArIGUuaGl0UmFkaXVzO1xuICAgIH1cbiAgfV0pO1xufShzdCk7XG53KEhlLCBcImlkXCIsIFwicG9pbnRcIiksXG4vKipcbiogQHR5cGUge2FueX1cbiovXG53KEhlLCBcImRlZmF1bHRzXCIsIHtcbiAgYm9yZGVyV2lkdGg6IDEsXG4gIGhpdFJhZGl1czogMSxcbiAgaG92ZXJCb3JkZXJXaWR0aDogMSxcbiAgaG92ZXJSYWRpdXM6IDQsXG4gIHBvaW50U3R5bGU6IFwiY2lyY2xlXCIsXG4gIHJhZGl1czogMyxcbiAgcm90YXRpb246IDBcbn0pLFxuLyoqXG4qIEB0eXBlIHthbnl9XG4qL1xudyhIZSwgXCJkZWZhdWx0Um91dGVzXCIsIHtcbiAgYmFja2dyb3VuZENvbG9yOiBcImJhY2tncm91bmRDb2xvclwiLFxuICBib3JkZXJDb2xvcjogXCJib3JkZXJDb2xvclwiXG59KTtcbmZ1bmN0aW9uIGVvKGksIHQpIHtcbiAgdmFyIF9pJGdldFByb3BzMiA9IGkuZ2V0UHJvcHMoW1wieFwiLCBcInlcIiwgXCJiYXNlXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIl0sIHQpLFxuICAgIGUgPSBfaSRnZXRQcm9wczIueCxcbiAgICBzID0gX2kkZ2V0UHJvcHMyLnksXG4gICAgbiA9IF9pJGdldFByb3BzMi5iYXNlLFxuICAgIG8gPSBfaSRnZXRQcm9wczIud2lkdGgsXG4gICAgciA9IF9pJGdldFByb3BzMi5oZWlnaHQ7XG4gIHZhciBhLCBsLCBjLCBoLCBkO1xuICByZXR1cm4gaS5ob3Jpem9udGFsID8gKGQgPSByIC8gMiwgYSA9IE1hdGgubWluKGUsIG4pLCBsID0gTWF0aC5tYXgoZSwgbiksIGMgPSBzIC0gZCwgaCA9IHMgKyBkKSA6IChkID0gbyAvIDIsIGEgPSBlIC0gZCwgbCA9IGUgKyBkLCBjID0gTWF0aC5taW4ocywgbiksIGggPSBNYXRoLm1heChzLCBuKSksIHtcbiAgICBsZWZ0OiBhLFxuICAgIHRvcDogYyxcbiAgICByaWdodDogbCxcbiAgICBib3R0b206IGhcbiAgfTtcbn1cbmZ1bmN0aW9uIE10KGksIHQsIGUsIHMpIHtcbiAgcmV0dXJuIGkgPyAwIDogVSh0LCBlLCBzKTtcbn1cbmZ1bmN0aW9uIEtsKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBpLm9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgbiA9IGkuYm9yZGVyU2tpcHBlZCxcbiAgICBvID0gT24ocyk7XG4gIHJldHVybiB7XG4gICAgdDogTXQobi50b3AsIG8udG9wLCAwLCBlKSxcbiAgICByOiBNdChuLnJpZ2h0LCBvLnJpZ2h0LCAwLCB0KSxcbiAgICBiOiBNdChuLmJvdHRvbSwgby5ib3R0b20sIDAsIGUpLFxuICAgIGw6IE10KG4ubGVmdCwgby5sZWZ0LCAwLCB0KVxuICB9O1xufVxuZnVuY3Rpb24gR2woaSwgdCwgZSkge1xuICB2YXIgX2kkZ2V0UHJvcHMzID0gaS5nZXRQcm9wcyhbXCJlbmFibGVCb3JkZXJSYWRpdXNcIl0pLFxuICAgIHMgPSBfaSRnZXRQcm9wczMuZW5hYmxlQm9yZGVyUmFkaXVzLFxuICAgIG4gPSBpLm9wdGlvbnMuYm9yZGVyUmFkaXVzLFxuICAgIG8gPSBZdChuKSxcbiAgICByID0gTWF0aC5taW4odCwgZSksXG4gICAgYSA9IGkuYm9yZGVyU2tpcHBlZCxcbiAgICBsID0gcyB8fCBUKG4pO1xuICByZXR1cm4ge1xuICAgIHRvcExlZnQ6IE10KCFsIHx8IGEudG9wIHx8IGEubGVmdCwgby50b3BMZWZ0LCAwLCByKSxcbiAgICB0b3BSaWdodDogTXQoIWwgfHwgYS50b3AgfHwgYS5yaWdodCwgby50b3BSaWdodCwgMCwgciksXG4gICAgYm90dG9tTGVmdDogTXQoIWwgfHwgYS5ib3R0b20gfHwgYS5sZWZ0LCBvLmJvdHRvbUxlZnQsIDAsIHIpLFxuICAgIGJvdHRvbVJpZ2h0OiBNdCghbCB8fCBhLmJvdHRvbSB8fCBhLnJpZ2h0LCBvLmJvdHRvbVJpZ2h0LCAwLCByKVxuICB9O1xufVxuZnVuY3Rpb24gSmwoaSkge1xuICB2YXIgdCA9IGVvKGkpLFxuICAgIGUgPSB0LnJpZ2h0IC0gdC5sZWZ0LFxuICAgIHMgPSB0LmJvdHRvbSAtIHQudG9wLFxuICAgIG4gPSBLbChpLCBlIC8gMiwgcyAvIDIpLFxuICAgIG8gPSBHbChpLCBlIC8gMiwgcyAvIDIpO1xuICByZXR1cm4ge1xuICAgIG91dGVyOiB7XG4gICAgICB4OiB0LmxlZnQsXG4gICAgICB5OiB0LnRvcCxcbiAgICAgIHc6IGUsXG4gICAgICBoOiBzLFxuICAgICAgcmFkaXVzOiBvXG4gICAgfSxcbiAgICBpbm5lcjoge1xuICAgICAgeDogdC5sZWZ0ICsgbi5sLFxuICAgICAgeTogdC50b3AgKyBuLnQsXG4gICAgICB3OiBlIC0gbi5sIC0gbi5yLFxuICAgICAgaDogcyAtIG4udCAtIG4uYixcbiAgICAgIHJhZGl1czoge1xuICAgICAgICB0b3BMZWZ0OiBNYXRoLm1heCgwLCBvLnRvcExlZnQgLSBNYXRoLm1heChuLnQsIG4ubCkpLFxuICAgICAgICB0b3BSaWdodDogTWF0aC5tYXgoMCwgby50b3BSaWdodCAtIE1hdGgubWF4KG4udCwgbi5yKSksXG4gICAgICAgIGJvdHRvbUxlZnQ6IE1hdGgubWF4KDAsIG8uYm90dG9tTGVmdCAtIE1hdGgubWF4KG4uYiwgbi5sKSksXG4gICAgICAgIGJvdHRvbVJpZ2h0OiBNYXRoLm1heCgwLCBvLmJvdHRvbVJpZ2h0IC0gTWF0aC5tYXgobi5iLCBuLnIpKVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSB0ID09PSBudWxsLFxuICAgIG8gPSBlID09PSBudWxsLFxuICAgIGEgPSBpICYmICEobiAmJiBvKSAmJiBlbyhpLCBzKTtcbiAgcmV0dXJuIGEgJiYgKG4gfHwgX3QodCwgYS5sZWZ0LCBhLnJpZ2h0KSkgJiYgKG8gfHwgX3QoZSwgYS50b3AsIGEuYm90dG9tKSk7XG59XG5mdW5jdGlvbiBabChpKSB7XG4gIHJldHVybiBpLnRvcExlZnQgfHwgaS50b3BSaWdodCB8fCBpLmJvdHRvbUxlZnQgfHwgaS5ib3R0b21SaWdodDtcbn1cbmZ1bmN0aW9uIFFsKGksIHQpIHtcbiAgaS5yZWN0KHQueCwgdC55LCB0LncsIHQuaCk7XG59XG5mdW5jdGlvbiBnaShpLCB0KSB7XG4gIHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHMgPSBpLnggIT09IGUueCA/IC10IDogMCxcbiAgICBuID0gaS55ICE9PSBlLnkgPyAtdCA6IDAsXG4gICAgbyA9IChpLnggKyBpLncgIT09IGUueCArIGUudyA/IHQgOiAwKSAtIHMsXG4gICAgciA9IChpLnkgKyBpLmggIT09IGUueSArIGUuaCA/IHQgOiAwKSAtIG47XG4gIHJldHVybiB7XG4gICAgeDogaS54ICsgcyxcbiAgICB5OiBpLnkgKyBuLFxuICAgIHc6IGkudyArIG8sXG4gICAgaDogaS5oICsgcixcbiAgICByYWRpdXM6IGkucmFkaXVzXG4gIH07XG59XG52YXIgV2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdDUpIHtcbiAgZnVuY3Rpb24gV2UodCkge1xuICAgIHZhciBfdGhpczIzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZSk7XG4gICAgX3RoaXMyMyA9IF9jYWxsU3VwZXIodGhpcywgV2UpLCBfdGhpczIzLm9wdGlvbnMgPSB2b2lkIDAsIF90aGlzMjMuaG9yaXpvbnRhbCA9IHZvaWQgMCwgX3RoaXMyMy5iYXNlID0gdm9pZCAwLCBfdGhpczIzLndpZHRoID0gdm9pZCAwLCBfdGhpczIzLmhlaWdodCA9IHZvaWQgMCwgX3RoaXMyMy5pbmZsYXRlQW1vdW50ID0gdm9pZCAwLCB0ICYmIE9iamVjdC5hc3NpZ24oX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczIzKSwgdCk7XG4gICAgcmV0dXJuIF90aGlzMjM7XG4gIH1cbiAgX2luaGVyaXRzKFdlLCBfc3Q1KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhXZSwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5pbmZsYXRlQW1vdW50LFxuICAgICAgICBfdGhpcyRvcHRpb25zMTIgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHMgPSBfdGhpcyRvcHRpb25zMTIuYm9yZGVyQ29sb3IsXG4gICAgICAgIG4gPSBfdGhpcyRvcHRpb25zMTIuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICBfSmwgPSBKbCh0aGlzKSxcbiAgICAgICAgbyA9IF9KbC5pbm5lcixcbiAgICAgICAgciA9IF9KbC5vdXRlcixcbiAgICAgICAgYSA9IFpsKHIucmFkaXVzKSA/IFVlIDogUWw7XG4gICAgICB0LnNhdmUoKSwgKHIudyAhPT0gby53IHx8IHIuaCAhPT0gby5oKSAmJiAodC5iZWdpblBhdGgoKSwgYSh0LCBnaShyLCBlLCBvKSksIHQuY2xpcCgpLCBhKHQsIGdpKG8sIC1lLCByKSksIHQuZmlsbFN0eWxlID0gcywgdC5maWxsKFwiZXZlbm9kZFwiKSksIHQuYmVnaW5QYXRoKCksIGEodCwgZ2kobywgZSkpLCB0LmZpbGxTdHlsZSA9IG4sIHQuZmlsbCgpLCB0LnJlc3RvcmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5SYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpblJhbmdlKHQsIGUsIHMpIHtcbiAgICAgIHJldHVybiBmaSh0aGlzLCB0LCBlLCBzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5YUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5YUmFuZ2UodCwgZSkge1xuICAgICAgcmV0dXJuIGZpKHRoaXMsIHQsIG51bGwsIGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbllSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbllSYW5nZSh0LCBlKSB7XG4gICAgICByZXR1cm4gZmkodGhpcywgbnVsbCwgdCwgZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENlbnRlclBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENlbnRlclBvaW50KHQpIHtcbiAgICAgIHZhciBfdGhpcyRnZXRQcm9wczYgPSB0aGlzLmdldFByb3BzKFtcInhcIiwgXCJ5XCIsIFwiYmFzZVwiLCBcImhvcml6b250YWxcIl0sIHQpLFxuICAgICAgICBlID0gX3RoaXMkZ2V0UHJvcHM2LngsXG4gICAgICAgIHMgPSBfdGhpcyRnZXRQcm9wczYueSxcbiAgICAgICAgbiA9IF90aGlzJGdldFByb3BzNi5iYXNlLFxuICAgICAgICBvID0gX3RoaXMkZ2V0UHJvcHM2Lmhvcml6b250YWw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBvID8gKGUgKyBuKSAvIDIgOiBlLFxuICAgICAgICB5OiBvID8gcyA6IChzICsgbikgLyAyXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSYW5nZSh0KSB7XG4gICAgICByZXR1cm4gdCA9PT0gXCJ4XCIgPyB0aGlzLndpZHRoIC8gMiA6IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICB9XG4gIH1dKTtcbn0oc3QpO1xudyhXZSwgXCJpZFwiLCBcImJhclwiKSwgdyhXZSwgXCJkZWZhdWx0c1wiLCB7XG4gIGJvcmRlclNraXBwZWQ6IFwic3RhcnRcIixcbiAgYm9yZGVyV2lkdGg6IDAsXG4gIGJvcmRlclJhZGl1czogMCxcbiAgaW5mbGF0ZUFtb3VudDogXCJhdXRvXCIsXG4gIHBvaW50U3R5bGU6IHZvaWQgMFxufSksIHcoV2UsIFwiZGVmYXVsdFJvdXRlc1wiLCB7XG4gIGJhY2tncm91bmRDb2xvcjogXCJiYWNrZ3JvdW5kQ29sb3JcIixcbiAgYm9yZGVyQ29sb3I6IFwiYm9yZGVyQ29sb3JcIlxufSk7XG5mdW5jdGlvbiB0YyhpLCB0LCBlKSB7XG4gIHZhciBzID0gaS5zZWdtZW50cyxcbiAgICBuID0gaS5wb2ludHMsXG4gICAgbyA9IHQucG9pbnRzLFxuICAgIHIgPSBbXTtcbiAgdmFyIF9pdGVyYXRvcjI4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocyksXG4gICAgX3N0ZXAyODtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjI4LnMoKTsgIShfc3RlcDI4ID0gX2l0ZXJhdG9yMjgubigpKS5kb25lOykge1xuICAgICAgdmFyIGEgPSBfc3RlcDI4LnZhbHVlO1xuICAgICAgdmFyIGwgPSBhLnN0YXJ0LFxuICAgICAgICBjID0gYS5lbmQ7XG4gICAgICBjID0gZWkobCwgYywgbik7XG4gICAgICB2YXIgaCA9IENpKGUsIG5bbF0sIG5bY10sIGEubG9vcCk7XG4gICAgICBpZiAoIXQuc2VnbWVudHMpIHtcbiAgICAgICAgci5wdXNoKHtcbiAgICAgICAgICBzb3VyY2U6IGEsXG4gICAgICAgICAgdGFyZ2V0OiBoLFxuICAgICAgICAgIHN0YXJ0OiBuW2xdLFxuICAgICAgICAgIGVuZDogbltjXVxuICAgICAgICB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZCA9IEhuKHQsIGgpO1xuICAgICAgdmFyIF9pdGVyYXRvcjI5ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZCksXG4gICAgICAgIF9zdGVwMjk7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjI5LnMoKTsgIShfc3RlcDI5ID0gX2l0ZXJhdG9yMjkubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciB1ID0gX3N0ZXAyOS52YWx1ZTtcbiAgICAgICAgICB2YXIgZiA9IENpKGUsIG9bdS5zdGFydF0sIG9bdS5lbmRdLCB1Lmxvb3ApLFxuICAgICAgICAgICAgcCA9IEJuKGEsIG4sIGYpO1xuICAgICAgICAgIHZhciBfaXRlcmF0b3IzMCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHApLFxuICAgICAgICAgICAgX3N0ZXAzMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IzMC5zKCk7ICEoX3N0ZXAzMCA9IF9pdGVyYXRvcjMwLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIGcgPSBfc3RlcDMwLnZhbHVlO1xuICAgICAgICAgICAgICByLnB1c2goe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogZyxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHUsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgZSwgVXMoaCwgZiwgXCJzdGFydFwiLCBNYXRoLm1heCkpLFxuICAgICAgICAgICAgICAgIGVuZDogX2RlZmluZVByb3BlcnR5KHt9LCBlLCBVcyhoLCBmLCBcImVuZFwiLCBNYXRoLm1pbikpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMzAuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IzMC5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMjkuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMjkuZigpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMjguZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjI4LmYoKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIENpKGksIHQsIGUsIHMpIHtcbiAgaWYgKHMpIHJldHVybjtcbiAgdmFyIG4gPSB0W2ldLFxuICAgIG8gPSBlW2ldO1xuICByZXR1cm4gaSA9PT0gXCJhbmdsZVwiICYmIChuID0gWihuKSwgbyA9IFoobykpLCB7XG4gICAgcHJvcGVydHk6IGksXG4gICAgc3RhcnQ6IG4sXG4gICAgZW5kOiBvXG4gIH07XG59XG5mdW5jdGlvbiBlYyhpLCB0KSB7XG4gIHZhciBfcmVmOCA9IGkgfHwge30sXG4gICAgX3JlZjgkeCA9IF9yZWY4LngsXG4gICAgZSA9IF9yZWY4JHggPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmOCR4LFxuICAgIF9yZWY4JHkgPSBfcmVmOC55LFxuICAgIHMgPSBfcmVmOCR5ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjgkeSxcbiAgICBuID0gdC5wb2ludHMsXG4gICAgbyA9IFtdO1xuICByZXR1cm4gdC5zZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmOSkge1xuICAgIHZhciByID0gX3JlZjkuc3RhcnQsXG4gICAgICBhID0gX3JlZjkuZW5kO1xuICAgIGEgPSBlaShyLCBhLCBuKTtcbiAgICB2YXIgbCA9IG5bcl0sXG4gICAgICBjID0gblthXTtcbiAgICBzICE9PSBudWxsID8gKG8ucHVzaCh7XG4gICAgICB4OiBsLngsXG4gICAgICB5OiBzXG4gICAgfSksIG8ucHVzaCh7XG4gICAgICB4OiBjLngsXG4gICAgICB5OiBzXG4gICAgfSkpIDogZSAhPT0gbnVsbCAmJiAoby5wdXNoKHtcbiAgICAgIHg6IGUsXG4gICAgICB5OiBsLnlcbiAgICB9KSwgby5wdXNoKHtcbiAgICAgIHg6IGUsXG4gICAgICB5OiBjLnlcbiAgICB9KSk7XG4gIH0pLCBvO1xufVxuZnVuY3Rpb24gZWkoaSwgdCwgZSkge1xuICBmb3IgKDsgdCA+IGk7IHQtLSkge1xuICAgIHZhciBzID0gZVt0XTtcbiAgICBpZiAoIWlzTmFOKHMueCkgJiYgIWlzTmFOKHMueSkpIGJyZWFrO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gVXMoaSwgdCwgZSwgcykge1xuICByZXR1cm4gaSAmJiB0ID8gcyhpW2VdLCB0W2VdKSA6IGkgPyBpW2VdIDogdCA/IHRbZV0gOiAwO1xufVxuZnVuY3Rpb24gaW8oaSwgdCkge1xuICB2YXIgZSA9IFtdLFxuICAgIHMgPSAhMTtcbiAgcmV0dXJuIE4oaSkgPyAocyA9ICEwLCBlID0gaSkgOiBlID0gZWMoaSwgdCksIGUubGVuZ3RoID8gbmV3IHZ0KHtcbiAgICBwb2ludHM6IGUsXG4gICAgb3B0aW9uczoge1xuICAgICAgdGVuc2lvbjogMFxuICAgIH0sXG4gICAgX2xvb3A6IHMsXG4gICAgX2Z1bGxMb29wOiBzXG4gIH0pIDogbnVsbDtcbn1cbmZ1bmN0aW9uIFhzKGkpIHtcbiAgcmV0dXJuIGkgJiYgaS5maWxsICE9PSAhMTtcbn1cbmZ1bmN0aW9uIGljKGksIHQsIGUpIHtcbiAgdmFyIG4gPSBpW3RdLmZpbGw7XG4gIHZhciBvID0gW3RdO1xuICB2YXIgcjtcbiAgaWYgKCFlKSByZXR1cm4gbjtcbiAgZm9yICg7IG4gIT09ICExICYmIG8uaW5kZXhPZihuKSA9PT0gLTE7KSB7XG4gICAgaWYgKCFxKG4pKSByZXR1cm4gbjtcbiAgICBpZiAociA9IGlbbl0sICFyKSByZXR1cm4gITE7XG4gICAgaWYgKHIudmlzaWJsZSkgcmV0dXJuIG47XG4gICAgby5wdXNoKG4pLCBuID0gci5maWxsO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIHNjKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBhYyhpKTtcbiAgaWYgKFQocykpIHJldHVybiBpc05hTihzLnZhbHVlKSA/ICExIDogcztcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHMpO1xuICByZXR1cm4gcShuKSAmJiBNYXRoLmZsb29yKG4pID09PSBuID8gbmMoc1swXSwgdCwgbiwgZSkgOiBbXCJvcmlnaW5cIiwgXCJzdGFydFwiLCBcImVuZFwiLCBcInN0YWNrXCIsIFwic2hhcGVcIl0uaW5kZXhPZihzKSA+PSAwICYmIHM7XG59XG5mdW5jdGlvbiBuYyhpLCB0LCBlLCBzKSB7XG4gIHJldHVybiAoaSA9PT0gXCItXCIgfHwgaSA9PT0gXCIrXCIpICYmIChlID0gdCArIGUpLCBlID09PSB0IHx8IGUgPCAwIHx8IGUgPj0gcyA/ICExIDogZTtcbn1cbmZ1bmN0aW9uIG9jKGksIHQpIHtcbiAgdmFyIGUgPSBudWxsO1xuICByZXR1cm4gaSA9PT0gXCJzdGFydFwiID8gZSA9IHQuYm90dG9tIDogaSA9PT0gXCJlbmRcIiA/IGUgPSB0LnRvcCA6IFQoaSkgPyBlID0gdC5nZXRQaXhlbEZvclZhbHVlKGkudmFsdWUpIDogdC5nZXRCYXNlUGl4ZWwgJiYgKGUgPSB0LmdldEJhc2VQaXhlbCgpKSwgZTtcbn1cbmZ1bmN0aW9uIHJjKGksIHQsIGUpIHtcbiAgdmFyIHM7XG4gIHJldHVybiBpID09PSBcInN0YXJ0XCIgPyBzID0gZSA6IGkgPT09IFwiZW5kXCIgPyBzID0gdC5vcHRpb25zLnJldmVyc2UgPyB0Lm1pbiA6IHQubWF4IDogVChpKSA/IHMgPSBpLnZhbHVlIDogcyA9IHQuZ2V0QmFzZVZhbHVlKCksIHM7XG59XG5mdW5jdGlvbiBhYyhpKSB7XG4gIHZhciB0ID0gaS5vcHRpb25zLFxuICAgIGUgPSB0LmZpbGw7XG4gIHZhciBzID0gRChlICYmIGUudGFyZ2V0LCBlKTtcbiAgcmV0dXJuIHMgPT09IHZvaWQgMCAmJiAocyA9ICEhdC5iYWNrZ3JvdW5kQ29sb3IpLCBzID09PSAhMSB8fCBzID09PSBudWxsID8gITEgOiBzID09PSAhMCA/IFwib3JpZ2luXCIgOiBzO1xufVxuZnVuY3Rpb24gbGMoaSkge1xuICB2YXIgdCA9IGkuc2NhbGUsXG4gICAgZSA9IGkuaW5kZXgsXG4gICAgcyA9IGkubGluZSxcbiAgICBuID0gW10sXG4gICAgbyA9IHMuc2VnbWVudHMsXG4gICAgciA9IHMucG9pbnRzLFxuICAgIGEgPSBjYyh0LCBlKTtcbiAgYS5wdXNoKGlvKHtcbiAgICB4OiBudWxsLFxuICAgIHk6IHQuYm90dG9tXG4gIH0sIHMpKTtcbiAgZm9yICh2YXIgbCA9IDA7IGwgPCBvLmxlbmd0aDsgbCsrKSB7XG4gICAgdmFyIGMgPSBvW2xdO1xuICAgIGZvciAodmFyIGggPSBjLnN0YXJ0OyBoIDw9IGMuZW5kOyBoKyspIGhjKG4sIHJbaF0sIGEpO1xuICB9XG4gIHJldHVybiBuZXcgdnQoe1xuICAgIHBvaW50czogbixcbiAgICBvcHRpb25zOiB7fVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNjKGksIHQpIHtcbiAgdmFyIGUgPSBbXSxcbiAgICBzID0gaS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyhcImxpbmVcIik7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgcy5sZW5ndGg7IG4rKykge1xuICAgIHZhciBvID0gc1tuXTtcbiAgICBpZiAoby5pbmRleCA9PT0gdCkgYnJlYWs7XG4gICAgby5oaWRkZW4gfHwgZS51bnNoaWZ0KG8uZGF0YXNldCk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBoYyhpLCB0LCBlKSB7XG4gIHZhciBzID0gW107XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykge1xuICAgIHZhciBvID0gZVtuXSxcbiAgICAgIF9kYyA9IGRjKG8sIHQsIFwieFwiKSxcbiAgICAgIHIgPSBfZGMuZmlyc3QsXG4gICAgICBhID0gX2RjLmxhc3QsXG4gICAgICBsID0gX2RjLnBvaW50O1xuICAgIGlmICghKCFsIHx8IHIgJiYgYSkpIHtcbiAgICAgIGlmIChyKSBzLnVuc2hpZnQobCk7ZWxzZSBpZiAoaS5wdXNoKGwpLCAhYSkgYnJlYWs7XG4gICAgfVxuICB9XG4gIGkucHVzaC5hcHBseShpLCBzKTtcbn1cbmZ1bmN0aW9uIGRjKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBpLmludGVycG9sYXRlKHQsIGUpO1xuICBpZiAoIXMpIHJldHVybiB7fTtcbiAgdmFyIG4gPSBzW2VdLFxuICAgIG8gPSBpLnNlZ21lbnRzLFxuICAgIHIgPSBpLnBvaW50cztcbiAgdmFyIGEgPSAhMSxcbiAgICBsID0gITE7XG4gIGZvciAodmFyIGMgPSAwOyBjIDwgby5sZW5ndGg7IGMrKykge1xuICAgIHZhciBoID0gb1tjXSxcbiAgICAgIGQgPSByW2guc3RhcnRdW2VdLFxuICAgICAgdSA9IHJbaC5lbmRdW2VdO1xuICAgIGlmIChfdChuLCBkLCB1KSkge1xuICAgICAgYSA9IG4gPT09IGQsIGwgPSBuID09PSB1O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZmlyc3Q6IGEsXG4gICAgbGFzdDogbCxcbiAgICBwb2ludDogc1xuICB9O1xufVxudmFyIHNvID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc28odCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBzbyk7XG4gICAgdGhpcy54ID0gdC54LCB0aGlzLnkgPSB0LnksIHRoaXMucmFkaXVzID0gdC5yYWRpdXM7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhzbywgW3tcbiAgICBrZXk6IFwicGF0aFNlZ21lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aFNlZ21lbnQodCwgZSwgcykge1xuICAgICAgdmFyIG4gPSB0aGlzLngsXG4gICAgICAgIG8gPSB0aGlzLnksXG4gICAgICAgIHIgPSB0aGlzLnJhZGl1cztcbiAgICAgIHJldHVybiBlID0gZSB8fCB7XG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IEJcbiAgICAgIH0sIHQuYXJjKG4sIG8sIHIsIGUuZW5kLCBlLnN0YXJ0LCAhMCksICFzLmJvdW5kcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJwb2xhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGUodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLngsXG4gICAgICAgIHMgPSB0aGlzLnksXG4gICAgICAgIG4gPSB0aGlzLnJhZGl1cyxcbiAgICAgICAgbyA9IHQuYW5nbGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBlICsgTWF0aC5jb3MobykgKiBuLFxuICAgICAgICB5OiBzICsgTWF0aC5zaW4obykgKiBuLFxuICAgICAgICBhbmdsZTogb1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbmZ1bmN0aW9uIHVjKGkpIHtcbiAgdmFyIHQgPSBpLmNoYXJ0LFxuICAgIGUgPSBpLmZpbGwsXG4gICAgcyA9IGkubGluZTtcbiAgaWYgKHEoZSkpIHJldHVybiBmYyh0LCBlKTtcbiAgaWYgKGUgPT09IFwic3RhY2tcIikgcmV0dXJuIGxjKGkpO1xuICBpZiAoZSA9PT0gXCJzaGFwZVwiKSByZXR1cm4gITA7XG4gIHZhciBuID0gZ2MoaSk7XG4gIHJldHVybiBuIGluc3RhbmNlb2Ygc28gPyBuIDogaW8obiwgcyk7XG59XG5mdW5jdGlvbiBmYyhpLCB0KSB7XG4gIHZhciBlID0gaS5nZXREYXRhc2V0TWV0YSh0KTtcbiAgcmV0dXJuIGUgJiYgaS5pc0RhdGFzZXRWaXNpYmxlKHQpID8gZS5kYXRhc2V0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdjKGkpIHtcbiAgcmV0dXJuIChpLnNjYWxlIHx8IHt9KS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUgPyBtYyhpKSA6IHBjKGkpO1xufVxuZnVuY3Rpb24gcGMoaSkge1xuICB2YXIgX2kkc2NhbGUgPSBpLnNjYWxlLFxuICAgIHQgPSBfaSRzY2FsZSA9PT0gdm9pZCAwID8ge30gOiBfaSRzY2FsZSxcbiAgICBlID0gaS5maWxsLFxuICAgIHMgPSBvYyhlLCB0KTtcbiAgaWYgKHEocykpIHtcbiAgICB2YXIgbiA9IHQuaXNIb3Jpem9udGFsKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IG4gPyBzIDogbnVsbCxcbiAgICAgIHk6IG4gPyBudWxsIDogc1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtYyhpKSB7XG4gIHZhciB0ID0gaS5zY2FsZSxcbiAgICBlID0gaS5maWxsLFxuICAgIHMgPSB0Lm9wdGlvbnMsXG4gICAgbiA9IHQuZ2V0TGFiZWxzKCkubGVuZ3RoLFxuICAgIG8gPSBzLnJldmVyc2UgPyB0Lm1heCA6IHQubWluLFxuICAgIHIgPSByYyhlLCB0LCBvKSxcbiAgICBhID0gW107XG4gIGlmIChzLmdyaWQuY2lyY3VsYXIpIHtcbiAgICB2YXIgbCA9IHQuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsIG8pO1xuICAgIHJldHVybiBuZXcgc28oe1xuICAgICAgeDogbC54LFxuICAgICAgeTogbC55LFxuICAgICAgcmFkaXVzOiB0LmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHIpXG4gICAgfSk7XG4gIH1cbiAgZm9yICh2YXIgX2wyID0gMDsgX2wyIDwgbjsgKytfbDIpIGEucHVzaCh0LmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShfbDIsIHIpKTtcbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBwaShpLCB0LCBlKSB7XG4gIHZhciBzID0gdWModCksXG4gICAgbiA9IHQuY2hhcnQsXG4gICAgbyA9IHQuaW5kZXgsXG4gICAgciA9IHQubGluZSxcbiAgICBhID0gdC5zY2FsZSxcbiAgICBsID0gdC5heGlzLFxuICAgIGMgPSByLm9wdGlvbnMsXG4gICAgaCA9IGMuZmlsbCxcbiAgICBkID0gYy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgX3JlZjAgPSBoIHx8IHt9LFxuICAgIF9yZWYwJGFib3ZlID0gX3JlZjAuYWJvdmUsXG4gICAgdSA9IF9yZWYwJGFib3ZlID09PSB2b2lkIDAgPyBkIDogX3JlZjAkYWJvdmUsXG4gICAgX3JlZjAkYmVsb3cgPSBfcmVmMC5iZWxvdyxcbiAgICBmID0gX3JlZjAkYmVsb3cgPT09IHZvaWQgMCA/IGQgOiBfcmVmMCRiZWxvdyxcbiAgICBwID0gbi5nZXREYXRhc2V0TWV0YShvKSxcbiAgICBnID0gV24obiwgcCk7XG4gIHMgJiYgci5wb2ludHMubGVuZ3RoICYmIChKZShpLCBlKSwgYmMoaSwge1xuICAgIGxpbmU6IHIsXG4gICAgdGFyZ2V0OiBzLFxuICAgIGFib3ZlOiB1LFxuICAgIGJlbG93OiBmLFxuICAgIGFyZWE6IGUsXG4gICAgc2NhbGU6IGEsXG4gICAgYXhpczogbCxcbiAgICBjbGlwOiBnXG4gIH0pLCBaZShpKSk7XG59XG5mdW5jdGlvbiBiYyhpLCB0KSB7XG4gIHZhciBlID0gdC5saW5lLFxuICAgIHMgPSB0LnRhcmdldCxcbiAgICBuID0gdC5hYm92ZSxcbiAgICBvID0gdC5iZWxvdyxcbiAgICByID0gdC5hcmVhLFxuICAgIGEgPSB0LnNjYWxlLFxuICAgIGwgPSB0LmNsaXAsXG4gICAgYyA9IGUuX2xvb3AgPyBcImFuZ2xlXCIgOiB0LmF4aXM7XG4gIGkuc2F2ZSgpO1xuICB2YXIgaCA9IG87XG4gIG8gIT09IG4gJiYgKGMgPT09IFwieFwiID8gKHFzKGksIHMsIHIudG9wKSwgbWkoaSwge1xuICAgIGxpbmU6IGUsXG4gICAgdGFyZ2V0OiBzLFxuICAgIGNvbG9yOiBuLFxuICAgIHNjYWxlOiBhLFxuICAgIHByb3BlcnR5OiBjLFxuICAgIGNsaXA6IGxcbiAgfSksIGkucmVzdG9yZSgpLCBpLnNhdmUoKSwgcXMoaSwgcywgci5ib3R0b20pKSA6IGMgPT09IFwieVwiICYmIChLcyhpLCBzLCByLmxlZnQpLCBtaShpLCB7XG4gICAgbGluZTogZSxcbiAgICB0YXJnZXQ6IHMsXG4gICAgY29sb3I6IG8sXG4gICAgc2NhbGU6IGEsXG4gICAgcHJvcGVydHk6IGMsXG4gICAgY2xpcDogbFxuICB9KSwgaS5yZXN0b3JlKCksIGkuc2F2ZSgpLCBLcyhpLCBzLCByLnJpZ2h0KSwgaCA9IG4pKSwgbWkoaSwge1xuICAgIGxpbmU6IGUsXG4gICAgdGFyZ2V0OiBzLFxuICAgIGNvbG9yOiBoLFxuICAgIHNjYWxlOiBhLFxuICAgIHByb3BlcnR5OiBjLFxuICAgIGNsaXA6IGxcbiAgfSksIGkucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gcXMoaSwgdCwgZSkge1xuICB2YXIgcyA9IHQuc2VnbWVudHMsXG4gICAgbiA9IHQucG9pbnRzO1xuICB2YXIgbyA9ICEwLFxuICAgIHIgPSAhMTtcbiAgaS5iZWdpblBhdGgoKTtcbiAgdmFyIF9pdGVyYXRvcjMxID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocyksXG4gICAgX3N0ZXAzMTtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjMxLnMoKTsgIShfc3RlcDMxID0gX2l0ZXJhdG9yMzEubigpKS5kb25lOykge1xuICAgICAgdmFyIGEgPSBfc3RlcDMxLnZhbHVlO1xuICAgICAgdmFyIGwgPSBhLnN0YXJ0LFxuICAgICAgICBjID0gYS5lbmQsXG4gICAgICAgIGggPSBuW2xdLFxuICAgICAgICBkID0gbltlaShsLCBjLCBuKV07XG4gICAgICBvID8gKGkubW92ZVRvKGgueCwgaC55KSwgbyA9ICExKSA6IChpLmxpbmVUbyhoLngsIGUpLCBpLmxpbmVUbyhoLngsIGgueSkpLCByID0gISF0LnBhdGhTZWdtZW50KGksIGEsIHtcbiAgICAgICAgbW92ZTogclxuICAgICAgfSksIHIgPyBpLmNsb3NlUGF0aCgpIDogaS5saW5lVG8oZC54LCBlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjMxLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IzMS5mKCk7XG4gIH1cbiAgaS5saW5lVG8odC5maXJzdCgpLngsIGUpLCBpLmNsb3NlUGF0aCgpLCBpLmNsaXAoKTtcbn1cbmZ1bmN0aW9uIEtzKGksIHQsIGUpIHtcbiAgdmFyIHMgPSB0LnNlZ21lbnRzLFxuICAgIG4gPSB0LnBvaW50cztcbiAgdmFyIG8gPSAhMCxcbiAgICByID0gITE7XG4gIGkuYmVnaW5QYXRoKCk7XG4gIHZhciBfaXRlcmF0b3IzMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHMpLFxuICAgIF9zdGVwMzI7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IzMi5zKCk7ICEoX3N0ZXAzMiA9IF9pdGVyYXRvcjMyLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBhID0gX3N0ZXAzMi52YWx1ZTtcbiAgICAgIHZhciBsID0gYS5zdGFydCxcbiAgICAgICAgYyA9IGEuZW5kLFxuICAgICAgICBoID0gbltsXSxcbiAgICAgICAgZCA9IG5bZWkobCwgYywgbildO1xuICAgICAgbyA/IChpLm1vdmVUbyhoLngsIGgueSksIG8gPSAhMSkgOiAoaS5saW5lVG8oZSwgaC55KSwgaS5saW5lVG8oaC54LCBoLnkpKSwgciA9ICEhdC5wYXRoU2VnbWVudChpLCBhLCB7XG4gICAgICAgIG1vdmU6IHJcbiAgICAgIH0pLCByID8gaS5jbG9zZVBhdGgoKSA6IGkubGluZVRvKGUsIGQueSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IzMi5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMzIuZigpO1xuICB9XG4gIGkubGluZVRvKGUsIHQuZmlyc3QoKS55KSwgaS5jbG9zZVBhdGgoKSwgaS5jbGlwKCk7XG59XG5mdW5jdGlvbiBtaShpLCB0KSB7XG4gIHZhciBlID0gdC5saW5lLFxuICAgIHMgPSB0LnRhcmdldCxcbiAgICBuID0gdC5wcm9wZXJ0eSxcbiAgICBvID0gdC5jb2xvcixcbiAgICByID0gdC5zY2FsZSxcbiAgICBhID0gdC5jbGlwLFxuICAgIGwgPSB0YyhlLCBzLCBuKTtcbiAgdmFyIF9pdGVyYXRvcjMzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobCksXG4gICAgX3N0ZXAzMztcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjMzLnMoKTsgIShfc3RlcDMzID0gX2l0ZXJhdG9yMzMubigpKS5kb25lOykge1xuICAgICAgdmFyIF9zdGVwMzMkdmFsdWUgPSBfc3RlcDMzLnZhbHVlLFxuICAgICAgICBjID0gX3N0ZXAzMyR2YWx1ZS5zb3VyY2UsXG4gICAgICAgIGggPSBfc3RlcDMzJHZhbHVlLnRhcmdldCxcbiAgICAgICAgZCA9IF9zdGVwMzMkdmFsdWUuc3RhcnQsXG4gICAgICAgIHUgPSBfc3RlcDMzJHZhbHVlLmVuZDtcbiAgICAgIHZhciBfYyRzdHlsZSA9IGMuc3R5bGUsXG4gICAgICAgIF9jJHN0eWxlMiA9IF9jJHN0eWxlID09PSB2b2lkIDAgPyB7fSA6IF9jJHN0eWxlLFxuICAgICAgICBfYyRzdHlsZTIkYmFja2dyb3VuZEMgPSBfYyRzdHlsZTIuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICBmID0gX2Mkc3R5bGUyJGJhY2tncm91bmRDID09PSB2b2lkIDAgPyBvIDogX2Mkc3R5bGUyJGJhY2tncm91bmRDLFxuICAgICAgICBwID0gcyAhPT0gITA7XG4gICAgICBpLnNhdmUoKSwgaS5maWxsU3R5bGUgPSBmLCBfYyhpLCByLCBhLCBwICYmIENpKG4sIGQsIHUpKSwgaS5iZWdpblBhdGgoKTtcbiAgICAgIHZhciBnID0gISFlLnBhdGhTZWdtZW50KGksIGMpO1xuICAgICAgdmFyIG0gPSB2b2lkIDA7XG4gICAgICBpZiAocCkge1xuICAgICAgICBnID8gaS5jbG9zZVBhdGgoKSA6IEdzKGksIHMsIHUsIG4pO1xuICAgICAgICB2YXIgYiA9ICEhcy5wYXRoU2VnbWVudChpLCBoLCB7XG4gICAgICAgICAgbW92ZTogZyxcbiAgICAgICAgICByZXZlcnNlOiAhMFxuICAgICAgICB9KTtcbiAgICAgICAgbSA9IGcgJiYgYiwgbSB8fCBHcyhpLCBzLCBkLCBuKTtcbiAgICAgIH1cbiAgICAgIGkuY2xvc2VQYXRoKCksIGkuZmlsbChtID8gXCJldmVub2RkXCIgOiBcIm5vbnplcm9cIiksIGkucmVzdG9yZSgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMzMuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjMzLmYoKTtcbiAgfVxufVxuZnVuY3Rpb24gX2MoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IHQuY2hhcnQuY2hhcnRBcmVhLFxuICAgIF9yZWYxID0gcyB8fCB7fSxcbiAgICBvID0gX3JlZjEucHJvcGVydHksXG4gICAgciA9IF9yZWYxLnN0YXJ0LFxuICAgIGEgPSBfcmVmMS5lbmQ7XG4gIGlmIChvID09PSBcInhcIiB8fCBvID09PSBcInlcIikge1xuICAgIHZhciBsLCBjLCBoLCBkO1xuICAgIG8gPT09IFwieFwiID8gKGwgPSByLCBjID0gbi50b3AsIGggPSBhLCBkID0gbi5ib3R0b20pIDogKGwgPSBuLmxlZnQsIGMgPSByLCBoID0gbi5yaWdodCwgZCA9IGEpLCBpLmJlZ2luUGF0aCgpLCBlICYmIChsID0gTWF0aC5tYXgobCwgZS5sZWZ0KSwgaCA9IE1hdGgubWluKGgsIGUucmlnaHQpLCBjID0gTWF0aC5tYXgoYywgZS50b3ApLCBkID0gTWF0aC5taW4oZCwgZS5ib3R0b20pKSwgaS5yZWN0KGwsIGMsIGggLSBsLCBkIC0gYyksIGkuY2xpcCgpO1xuICB9XG59XG5mdW5jdGlvbiBHcyhpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gdC5pbnRlcnBvbGF0ZShlLCBzKTtcbiAgbiAmJiBpLmxpbmVUbyhuLngsIG4ueSk7XG59XG52YXIgeGMgPSB7XG4gIGlkOiBcImZpbGxlclwiLFxuICBhZnRlckRhdGFzZXRzVXBkYXRlOiBmdW5jdGlvbiBhZnRlckRhdGFzZXRzVXBkYXRlKGksIHQsIGUpIHtcbiAgICB2YXIgcyA9IChpLmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aCxcbiAgICAgIG4gPSBbXTtcbiAgICB2YXIgbywgciwgYSwgbDtcbiAgICBmb3IgKHIgPSAwOyByIDwgczsgKytyKSBvID0gaS5nZXREYXRhc2V0TWV0YShyKSwgYSA9IG8uZGF0YXNldCwgbCA9IG51bGwsIGEgJiYgYS5vcHRpb25zICYmIGEgaW5zdGFuY2VvZiB2dCAmJiAobCA9IHtcbiAgICAgIHZpc2libGU6IGkuaXNEYXRhc2V0VmlzaWJsZShyKSxcbiAgICAgIGluZGV4OiByLFxuICAgICAgZmlsbDogc2MoYSwgciwgcyksXG4gICAgICBjaGFydDogaSxcbiAgICAgIGF4aXM6IG8uY29udHJvbGxlci5vcHRpb25zLmluZGV4QXhpcyxcbiAgICAgIHNjYWxlOiBvLnZTY2FsZSxcbiAgICAgIGxpbmU6IGFcbiAgICB9KSwgby4kZmlsbGVyID0gbCwgbi5wdXNoKGwpO1xuICAgIGZvciAociA9IDA7IHIgPCBzOyArK3IpIGwgPSBuW3JdLCAhKCFsIHx8IGwuZmlsbCA9PT0gITEpICYmIChsLmZpbGwgPSBpYyhuLCByLCBlLnByb3BhZ2F0ZSkpO1xuICB9LFxuICBiZWZvcmVEcmF3OiBmdW5jdGlvbiBiZWZvcmVEcmF3KGksIHQsIGUpIHtcbiAgICB2YXIgcyA9IGUuZHJhd1RpbWUgPT09IFwiYmVmb3JlRHJhd1wiLFxuICAgICAgbiA9IGkuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLFxuICAgICAgbyA9IGkuY2hhcnRBcmVhO1xuICAgIGZvciAodmFyIHIgPSBuLmxlbmd0aCAtIDE7IHIgPj0gMDsgLS1yKSB7XG4gICAgICB2YXIgYSA9IG5bcl0uJGZpbGxlcjtcbiAgICAgIGEgJiYgKGEubGluZS51cGRhdGVDb250cm9sUG9pbnRzKG8sIGEuYXhpcyksIHMgJiYgYS5maWxsICYmIHBpKGkuY3R4LCBhLCBvKSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVEYXRhc2V0c0RyYXc6IGZ1bmN0aW9uIGJlZm9yZURhdGFzZXRzRHJhdyhpLCB0LCBlKSB7XG4gICAgaWYgKGUuZHJhd1RpbWUgIT09IFwiYmVmb3JlRGF0YXNldHNEcmF3XCIpIHJldHVybjtcbiAgICB2YXIgcyA9IGkuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAodmFyIG4gPSBzLmxlbmd0aCAtIDE7IG4gPj0gMDsgLS1uKSB7XG4gICAgICB2YXIgbyA9IHNbbl0uJGZpbGxlcjtcbiAgICAgIFhzKG8pICYmIHBpKGkuY3R4LCBvLCBpLmNoYXJ0QXJlYSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVEYXRhc2V0RHJhdzogZnVuY3Rpb24gYmVmb3JlRGF0YXNldERyYXcoaSwgdCwgZSkge1xuICAgIHZhciBzID0gdC5tZXRhLiRmaWxsZXI7XG4gICAgIVhzKHMpIHx8IGUuZHJhd1RpbWUgIT09IFwiYmVmb3JlRGF0YXNldERyYXdcIiB8fCBwaShpLmN0eCwgcywgaS5jaGFydEFyZWEpO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIHByb3BhZ2F0ZTogITAsXG4gICAgZHJhd1RpbWU6IFwiYmVmb3JlRGF0YXNldERyYXdcIlxuICB9XG59O1xudmFyIEpzID0gZnVuY3Rpb24gSnMoaSwgdCkge1xuICAgIHZhciBfaSRib3hIZWlnaHQgPSBpLmJveEhlaWdodCxcbiAgICAgIGUgPSBfaSRib3hIZWlnaHQgPT09IHZvaWQgMCA/IHQgOiBfaSRib3hIZWlnaHQsXG4gICAgICBfaSRib3hXaWR0aCA9IGkuYm94V2lkdGgsXG4gICAgICBzID0gX2kkYm94V2lkdGggPT09IHZvaWQgMCA/IHQgOiBfaSRib3hXaWR0aDtcbiAgICByZXR1cm4gaS51c2VQb2ludFN0eWxlICYmIChlID0gTWF0aC5taW4oZSwgdCksIHMgPSBpLnBvaW50U3R5bGVXaWR0aCB8fCBNYXRoLm1pbihzLCB0KSksIHtcbiAgICAgIGJveFdpZHRoOiBzLFxuICAgICAgYm94SGVpZ2h0OiBlLFxuICAgICAgaXRlbUhlaWdodDogTWF0aC5tYXgodCwgZSlcbiAgICB9O1xuICB9LFxuICB5YyA9IGZ1bmN0aW9uIHljKGksIHQpIHtcbiAgICByZXR1cm4gaSAhPT0gbnVsbCAmJiB0ICE9PSBudWxsICYmIGkuZGF0YXNldEluZGV4ID09PSB0LmRhdGFzZXRJbmRleCAmJiBpLmluZGV4ID09PSB0LmluZGV4O1xuICB9O1xudmFyIFpzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3Q2KSB7XG4gIGZ1bmN0aW9uIFpzKHQpIHtcbiAgICB2YXIgX3RoaXMyNDtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWnMpO1xuICAgIF90aGlzMjQgPSBfY2FsbFN1cGVyKHRoaXMsIFpzKSwgX3RoaXMyNC5fYWRkZWQgPSAhMSwgX3RoaXMyNC5sZWdlbmRIaXRCb3hlcyA9IFtdLCBfdGhpczI0Ll9ob3ZlcmVkSXRlbSA9IG51bGwsIF90aGlzMjQuZG91Z2hudXRNb2RlID0gITEsIF90aGlzMjQuY2hhcnQgPSB0LmNoYXJ0LCBfdGhpczI0Lm9wdGlvbnMgPSB0Lm9wdGlvbnMsIF90aGlzMjQuY3R4ID0gdC5jdHgsIF90aGlzMjQubGVnZW5kSXRlbXMgPSB2b2lkIDAsIF90aGlzMjQuY29sdW1uU2l6ZXMgPSB2b2lkIDAsIF90aGlzMjQubGluZVdpZHRocyA9IHZvaWQgMCwgX3RoaXMyNC5tYXhIZWlnaHQgPSB2b2lkIDAsIF90aGlzMjQubWF4V2lkdGggPSB2b2lkIDAsIF90aGlzMjQudG9wID0gdm9pZCAwLCBfdGhpczI0LmJvdHRvbSA9IHZvaWQgMCwgX3RoaXMyNC5sZWZ0ID0gdm9pZCAwLCBfdGhpczI0LnJpZ2h0ID0gdm9pZCAwLCBfdGhpczI0LmhlaWdodCA9IHZvaWQgMCwgX3RoaXMyNC53aWR0aCA9IHZvaWQgMCwgX3RoaXMyNC5fbWFyZ2lucyA9IHZvaWQgMCwgX3RoaXMyNC5wb3NpdGlvbiA9IHZvaWQgMCwgX3RoaXMyNC53ZWlnaHQgPSB2b2lkIDAsIF90aGlzMjQuZnVsbFNpemUgPSB2b2lkIDA7XG4gICAgcmV0dXJuIF90aGlzMjQ7XG4gIH1cbiAgX2luaGVyaXRzKFpzLCBfc3Q2KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhacywgW3tcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSh0LCBlLCBzKSB7XG4gICAgICB0aGlzLm1heFdpZHRoID0gdCwgdGhpcy5tYXhIZWlnaHQgPSBlLCB0aGlzLl9tYXJnaW5zID0gcywgdGhpcy5zZXREaW1lbnNpb25zKCksIHRoaXMuYnVpbGRMYWJlbHMoKSwgdGhpcy5maXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREaW1lbnNpb25zKCkge1xuICAgICAgdGhpcy5pc0hvcml6b250YWwoKSA/ICh0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aCwgdGhpcy5sZWZ0ID0gdGhpcy5fbWFyZ2lucy5sZWZ0LCB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aCkgOiAodGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodCwgdGhpcy50b3AgPSB0aGlzLl9tYXJnaW5zLnRvcCwgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkTGFiZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkTGFiZWxzKCkge1xuICAgICAgdmFyIF90aGlzMjUgPSB0aGlzO1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMubGFiZWxzIHx8IHt9O1xuICAgICAgdmFyIGUgPSBJKHQuZ2VuZXJhdGVMYWJlbHMsIFt0aGlzLmNoYXJ0XSwgdGhpcykgfHwgW107XG4gICAgICB0LmZpbHRlciAmJiAoZSA9IGUuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiB0LmZpbHRlcihzLCBfdGhpczI1LmNoYXJ0LmRhdGEpO1xuICAgICAgfSkpLCB0LnNvcnQgJiYgKGUgPSBlLnNvcnQoZnVuY3Rpb24gKHMsIG4pIHtcbiAgICAgICAgcmV0dXJuIHQuc29ydChzLCBuLCBfdGhpczI1LmNoYXJ0LmRhdGEpO1xuICAgICAgfSkpLCB0aGlzLm9wdGlvbnMucmV2ZXJzZSAmJiBlLnJldmVyc2UoKSwgdGhpcy5sZWdlbmRJdGVtcyA9IGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXQoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZSA9IHRoaXMuY3R4O1xuICAgICAgaWYgKCF0LmRpc3BsYXkpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHMgPSB0LmxhYmVscyxcbiAgICAgICAgbiA9IFgocy5mb250KSxcbiAgICAgICAgbyA9IG4uc2l6ZSxcbiAgICAgICAgciA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpLFxuICAgICAgICBfSnMgPSBKcyhzLCBvKSxcbiAgICAgICAgYSA9IF9Kcy5ib3hXaWR0aCxcbiAgICAgICAgbCA9IF9Kcy5pdGVtSGVpZ2h0O1xuICAgICAgdmFyIGMsIGg7XG4gICAgICBlLmZvbnQgPSBuLnN0cmluZywgdGhpcy5pc0hvcml6b250YWwoKSA/IChjID0gdGhpcy5tYXhXaWR0aCwgaCA9IHRoaXMuX2ZpdFJvd3MociwgbywgYSwgbCkgKyAxMCkgOiAoaCA9IHRoaXMubWF4SGVpZ2h0LCBjID0gdGhpcy5fZml0Q29scyhyLCBuLCBhLCBsKSArIDEwKSwgdGhpcy53aWR0aCA9IE1hdGgubWluKGMsIHQubWF4V2lkdGggfHwgdGhpcy5tYXhXaWR0aCksIHRoaXMuaGVpZ2h0ID0gTWF0aC5taW4oaCwgdC5tYXhIZWlnaHQgfHwgdGhpcy5tYXhIZWlnaHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZml0Um93c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZml0Um93cyh0LCBlLCBzLCBuKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuY3R4LFxuICAgICAgICByID0gdGhpcy5tYXhXaWR0aCxcbiAgICAgICAgYSA9IHRoaXMub3B0aW9ucy5sYWJlbHMucGFkZGluZyxcbiAgICAgICAgbCA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXSxcbiAgICAgICAgYyA9IHRoaXMubGluZVdpZHRocyA9IFswXSxcbiAgICAgICAgaCA9IG4gKyBhO1xuICAgICAgdmFyIGQgPSB0O1xuICAgICAgby50ZXh0QWxpZ24gPSBcImxlZnRcIiwgby50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgdmFyIHUgPSAtMSxcbiAgICAgICAgZiA9IC1oO1xuICAgICAgcmV0dXJuIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaChmdW5jdGlvbiAocCwgZykge1xuICAgICAgICB2YXIgbSA9IHMgKyBlIC8gMiArIG8ubWVhc3VyZVRleHQocC50ZXh0KS53aWR0aDtcbiAgICAgICAgKGcgPT09IDAgfHwgY1tjLmxlbmd0aCAtIDFdICsgbSArIDIgKiBhID4gcikgJiYgKGQgKz0gaCwgY1tjLmxlbmd0aCAtIChnID4gMCA/IDAgOiAxKV0gPSAwLCBmICs9IGgsIHUrKyksIGxbZ10gPSB7XG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB0b3A6IGYsXG4gICAgICAgICAgcm93OiB1LFxuICAgICAgICAgIHdpZHRoOiBtLFxuICAgICAgICAgIGhlaWdodDogblxuICAgICAgICB9LCBjW2MubGVuZ3RoIC0gMV0gKz0gbSArIGE7XG4gICAgICB9KSwgZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpdENvbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpdENvbHModCwgZSwgcywgbikge1xuICAgICAgdmFyIG8gPSB0aGlzLmN0eCxcbiAgICAgICAgciA9IHRoaXMubWF4SGVpZ2h0LFxuICAgICAgICBhID0gdGhpcy5vcHRpb25zLmxhYmVscy5wYWRkaW5nLFxuICAgICAgICBsID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdLFxuICAgICAgICBjID0gdGhpcy5jb2x1bW5TaXplcyA9IFtdLFxuICAgICAgICBoID0gciAtIHQ7XG4gICAgICB2YXIgZCA9IGEsXG4gICAgICAgIHUgPSAwLFxuICAgICAgICBmID0gMCxcbiAgICAgICAgcCA9IDAsXG4gICAgICAgIGcgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaChmdW5jdGlvbiAobSwgYikge1xuICAgICAgICB2YXIgX3ZjID0gdmMocywgZSwgbywgbSwgbiksXG4gICAgICAgICAgXyA9IF92Yy5pdGVtV2lkdGgsXG4gICAgICAgICAgdiA9IF92Yy5pdGVtSGVpZ2h0O1xuICAgICAgICBiID4gMCAmJiBmICsgdiArIDIgKiBhID4gaCAmJiAoZCArPSB1ICsgYSwgYy5wdXNoKHtcbiAgICAgICAgICB3aWR0aDogdSxcbiAgICAgICAgICBoZWlnaHQ6IGZcbiAgICAgICAgfSksIHAgKz0gdSArIGEsIGcrKywgdSA9IGYgPSAwKSwgbFtiXSA9IHtcbiAgICAgICAgICBsZWZ0OiBwLFxuICAgICAgICAgIHRvcDogZixcbiAgICAgICAgICBjb2w6IGcsXG4gICAgICAgICAgd2lkdGg6IF8sXG4gICAgICAgICAgaGVpZ2h0OiB2XG4gICAgICAgIH0sIHUgPSBNYXRoLm1heCh1LCBfKSwgZiArPSB2ICsgYTtcbiAgICAgIH0pLCBkICs9IHUsIGMucHVzaCh7XG4gICAgICAgIHdpZHRoOiB1LFxuICAgICAgICBoZWlnaHQ6IGZcbiAgICAgIH0pLCBkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGp1c3RIaXRCb3hlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGp1c3RIaXRCb3hlcygpIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc3BsYXkpIHJldHVybjtcbiAgICAgIHZhciB0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCksXG4gICAgICAgIGUgPSB0aGlzLmxlZ2VuZEhpdEJveGVzLFxuICAgICAgICBfdGhpcyRvcHRpb25zMTMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHMgPSBfdGhpcyRvcHRpb25zMTMuYWxpZ24sXG4gICAgICAgIG4gPSBfdGhpcyRvcHRpb25zMTMubGFiZWxzLnBhZGRpbmcsXG4gICAgICAgIG8gPSBfdGhpcyRvcHRpb25zMTMucnRsLFxuICAgICAgICByID0gVXQobywgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgIHZhciBhID0gMCxcbiAgICAgICAgICBsID0gWShzLCB0aGlzLmxlZnQgKyBuLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW2FdKTtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjM0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZSksXG4gICAgICAgICAgX3N0ZXAzNDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjM0LnMoKTsgIShfc3RlcDM0ID0gX2l0ZXJhdG9yMzQubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGMgPSBfc3RlcDM0LnZhbHVlO1xuICAgICAgICAgICAgYSAhPT0gYy5yb3cgJiYgKGEgPSBjLnJvdywgbCA9IFkocywgdGhpcy5sZWZ0ICsgbiwgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1thXSkpLCBjLnRvcCArPSB0aGlzLnRvcCArIHQgKyBuLCBjLmxlZnQgPSByLmxlZnRGb3JMdHIoci54KGwpLCBjLndpZHRoKSwgbCArPSBjLndpZHRoICsgbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjM0LmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IzNC5mKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfYTMgPSAwLFxuICAgICAgICAgIF9sMyA9IFkocywgdGhpcy50b3AgKyB0ICsgbiwgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW19hM10uaGVpZ2h0KTtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjM1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZSksXG4gICAgICAgICAgX3N0ZXAzNTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjM1LnMoKTsgIShfc3RlcDM1ID0gX2l0ZXJhdG9yMzUubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIF9jMyA9IF9zdGVwMzUudmFsdWU7XG4gICAgICAgICAgICBfYzMuY29sICE9PSBfYTMgJiYgKF9hMyA9IF9jMy5jb2wsIF9sMyA9IFkocywgdGhpcy50b3AgKyB0ICsgbiwgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW19hM10uaGVpZ2h0KSksIF9jMy50b3AgPSBfbDMsIF9jMy5sZWZ0ICs9IHRoaXMubGVmdCArIG4sIF9jMy5sZWZ0ID0gci5sZWZ0Rm9yTHRyKHIueChfYzMubGVmdCksIF9jMy53aWR0aCksIF9sMyArPSBfYzMuaGVpZ2h0ICsgbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjM1LmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IzNS5mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNIb3Jpem9udGFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzSG9yaXpvbnRhbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09IFwidG9wXCIgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSBcImJvdHRvbVwiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmN0eDtcbiAgICAgICAgSmUodCwgdGhpcyksIHRoaXMuX2RyYXcoKSwgWmUodCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3KCkge1xuICAgICAgdmFyIF90aGlzMjYgPSB0aGlzO1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGUgPSB0aGlzLmNvbHVtblNpemVzLFxuICAgICAgICBzID0gdGhpcy5saW5lV2lkdGhzLFxuICAgICAgICBuID0gdGhpcy5jdHgsXG4gICAgICAgIG8gPSB0LmFsaWduLFxuICAgICAgICByID0gdC5sYWJlbHMsXG4gICAgICAgIGEgPSBXLmNvbG9yLFxuICAgICAgICBsID0gVXQodC5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCksXG4gICAgICAgIGMgPSBYKHIuZm9udCksXG4gICAgICAgIGggPSByLnBhZGRpbmcsXG4gICAgICAgIGQgPSBjLnNpemUsXG4gICAgICAgIHUgPSBkIC8gMjtcbiAgICAgIHZhciBmO1xuICAgICAgdGhpcy5kcmF3VGl0bGUoKSwgbi50ZXh0QWxpZ24gPSBsLnRleHRBbGlnbihcImxlZnRcIiksIG4udGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIiwgbi5saW5lV2lkdGggPSAwLjUsIG4uZm9udCA9IGMuc3RyaW5nO1xuICAgICAgdmFyIF9KczIgPSBKcyhyLCBkKSxcbiAgICAgICAgcCA9IF9KczIuYm94V2lkdGgsXG4gICAgICAgIGcgPSBfSnMyLmJveEhlaWdodCxcbiAgICAgICAgbSA9IF9KczIuaXRlbUhlaWdodCxcbiAgICAgICAgYiA9IGZ1bmN0aW9uIGIoTSwgUywgaykge1xuICAgICAgICAgIGlmIChpc05hTihwKSB8fCBwIDw9IDAgfHwgaXNOYU4oZykgfHwgZyA8IDApIHJldHVybjtcbiAgICAgICAgICBuLnNhdmUoKTtcbiAgICAgICAgICB2YXIgUCA9IEQoay5saW5lV2lkdGgsIDEpO1xuICAgICAgICAgIGlmIChuLmZpbGxTdHlsZSA9IEQoay5maWxsU3R5bGUsIGEpLCBuLmxpbmVDYXAgPSBEKGsubGluZUNhcCwgXCJidXR0XCIpLCBuLmxpbmVEYXNoT2Zmc2V0ID0gRChrLmxpbmVEYXNoT2Zmc2V0LCAwKSwgbi5saW5lSm9pbiA9IEQoay5saW5lSm9pbiwgXCJtaXRlclwiKSwgbi5saW5lV2lkdGggPSBQLCBuLnN0cm9rZVN0eWxlID0gRChrLnN0cm9rZVN0eWxlLCBhKSwgbi5zZXRMaW5lRGFzaChEKGsubGluZURhc2gsIFtdKSksIHIudXNlUG9pbnRTdHlsZSkge1xuICAgICAgICAgICAgdmFyIEMgPSB7XG4gICAgICAgICAgICAgICAgcmFkaXVzOiBnICogTWF0aC5TUVJUMiAvIDIsXG4gICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogay5wb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBrLnJvdGF0aW9uLFxuICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiBQXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIE8gPSBsLnhQbHVzKE0sIHAgLyAyKSxcbiAgICAgICAgICAgICAgQSA9IFMgKyB1O1xuICAgICAgICAgICAgQ24obiwgQywgTywgQSwgci5wb2ludFN0eWxlV2lkdGggJiYgcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfQyA9IFMgKyBNYXRoLm1heCgoZCAtIGcpIC8gMiwgMCksXG4gICAgICAgICAgICAgIF9PID0gbC5sZWZ0Rm9yTHRyKE0sIHApLFxuICAgICAgICAgICAgICBfQSA9IFl0KGsuYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgICAgIG4uYmVnaW5QYXRoKCksIE9iamVjdC52YWx1ZXMoX0EpLnNvbWUoZnVuY3Rpb24gKGopIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGogIT09IDA7XG4gICAgICAgICAgICB9KSA/IFVlKG4sIHtcbiAgICAgICAgICAgICAgeDogX08sXG4gICAgICAgICAgICAgIHk6IF9DLFxuICAgICAgICAgICAgICB3OiBwLFxuICAgICAgICAgICAgICBoOiBnLFxuICAgICAgICAgICAgICByYWRpdXM6IF9BXG4gICAgICAgICAgICB9KSA6IG4ucmVjdChfTywgX0MsIHAsIGcpLCBuLmZpbGwoKSwgUCAhPT0gMCAmJiBuLnN0cm9rZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuLnJlc3RvcmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgXyA9IGZ1bmN0aW9uIF8oTSwgUywgaykge1xuICAgICAgICAgIGJlKG4sIGsudGV4dCwgTSwgUyArIG0gLyAyLCBjLCB7XG4gICAgICAgICAgICBzdHJpa2V0aHJvdWdoOiBrLmhpZGRlbixcbiAgICAgICAgICAgIHRleHRBbGlnbjogbC50ZXh0QWxpZ24oay50ZXh0QWxpZ24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHYgPSB0aGlzLmlzSG9yaXpvbnRhbCgpLFxuICAgICAgICB5ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgICB2ID8gZiA9IHtcbiAgICAgICAgeDogWShvLCB0aGlzLmxlZnQgKyBoLCB0aGlzLnJpZ2h0IC0gc1swXSksXG4gICAgICAgIHk6IHRoaXMudG9wICsgaCArIHksXG4gICAgICAgIGxpbmU6IDBcbiAgICAgIH0gOiBmID0ge1xuICAgICAgICB4OiB0aGlzLmxlZnQgKyBoLFxuICAgICAgICB5OiBZKG8sIHRoaXMudG9wICsgeSArIGgsIHRoaXMuYm90dG9tIC0gZVswXS5oZWlnaHQpLFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9LCBGbih0aGlzLmN0eCwgdC50ZXh0RGlyZWN0aW9uKTtcbiAgICAgIHZhciB4ID0gbSArIGg7XG4gICAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKE0sIFMpIHtcbiAgICAgICAgbi5zdHJva2VTdHlsZSA9IE0uZm9udENvbG9yLCBuLmZpbGxTdHlsZSA9IE0uZm9udENvbG9yO1xuICAgICAgICB2YXIgayA9IG4ubWVhc3VyZVRleHQoTS50ZXh0KS53aWR0aCxcbiAgICAgICAgICBQID0gbC50ZXh0QWxpZ24oTS50ZXh0QWxpZ24gfHwgKE0udGV4dEFsaWduID0gci50ZXh0QWxpZ24pKSxcbiAgICAgICAgICBDID0gcCArIHUgKyBrO1xuICAgICAgICB2YXIgTyA9IGYueCxcbiAgICAgICAgICBBID0gZi55O1xuICAgICAgICBsLnNldFdpZHRoKF90aGlzMjYud2lkdGgpLCB2ID8gUyA+IDAgJiYgTyArIEMgKyBoID4gX3RoaXMyNi5yaWdodCAmJiAoQSA9IGYueSArPSB4LCBmLmxpbmUrKywgTyA9IGYueCA9IFkobywgX3RoaXMyNi5sZWZ0ICsgaCwgX3RoaXMyNi5yaWdodCAtIHNbZi5saW5lXSkpIDogUyA+IDAgJiYgQSArIHggPiBfdGhpczI2LmJvdHRvbSAmJiAoTyA9IGYueCA9IE8gKyBlW2YubGluZV0ud2lkdGggKyBoLCBmLmxpbmUrKywgQSA9IGYueSA9IFkobywgX3RoaXMyNi50b3AgKyB5ICsgaCwgX3RoaXMyNi5ib3R0b20gLSBlW2YubGluZV0uaGVpZ2h0KSk7XG4gICAgICAgIHZhciBqID0gbC54KE8pO1xuICAgICAgICBpZiAoYihqLCBBLCBNKSwgTyA9IFFvKFAsIE8gKyBwICsgdSwgdiA/IE8gKyBDIDogX3RoaXMyNi5yaWdodCwgdC5ydGwpLCBfKGwueChPKSwgQSwgTSksIHYpIGYueCArPSBDICsgaDtlbHNlIGlmICh0eXBlb2YgTS50ZXh0ICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB2YXIgSiA9IGMubGluZUhlaWdodDtcbiAgICAgICAgICBmLnkgKz0gbm8oTSwgSikgKyBoO1xuICAgICAgICB9IGVsc2UgZi55ICs9IHg7XG4gICAgICB9KSwgSW4odGhpcy5jdHgsIHQudGV4dERpcmVjdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdUaXRsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3VGl0bGUoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZSA9IHQudGl0bGUsXG4gICAgICAgIHMgPSBYKGUuZm9udCksXG4gICAgICAgIG4gPSBldChlLnBhZGRpbmcpO1xuICAgICAgaWYgKCFlLmRpc3BsYXkpIHJldHVybjtcbiAgICAgIHZhciBvID0gVXQodC5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCksXG4gICAgICAgIHIgPSB0aGlzLmN0eCxcbiAgICAgICAgYSA9IGUucG9zaXRpb24sXG4gICAgICAgIGwgPSBzLnNpemUgLyAyLFxuICAgICAgICBjID0gbi50b3AgKyBsO1xuICAgICAgdmFyIGgsXG4gICAgICAgIGQgPSB0aGlzLmxlZnQsXG4gICAgICAgIHUgPSB0aGlzLndpZHRoO1xuICAgICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHUgPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5saW5lV2lkdGhzKSksIGggPSB0aGlzLnRvcCArIGMsIGQgPSBZKHQuYWxpZ24sIGQsIHRoaXMucmlnaHQgLSB1KTtlbHNlIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmNvbHVtblNpemVzLnJlZHVjZShmdW5jdGlvbiAoZywgbSkge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heChnLCBtLmhlaWdodCk7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBoID0gYyArIFkodC5hbGlnbiwgdGhpcy50b3AsIHRoaXMuYm90dG9tIC0gcCAtIHQubGFiZWxzLnBhZGRpbmcgLSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKSk7XG4gICAgICB9XG4gICAgICB2YXIgZiA9IFkoYSwgZCwgZCArIHUpO1xuICAgICAgci50ZXh0QWxpZ24gPSBvLnRleHRBbGlnbih6aShhKSksIHIudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIiwgci5zdHJva2VTdHlsZSA9IGUuY29sb3IsIHIuZmlsbFN0eWxlID0gZS5jb2xvciwgci5mb250ID0gcy5zdHJpbmcsIGJlKHIsIGUudGV4dCwgZiwgaCwgcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jb21wdXRlVGl0bGVIZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXB1dGVUaXRsZUhlaWdodCgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLnRpdGxlLFxuICAgICAgICBlID0gWCh0LmZvbnQpLFxuICAgICAgICBzID0gZXQodC5wYWRkaW5nKTtcbiAgICAgIHJldHVybiB0LmRpc3BsYXkgPyBlLmxpbmVIZWlnaHQgKyBzLmhlaWdodCA6IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRMZWdlbmRJdGVtQXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldExlZ2VuZEl0ZW1BdCh0LCBlKSB7XG4gICAgICB2YXIgcywgbiwgbztcbiAgICAgIGlmIChfdCh0LCB0aGlzLmxlZnQsIHRoaXMucmlnaHQpICYmIF90KGUsIHRoaXMudG9wLCB0aGlzLmJvdHRvbSkpIHtcbiAgICAgICAgZm9yIChvID0gdGhpcy5sZWdlbmRIaXRCb3hlcywgcyA9IDA7IHMgPCBvLmxlbmd0aDsgKytzKSBpZiAobiA9IG9bc10sIF90KHQsIG4ubGVmdCwgbi5sZWZ0ICsgbi53aWR0aCkgJiYgX3QoZSwgbi50b3AsIG4udG9wICsgbi5oZWlnaHQpKSByZXR1cm4gdGhpcy5sZWdlbmRJdGVtc1tzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVFdmVudCh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmICgha2ModC50eXBlLCBlKSkgcmV0dXJuO1xuICAgICAgdmFyIHMgPSB0aGlzLl9nZXRMZWdlbmRJdGVtQXQodC54LCB0LnkpO1xuICAgICAgaWYgKHQudHlwZSA9PT0gXCJtb3VzZW1vdmVcIiB8fCB0LnR5cGUgPT09IFwibW91c2VvdXRcIikge1xuICAgICAgICB2YXIgbiA9IHRoaXMuX2hvdmVyZWRJdGVtLFxuICAgICAgICAgIG8gPSB5YyhuLCBzKTtcbiAgICAgICAgbiAmJiAhbyAmJiBJKGUub25MZWF2ZSwgW3QsIG4sIHRoaXNdLCB0aGlzKSwgdGhpcy5faG92ZXJlZEl0ZW0gPSBzLCBzICYmICFvICYmIEkoZS5vbkhvdmVyLCBbdCwgcywgdGhpc10sIHRoaXMpO1xuICAgICAgfSBlbHNlIHMgJiYgSShlLm9uQ2xpY2ssIFt0LCBzLCB0aGlzXSwgdGhpcyk7XG4gICAgfVxuICB9XSk7XG59KHN0KTtcbmZ1bmN0aW9uIHZjKGksIHQsIGUsIHMsIG4pIHtcbiAgdmFyIG8gPSBNYyhzLCBpLCB0LCBlKSxcbiAgICByID0gU2MobiwgcywgdC5saW5lSGVpZ2h0KTtcbiAgcmV0dXJuIHtcbiAgICBpdGVtV2lkdGg6IG8sXG4gICAgaXRlbUhlaWdodDogclxuICB9O1xufVxuZnVuY3Rpb24gTWMoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IGkudGV4dDtcbiAgcmV0dXJuIG4gJiYgdHlwZW9mIG4gIT0gXCJzdHJpbmdcIiAmJiAobiA9IG4ucmVkdWNlKGZ1bmN0aW9uIChvLCByKSB7XG4gICAgcmV0dXJuIG8ubGVuZ3RoID4gci5sZW5ndGggPyBvIDogcjtcbiAgfSkpLCB0ICsgZS5zaXplIC8gMiArIHMubWVhc3VyZVRleHQobikud2lkdGg7XG59XG5mdW5jdGlvbiBTYyhpLCB0LCBlKSB7XG4gIHZhciBzID0gaTtcbiAgcmV0dXJuIHR5cGVvZiB0LnRleHQgIT0gXCJzdHJpbmdcIiAmJiAocyA9IG5vKHQsIGUpKSwgcztcbn1cbmZ1bmN0aW9uIG5vKGksIHQpIHtcbiAgdmFyIGUgPSBpLnRleHQgPyBpLnRleHQubGVuZ3RoIDogMDtcbiAgcmV0dXJuIHQgKiBlO1xufVxuZnVuY3Rpb24ga2MoaSwgdCkge1xuICByZXR1cm4gISEoKGkgPT09IFwibW91c2Vtb3ZlXCIgfHwgaSA9PT0gXCJtb3VzZW91dFwiKSAmJiAodC5vbkhvdmVyIHx8IHQub25MZWF2ZSkgfHwgdC5vbkNsaWNrICYmIChpID09PSBcImNsaWNrXCIgfHwgaSA9PT0gXCJtb3VzZXVwXCIpKTtcbn1cbnZhciB3YyA9IHtcbiAgaWQ6IFwibGVnZW5kXCIsXG4gIF9lbGVtZW50OiBacyxcbiAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KGksIHQsIGUpIHtcbiAgICB2YXIgcyA9IGkubGVnZW5kID0gbmV3IFpzKHtcbiAgICAgIGN0eDogaS5jdHgsXG4gICAgICBvcHRpb25zOiBlLFxuICAgICAgY2hhcnQ6IGlcbiAgICB9KTtcbiAgICB0dC5jb25maWd1cmUoaSwgcywgZSksIHR0LmFkZEJveChpLCBzKTtcbiAgfSxcbiAgc3RvcDogZnVuY3Rpb24gc3RvcChpKSB7XG4gICAgdHQucmVtb3ZlQm94KGksIGkubGVnZW5kKSwgZGVsZXRlIGkubGVnZW5kO1xuICB9LFxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZShpLCB0LCBlKSB7XG4gICAgdmFyIHMgPSBpLmxlZ2VuZDtcbiAgICB0dC5jb25maWd1cmUoaSwgcywgZSksIHMub3B0aW9ucyA9IGU7XG4gIH0sXG4gIGFmdGVyVXBkYXRlOiBmdW5jdGlvbiBhZnRlclVwZGF0ZShpKSB7XG4gICAgdmFyIHQgPSBpLmxlZ2VuZDtcbiAgICB0LmJ1aWxkTGFiZWxzKCksIHQuYWRqdXN0SGl0Qm94ZXMoKTtcbiAgfSxcbiAgYWZ0ZXJFdmVudDogZnVuY3Rpb24gYWZ0ZXJFdmVudChpLCB0KSB7XG4gICAgdC5yZXBsYXkgfHwgaS5sZWdlbmQuaGFuZGxlRXZlbnQodC5ldmVudCk7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgZGlzcGxheTogITAsXG4gICAgcG9zaXRpb246IFwidG9wXCIsXG4gICAgYWxpZ246IFwiY2VudGVyXCIsXG4gICAgZnVsbFNpemU6ICEwLFxuICAgIHJldmVyc2U6ICExLFxuICAgIHdlaWdodDogMWUzLFxuICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soaSwgdCwgZSkge1xuICAgICAgdmFyIHMgPSB0LmRhdGFzZXRJbmRleCxcbiAgICAgICAgbiA9IGUuY2hhcnQ7XG4gICAgICBuLmlzRGF0YXNldFZpc2libGUocykgPyAobi5oaWRlKHMpLCB0LmhpZGRlbiA9ICEwKSA6IChuLnNob3cocyksIHQuaGlkZGVuID0gITEpO1xuICAgIH0sXG4gICAgb25Ib3ZlcjogbnVsbCxcbiAgICBvbkxlYXZlOiBudWxsLFxuICAgIGxhYmVsczoge1xuICAgICAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKGkpIHtcbiAgICAgICAgcmV0dXJuIGkuY2hhcnQub3B0aW9ucy5jb2xvcjtcbiAgICAgIH0sXG4gICAgICBib3hXaWR0aDogNDAsXG4gICAgICBwYWRkaW5nOiAxMCxcbiAgICAgIGdlbmVyYXRlTGFiZWxzOiBmdW5jdGlvbiBnZW5lcmF0ZUxhYmVscyhpKSB7XG4gICAgICAgIHZhciB0ID0gaS5kYXRhLmRhdGFzZXRzLFxuICAgICAgICAgIF9pJGxlZ2VuZCRvcHRpb25zJGxhYiA9IGkubGVnZW5kLm9wdGlvbnMubGFiZWxzLFxuICAgICAgICAgIGUgPSBfaSRsZWdlbmQkb3B0aW9ucyRsYWIudXNlUG9pbnRTdHlsZSxcbiAgICAgICAgICBzID0gX2kkbGVnZW5kJG9wdGlvbnMkbGFiLnBvaW50U3R5bGUsXG4gICAgICAgICAgbiA9IF9pJGxlZ2VuZCRvcHRpb25zJGxhYi50ZXh0QWxpZ24sXG4gICAgICAgICAgbyA9IF9pJGxlZ2VuZCRvcHRpb25zJGxhYi5jb2xvcixcbiAgICAgICAgICByID0gX2kkbGVnZW5kJG9wdGlvbnMkbGFiLnVzZUJvcmRlclJhZGl1cyxcbiAgICAgICAgICBhID0gX2kkbGVnZW5kJG9wdGlvbnMkbGFiLmJvcmRlclJhZGl1cztcbiAgICAgICAgcmV0dXJuIGkuX2dldFNvcnRlZERhdGFzZXRNZXRhcygpLm1hcChmdW5jdGlvbiAobCkge1xuICAgICAgICAgIHZhciBjID0gbC5jb250cm9sbGVyLmdldFN0eWxlKGUgPyAwIDogdm9pZCAwKSxcbiAgICAgICAgICAgIGggPSBldChjLmJvcmRlcldpZHRoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogdFtsLmluZGV4XS5sYWJlbCxcbiAgICAgICAgICAgIGZpbGxTdHlsZTogYy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBmb250Q29sb3I6IG8sXG4gICAgICAgICAgICBoaWRkZW46ICFsLnZpc2libGUsXG4gICAgICAgICAgICBsaW5lQ2FwOiBjLmJvcmRlckNhcFN0eWxlLFxuICAgICAgICAgICAgbGluZURhc2g6IGMuYm9yZGVyRGFzaCxcbiAgICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBjLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgICBsaW5lSm9pbjogYy5ib3JkZXJKb2luU3R5bGUsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IChoLndpZHRoICsgaC5oZWlnaHQpIC8gNCxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBjLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgcG9pbnRTdHlsZTogcyB8fCBjLnBvaW50U3R5bGUsXG4gICAgICAgICAgICByb3RhdGlvbjogYy5yb3RhdGlvbixcbiAgICAgICAgICAgIHRleHRBbGlnbjogbiB8fCBjLnRleHRBbGlnbixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogciAmJiAoYSB8fCBjLmJvcmRlclJhZGl1cyksXG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IGwuaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRpdGxlOiB7XG4gICAgICBjb2xvcjogZnVuY3Rpb24gY29sb3IoaSkge1xuICAgICAgICByZXR1cm4gaS5jaGFydC5vcHRpb25zLmNvbG9yO1xuICAgICAgfSxcbiAgICAgIGRpc3BsYXk6ICExLFxuICAgICAgcG9zaXRpb246IFwiY2VudGVyXCIsXG4gICAgICB0ZXh0OiBcIlwiXG4gICAgfVxuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiBmdW5jdGlvbiBfc2NyaXB0YWJsZShpKSB7XG4gICAgICByZXR1cm4gIWkuc3RhcnRzV2l0aChcIm9uXCIpO1xuICAgIH0sXG4gICAgbGFiZWxzOiB7XG4gICAgICBfc2NyaXB0YWJsZTogZnVuY3Rpb24gX3NjcmlwdGFibGUoaSkge1xuICAgICAgICByZXR1cm4gIVtcImdlbmVyYXRlTGFiZWxzXCIsIFwiZmlsdGVyXCIsIFwic29ydFwiXS5pbmNsdWRlcyhpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgb28gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdDcpIHtcbiAgZnVuY3Rpb24gb28odCkge1xuICAgIHZhciBfdGhpczI3O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBvbyk7XG4gICAgX3RoaXMyNyA9IF9jYWxsU3VwZXIodGhpcywgb28pLCBfdGhpczI3LmNoYXJ0ID0gdC5jaGFydCwgX3RoaXMyNy5vcHRpb25zID0gdC5vcHRpb25zLCBfdGhpczI3LmN0eCA9IHQuY3R4LCBfdGhpczI3Ll9wYWRkaW5nID0gdm9pZCAwLCBfdGhpczI3LnRvcCA9IHZvaWQgMCwgX3RoaXMyNy5ib3R0b20gPSB2b2lkIDAsIF90aGlzMjcubGVmdCA9IHZvaWQgMCwgX3RoaXMyNy5yaWdodCA9IHZvaWQgMCwgX3RoaXMyNy53aWR0aCA9IHZvaWQgMCwgX3RoaXMyNy5oZWlnaHQgPSB2b2lkIDAsIF90aGlzMjcucG9zaXRpb24gPSB2b2lkIDAsIF90aGlzMjcud2VpZ2h0ID0gdm9pZCAwLCBfdGhpczI3LmZ1bGxTaXplID0gdm9pZCAwO1xuICAgIHJldHVybiBfdGhpczI3O1xuICB9XG4gIF9pbmhlcml0cyhvbywgX3N0Nyk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3Mob28sIFt7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUodCwgZSkge1xuICAgICAgdmFyIHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAodGhpcy5sZWZ0ID0gMCwgdGhpcy50b3AgPSAwLCAhcy5kaXNwbGF5KSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IHRoaXMucmlnaHQgPSB0aGlzLmJvdHRvbSA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLnJpZ2h0ID0gdCwgdGhpcy5oZWlnaHQgPSB0aGlzLmJvdHRvbSA9IGU7XG4gICAgICB2YXIgbiA9IE4ocy50ZXh0KSA/IHMudGV4dC5sZW5ndGggOiAxO1xuICAgICAgdGhpcy5fcGFkZGluZyA9IGV0KHMucGFkZGluZyk7XG4gICAgICB2YXIgbyA9IG4gKiBYKHMuZm9udCkubGluZUhlaWdodCArIHRoaXMuX3BhZGRpbmcuaGVpZ2h0O1xuICAgICAgdGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMuaGVpZ2h0ID0gbyA6IHRoaXMud2lkdGggPSBvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0hvcml6b250YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNIb3Jpem9udGFsKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgICByZXR1cm4gdCA9PT0gXCJ0b3BcIiB8fCB0ID09PSBcImJvdHRvbVwiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd0FyZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdBcmdzKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy50b3AsXG4gICAgICAgIHMgPSB0aGlzLmxlZnQsXG4gICAgICAgIG4gPSB0aGlzLmJvdHRvbSxcbiAgICAgICAgbyA9IHRoaXMucmlnaHQsXG4gICAgICAgIHIgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGEgPSByLmFsaWduO1xuICAgICAgdmFyIGwgPSAwLFxuICAgICAgICBjLFxuICAgICAgICBoLFxuICAgICAgICBkO1xuICAgICAgcmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKCkgPyAoaCA9IFkoYSwgcywgbyksIGQgPSBlICsgdCwgYyA9IG8gLSBzKSA6IChyLnBvc2l0aW9uID09PSBcImxlZnRcIiA/IChoID0gcyArIHQsIGQgPSBZKGEsIG4sIGUpLCBsID0gRSAqIC0wLjUpIDogKGggPSBvIC0gdCwgZCA9IFkoYSwgZSwgbiksIGwgPSBFICogMC41KSwgYyA9IG4gLSBlKSwge1xuICAgICAgICB0aXRsZVg6IGgsXG4gICAgICAgIHRpdGxlWTogZCxcbiAgICAgICAgbWF4V2lkdGg6IGMsXG4gICAgICAgIHJvdGF0aW9uOiBsXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuY3R4LFxuICAgICAgICBlID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKCFlLmRpc3BsYXkpIHJldHVybjtcbiAgICAgIHZhciBzID0gWChlLmZvbnQpLFxuICAgICAgICBvID0gcy5saW5lSGVpZ2h0IC8gMiArIHRoaXMuX3BhZGRpbmcudG9wLFxuICAgICAgICBfdGhpcyRfZHJhd0FyZ3MgPSB0aGlzLl9kcmF3QXJncyhvKSxcbiAgICAgICAgciA9IF90aGlzJF9kcmF3QXJncy50aXRsZVgsXG4gICAgICAgIGEgPSBfdGhpcyRfZHJhd0FyZ3MudGl0bGVZLFxuICAgICAgICBsID0gX3RoaXMkX2RyYXdBcmdzLm1heFdpZHRoLFxuICAgICAgICBjID0gX3RoaXMkX2RyYXdBcmdzLnJvdGF0aW9uO1xuICAgICAgYmUodCwgZS50ZXh0LCAwLCAwLCBzLCB7XG4gICAgICAgIGNvbG9yOiBlLmNvbG9yLFxuICAgICAgICBtYXhXaWR0aDogbCxcbiAgICAgICAgcm90YXRpb246IGMsXG4gICAgICAgIHRleHRBbGlnbjogemkoZS5hbGlnbiksXG4gICAgICAgIHRleHRCYXNlbGluZTogXCJtaWRkbGVcIixcbiAgICAgICAgdHJhbnNsYXRpb246IFtyLCBhXVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG59KHN0KTtcbmZ1bmN0aW9uIFBjKGksIHQpIHtcbiAgdmFyIGUgPSBuZXcgb28oe1xuICAgIGN0eDogaS5jdHgsXG4gICAgb3B0aW9uczogdCxcbiAgICBjaGFydDogaVxuICB9KTtcbiAgdHQuY29uZmlndXJlKGksIGUsIHQpLCB0dC5hZGRCb3goaSwgZSksIGkudGl0bGVCbG9jayA9IGU7XG59XG52YXIgRGMgPSB7XG4gIGlkOiBcInRpdGxlXCIsXG4gIF9lbGVtZW50OiBvbyxcbiAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KGksIHQsIGUpIHtcbiAgICBQYyhpLCBlKTtcbiAgfSxcbiAgc3RvcDogZnVuY3Rpb24gc3RvcChpKSB7XG4gICAgdmFyIHQgPSBpLnRpdGxlQmxvY2s7XG4gICAgdHQucmVtb3ZlQm94KGksIHQpLCBkZWxldGUgaS50aXRsZUJsb2NrO1xuICB9LFxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZShpLCB0LCBlKSB7XG4gICAgdmFyIHMgPSBpLnRpdGxlQmxvY2s7XG4gICAgdHQuY29uZmlndXJlKGksIHMsIGUpLCBzLm9wdGlvbnMgPSBlO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiBcImNlbnRlclwiLFxuICAgIGRpc3BsYXk6ICExLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogXCJib2xkXCJcbiAgICB9LFxuICAgIGZ1bGxTaXplOiAhMCxcbiAgICBwYWRkaW5nOiAxMCxcbiAgICBwb3NpdGlvbjogXCJ0b3BcIixcbiAgICB0ZXh0OiBcIlwiLFxuICAgIHdlaWdodDogMmUzXG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogXCJjb2xvclwiXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6ICEwLFxuICAgIF9pbmRleGFibGU6ICExXG4gIH1cbn07XG52YXIgYWUgPSB7XG4gIGF2ZXJhZ2U6IGZ1bmN0aW9uIGF2ZXJhZ2UoaSkge1xuICAgIGlmICghaS5sZW5ndGgpIHJldHVybiAhMTtcbiAgICB2YXIgdCxcbiAgICAgIGUsXG4gICAgICBzID0gLyogQF9fUFVSRV9fICovbmV3IFNldCgpLFxuICAgICAgbiA9IDAsXG4gICAgICBvID0gMDtcbiAgICBmb3IgKHQgPSAwLCBlID0gaS5sZW5ndGg7IHQgPCBlOyArK3QpIHtcbiAgICAgIHZhciBhID0gaVt0XS5lbGVtZW50O1xuICAgICAgaWYgKGEgJiYgYS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHZhciBsID0gYS50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgICAgcy5hZGQobC54KSwgbiArPSBsLnksICsrbztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG8gPT09IDAgfHwgcy5zaXplID09PSAwID8gITEgOiB7XG4gICAgICB4OiBfdG9Db25zdW1hYmxlQXJyYXkocykucmVkdWNlKGZ1bmN0aW9uIChhLCBsKSB7XG4gICAgICAgIHJldHVybiBhICsgbDtcbiAgICAgIH0pIC8gcy5zaXplLFxuICAgICAgeTogbiAvIG9cbiAgICB9O1xuICB9LFxuICBuZWFyZXN0OiBmdW5jdGlvbiBuZWFyZXN0KGksIHQpIHtcbiAgICBpZiAoIWkubGVuZ3RoKSByZXR1cm4gITE7XG4gICAgdmFyIGUgPSB0LngsXG4gICAgICBzID0gdC55LFxuICAgICAgbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgIG8sXG4gICAgICByLFxuICAgICAgYTtcbiAgICBmb3IgKG8gPSAwLCByID0gaS5sZW5ndGg7IG8gPCByOyArK28pIHtcbiAgICAgIHZhciBsID0gaVtvXS5lbGVtZW50O1xuICAgICAgaWYgKGwgJiYgbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHZhciBjID0gbC5nZXRDZW50ZXJQb2ludCgpLFxuICAgICAgICAgIGggPSB2aSh0LCBjKTtcbiAgICAgICAgaCA8IG4gJiYgKG4gPSBoLCBhID0gbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhKSB7XG4gICAgICB2YXIgX2w0ID0gYS50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgIGUgPSBfbDQueCwgcyA9IF9sNC55O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeDogZSxcbiAgICAgIHk6IHNcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gcnQoaSwgdCkge1xuICByZXR1cm4gdCAmJiAoTih0KSA/IEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGksIHQpIDogaS5wdXNoKHQpKSwgaTtcbn1cbmZ1bmN0aW9uIGZ0KGkpIHtcbiAgcmV0dXJuICh0eXBlb2YgaSA9PSBcInN0cmluZ1wiIHx8IGkgaW5zdGFuY2VvZiBTdHJpbmcpICYmIGkuaW5kZXhPZihcIlxcblwiKSA+IC0xID8gaS5zcGxpdChcIlxcblwiKSA6IGk7XG59XG5mdW5jdGlvbiBDYyhpLCB0KSB7XG4gIHZhciBlID0gdC5lbGVtZW50LFxuICAgIHMgPSB0LmRhdGFzZXRJbmRleCxcbiAgICBuID0gdC5pbmRleCxcbiAgICBvID0gaS5nZXREYXRhc2V0TWV0YShzKS5jb250cm9sbGVyLFxuICAgIF9vJGdldExhYmVsQW5kVmFsdWUgPSBvLmdldExhYmVsQW5kVmFsdWUobiksXG4gICAgciA9IF9vJGdldExhYmVsQW5kVmFsdWUubGFiZWwsXG4gICAgYSA9IF9vJGdldExhYmVsQW5kVmFsdWUudmFsdWU7XG4gIHJldHVybiB7XG4gICAgY2hhcnQ6IGksXG4gICAgbGFiZWw6IHIsXG4gICAgcGFyc2VkOiBvLmdldFBhcnNlZChuKSxcbiAgICByYXc6IGkuZGF0YS5kYXRhc2V0c1tzXS5kYXRhW25dLFxuICAgIGZvcm1hdHRlZFZhbHVlOiBhLFxuICAgIGRhdGFzZXQ6IG8uZ2V0RGF0YXNldCgpLFxuICAgIGRhdGFJbmRleDogbixcbiAgICBkYXRhc2V0SW5kZXg6IHMsXG4gICAgZWxlbWVudDogZVxuICB9O1xufVxuZnVuY3Rpb24gUXMoaSwgdCkge1xuICB2YXIgZSA9IGkuY2hhcnQuY3R4LFxuICAgIHMgPSBpLmJvZHksXG4gICAgbiA9IGkuZm9vdGVyLFxuICAgIG8gPSBpLnRpdGxlLFxuICAgIHIgPSB0LmJveFdpZHRoLFxuICAgIGEgPSB0LmJveEhlaWdodCxcbiAgICBsID0gWCh0LmJvZHlGb250KSxcbiAgICBjID0gWCh0LnRpdGxlRm9udCksXG4gICAgaCA9IFgodC5mb290ZXJGb250KSxcbiAgICBkID0gby5sZW5ndGgsXG4gICAgdSA9IG4ubGVuZ3RoLFxuICAgIGYgPSBzLmxlbmd0aCxcbiAgICBwID0gZXQodC5wYWRkaW5nKTtcbiAgdmFyIGcgPSBwLmhlaWdodCxcbiAgICBtID0gMCxcbiAgICBiID0gcy5yZWR1Y2UoZnVuY3Rpb24gKHksIHgpIHtcbiAgICAgIHJldHVybiB5ICsgeC5iZWZvcmUubGVuZ3RoICsgeC5saW5lcy5sZW5ndGggKyB4LmFmdGVyLmxlbmd0aDtcbiAgICB9LCAwKTtcbiAgaWYgKGIgKz0gaS5iZWZvcmVCb2R5Lmxlbmd0aCArIGkuYWZ0ZXJCb2R5Lmxlbmd0aCwgZCAmJiAoZyArPSBkICogYy5saW5lSGVpZ2h0ICsgKGQgLSAxKSAqIHQudGl0bGVTcGFjaW5nICsgdC50aXRsZU1hcmdpbkJvdHRvbSksIGIpIHtcbiAgICB2YXIgeSA9IHQuZGlzcGxheUNvbG9ycyA/IE1hdGgubWF4KGEsIGwubGluZUhlaWdodCkgOiBsLmxpbmVIZWlnaHQ7XG4gICAgZyArPSBmICogeSArIChiIC0gZikgKiBsLmxpbmVIZWlnaHQgKyAoYiAtIDEpICogdC5ib2R5U3BhY2luZztcbiAgfVxuICB1ICYmIChnICs9IHQuZm9vdGVyTWFyZ2luVG9wICsgdSAqIGgubGluZUhlaWdodCArICh1IC0gMSkgKiB0LmZvb3RlclNwYWNpbmcpO1xuICB2YXIgXyA9IDA7XG4gIHZhciB2ID0gZnVuY3Rpb24gdih5KSB7XG4gICAgbSA9IE1hdGgubWF4KG0sIGUubWVhc3VyZVRleHQoeSkud2lkdGggKyBfKTtcbiAgfTtcbiAgcmV0dXJuIGUuc2F2ZSgpLCBlLmZvbnQgPSBjLnN0cmluZywgTChpLnRpdGxlLCB2KSwgZS5mb250ID0gbC5zdHJpbmcsIEwoaS5iZWZvcmVCb2R5LmNvbmNhdChpLmFmdGVyQm9keSksIHYpLCBfID0gdC5kaXNwbGF5Q29sb3JzID8gciArIDIgKyB0LmJveFBhZGRpbmcgOiAwLCBMKHMsIGZ1bmN0aW9uICh5KSB7XG4gICAgTCh5LmJlZm9yZSwgdiksIEwoeS5saW5lcywgdiksIEwoeS5hZnRlciwgdik7XG4gIH0pLCBfID0gMCwgZS5mb250ID0gaC5zdHJpbmcsIEwoaS5mb290ZXIsIHYpLCBlLnJlc3RvcmUoKSwgbSArPSBwLndpZHRoLCB7XG4gICAgd2lkdGg6IG0sXG4gICAgaGVpZ2h0OiBnXG4gIH07XG59XG5mdW5jdGlvbiBPYyhpLCB0KSB7XG4gIHZhciBlID0gdC55LFxuICAgIHMgPSB0LmhlaWdodDtcbiAgcmV0dXJuIGUgPCBzIC8gMiA/IFwidG9wXCIgOiBlID4gaS5oZWlnaHQgLSBzIC8gMiA/IFwiYm90dG9tXCIgOiBcImNlbnRlclwiO1xufVxuZnVuY3Rpb24gVGMoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IHMueCxcbiAgICBvID0gcy53aWR0aCxcbiAgICByID0gZS5jYXJldFNpemUgKyBlLmNhcmV0UGFkZGluZztcbiAgaWYgKGkgPT09IFwibGVmdFwiICYmIG4gKyBvICsgciA+IHQud2lkdGggfHwgaSA9PT0gXCJyaWdodFwiICYmIG4gLSBvIC0gciA8IDApIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIEFjKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBlLngsXG4gICAgbyA9IGUud2lkdGgsXG4gICAgciA9IGkud2lkdGgsXG4gICAgX2kkY2hhcnRBcmVhID0gaS5jaGFydEFyZWEsXG4gICAgYSA9IF9pJGNoYXJ0QXJlYS5sZWZ0LFxuICAgIGwgPSBfaSRjaGFydEFyZWEucmlnaHQ7XG4gIHZhciBjID0gXCJjZW50ZXJcIjtcbiAgcmV0dXJuIHMgPT09IFwiY2VudGVyXCIgPyBjID0gbiA8PSAoYSArIGwpIC8gMiA/IFwibGVmdFwiIDogXCJyaWdodFwiIDogbiA8PSBvIC8gMiA/IGMgPSBcImxlZnRcIiA6IG4gPj0gciAtIG8gLyAyICYmIChjID0gXCJyaWdodFwiKSwgVGMoYywgaSwgdCwgZSkgJiYgKGMgPSBcImNlbnRlclwiKSwgYztcbn1cbmZ1bmN0aW9uIHRuKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBlLnlBbGlnbiB8fCB0LnlBbGlnbiB8fCBPYyhpLCBlKTtcbiAgcmV0dXJuIHtcbiAgICB4QWxpZ246IGUueEFsaWduIHx8IHQueEFsaWduIHx8IEFjKGksIHQsIGUsIHMpLFxuICAgIHlBbGlnbjogc1xuICB9O1xufVxuZnVuY3Rpb24gUmMoaSwgdCkge1xuICB2YXIgZSA9IGkueCxcbiAgICBzID0gaS53aWR0aDtcbiAgcmV0dXJuIHQgPT09IFwicmlnaHRcIiA/IGUgLT0gcyA6IHQgPT09IFwiY2VudGVyXCIgJiYgKGUgLT0gcyAvIDIpLCBlO1xufVxuZnVuY3Rpb24gTGMoaSwgdCwgZSkge1xuICB2YXIgcyA9IGkueSxcbiAgICBuID0gaS5oZWlnaHQ7XG4gIHJldHVybiB0ID09PSBcInRvcFwiID8gcyArPSBlIDogdCA9PT0gXCJib3R0b21cIiA/IHMgLT0gbiArIGUgOiBzIC09IG4gLyAyLCBzO1xufVxuZnVuY3Rpb24gZW4oaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IGkuY2FyZXRTaXplLFxuICAgIG8gPSBpLmNhcmV0UGFkZGluZyxcbiAgICByID0gaS5jb3JuZXJSYWRpdXMsXG4gICAgYSA9IGUueEFsaWduLFxuICAgIGwgPSBlLnlBbGlnbixcbiAgICBjID0gbiArIG8sXG4gICAgX1l0ID0gWXQociksXG4gICAgaCA9IF9ZdC50b3BMZWZ0LFxuICAgIGQgPSBfWXQudG9wUmlnaHQsXG4gICAgdSA9IF9ZdC5ib3R0b21MZWZ0LFxuICAgIGYgPSBfWXQuYm90dG9tUmlnaHQ7XG4gIHZhciBwID0gUmModCwgYSk7XG4gIHZhciBnID0gTGModCwgbCwgYyk7XG4gIHJldHVybiBsID09PSBcImNlbnRlclwiID8gYSA9PT0gXCJsZWZ0XCIgPyBwICs9IGMgOiBhID09PSBcInJpZ2h0XCIgJiYgKHAgLT0gYykgOiBhID09PSBcImxlZnRcIiA/IHAgLT0gTWF0aC5tYXgoaCwgdSkgKyBuIDogYSA9PT0gXCJyaWdodFwiICYmIChwICs9IE1hdGgubWF4KGQsIGYpICsgbiksIHtcbiAgICB4OiBVKHAsIDAsIHMud2lkdGggLSB0LndpZHRoKSxcbiAgICB5OiBVKGcsIDAsIHMuaGVpZ2h0IC0gdC5oZWlnaHQpXG4gIH07XG59XG5mdW5jdGlvbiBSZShpLCB0LCBlKSB7XG4gIHZhciBzID0gZXQoZS5wYWRkaW5nKTtcbiAgcmV0dXJuIHQgPT09IFwiY2VudGVyXCIgPyBpLnggKyBpLndpZHRoIC8gMiA6IHQgPT09IFwicmlnaHRcIiA/IGkueCArIGkud2lkdGggLSBzLnJpZ2h0IDogaS54ICsgcy5sZWZ0O1xufVxuZnVuY3Rpb24gc24oaSkge1xuICByZXR1cm4gcnQoW10sIGZ0KGkpKTtcbn1cbmZ1bmN0aW9uIEVjKGksIHQsIGUpIHtcbiAgcmV0dXJuIEJ0KGksIHtcbiAgICB0b29sdGlwOiB0LFxuICAgIHRvb2x0aXBJdGVtczogZSxcbiAgICB0eXBlOiBcInRvb2x0aXBcIlxuICB9KTtcbn1cbmZ1bmN0aW9uIG5uKGksIHQpIHtcbiAgdmFyIGUgPSB0ICYmIHQuZGF0YXNldCAmJiB0LmRhdGFzZXQudG9vbHRpcCAmJiB0LmRhdGFzZXQudG9vbHRpcC5jYWxsYmFja3M7XG4gIHJldHVybiBlID8gaS5vdmVycmlkZShlKSA6IGk7XG59XG52YXIgcm8gPSB7XG4gIGJlZm9yZVRpdGxlOiBkdCxcbiAgdGl0bGU6IGZ1bmN0aW9uIHRpdGxlKGkpIHtcbiAgICBpZiAoaS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdCA9IGlbMF0sXG4gICAgICAgIGUgPSB0LmNoYXJ0LmRhdGEubGFiZWxzLFxuICAgICAgICBzID0gZSA/IGUubGVuZ3RoIDogMDtcbiAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gXCJkYXRhc2V0XCIpIHJldHVybiB0LmRhdGFzZXQubGFiZWwgfHwgXCJcIjtcbiAgICAgIGlmICh0LmxhYmVsKSByZXR1cm4gdC5sYWJlbDtcbiAgICAgIGlmIChzID4gMCAmJiB0LmRhdGFJbmRleCA8IHMpIHJldHVybiBlW3QuZGF0YUluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG4gIH0sXG4gIGFmdGVyVGl0bGU6IGR0LFxuICBiZWZvcmVCb2R5OiBkdCxcbiAgYmVmb3JlTGFiZWw6IGR0LFxuICBsYWJlbDogZnVuY3Rpb24gbGFiZWwoaSkge1xuICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gXCJkYXRhc2V0XCIpIHJldHVybiBpLmxhYmVsICsgXCI6IFwiICsgaS5mb3JtYXR0ZWRWYWx1ZSB8fCBpLmZvcm1hdHRlZFZhbHVlO1xuICAgIHZhciB0ID0gaS5kYXRhc2V0LmxhYmVsIHx8IFwiXCI7XG4gICAgdCAmJiAodCArPSBcIjogXCIpO1xuICAgIHZhciBlID0gaS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICByZXR1cm4gUihlKSB8fCAodCArPSBlKSwgdDtcbiAgfSxcbiAgbGFiZWxDb2xvcjogZnVuY3Rpb24gbGFiZWxDb2xvcihpKSB7XG4gICAgdmFyIGUgPSBpLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkuZGF0YXNldEluZGV4KS5jb250cm9sbGVyLmdldFN0eWxlKGkuZGF0YUluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgYm9yZGVyQ29sb3I6IGUuYm9yZGVyQ29sb3IsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgYm9yZGVyV2lkdGg6IGUuYm9yZGVyV2lkdGgsXG4gICAgICBib3JkZXJEYXNoOiBlLmJvcmRlckRhc2gsXG4gICAgICBib3JkZXJEYXNoT2Zmc2V0OiBlLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICBib3JkZXJSYWRpdXM6IDBcbiAgICB9O1xuICB9LFxuICBsYWJlbFRleHRDb2xvcjogZnVuY3Rpb24gbGFiZWxUZXh0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ib2R5Q29sb3I7XG4gIH0sXG4gIGxhYmVsUG9pbnRTdHlsZTogZnVuY3Rpb24gbGFiZWxQb2ludFN0eWxlKGkpIHtcbiAgICB2YXIgZSA9IGkuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaS5kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaS5kYXRhSW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludFN0eWxlOiBlLnBvaW50U3R5bGUsXG4gICAgICByb3RhdGlvbjogZS5yb3RhdGlvblxuICAgIH07XG4gIH0sXG4gIGFmdGVyTGFiZWw6IGR0LFxuICBhZnRlckJvZHk6IGR0LFxuICBiZWZvcmVGb290ZXI6IGR0LFxuICBmb290ZXI6IGR0LFxuICBhZnRlckZvb3RlcjogZHRcbn07XG5mdW5jdGlvbiBLKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBpW3RdLmNhbGwoZSwgcyk7XG4gIHJldHVybiBfdHlwZW9mKG4pID4gXCJ1XCIgPyByb1t0XS5jYWxsKGUsIHMpIDogbjtcbn1cbnZhciBPaSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N0OCkge1xuICBmdW5jdGlvbiBPaSh0KSB7XG4gICAgdmFyIF90aGlzMjg7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9pKTtcbiAgICBfdGhpczI4ID0gX2NhbGxTdXBlcih0aGlzLCBPaSksIF90aGlzMjgub3BhY2l0eSA9IDAsIF90aGlzMjguX2FjdGl2ZSA9IFtdLCBfdGhpczI4Ll9ldmVudFBvc2l0aW9uID0gdm9pZCAwLCBfdGhpczI4Ll9zaXplID0gdm9pZCAwLCBfdGhpczI4Ll9jYWNoZWRBbmltYXRpb25zID0gdm9pZCAwLCBfdGhpczI4Ll90b29sdGlwSXRlbXMgPSBbXSwgX3RoaXMyOC4kYW5pbWF0aW9ucyA9IHZvaWQgMCwgX3RoaXMyOC4kY29udGV4dCA9IHZvaWQgMCwgX3RoaXMyOC5jaGFydCA9IHQuY2hhcnQsIF90aGlzMjgub3B0aW9ucyA9IHQub3B0aW9ucywgX3RoaXMyOC5kYXRhUG9pbnRzID0gdm9pZCAwLCBfdGhpczI4LnRpdGxlID0gdm9pZCAwLCBfdGhpczI4LmJlZm9yZUJvZHkgPSB2b2lkIDAsIF90aGlzMjguYm9keSA9IHZvaWQgMCwgX3RoaXMyOC5hZnRlckJvZHkgPSB2b2lkIDAsIF90aGlzMjguZm9vdGVyID0gdm9pZCAwLCBfdGhpczI4LnhBbGlnbiA9IHZvaWQgMCwgX3RoaXMyOC55QWxpZ24gPSB2b2lkIDAsIF90aGlzMjgueCA9IHZvaWQgMCwgX3RoaXMyOC55ID0gdm9pZCAwLCBfdGhpczI4LmhlaWdodCA9IHZvaWQgMCwgX3RoaXMyOC53aWR0aCA9IHZvaWQgMCwgX3RoaXMyOC5jYXJldFggPSB2b2lkIDAsIF90aGlzMjguY2FyZXRZID0gdm9pZCAwLCBfdGhpczI4LmxhYmVsQ29sb3JzID0gdm9pZCAwLCBfdGhpczI4LmxhYmVsUG9pbnRTdHlsZXMgPSB2b2lkIDAsIF90aGlzMjgubGFiZWxUZXh0Q29sb3JzID0gdm9pZCAwO1xuICAgIHJldHVybiBfdGhpczI4O1xuICB9XG4gIF9pbmhlcml0cyhPaSwgX3N0OCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoT2ksIFt7XG4gICAga2V5OiBcImluaXRpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZSh0KSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB0LCB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdm9pZCAwLCB0aGlzLiRjb250ZXh0ID0gdm9pZCAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVzb2x2ZUFuaW1hdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc29sdmVBbmltYXRpb25zKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9jYWNoZWRBbmltYXRpb25zO1xuICAgICAgaWYgKHQpIHJldHVybiB0O1xuICAgICAgdmFyIGUgPSB0aGlzLmNoYXJ0LFxuICAgICAgICBzID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpLFxuICAgICAgICBuID0gcy5lbmFibGVkICYmIGUub3B0aW9ucy5hbmltYXRpb24gJiYgcy5hbmltYXRpb25zLFxuICAgICAgICBvID0gbmV3IE5uKHRoaXMuY2hhcnQsIG4pO1xuICAgICAgcmV0dXJuIG4uX2NhY2hlYWJsZSAmJiAodGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IE9iamVjdC5mcmVlemUobykpLCBvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fCAodGhpcy4kY29udGV4dCA9IEVjKHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLCB0aGlzLl90b29sdGlwSXRlbXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGl0bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGl0bGUodCwgZSkge1xuICAgICAgdmFyIHMgPSBlLmNhbGxiYWNrcyxcbiAgICAgICAgbiA9IEsocywgXCJiZWZvcmVUaXRsZVwiLCB0aGlzLCB0KSxcbiAgICAgICAgbyA9IEsocywgXCJ0aXRsZVwiLCB0aGlzLCB0KSxcbiAgICAgICAgciA9IEsocywgXCJhZnRlclRpdGxlXCIsIHRoaXMsIHQpO1xuICAgICAgdmFyIGEgPSBbXTtcbiAgICAgIHJldHVybiBhID0gcnQoYSwgZnQobikpLCBhID0gcnQoYSwgZnQobykpLCBhID0gcnQoYSwgZnQocikpLCBhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCZWZvcmVCb2R5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJlZm9yZUJvZHkodCwgZSkge1xuICAgICAgcmV0dXJuIHNuKEsoZS5jYWxsYmFja3MsIFwiYmVmb3JlQm9keVwiLCB0aGlzLCB0KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJvZHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm9keSh0LCBlKSB7XG4gICAgICB2YXIgX3RoaXMyOSA9IHRoaXM7XG4gICAgICB2YXIgcyA9IGUuY2FsbGJhY2tzLFxuICAgICAgICBuID0gW107XG4gICAgICByZXR1cm4gTCh0LCBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgciA9IHtcbiAgICAgICAgICAgIGJlZm9yZTogW10sXG4gICAgICAgICAgICBsaW5lczogW10sXG4gICAgICAgICAgICBhZnRlcjogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGEgPSBubihzLCBvKTtcbiAgICAgICAgcnQoci5iZWZvcmUsIGZ0KEsoYSwgXCJiZWZvcmVMYWJlbFwiLCBfdGhpczI5LCBvKSkpLCBydChyLmxpbmVzLCBLKGEsIFwibGFiZWxcIiwgX3RoaXMyOSwgbykpLCBydChyLmFmdGVyLCBmdChLKGEsIFwiYWZ0ZXJMYWJlbFwiLCBfdGhpczI5LCBvKSkpLCBuLnB1c2gocik7XG4gICAgICB9KSwgbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QWZ0ZXJCb2R5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFmdGVyQm9keSh0LCBlKSB7XG4gICAgICByZXR1cm4gc24oSyhlLmNhbGxiYWNrcywgXCJhZnRlckJvZHlcIiwgdGhpcywgdCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRGb290ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9vdGVyKHQsIGUpIHtcbiAgICAgIHZhciBzID0gZS5jYWxsYmFja3MsXG4gICAgICAgIG4gPSBLKHMsIFwiYmVmb3JlRm9vdGVyXCIsIHRoaXMsIHQpLFxuICAgICAgICBvID0gSyhzLCBcImZvb3RlclwiLCB0aGlzLCB0KSxcbiAgICAgICAgciA9IEsocywgXCJhZnRlckZvb3RlclwiLCB0aGlzLCB0KTtcbiAgICAgIHZhciBhID0gW107XG4gICAgICByZXR1cm4gYSA9IHJ0KGEsIGZ0KG4pKSwgYSA9IHJ0KGEsIGZ0KG8pKSwgYSA9IHJ0KGEsIGZ0KHIpKSwgYTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUl0ZW1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVJdGVtcyh0KSB7XG4gICAgICB2YXIgX3RoaXMzMCA9IHRoaXM7XG4gICAgICB2YXIgZSA9IHRoaXMuX2FjdGl2ZSxcbiAgICAgICAgcyA9IHRoaXMuY2hhcnQuZGF0YSxcbiAgICAgICAgbiA9IFtdLFxuICAgICAgICBvID0gW10sXG4gICAgICAgIHIgPSBbXTtcbiAgICAgIHZhciBhID0gW10sXG4gICAgICAgIGwsXG4gICAgICAgIGM7XG4gICAgICBmb3IgKGwgPSAwLCBjID0gZS5sZW5ndGg7IGwgPCBjOyArK2wpIGEucHVzaChDYyh0aGlzLmNoYXJ0LCBlW2xdKSk7XG4gICAgICByZXR1cm4gdC5maWx0ZXIgJiYgKGEgPSBhLmZpbHRlcihmdW5jdGlvbiAoaCwgZCwgdSkge1xuICAgICAgICByZXR1cm4gdC5maWx0ZXIoaCwgZCwgdSwgcyk7XG4gICAgICB9KSksIHQuaXRlbVNvcnQgJiYgKGEgPSBhLnNvcnQoZnVuY3Rpb24gKGgsIGQpIHtcbiAgICAgICAgcmV0dXJuIHQuaXRlbVNvcnQoaCwgZCwgcyk7XG4gICAgICB9KSksIEwoYSwgZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgdmFyIGQgPSBubih0LmNhbGxiYWNrcywgaCk7XG4gICAgICAgIG4ucHVzaChLKGQsIFwibGFiZWxDb2xvclwiLCBfdGhpczMwLCBoKSksIG8ucHVzaChLKGQsIFwibGFiZWxQb2ludFN0eWxlXCIsIF90aGlzMzAsIGgpKSwgci5wdXNoKEsoZCwgXCJsYWJlbFRleHRDb2xvclwiLCBfdGhpczMwLCBoKSk7XG4gICAgICB9KSwgdGhpcy5sYWJlbENvbG9ycyA9IG4sIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IG8sIHRoaXMubGFiZWxUZXh0Q29sb3JzID0gciwgdGhpcy5kYXRhUG9pbnRzID0gYSwgYTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSh0LCBlKSB7XG4gICAgICB2YXIgcyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKSxcbiAgICAgICAgbiA9IHRoaXMuX2FjdGl2ZTtcbiAgICAgIHZhciBvLFxuICAgICAgICByID0gW107XG4gICAgICBpZiAoIW4ubGVuZ3RoKSB0aGlzLm9wYWNpdHkgIT09IDAgJiYgKG8gPSB7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0pO2Vsc2Uge1xuICAgICAgICB2YXIgYSA9IGFlW3MucG9zaXRpb25dLmNhbGwodGhpcywgbiwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICAgIHIgPSB0aGlzLl9jcmVhdGVJdGVtcyhzKSwgdGhpcy50aXRsZSA9IHRoaXMuZ2V0VGl0bGUociwgcyksIHRoaXMuYmVmb3JlQm9keSA9IHRoaXMuZ2V0QmVmb3JlQm9keShyLCBzKSwgdGhpcy5ib2R5ID0gdGhpcy5nZXRCb2R5KHIsIHMpLCB0aGlzLmFmdGVyQm9keSA9IHRoaXMuZ2V0QWZ0ZXJCb2R5KHIsIHMpLCB0aGlzLmZvb3RlciA9IHRoaXMuZ2V0Rm9vdGVyKHIsIHMpO1xuICAgICAgICB2YXIgbCA9IHRoaXMuX3NpemUgPSBRcyh0aGlzLCBzKSxcbiAgICAgICAgICBjID0gT2JqZWN0LmFzc2lnbih7fSwgYSwgbCksXG4gICAgICAgICAgaCA9IHRuKHRoaXMuY2hhcnQsIHMsIGMpLFxuICAgICAgICAgIGQgPSBlbihzLCBjLCBoLCB0aGlzLmNoYXJ0KTtcbiAgICAgICAgdGhpcy54QWxpZ24gPSBoLnhBbGlnbiwgdGhpcy55QWxpZ24gPSBoLnlBbGlnbiwgbyA9IHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIHg6IGQueCxcbiAgICAgICAgICB5OiBkLnksXG4gICAgICAgICAgd2lkdGg6IGwud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBsLmhlaWdodCxcbiAgICAgICAgICBjYXJldFg6IGEueCxcbiAgICAgICAgICBjYXJldFk6IGEueVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5fdG9vbHRpcEl0ZW1zID0gciwgdGhpcy4kY29udGV4dCA9IHZvaWQgMCwgbyAmJiB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBvKSwgdCAmJiBzLmV4dGVybmFsICYmIHMuZXh0ZXJuYWwuY2FsbCh0aGlzLCB7XG4gICAgICAgIGNoYXJ0OiB0aGlzLmNoYXJ0LFxuICAgICAgICB0b29sdGlwOiB0aGlzLFxuICAgICAgICByZXBsYXk6IGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Q2FyZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0NhcmV0KHQsIGUsIHMsIG4pIHtcbiAgICAgIHZhciBvID0gdGhpcy5nZXRDYXJldFBvc2l0aW9uKHQsIHMsIG4pO1xuICAgICAgZS5saW5lVG8oby54MSwgby55MSksIGUubGluZVRvKG8ueDIsIG8ueTIpLCBlLmxpbmVUbyhvLngzLCBvLnkzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FyZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYXJldFBvc2l0aW9uKHQsIGUsIHMpIHtcbiAgICAgIHZhciBuID0gdGhpcy54QWxpZ24sXG4gICAgICAgIG8gPSB0aGlzLnlBbGlnbixcbiAgICAgICAgciA9IHMuY2FyZXRTaXplLFxuICAgICAgICBhID0gcy5jb3JuZXJSYWRpdXMsXG4gICAgICAgIF9ZdDIgPSBZdChhKSxcbiAgICAgICAgbCA9IF9ZdDIudG9wTGVmdCxcbiAgICAgICAgYyA9IF9ZdDIudG9wUmlnaHQsXG4gICAgICAgIGggPSBfWXQyLmJvdHRvbUxlZnQsXG4gICAgICAgIGQgPSBfWXQyLmJvdHRvbVJpZ2h0LFxuICAgICAgICB1ID0gdC54LFxuICAgICAgICBmID0gdC55LFxuICAgICAgICBwID0gZS53aWR0aCxcbiAgICAgICAgZyA9IGUuaGVpZ2h0O1xuICAgICAgdmFyIG0sIGIsIF8sIHYsIHksIHg7XG4gICAgICByZXR1cm4gbyA9PT0gXCJjZW50ZXJcIiA/ICh5ID0gZiArIGcgLyAyLCBuID09PSBcImxlZnRcIiA/IChtID0gdSwgYiA9IG0gLSByLCB2ID0geSArIHIsIHggPSB5IC0gcikgOiAobSA9IHUgKyBwLCBiID0gbSArIHIsIHYgPSB5IC0gciwgeCA9IHkgKyByKSwgXyA9IG0pIDogKG4gPT09IFwibGVmdFwiID8gYiA9IHUgKyBNYXRoLm1heChsLCBoKSArIHIgOiBuID09PSBcInJpZ2h0XCIgPyBiID0gdSArIHAgLSBNYXRoLm1heChjLCBkKSAtIHIgOiBiID0gdGhpcy5jYXJldFgsIG8gPT09IFwidG9wXCIgPyAodiA9IGYsIHkgPSB2IC0gciwgbSA9IGIgLSByLCBfID0gYiArIHIpIDogKHYgPSBmICsgZywgeSA9IHYgKyByLCBtID0gYiArIHIsIF8gPSBiIC0gciksIHggPSB2KSwge1xuICAgICAgICB4MTogbSxcbiAgICAgICAgeDI6IGIsXG4gICAgICAgIHgzOiBfLFxuICAgICAgICB5MTogdixcbiAgICAgICAgeTI6IHksXG4gICAgICAgIHkzOiB4XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3VGl0bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1RpdGxlKHQsIGUsIHMpIHtcbiAgICAgIHZhciBuID0gdGhpcy50aXRsZSxcbiAgICAgICAgbyA9IG4ubGVuZ3RoO1xuICAgICAgdmFyIHIsIGEsIGw7XG4gICAgICBpZiAobykge1xuICAgICAgICB2YXIgYyA9IFV0KHMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuICAgICAgICBmb3IgKHQueCA9IFJlKHRoaXMsIHMudGl0bGVBbGlnbiwgcyksIGUudGV4dEFsaWduID0gYy50ZXh0QWxpZ24ocy50aXRsZUFsaWduKSwgZS50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiLCByID0gWChzLnRpdGxlRm9udCksIGEgPSBzLnRpdGxlU3BhY2luZywgZS5maWxsU3R5bGUgPSBzLnRpdGxlQ29sb3IsIGUuZm9udCA9IHIuc3RyaW5nLCBsID0gMDsgbCA8IG87ICsrbCkgZS5maWxsVGV4dChuW2xdLCBjLngodC54KSwgdC55ICsgci5saW5lSGVpZ2h0IC8gMiksIHQueSArPSByLmxpbmVIZWlnaHQgKyBhLCBsICsgMSA9PT0gbyAmJiAodC55ICs9IHMudGl0bGVNYXJnaW5Cb3R0b20gLSBhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdDb2xvckJveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0NvbG9yQm94KHQsIGUsIHMsIG4sIG8pIHtcbiAgICAgIHZhciByID0gdGhpcy5sYWJlbENvbG9yc1tzXSxcbiAgICAgICAgYSA9IHRoaXMubGFiZWxQb2ludFN0eWxlc1tzXSxcbiAgICAgICAgbCA9IG8uYm94SGVpZ2h0LFxuICAgICAgICBjID0gby5ib3hXaWR0aCxcbiAgICAgICAgaCA9IFgoby5ib2R5Rm9udCksXG4gICAgICAgIGQgPSBSZSh0aGlzLCBcImxlZnRcIiwgbyksXG4gICAgICAgIHUgPSBuLngoZCksXG4gICAgICAgIGYgPSBsIDwgaC5saW5lSGVpZ2h0ID8gKGgubGluZUhlaWdodCAtIGwpIC8gMiA6IDAsXG4gICAgICAgIHAgPSBlLnkgKyBmO1xuICAgICAgaWYgKG8udXNlUG9pbnRTdHlsZSkge1xuICAgICAgICB2YXIgZyA9IHtcbiAgICAgICAgICAgIHJhZGl1czogTWF0aC5taW4oYywgbCkgLyAyLFxuICAgICAgICAgICAgcG9pbnRTdHlsZTogYS5wb2ludFN0eWxlLFxuICAgICAgICAgICAgcm90YXRpb246IGEucm90YXRpb24sXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbSA9IG4ubGVmdEZvckx0cih1LCBjKSArIGMgLyAyLFxuICAgICAgICAgIGIgPSBwICsgbCAvIDI7XG4gICAgICAgIHQuc3Ryb2tlU3R5bGUgPSBvLm11bHRpS2V5QmFja2dyb3VuZCwgdC5maWxsU3R5bGUgPSBvLm11bHRpS2V5QmFja2dyb3VuZCwgU2kodCwgZywgbSwgYiksIHQuc3Ryb2tlU3R5bGUgPSByLmJvcmRlckNvbG9yLCB0LmZpbGxTdHlsZSA9IHIuYmFja2dyb3VuZENvbG9yLCBTaSh0LCBnLCBtLCBiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQubGluZVdpZHRoID0gVChyLmJvcmRlcldpZHRoKSA/IE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShPYmplY3QudmFsdWVzKHIuYm9yZGVyV2lkdGgpKSkgOiByLmJvcmRlcldpZHRoIHx8IDEsIHQuc3Ryb2tlU3R5bGUgPSByLmJvcmRlckNvbG9yLCB0LnNldExpbmVEYXNoKHIuYm9yZGVyRGFzaCB8fCBbXSksIHQubGluZURhc2hPZmZzZXQgPSByLmJvcmRlckRhc2hPZmZzZXQgfHwgMDtcbiAgICAgICAgdmFyIF9nMiA9IG4ubGVmdEZvckx0cih1LCBjKSxcbiAgICAgICAgICBfbSA9IG4ubGVmdEZvckx0cihuLnhQbHVzKHUsIDEpLCBjIC0gMiksXG4gICAgICAgICAgX2IzID0gWXQoci5ib3JkZXJSYWRpdXMpO1xuICAgICAgICBPYmplY3QudmFsdWVzKF9iMykuc29tZShmdW5jdGlvbiAoXykge1xuICAgICAgICAgIHJldHVybiBfICE9PSAwO1xuICAgICAgICB9KSA/ICh0LmJlZ2luUGF0aCgpLCB0LmZpbGxTdHlsZSA9IG8ubXVsdGlLZXlCYWNrZ3JvdW5kLCBVZSh0LCB7XG4gICAgICAgICAgeDogX2cyLFxuICAgICAgICAgIHk6IHAsXG4gICAgICAgICAgdzogYyxcbiAgICAgICAgICBoOiBsLFxuICAgICAgICAgIHJhZGl1czogX2IzXG4gICAgICAgIH0pLCB0LmZpbGwoKSwgdC5zdHJva2UoKSwgdC5maWxsU3R5bGUgPSByLmJhY2tncm91bmRDb2xvciwgdC5iZWdpblBhdGgoKSwgVWUodCwge1xuICAgICAgICAgIHg6IF9tLFxuICAgICAgICAgIHk6IHAgKyAxLFxuICAgICAgICAgIHc6IGMgLSAyLFxuICAgICAgICAgIGg6IGwgLSAyLFxuICAgICAgICAgIHJhZGl1czogX2IzXG4gICAgICAgIH0pLCB0LmZpbGwoKSkgOiAodC5maWxsU3R5bGUgPSBvLm11bHRpS2V5QmFja2dyb3VuZCwgdC5maWxsUmVjdChfZzIsIHAsIGMsIGwpLCB0LnN0cm9rZVJlY3QoX2cyLCBwLCBjLCBsKSwgdC5maWxsU3R5bGUgPSByLmJhY2tncm91bmRDb2xvciwgdC5maWxsUmVjdChfbSwgcCArIDEsIGMgLSAyLCBsIC0gMikpO1xuICAgICAgfVxuICAgICAgdC5maWxsU3R5bGUgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tzXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0JvZHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0JvZHkodCwgZSwgcykge1xuICAgICAgdmFyIG4gPSB0aGlzLmJvZHksXG4gICAgICAgIG8gPSBzLmJvZHlTcGFjaW5nLFxuICAgICAgICByID0gcy5ib2R5QWxpZ24sXG4gICAgICAgIGEgPSBzLmRpc3BsYXlDb2xvcnMsXG4gICAgICAgIGwgPSBzLmJveEhlaWdodCxcbiAgICAgICAgYyA9IHMuYm94V2lkdGgsXG4gICAgICAgIGggPSBzLmJveFBhZGRpbmcsXG4gICAgICAgIGQgPSBYKHMuYm9keUZvbnQpO1xuICAgICAgdmFyIHUgPSBkLmxpbmVIZWlnaHQsXG4gICAgICAgIGYgPSAwO1xuICAgICAgdmFyIHAgPSBVdChzLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKSxcbiAgICAgICAgZyA9IGZ1bmN0aW9uIGcoaykge1xuICAgICAgICAgIGUuZmlsbFRleHQoaywgcC54KHQueCArIGYpLCB0LnkgKyB1IC8gMiksIHQueSArPSB1ICsgbztcbiAgICAgICAgfSxcbiAgICAgICAgbSA9IHAudGV4dEFsaWduKHIpO1xuICAgICAgdmFyIGIsIF8sIHYsIHksIHgsIE0sIFM7XG4gICAgICBmb3IgKGUudGV4dEFsaWduID0gciwgZS50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiLCBlLmZvbnQgPSBkLnN0cmluZywgdC54ID0gUmUodGhpcywgbSwgcyksIGUuZmlsbFN0eWxlID0gcy5ib2R5Q29sb3IsIEwodGhpcy5iZWZvcmVCb2R5LCBnKSwgZiA9IGEgJiYgbSAhPT0gXCJyaWdodFwiID8gciA9PT0gXCJjZW50ZXJcIiA/IGMgLyAyICsgaCA6IGMgKyAyICsgaCA6IDAsIHkgPSAwLCBNID0gbi5sZW5ndGg7IHkgPCBNOyArK3kpIHtcbiAgICAgICAgZm9yIChiID0gblt5XSwgXyA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW3ldLCBlLmZpbGxTdHlsZSA9IF8sIEwoYi5iZWZvcmUsIGcpLCB2ID0gYi5saW5lcywgYSAmJiB2Lmxlbmd0aCAmJiAodGhpcy5fZHJhd0NvbG9yQm94KGUsIHQsIHksIHAsIHMpLCB1ID0gTWF0aC5tYXgoZC5saW5lSGVpZ2h0LCBsKSksIHggPSAwLCBTID0gdi5sZW5ndGg7IHggPCBTOyArK3gpIGcodlt4XSksIHUgPSBkLmxpbmVIZWlnaHQ7XG4gICAgICAgIEwoYi5hZnRlciwgZyk7XG4gICAgICB9XG4gICAgICBmID0gMCwgdSA9IGQubGluZUhlaWdodCwgTCh0aGlzLmFmdGVyQm9keSwgZyksIHQueSAtPSBvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Rm9vdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdGb290ZXIodCwgZSwgcykge1xuICAgICAgdmFyIG4gPSB0aGlzLmZvb3RlcixcbiAgICAgICAgbyA9IG4ubGVuZ3RoO1xuICAgICAgdmFyIHIsIGE7XG4gICAgICBpZiAobykge1xuICAgICAgICB2YXIgbCA9IFV0KHMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuICAgICAgICBmb3IgKHQueCA9IFJlKHRoaXMsIHMuZm9vdGVyQWxpZ24sIHMpLCB0LnkgKz0gcy5mb290ZXJNYXJnaW5Ub3AsIGUudGV4dEFsaWduID0gbC50ZXh0QWxpZ24ocy5mb290ZXJBbGlnbiksIGUudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIiwgciA9IFgocy5mb290ZXJGb250KSwgZS5maWxsU3R5bGUgPSBzLmZvb3RlckNvbG9yLCBlLmZvbnQgPSByLnN0cmluZywgYSA9IDA7IGEgPCBvOyArK2EpIGUuZmlsbFRleHQoblthXSwgbC54KHQueCksIHQueSArIHIubGluZUhlaWdodCAvIDIpLCB0LnkgKz0gci5saW5lSGVpZ2h0ICsgcy5mb290ZXJTcGFjaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3QmFja2dyb3VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QmFja2dyb3VuZCh0LCBlLCBzLCBuKSB7XG4gICAgICB2YXIgbyA9IHRoaXMueEFsaWduLFxuICAgICAgICByID0gdGhpcy55QWxpZ24sXG4gICAgICAgIGEgPSB0LngsXG4gICAgICAgIGwgPSB0LnksXG4gICAgICAgIGMgPSBzLndpZHRoLFxuICAgICAgICBoID0gcy5oZWlnaHQsXG4gICAgICAgIF9ZdDMgPSBZdChuLmNvcm5lclJhZGl1cyksXG4gICAgICAgIGQgPSBfWXQzLnRvcExlZnQsXG4gICAgICAgIHUgPSBfWXQzLnRvcFJpZ2h0LFxuICAgICAgICBmID0gX1l0My5ib3R0b21MZWZ0LFxuICAgICAgICBwID0gX1l0My5ib3R0b21SaWdodDtcbiAgICAgIGUuZmlsbFN0eWxlID0gbi5iYWNrZ3JvdW5kQ29sb3IsIGUuc3Ryb2tlU3R5bGUgPSBuLmJvcmRlckNvbG9yLCBlLmxpbmVXaWR0aCA9IG4uYm9yZGVyV2lkdGgsIGUuYmVnaW5QYXRoKCksIGUubW92ZVRvKGEgKyBkLCBsKSwgciA9PT0gXCJ0b3BcIiAmJiB0aGlzLmRyYXdDYXJldCh0LCBlLCBzLCBuKSwgZS5saW5lVG8oYSArIGMgLSB1LCBsKSwgZS5xdWFkcmF0aWNDdXJ2ZVRvKGEgKyBjLCBsLCBhICsgYywgbCArIHUpLCByID09PSBcImNlbnRlclwiICYmIG8gPT09IFwicmlnaHRcIiAmJiB0aGlzLmRyYXdDYXJldCh0LCBlLCBzLCBuKSwgZS5saW5lVG8oYSArIGMsIGwgKyBoIC0gcCksIGUucXVhZHJhdGljQ3VydmVUbyhhICsgYywgbCArIGgsIGEgKyBjIC0gcCwgbCArIGgpLCByID09PSBcImJvdHRvbVwiICYmIHRoaXMuZHJhd0NhcmV0KHQsIGUsIHMsIG4pLCBlLmxpbmVUbyhhICsgZiwgbCArIGgpLCBlLnF1YWRyYXRpY0N1cnZlVG8oYSwgbCArIGgsIGEsIGwgKyBoIC0gZiksIHIgPT09IFwiY2VudGVyXCIgJiYgbyA9PT0gXCJsZWZ0XCIgJiYgdGhpcy5kcmF3Q2FyZXQodCwgZSwgcywgbiksIGUubGluZVRvKGEsIGwgKyBkKSwgZS5xdWFkcmF0aWNDdXJ2ZVRvKGEsIGwsIGEgKyBkLCBsKSwgZS5jbG9zZVBhdGgoKSwgZS5maWxsKCksIG4uYm9yZGVyV2lkdGggPiAwICYmIGUuc3Ryb2tlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVBbmltYXRpb25UYXJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUFuaW1hdGlvblRhcmdldCh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuY2hhcnQsXG4gICAgICAgIHMgPSB0aGlzLiRhbmltYXRpb25zLFxuICAgICAgICBuID0gcyAmJiBzLngsXG4gICAgICAgIG8gPSBzICYmIHMueTtcbiAgICAgIGlmIChuIHx8IG8pIHtcbiAgICAgICAgdmFyIHIgPSBhZVt0LnBvc2l0aW9uXS5jYWxsKHRoaXMsIHRoaXMuX2FjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICAgIGlmICghcikgcmV0dXJuO1xuICAgICAgICB2YXIgYSA9IHRoaXMuX3NpemUgPSBRcyh0aGlzLCB0KSxcbiAgICAgICAgICBsID0gT2JqZWN0LmFzc2lnbih7fSwgciwgdGhpcy5fc2l6ZSksXG4gICAgICAgICAgYyA9IHRuKGUsIHQsIGwpLFxuICAgICAgICAgIGggPSBlbih0LCBsLCBjLCBlKTtcbiAgICAgICAgKG4uX3RvICE9PSBoLnggfHwgby5fdG8gIT09IGgueSkgJiYgKHRoaXMueEFsaWduID0gYy54QWxpZ24sIHRoaXMueUFsaWduID0gYy55QWxpZ24sIHRoaXMud2lkdGggPSBhLndpZHRoLCB0aGlzLmhlaWdodCA9IGEuaGVpZ2h0LCB0aGlzLmNhcmV0WCA9IHIueCwgdGhpcy5jYXJldFkgPSByLnksIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIGgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3dpbGxSZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3dpbGxSZW5kZXIoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLm9wYWNpdHk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICAgIHZhciBzID0gdGhpcy5vcGFjaXR5O1xuICAgICAgaWYgKCFzKSByZXR1cm47XG4gICAgICB0aGlzLl91cGRhdGVBbmltYXRpb25UYXJnZXQoZSk7XG4gICAgICB2YXIgbiA9IHtcbiAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIG8gPSB7XG4gICAgICAgICAgeDogdGhpcy54LFxuICAgICAgICAgIHk6IHRoaXMueVxuICAgICAgICB9O1xuICAgICAgcyA9IE1hdGguYWJzKHMpIDwgMWUtMyA/IDAgOiBzO1xuICAgICAgdmFyIHIgPSBldChlLnBhZGRpbmcpLFxuICAgICAgICBhID0gdGhpcy50aXRsZS5sZW5ndGggfHwgdGhpcy5iZWZvcmVCb2R5Lmxlbmd0aCB8fCB0aGlzLmJvZHkubGVuZ3RoIHx8IHRoaXMuYWZ0ZXJCb2R5Lmxlbmd0aCB8fCB0aGlzLmZvb3Rlci5sZW5ndGg7XG4gICAgICBlLmVuYWJsZWQgJiYgYSAmJiAodC5zYXZlKCksIHQuZ2xvYmFsQWxwaGEgPSBzLCB0aGlzLmRyYXdCYWNrZ3JvdW5kKG8sIHQsIG4sIGUpLCBGbih0LCBlLnRleHREaXJlY3Rpb24pLCBvLnkgKz0gci50b3AsIHRoaXMuZHJhd1RpdGxlKG8sIHQsIGUpLCB0aGlzLmRyYXdCb2R5KG8sIHQsIGUpLCB0aGlzLmRyYXdGb290ZXIobywgdCwgZSksIEluKHQsIGUudGV4dERpcmVjdGlvbiksIHQucmVzdG9yZSgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QWN0aXZlRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRBY3RpdmVFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBY3RpdmVFbGVtZW50cyh0LCBlKSB7XG4gICAgICB2YXIgX3RoaXMzMSA9IHRoaXM7XG4gICAgICB2YXIgcyA9IHRoaXMuX2FjdGl2ZSxcbiAgICAgICAgbiA9IHQubWFwKGZ1bmN0aW9uIChfcmVmMTApIHtcbiAgICAgICAgICB2YXIgYSA9IF9yZWYxMC5kYXRhc2V0SW5kZXgsXG4gICAgICAgICAgICBsID0gX3JlZjEwLmluZGV4O1xuICAgICAgICAgIHZhciBjID0gX3RoaXMzMS5jaGFydC5nZXREYXRhc2V0TWV0YShhKTtcbiAgICAgICAgICBpZiAoIWMpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGF0YXNldCBhdCBpbmRleCBcIiArIGEpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IGEsXG4gICAgICAgICAgICBlbGVtZW50OiBjLmRhdGFbbF0sXG4gICAgICAgICAgICBpbmRleDogbFxuICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICBvID0gIWplKHMsIG4pLFxuICAgICAgICByID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKG4sIGUpO1xuICAgICAgKG8gfHwgcikgJiYgKHRoaXMuX2FjdGl2ZSA9IG4sIHRoaXMuX2V2ZW50UG9zaXRpb24gPSBlLCB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSAhMCwgdGhpcy51cGRhdGUoITApKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRXZlbnQodCwgZSkge1xuICAgICAgdmFyIHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICEwO1xuICAgICAgaWYgKGUgJiYgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzKSByZXR1cm4gITE7XG4gICAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSAhMTtcbiAgICAgIHZhciBuID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBvID0gdGhpcy5fYWN0aXZlIHx8IFtdLFxuICAgICAgICByID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHModCwgbywgZSwgcyksXG4gICAgICAgIGEgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQociwgdCksXG4gICAgICAgIGwgPSBlIHx8ICFqZShyLCBvKSB8fCBhO1xuICAgICAgcmV0dXJuIGwgJiYgKHRoaXMuX2FjdGl2ZSA9IHIsIChuLmVuYWJsZWQgfHwgbi5leHRlcm5hbCkgJiYgKHRoaXMuX2V2ZW50UG9zaXRpb24gPSB7XG4gICAgICAgIHg6IHQueCxcbiAgICAgICAgeTogdC55XG4gICAgICB9LCB0aGlzLnVwZGF0ZSghMCwgZSkpKSwgbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEFjdGl2ZUVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBY3RpdmVFbGVtZW50cyh0LCBlLCBzLCBuKSB7XG4gICAgICB2YXIgX3RoaXMzMiA9IHRoaXM7XG4gICAgICB2YXIgbyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmICh0LnR5cGUgPT09IFwibW91c2VvdXRcIikgcmV0dXJuIFtdO1xuICAgICAgaWYgKCFuKSByZXR1cm4gZS5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMzIuY2hhcnQuZGF0YS5kYXRhc2V0c1thLmRhdGFzZXRJbmRleF0gJiYgX3RoaXMzMi5jaGFydC5nZXREYXRhc2V0TWV0YShhLmRhdGFzZXRJbmRleCkuY29udHJvbGxlci5nZXRQYXJzZWQoYS5pbmRleCkgIT09IHZvaWQgMDtcbiAgICAgIH0pO1xuICAgICAgdmFyIHIgPSB0aGlzLmNoYXJ0LmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUodCwgby5tb2RlLCBvLCBzKTtcbiAgICAgIHJldHVybiBvLnJldmVyc2UgJiYgci5yZXZlcnNlKCksIHI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9wb3NpdGlvbkNoYW5nZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Bvc2l0aW9uQ2hhbmdlZCh0LCBlKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuY2FyZXRYLFxuICAgICAgICBuID0gdGhpcy5jYXJldFksXG4gICAgICAgIG8gPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHIgPSBhZVtvLnBvc2l0aW9uXS5jYWxsKHRoaXMsIHQsIGUpO1xuICAgICAgcmV0dXJuIHIgIT09ICExICYmIChzICE9PSByLnggfHwgbiAhPT0gci55KTtcbiAgICB9XG4gIH1dKTtcbn0oc3QpO1xudyhPaSwgXCJwb3NpdGlvbmVyc1wiLCBhZSk7XG52YXIgRmMgPSB7XG4gIGlkOiBcInRvb2x0aXBcIixcbiAgX2VsZW1lbnQ6IE9pLFxuICBwb3NpdGlvbmVyczogYWUsXG4gIGFmdGVySW5pdDogZnVuY3Rpb24gYWZ0ZXJJbml0KGksIHQsIGUpIHtcbiAgICBlICYmIChpLnRvb2x0aXAgPSBuZXcgT2koe1xuICAgICAgY2hhcnQ6IGksXG4gICAgICBvcHRpb25zOiBlXG4gICAgfSkpO1xuICB9LFxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZShpLCB0LCBlKSB7XG4gICAgaS50b29sdGlwICYmIGkudG9vbHRpcC5pbml0aWFsaXplKGUpO1xuICB9LFxuICByZXNldDogZnVuY3Rpb24gcmVzZXQoaSwgdCwgZSkge1xuICAgIGkudG9vbHRpcCAmJiBpLnRvb2x0aXAuaW5pdGlhbGl6ZShlKTtcbiAgfSxcbiAgYWZ0ZXJEcmF3OiBmdW5jdGlvbiBhZnRlckRyYXcoaSkge1xuICAgIHZhciB0ID0gaS50b29sdGlwO1xuICAgIGlmICh0ICYmIHQuX3dpbGxSZW5kZXIoKSkge1xuICAgICAgdmFyIGUgPSB7XG4gICAgICAgIHRvb2x0aXA6IHRcbiAgICAgIH07XG4gICAgICBpZiAoaS5ub3RpZnlQbHVnaW5zKFwiYmVmb3JlVG9vbHRpcERyYXdcIiwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlKSwge30sIHtcbiAgICAgICAgY2FuY2VsYWJsZTogITBcbiAgICAgIH0pKSA9PT0gITEpIHJldHVybjtcbiAgICAgIHQuZHJhdyhpLmN0eCksIGkubm90aWZ5UGx1Z2lucyhcImFmdGVyVG9vbHRpcERyYXdcIiwgZSk7XG4gICAgfVxuICB9LFxuICBhZnRlckV2ZW50OiBmdW5jdGlvbiBhZnRlckV2ZW50KGksIHQpIHtcbiAgICBpZiAoaS50b29sdGlwKSB7XG4gICAgICB2YXIgZSA9IHQucmVwbGF5O1xuICAgICAgaS50b29sdGlwLmhhbmRsZUV2ZW50KHQuZXZlbnQsIGUsIHQuaW5DaGFydEFyZWEpICYmICh0LmNoYW5nZWQgPSAhMCk7XG4gICAgfVxuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGVuYWJsZWQ6ICEwLFxuICAgIGV4dGVybmFsOiBudWxsLFxuICAgIHBvc2l0aW9uOiBcImF2ZXJhZ2VcIixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSgwLDAsMCwwLjgpXCIsXG4gICAgdGl0bGVDb2xvcjogXCIjZmZmXCIsXG4gICAgdGl0bGVGb250OiB7XG4gICAgICB3ZWlnaHQ6IFwiYm9sZFwiXG4gICAgfSxcbiAgICB0aXRsZVNwYWNpbmc6IDIsXG4gICAgdGl0bGVNYXJnaW5Cb3R0b206IDYsXG4gICAgdGl0bGVBbGlnbjogXCJsZWZ0XCIsXG4gICAgYm9keUNvbG9yOiBcIiNmZmZcIixcbiAgICBib2R5U3BhY2luZzogMixcbiAgICBib2R5Rm9udDoge30sXG4gICAgYm9keUFsaWduOiBcImxlZnRcIixcbiAgICBmb290ZXJDb2xvcjogXCIjZmZmXCIsXG4gICAgZm9vdGVyU3BhY2luZzogMixcbiAgICBmb290ZXJNYXJnaW5Ub3A6IDYsXG4gICAgZm9vdGVyRm9udDoge1xuICAgICAgd2VpZ2h0OiBcImJvbGRcIlxuICAgIH0sXG4gICAgZm9vdGVyQWxpZ246IFwibGVmdFwiLFxuICAgIHBhZGRpbmc6IDYsXG4gICAgY2FyZXRQYWRkaW5nOiAyLFxuICAgIGNhcmV0U2l6ZTogNSxcbiAgICBjb3JuZXJSYWRpdXM6IDYsXG4gICAgYm94SGVpZ2h0OiBmdW5jdGlvbiBib3hIZWlnaHQoaSwgdCkge1xuICAgICAgcmV0dXJuIHQuYm9keUZvbnQuc2l6ZTtcbiAgICB9LFxuICAgIGJveFdpZHRoOiBmdW5jdGlvbiBib3hXaWR0aChpLCB0KSB7XG4gICAgICByZXR1cm4gdC5ib2R5Rm9udC5zaXplO1xuICAgIH0sXG4gICAgbXVsdGlLZXlCYWNrZ3JvdW5kOiBcIiNmZmZcIixcbiAgICBkaXNwbGF5Q29sb3JzOiAhMCxcbiAgICBib3hQYWRkaW5nOiAwLFxuICAgIGJvcmRlckNvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiA0MDAsXG4gICAgICBlYXNpbmc6IFwiZWFzZU91dFF1YXJ0XCJcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgcHJvcGVydGllczogW1wieFwiLCBcInlcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcImNhcmV0WFwiLCBcImNhcmV0WVwiXVxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgZWFzaW5nOiBcImxpbmVhclwiLFxuICAgICAgICBkdXJhdGlvbjogMjAwXG4gICAgICB9XG4gICAgfSxcbiAgICBjYWxsYmFja3M6IHJvXG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBib2R5Rm9udDogXCJmb250XCIsXG4gICAgZm9vdGVyRm9udDogXCJmb250XCIsXG4gICAgdGl0bGVGb250OiBcImZvbnRcIlxuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiBmdW5jdGlvbiBfc2NyaXB0YWJsZShpKSB7XG4gICAgICByZXR1cm4gaSAhPT0gXCJmaWx0ZXJcIiAmJiBpICE9PSBcIml0ZW1Tb3J0XCIgJiYgaSAhPT0gXCJleHRlcm5hbFwiO1xuICAgIH0sXG4gICAgX2luZGV4YWJsZTogITEsXG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBfc2NyaXB0YWJsZTogITEsXG4gICAgICBfaW5kZXhhYmxlOiAhMVxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBfZmFsbGJhY2s6ICExXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBfZmFsbGJhY2s6IFwiYW5pbWF0aW9uXCJcbiAgICB9XG4gIH0sXG4gIGFkZGl0aW9uYWxPcHRpb25TY29wZXM6IFtcImludGVyYWN0aW9uXCJdXG59O1xudmFyIEljID0gZnVuY3Rpb24gSWMoaSwgdCwgZSwgcykge1xuICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IChlID0gaS5wdXNoKHQpIC0gMSwgcy51bnNoaWZ0KHtcbiAgICBpbmRleDogZSxcbiAgICBsYWJlbDogdFxuICB9KSkgOiBpc05hTih0KSAmJiAoZSA9IG51bGwpLCBlO1xufTtcbmZ1bmN0aW9uIHpjKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBpLmluZGV4T2YodCk7XG4gIGlmIChuID09PSAtMSkgcmV0dXJuIEljKGksIHQsIGUsIHMpO1xuICB2YXIgbyA9IGkubGFzdEluZGV4T2YodCk7XG4gIHJldHVybiBuICE9PSBvID8gZSA6IG47XG59XG52YXIgQmMgPSBmdW5jdGlvbiBCYyhpLCB0KSB7XG4gIHJldHVybiBpID09PSBudWxsID8gbnVsbCA6IFUoTWF0aC5yb3VuZChpKSwgMCwgdCk7XG59O1xuZnVuY3Rpb24gb24oaSkge1xuICB2YXIgdCA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gIHJldHVybiBpID49IDAgJiYgaSA8IHQubGVuZ3RoID8gdFtpXSA6IGk7XG59XG52YXIgVGkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9HdCkge1xuICBmdW5jdGlvbiBUaSh0KSB7XG4gICAgdmFyIF90aGlzMzM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRpKTtcbiAgICBfdGhpczMzID0gX2NhbGxTdXBlcih0aGlzLCBUaSwgW3RdKSwgX3RoaXMzMy5fc3RhcnRWYWx1ZSA9IHZvaWQgMCwgX3RoaXMzMy5fdmFsdWVSYW5nZSA9IDAsIF90aGlzMzMuX2FkZGVkTGFiZWxzID0gW107XG4gICAgcmV0dXJuIF90aGlzMzM7XG4gIH1cbiAgX2luaGVyaXRzKFRpLCBfR3QpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFRpLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9hZGRlZExhYmVscztcbiAgICAgIGlmIChlLmxlbmd0aCkge1xuICAgICAgICB2YXIgcyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgICAgIHZhciBfaXRlcmF0b3IzNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGUpLFxuICAgICAgICAgIF9zdGVwMzY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IzNi5zKCk7ICEoX3N0ZXAzNiA9IF9pdGVyYXRvcjM2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBfc3RlcDM2JHZhbHVlID0gX3N0ZXAzNi52YWx1ZSxcbiAgICAgICAgICAgICAgbiA9IF9zdGVwMzYkdmFsdWUuaW5kZXgsXG4gICAgICAgICAgICAgIG8gPSBfc3RlcDM2JHZhbHVlLmxhYmVsO1xuICAgICAgICAgICAgc1tuXSA9PT0gbyAmJiBzLnNwbGljZShuLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjM2LmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IzNi5mKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIF9zdXBlclByb3BHZXQoVGksIFwiaW5pdFwiLCB0aGlzLCAzKShbdF0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZSh0LCBlKSB7XG4gICAgICBpZiAoUih0KSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgcyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgICByZXR1cm4gZSA9IGlzRmluaXRlKGUpICYmIHNbZV0gPT09IHQgPyBlIDogemMocywgdCwgRChlLCB0KSwgdGhpcy5fYWRkZWRMYWJlbHMpLCBCYyhlLCBzLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXRlcm1pbmVEYXRhTGltaXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0VXNlckJvdW5kczIgPSB0aGlzLmdldFVzZXJCb3VuZHMoKSxcbiAgICAgICAgdCA9IF90aGlzJGdldFVzZXJCb3VuZHMyLm1pbkRlZmluZWQsXG4gICAgICAgIGUgPSBfdGhpcyRnZXRVc2VyQm91bmRzMi5tYXhEZWZpbmVkO1xuICAgICAgdmFyIF90aGlzJGdldE1pbk1heCA9IHRoaXMuZ2V0TWluTWF4KCEwKSxcbiAgICAgICAgcyA9IF90aGlzJGdldE1pbk1heC5taW4sXG4gICAgICAgIG4gPSBfdGhpcyRnZXRNaW5NYXgubWF4O1xuICAgICAgdGhpcy5vcHRpb25zLmJvdW5kcyA9PT0gXCJ0aWNrc1wiICYmICh0IHx8IChzID0gMCksIGUgfHwgKG4gPSB0aGlzLmdldExhYmVscygpLmxlbmd0aCAtIDEpKSwgdGhpcy5taW4gPSBzLCB0aGlzLm1heCA9IG47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkVGlja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRUaWNrcygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5taW4sXG4gICAgICAgIGUgPSB0aGlzLm1heCxcbiAgICAgICAgcyA9IHRoaXMub3B0aW9ucy5vZmZzZXQsXG4gICAgICAgIG4gPSBbXTtcbiAgICAgIHZhciBvID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICAgIG8gPSB0ID09PSAwICYmIGUgPT09IG8ubGVuZ3RoIC0gMSA/IG8gOiBvLnNsaWNlKHQsIGUgKyAxKSwgdGhpcy5fdmFsdWVSYW5nZSA9IE1hdGgubWF4KG8ubGVuZ3RoIC0gKHMgPyAwIDogMSksIDEpLCB0aGlzLl9zdGFydFZhbHVlID0gdGhpcy5taW4gLSAocyA/IDAuNSA6IDApO1xuICAgICAgZm9yICh2YXIgciA9IHQ7IHIgPD0gZTsgcisrKSBuLnB1c2goe1xuICAgICAgICB2YWx1ZTogclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGFiZWxGb3JWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbEZvclZhbHVlKHQpIHtcbiAgICAgIHJldHVybiBvbi5jYWxsKHRoaXMsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25maWd1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uZmlndXJlKCkge1xuICAgICAgX3N1cGVyUHJvcEdldChUaSwgXCJjb25maWd1cmVcIiwgdGhpcywgMykoW10pLCB0aGlzLmlzSG9yaXpvbnRhbCgpIHx8ICh0aGlzLl9yZXZlcnNlUGl4ZWxzID0gIXRoaXMuX3JldmVyc2VQaXhlbHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQaXhlbEZvclZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBpeGVsRm9yVmFsdWUodCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB0ICE9IFwibnVtYmVyXCIgJiYgKHQgPSB0aGlzLnBhcnNlKHQpKSwgdCA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh0IC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGl4ZWxGb3JUaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBpeGVsRm9yVGljayh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMudGlja3M7XG4gICAgICByZXR1cm4gdCA8IDAgfHwgdCA+IGUubGVuZ3RoIC0gMSA/IG51bGwgOiB0aGlzLmdldFBpeGVsRm9yVmFsdWUoZVt0XS52YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFZhbHVlRm9yUGl4ZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWVGb3JQaXhlbCh0KSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwodCkgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmFzZVBpeGVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2VQaXhlbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJvdHRvbTtcbiAgICB9XG4gIH1dKTtcbn0oR3QpO1xudyhUaSwgXCJpZFwiLCBcImNhdGVnb3J5XCIpLCB3KFRpLCBcImRlZmF1bHRzXCIsIHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogb25cbiAgfVxufSk7XG5mdW5jdGlvbiBIYyhpLCB0KSB7XG4gIHZhciBlID0gW10sXG4gICAgbiA9IGkuYm91bmRzLFxuICAgIG8gPSBpLnN0ZXAsXG4gICAgciA9IGkubWluLFxuICAgIGEgPSBpLm1heCxcbiAgICBsID0gaS5wcmVjaXNpb24sXG4gICAgYyA9IGkuY291bnQsXG4gICAgaCA9IGkubWF4VGlja3MsXG4gICAgZCA9IGkubWF4RGlnaXRzLFxuICAgIHUgPSBpLmluY2x1ZGVCb3VuZHMsXG4gICAgZiA9IG8gfHwgMSxcbiAgICBwID0gaCAtIDEsXG4gICAgZyA9IHQubWluLFxuICAgIG0gPSB0Lm1heCxcbiAgICBiID0gIVIociksXG4gICAgXyA9ICFSKGEpLFxuICAgIHYgPSAhUihjKSxcbiAgICB5ID0gKG0gLSBnKSAvIChkICsgMSk7XG4gIHZhciB4ID0gZXMoKG0gLSBnKSAvIHAgLyBmKSAqIGYsXG4gICAgTSxcbiAgICBTLFxuICAgIGssXG4gICAgUDtcbiAgaWYgKHggPCAxZS0xNCAmJiAhYiAmJiAhXykgcmV0dXJuIFt7XG4gICAgdmFsdWU6IGdcbiAgfSwge1xuICAgIHZhbHVlOiBtXG4gIH1dO1xuICBQID0gTWF0aC5jZWlsKG0gLyB4KSAtIE1hdGguZmxvb3IoZyAvIHgpLCBQID4gcCAmJiAoeCA9IGVzKFAgKiB4IC8gcCAvIGYpICogZiksIFIobCkgfHwgKE0gPSBNYXRoLnBvdygxMCwgbCksIHggPSBNYXRoLmNlaWwoeCAqIE0pIC8gTSksIG4gPT09IFwidGlja3NcIiA/IChTID0gTWF0aC5mbG9vcihnIC8geCkgKiB4LCBrID0gTWF0aC5jZWlsKG0gLyB4KSAqIHgpIDogKFMgPSBnLCBrID0gbSksIGIgJiYgXyAmJiBvICYmICRvKChhIC0gcikgLyBvLCB4IC8gMWUzKSA/IChQID0gTWF0aC5yb3VuZChNYXRoLm1pbigoYSAtIHIpIC8geCwgaCkpLCB4ID0gKGEgLSByKSAvIFAsIFMgPSByLCBrID0gYSkgOiB2ID8gKFMgPSBiID8gciA6IFMsIGsgPSBfID8gYSA6IGssIFAgPSBjIC0gMSwgeCA9IChrIC0gUykgLyBQKSA6IChQID0gKGsgLSBTKSAvIHgsIGNlKFAsIE1hdGgucm91bmQoUCksIHggLyAxZTMpID8gUCA9IE1hdGgucm91bmQoUCkgOiBQID0gTWF0aC5jZWlsKFApKTtcbiAgdmFyIEMgPSBNYXRoLm1heChpcyh4KSwgaXMoUykpO1xuICBNID0gTWF0aC5wb3coMTAsIFIobCkgPyBDIDogbCksIFMgPSBNYXRoLnJvdW5kKFMgKiBNKSAvIE0sIGsgPSBNYXRoLnJvdW5kKGsgKiBNKSAvIE07XG4gIHZhciBPID0gMDtcbiAgZm9yIChiICYmICh1ICYmIFMgIT09IHIgPyAoZS5wdXNoKHtcbiAgICB2YWx1ZTogclxuICB9KSwgUyA8IHIgJiYgTysrLCBjZShNYXRoLnJvdW5kKChTICsgTyAqIHgpICogTSkgLyBNLCByLCBybihyLCB5LCBpKSkgJiYgTysrKSA6IFMgPCByICYmIE8rKyk7IE8gPCBQOyArK08pIHtcbiAgICB2YXIgQSA9IE1hdGgucm91bmQoKFMgKyBPICogeCkgKiBNKSAvIE07XG4gICAgaWYgKF8gJiYgQSA+IGEpIGJyZWFrO1xuICAgIGUucHVzaCh7XG4gICAgICB2YWx1ZTogQVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBfICYmIHUgJiYgayAhPT0gYSA/IGUubGVuZ3RoICYmIGNlKGVbZS5sZW5ndGggLSAxXS52YWx1ZSwgYSwgcm4oYSwgeSwgaSkpID8gZVtlLmxlbmd0aCAtIDFdLnZhbHVlID0gYSA6IGUucHVzaCh7XG4gICAgdmFsdWU6IGFcbiAgfSkgOiAoIV8gfHwgayA9PT0gYSkgJiYgZS5wdXNoKHtcbiAgICB2YWx1ZToga1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIHJuKGksIHQsIF9yZWYxMSkge1xuICB2YXIgZSA9IF9yZWYxMS5ob3Jpem9udGFsLFxuICAgIHMgPSBfcmVmMTEubWluUm90YXRpb247XG4gIHZhciBuID0gYnQocyksXG4gICAgbyA9IChlID8gTWF0aC5zaW4obikgOiBNYXRoLmNvcyhuKSkgfHwgMWUtMyxcbiAgICByID0gMC43NSAqIHQgKiAoXCJcIiArIGkpLmxlbmd0aDtcbiAgcmV0dXJuIE1hdGgubWluKHQgLyBvLCByKTtcbn1cbnZhciBXYyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0d0Mikge1xuICBmdW5jdGlvbiBXYyh0KSB7XG4gICAgdmFyIF90aGlzMzQ7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdjKTtcbiAgICBfdGhpczM0ID0gX2NhbGxTdXBlcih0aGlzLCBXYywgW3RdKSwgX3RoaXMzNC5zdGFydCA9IHZvaWQgMCwgX3RoaXMzNC5lbmQgPSB2b2lkIDAsIF90aGlzMzQuX3N0YXJ0VmFsdWUgPSB2b2lkIDAsIF90aGlzMzQuX2VuZFZhbHVlID0gdm9pZCAwLCBfdGhpczM0Ll92YWx1ZVJhbmdlID0gMDtcbiAgICByZXR1cm4gX3RoaXMzNDtcbiAgfVxuICBfaW5oZXJpdHMoV2MsIF9HdDIpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFdjLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZSh0LCBlKSB7XG4gICAgICByZXR1cm4gUih0KSB8fCAodHlwZW9mIHQgPT0gXCJudW1iZXJcIiB8fCB0IGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhaXNGaW5pdGUoK3QpID8gbnVsbCA6ICt0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVUaWNrUmFuZ2VPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMub3B0aW9ucy5iZWdpbkF0WmVybyxcbiAgICAgICAgX3RoaXMkZ2V0VXNlckJvdW5kczMgPSB0aGlzLmdldFVzZXJCb3VuZHMoKSxcbiAgICAgICAgZSA9IF90aGlzJGdldFVzZXJCb3VuZHMzLm1pbkRlZmluZWQsXG4gICAgICAgIHMgPSBfdGhpcyRnZXRVc2VyQm91bmRzMy5tYXhEZWZpbmVkO1xuICAgICAgdmFyIG4gPSB0aGlzLm1pbixcbiAgICAgICAgbyA9IHRoaXMubWF4O1xuICAgICAgdmFyIHIgPSBmdW5jdGlvbiByKGwpIHtcbiAgICAgICAgICByZXR1cm4gbiA9IGUgPyBuIDogbDtcbiAgICAgICAgfSxcbiAgICAgICAgYSA9IGZ1bmN0aW9uIGEobCkge1xuICAgICAgICAgIHJldHVybiBvID0gcyA/IG8gOiBsO1xuICAgICAgICB9O1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgdmFyIGwgPSBsdChuKSxcbiAgICAgICAgICBjID0gbHQobyk7XG4gICAgICAgIGwgPCAwICYmIGMgPCAwID8gYSgwKSA6IGwgPiAwICYmIGMgPiAwICYmIHIoMCk7XG4gICAgICB9XG4gICAgICBpZiAobiA9PT0gbykge1xuICAgICAgICB2YXIgX2w1ID0gbyA9PT0gMCA/IDEgOiBNYXRoLmFicyhvICogMC4wNSk7XG4gICAgICAgIGEobyArIF9sNSksIHQgfHwgcihuIC0gX2w1KTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWluID0gbiwgdGhpcy5tYXggPSBvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUaWNrTGltaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGlja0xpbWl0KCkge1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgICB2YXIgZSA9IHQubWF4VGlja3NMaW1pdCxcbiAgICAgICAgcyA9IHQuc3RlcFNpemUsXG4gICAgICAgIG47XG4gICAgICByZXR1cm4gcyA/IChuID0gTWF0aC5jZWlsKHRoaXMubWF4IC8gcykgLSBNYXRoLmZsb29yKHRoaXMubWluIC8gcykgKyAxLCBuID4gMWUzICYmIChjb25zb2xlLndhcm4oXCJzY2FsZXMuXCIuY29uY2F0KHRoaXMuaWQsIFwiLnRpY2tzLnN0ZXBTaXplOiBcIikuY29uY2F0KHMsIFwiIHdvdWxkIHJlc3VsdCBnZW5lcmF0aW5nIHVwIHRvIFwiKS5jb25jYXQobiwgXCIgdGlja3MuIExpbWl0aW5nIHRvIDEwMDAuXCIpKSwgbiA9IDFlMykpIDogKG4gPSB0aGlzLmNvbXB1dGVUaWNrTGltaXQoKSwgZSA9IGUgfHwgMTEpLCBlICYmIChuID0gTWF0aC5taW4oZSwgbikpLCBuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wdXRlVGlja0xpbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWlsZFRpY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkVGlja3MoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZSA9IHQudGlja3M7XG4gICAgICB2YXIgcyA9IHRoaXMuZ2V0VGlja0xpbWl0KCk7XG4gICAgICBzID0gTWF0aC5tYXgoMiwgcyk7XG4gICAgICB2YXIgbiA9IHtcbiAgICAgICAgICBtYXhUaWNrczogcyxcbiAgICAgICAgICBib3VuZHM6IHQuYm91bmRzLFxuICAgICAgICAgIG1pbjogdC5taW4sXG4gICAgICAgICAgbWF4OiB0Lm1heCxcbiAgICAgICAgICBwcmVjaXNpb246IGUucHJlY2lzaW9uLFxuICAgICAgICAgIHN0ZXA6IGUuc3RlcFNpemUsXG4gICAgICAgICAgY291bnQ6IGUuY291bnQsXG4gICAgICAgICAgbWF4RGlnaXRzOiB0aGlzLl9tYXhEaWdpdHMoKSxcbiAgICAgICAgICBob3Jpem9udGFsOiB0aGlzLmlzSG9yaXpvbnRhbCgpLFxuICAgICAgICAgIG1pblJvdGF0aW9uOiBlLm1pblJvdGF0aW9uIHx8IDAsXG4gICAgICAgICAgaW5jbHVkZUJvdW5kczogZS5pbmNsdWRlQm91bmRzICE9PSAhMVxuICAgICAgICB9LFxuICAgICAgICBvID0gdGhpcy5fcmFuZ2UgfHwgdGhpcyxcbiAgICAgICAgciA9IEhjKG4sIG8pO1xuICAgICAgcmV0dXJuIHQuYm91bmRzID09PSBcInRpY2tzXCIgJiYgWW8ociwgdGhpcywgXCJ2YWx1ZVwiKSwgdC5yZXZlcnNlID8gKHIucmV2ZXJzZSgpLCB0aGlzLnN0YXJ0ID0gdGhpcy5tYXgsIHRoaXMuZW5kID0gdGhpcy5taW4pIDogKHRoaXMuc3RhcnQgPSB0aGlzLm1pbiwgdGhpcy5lbmQgPSB0aGlzLm1heCksIHI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbmZpZ3VyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25maWd1cmUoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMudGlja3M7XG4gICAgICB2YXIgZSA9IHRoaXMubWluLFxuICAgICAgICBzID0gdGhpcy5tYXg7XG4gICAgICBpZiAoX3N1cGVyUHJvcEdldChXYywgXCJjb25maWd1cmVcIiwgdGhpcywgMykoW10pLCB0aGlzLm9wdGlvbnMub2Zmc2V0ICYmIHQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuID0gKHMgLSBlKSAvIE1hdGgubWF4KHQubGVuZ3RoIC0gMSwgMSkgLyAyO1xuICAgICAgICBlIC09IG4sIHMgKz0gbjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBlLCB0aGlzLl9lbmRWYWx1ZSA9IHMsIHRoaXMuX3ZhbHVlUmFuZ2UgPSBzIC0gZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGFiZWxGb3JWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbEZvclZhbHVlKHQpIHtcbiAgICAgIHJldHVybiBIaSh0LCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgICB9XG4gIH1dKTtcbn0oR3QpO1xudmFyIEFpID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfV2MpIHtcbiAgZnVuY3Rpb24gQWkoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFpKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBBaSwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoQWksIF9XYyk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQWksIFt7XG4gICAga2V5OiBcImRldGVybWluZURhdGFMaW1pdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICAgIHZhciBfdGhpcyRnZXRNaW5NYXgyID0gdGhpcy5nZXRNaW5NYXgoITApLFxuICAgICAgICB0ID0gX3RoaXMkZ2V0TWluTWF4Mi5taW4sXG4gICAgICAgIGUgPSBfdGhpcyRnZXRNaW5NYXgyLm1heDtcbiAgICAgIHRoaXMubWluID0gcSh0KSA/IHQgOiAwLCB0aGlzLm1heCA9IHEoZSkgPyBlIDogMSwgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXB1dGVUaWNrTGltaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5pc0hvcml6b250YWwoKSxcbiAgICAgICAgZSA9IHQgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQsXG4gICAgICAgIHMgPSBidCh0aGlzLm9wdGlvbnMudGlja3MubWluUm90YXRpb24pLFxuICAgICAgICBuID0gKHQgPyBNYXRoLnNpbihzKSA6IE1hdGguY29zKHMpKSB8fCAxZS0zLFxuICAgICAgICBvID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKTtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwoZSAvIE1hdGgubWluKDQwLCBvLmxpbmVIZWlnaHQgLyBuKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBpeGVsRm9yVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGl4ZWxGb3JWYWx1ZSh0KSB7XG4gICAgICByZXR1cm4gdCA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh0IC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmFsdWVGb3JQaXhlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZUZvclBpeGVsKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwodCkgKiB0aGlzLl92YWx1ZVJhbmdlO1xuICAgIH1cbiAgfV0pO1xufShXYyk7XG53KEFpLCBcImlkXCIsIFwibGluZWFyXCIpLCB3KEFpLCBcImRlZmF1bHRzXCIsIHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogRG4uZm9ybWF0dGVycy5udW1lcmljXG4gIH1cbn0pO1xudmFyIGlpID0ge1xuICAgIG1pbGxpc2Vjb25kOiB7XG4gICAgICBjb21tb246ICEwLFxuICAgICAgc2l6ZTogMSxcbiAgICAgIHN0ZXBzOiAxZTNcbiAgICB9LFxuICAgIHNlY29uZDoge1xuICAgICAgY29tbW9uOiAhMCxcbiAgICAgIHNpemU6IDFlMyxcbiAgICAgIHN0ZXBzOiA2MFxuICAgIH0sXG4gICAgbWludXRlOiB7XG4gICAgICBjb21tb246ICEwLFxuICAgICAgc2l6ZTogNmU0LFxuICAgICAgc3RlcHM6IDYwXG4gICAgfSxcbiAgICBob3VyOiB7XG4gICAgICBjb21tb246ICEwLFxuICAgICAgc2l6ZTogMzZlNSxcbiAgICAgIHN0ZXBzOiAyNFxuICAgIH0sXG4gICAgZGF5OiB7XG4gICAgICBjb21tb246ICEwLFxuICAgICAgc2l6ZTogODY0ZTUsXG4gICAgICBzdGVwczogMzBcbiAgICB9LFxuICAgIHdlZWs6IHtcbiAgICAgIGNvbW1vbjogITEsXG4gICAgICBzaXplOiA2MDQ4ZTUsXG4gICAgICBzdGVwczogNFxuICAgIH0sXG4gICAgbW9udGg6IHtcbiAgICAgIGNvbW1vbjogITAsXG4gICAgICBzaXplOiAyNjI4ZTYsXG4gICAgICBzdGVwczogMTJcbiAgICB9LFxuICAgIHF1YXJ0ZXI6IHtcbiAgICAgIGNvbW1vbjogITEsXG4gICAgICBzaXplOiA3ODg0ZTYsXG4gICAgICBzdGVwczogNFxuICAgIH0sXG4gICAgeWVhcjoge1xuICAgICAgY29tbW9uOiAhMCxcbiAgICAgIHNpemU6IDMxNTRlN1xuICAgIH1cbiAgfSxcbiAgRyA9IC8qIEBfX1BVUkVfXyAqL09iamVjdC5rZXlzKGlpKTtcbmZ1bmN0aW9uIGFuKGksIHQpIHtcbiAgcmV0dXJuIGkgLSB0O1xufVxuZnVuY3Rpb24gbG4oaSwgdCkge1xuICBpZiAoUih0KSkgcmV0dXJuIG51bGw7XG4gIHZhciBlID0gaS5fYWRhcHRlcixcbiAgICBfaSRfcGFyc2VPcHRzID0gaS5fcGFyc2VPcHRzLFxuICAgIHMgPSBfaSRfcGFyc2VPcHRzLnBhcnNlcixcbiAgICBuID0gX2kkX3BhcnNlT3B0cy5yb3VuZCxcbiAgICBvID0gX2kkX3BhcnNlT3B0cy5pc29XZWVrZGF5O1xuICB2YXIgciA9IHQ7XG4gIHJldHVybiB0eXBlb2YgcyA9PSBcImZ1bmN0aW9uXCIgJiYgKHIgPSBzKHIpKSwgcShyKSB8fCAociA9IHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyBlLnBhcnNlKHIsIHMpIDogZS5wYXJzZShyKSksIHIgPT09IG51bGwgPyBudWxsIDogKG4gJiYgKHIgPSBuID09PSBcIndlZWtcIiAmJiAoWHQobykgfHwgbyA9PT0gITApID8gZS5zdGFydE9mKHIsIFwiaXNvV2Vla1wiLCBvKSA6IGUuc3RhcnRPZihyLCBuKSksICtyKTtcbn1cbmZ1bmN0aW9uIGNuKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBHLmxlbmd0aDtcbiAgZm9yICh2YXIgbyA9IEcuaW5kZXhPZihpKTsgbyA8IG4gLSAxOyArK28pIHtcbiAgICB2YXIgciA9IGlpW0dbb11dLFxuICAgICAgYSA9IHIuc3RlcHMgPyByLnN0ZXBzIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgaWYgKHIuY29tbW9uICYmIE1hdGguY2VpbCgoZSAtIHQpIC8gKGEgKiByLnNpemUpKSA8PSBzKSByZXR1cm4gR1tvXTtcbiAgfVxuICByZXR1cm4gR1tuIC0gMV07XG59XG5mdW5jdGlvbiBOYyhpLCB0LCBlLCBzLCBuKSB7XG4gIGZvciAodmFyIG8gPSBHLmxlbmd0aCAtIDE7IG8gPj0gRy5pbmRleE9mKGUpOyBvLS0pIHtcbiAgICB2YXIgciA9IEdbb107XG4gICAgaWYgKGlpW3JdLmNvbW1vbiAmJiBpLl9hZGFwdGVyLmRpZmYobiwgcywgcikgPj0gdCAtIDEpIHJldHVybiByO1xuICB9XG4gIHJldHVybiBHW2UgPyBHLmluZGV4T2YoZSkgOiAwXTtcbn1cbmZ1bmN0aW9uIFZjKGkpIHtcbiAgZm9yICh2YXIgdCA9IEcuaW5kZXhPZihpKSArIDEsIGUgPSBHLmxlbmd0aDsgdCA8IGU7ICsrdCkgaWYgKGlpW0dbdF1dLmNvbW1vbikgcmV0dXJuIEdbdF07XG59XG5mdW5jdGlvbiBobihpLCB0LCBlKSB7XG4gIGlmICghZSkgaVt0XSA9ICEwO2Vsc2UgaWYgKGUubGVuZ3RoKSB7XG4gICAgdmFyIF9JaSA9IElpKGUsIHQpLFxuICAgICAgcyA9IF9JaS5sbyxcbiAgICAgIG4gPSBfSWkuaGksXG4gICAgICBvID0gZVtzXSA+PSB0ID8gZVtzXSA6IGVbbl07XG4gICAgaVtvXSA9ICEwO1xuICB9XG59XG5mdW5jdGlvbiBqYyhpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gaS5fYWRhcHRlcixcbiAgICBvID0gK24uc3RhcnRPZih0WzBdLnZhbHVlLCBzKSxcbiAgICByID0gdFt0Lmxlbmd0aCAtIDFdLnZhbHVlO1xuICB2YXIgYSwgbDtcbiAgZm9yIChhID0gbzsgYSA8PSByOyBhID0gK24uYWRkKGEsIDEsIHMpKSBsID0gZVthXSwgbCA+PSAwICYmICh0W2xdLm1ham9yID0gITApO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIGRuKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBbXSxcbiAgICBuID0ge30sXG4gICAgbyA9IHQubGVuZ3RoO1xuICB2YXIgciwgYTtcbiAgZm9yIChyID0gMDsgciA8IG87ICsrcikgYSA9IHRbcl0sIG5bYV0gPSByLCBzLnB1c2goe1xuICAgIHZhbHVlOiBhLFxuICAgIG1ham9yOiAhMVxuICB9KTtcbiAgcmV0dXJuIG8gPT09IDAgfHwgIWUgPyBzIDogamMoaSwgcywgbiwgZSk7XG59XG52YXIgR2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9HdDMpIHtcbiAgZnVuY3Rpb24gR2UodCkge1xuICAgIHZhciBfdGhpczM1O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHZSk7XG4gICAgX3RoaXMzNSA9IF9jYWxsU3VwZXIodGhpcywgR2UsIFt0XSksIF90aGlzMzUuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH0sIF90aGlzMzUuX3VuaXQgPSBcImRheVwiLCBfdGhpczM1Ll9tYWpvclVuaXQgPSB2b2lkIDAsIF90aGlzMzUuX29mZnNldHMgPSB7fSwgX3RoaXMzNS5fbm9ybWFsaXplZCA9ICExLCBfdGhpczM1Ll9wYXJzZU9wdHMgPSB2b2lkIDA7XG4gICAgcmV0dXJuIF90aGlzMzU7XG4gIH1cbiAgX2luaGVyaXRzKEdlLCBfR3QzKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhHZSwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KHQpIHtcbiAgICAgIHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBzID0gdC50aW1lIHx8ICh0LnRpbWUgPSB7fSksXG4gICAgICAgIG4gPSB0aGlzLl9hZGFwdGVyID0gbmV3IHdhLl9kYXRlKHQuYWRhcHRlcnMuZGF0ZSk7XG4gICAgICBuLmluaXQoZSksIGxlKHMuZGlzcGxheUZvcm1hdHMsIG4uZm9ybWF0cygpKSwgdGhpcy5fcGFyc2VPcHRzID0ge1xuICAgICAgICBwYXJzZXI6IHMucGFyc2VyLFxuICAgICAgICByb3VuZDogcy5yb3VuZCxcbiAgICAgICAgaXNvV2Vla2RheTogcy5pc29XZWVrZGF5XG4gICAgICB9LCBfc3VwZXJQcm9wR2V0KEdlLCBcImluaXRcIiwgdGhpcywgMykoW3RdKSwgdGhpcy5fbm9ybWFsaXplZCA9IGUubm9ybWFsaXplZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UodCwgZSkge1xuICAgICAgcmV0dXJuIHQgPT09IHZvaWQgMCA/IG51bGwgOiBsbih0aGlzLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmVmb3JlTGF5b3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZm9yZUxheW91dCgpIHtcbiAgICAgIF9zdXBlclByb3BHZXQoR2UsIFwiYmVmb3JlTGF5b3V0XCIsIHRoaXMsIDMpKFtdKSwgdGhpcy5fY2FjaGUgPSB7XG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBsYWJlbHM6IFtdLFxuICAgICAgICBhbGw6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXRlcm1pbmVEYXRhTGltaXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZSA9IHRoaXMuX2FkYXB0ZXIsXG4gICAgICAgIHMgPSB0LnRpbWUudW5pdCB8fCBcImRheVwiO1xuICAgICAgdmFyIF90aGlzJGdldFVzZXJCb3VuZHM0ID0gdGhpcy5nZXRVc2VyQm91bmRzKCksXG4gICAgICAgIG4gPSBfdGhpcyRnZXRVc2VyQm91bmRzNC5taW4sXG4gICAgICAgIG8gPSBfdGhpcyRnZXRVc2VyQm91bmRzNC5tYXgsXG4gICAgICAgIHIgPSBfdGhpcyRnZXRVc2VyQm91bmRzNC5taW5EZWZpbmVkLFxuICAgICAgICBhID0gX3RoaXMkZ2V0VXNlckJvdW5kczQubWF4RGVmaW5lZDtcbiAgICAgIGZ1bmN0aW9uIGwoYykge1xuICAgICAgICAhciAmJiAhaXNOYU4oYy5taW4pICYmIChuID0gTWF0aC5taW4obiwgYy5taW4pKSwgIWEgJiYgIWlzTmFOKGMubWF4KSAmJiAobyA9IE1hdGgubWF4KG8sIGMubWF4KSk7XG4gICAgICB9XG4gICAgICAoIXIgfHwgIWEpICYmIChsKHRoaXMuX2dldExhYmVsQm91bmRzKCkpLCAodC5ib3VuZHMgIT09IFwidGlja3NcIiB8fCB0LnRpY2tzLnNvdXJjZSAhPT0gXCJsYWJlbHNcIikgJiYgbCh0aGlzLmdldE1pbk1heCghMSkpKSwgbiA9IHEobikgJiYgIWlzTmFOKG4pID8gbiA6ICtlLnN0YXJ0T2YoRGF0ZS5ub3coKSwgcyksIG8gPSBxKG8pICYmICFpc05hTihvKSA/IG8gOiArZS5lbmRPZihEYXRlLm5vdygpLCBzKSArIDEsIHRoaXMubWluID0gTWF0aC5taW4obiwgbyAtIDEpLCB0aGlzLm1heCA9IE1hdGgubWF4KG4gKyAxLCBvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldExhYmVsQm91bmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRMYWJlbEJvdW5kcygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICAgIHZhciBlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICBzID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgcmV0dXJuIHQubGVuZ3RoICYmIChlID0gdFswXSwgcyA9IHRbdC5sZW5ndGggLSAxXSksIHtcbiAgICAgICAgbWluOiBlLFxuICAgICAgICBtYXg6IHNcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkVGlja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRUaWNrcygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBlID0gdC50aW1lLFxuICAgICAgICBzID0gdC50aWNrcyxcbiAgICAgICAgbiA9IHMuc291cmNlID09PSBcImxhYmVsc1wiID8gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKSA6IHRoaXMuX2dlbmVyYXRlKCk7XG4gICAgICB0LmJvdW5kcyA9PT0gXCJ0aWNrc1wiICYmIG4ubGVuZ3RoICYmICh0aGlzLm1pbiA9IHRoaXMuX3VzZXJNaW4gfHwgblswXSwgdGhpcy5tYXggPSB0aGlzLl91c2VyTWF4IHx8IG5bbi5sZW5ndGggLSAxXSk7XG4gICAgICB2YXIgbyA9IHRoaXMubWluLFxuICAgICAgICByID0gdGhpcy5tYXgsXG4gICAgICAgIGEgPSBHbyhuLCBvLCByKTtcbiAgICAgIHJldHVybiB0aGlzLl91bml0ID0gZS51bml0IHx8IChzLmF1dG9Ta2lwID8gY24oZS5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobykpIDogTmModGhpcywgYS5sZW5ndGgsIGUubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4KSksIHRoaXMuX21ham9yVW5pdCA9ICFzLm1ham9yLmVuYWJsZWQgfHwgdGhpcy5fdW5pdCA9PT0gXCJ5ZWFyXCIgPyB2b2lkIDAgOiBWYyh0aGlzLl91bml0KSwgdGhpcy5pbml0T2Zmc2V0cyhuKSwgdC5yZXZlcnNlICYmIGEucmV2ZXJzZSgpLCBkbih0aGlzLCBhLCB0aGlzLl9tYWpvclVuaXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZnRlckF1dG9Ta2lwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFmdGVyQXV0b1NraXAoKSB7XG4gICAgICB0aGlzLm9wdGlvbnMub2Zmc2V0QWZ0ZXJBdXRvc2tpcCAmJiB0aGlzLmluaXRPZmZzZXRzKHRoaXMudGlja3MubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiArdC52YWx1ZTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdE9mZnNldHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdE9mZnNldHMoKSB7XG4gICAgICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgICB2YXIgZSA9IDAsXG4gICAgICAgIHMgPSAwLFxuICAgICAgICBuLFxuICAgICAgICBvO1xuICAgICAgdGhpcy5vcHRpb25zLm9mZnNldCAmJiB0Lmxlbmd0aCAmJiAobiA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRbMF0pLCB0Lmxlbmd0aCA9PT0gMSA/IGUgPSAxIC0gbiA6IGUgPSAodGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodFsxXSkgLSBuKSAvIDIsIG8gPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0W3QubGVuZ3RoIC0gMV0pLCB0Lmxlbmd0aCA9PT0gMSA/IHMgPSBvIDogcyA9IChvIC0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodFt0Lmxlbmd0aCAtIDJdKSkgLyAyKTtcbiAgICAgIHZhciByID0gdC5sZW5ndGggPCAzID8gMC41IDogMC4yNTtcbiAgICAgIGUgPSBVKGUsIDAsIHIpLCBzID0gVShzLCAwLCByKSwgdGhpcy5fb2Zmc2V0cyA9IHtcbiAgICAgICAgc3RhcnQ6IGUsXG4gICAgICAgIGVuZDogcyxcbiAgICAgICAgZmFjdG9yOiAxIC8gKGUgKyAxICsgcylcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZW5lcmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGUoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2FkYXB0ZXIsXG4gICAgICAgIGUgPSB0aGlzLm1pbixcbiAgICAgICAgcyA9IHRoaXMubWF4LFxuICAgICAgICBuID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBvID0gbi50aW1lLFxuICAgICAgICByID0gby51bml0IHx8IGNuKG8ubWluVW5pdCwgZSwgcywgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShlKSksXG4gICAgICAgIGEgPSBEKG4udGlja3Muc3RlcFNpemUsIDEpLFxuICAgICAgICBsID0gciA9PT0gXCJ3ZWVrXCIgPyBvLmlzb1dlZWtkYXkgOiAhMSxcbiAgICAgICAgYyA9IFh0KGwpIHx8IGwgPT09ICEwLFxuICAgICAgICBoID0ge307XG4gICAgICB2YXIgZCA9IGUsXG4gICAgICAgIHUsXG4gICAgICAgIGY7XG4gICAgICBpZiAoYyAmJiAoZCA9ICt0LnN0YXJ0T2YoZCwgXCJpc29XZWVrXCIsIGwpKSwgZCA9ICt0LnN0YXJ0T2YoZCwgYyA/IFwiZGF5XCIgOiByKSwgdC5kaWZmKHMsIGUsIHIpID4gMWU1ICogYSkgdGhyb3cgbmV3IEVycm9yKGUgKyBcIiBhbmQgXCIgKyBzICsgXCIgYXJlIHRvbyBmYXIgYXBhcnQgd2l0aCBzdGVwU2l6ZSBvZiBcIiArIGEgKyBcIiBcIiArIHIpO1xuICAgICAgdmFyIHAgPSBuLnRpY2tzLnNvdXJjZSA9PT0gXCJkYXRhXCIgJiYgdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgICAgZm9yICh1ID0gZCwgZiA9IDA7IHUgPCBzOyB1ID0gK3QuYWRkKHUsIGEsIHIpLCBmKyspIGhuKGgsIHUsIHApO1xuICAgICAgcmV0dXJuICh1ID09PSBzIHx8IG4uYm91bmRzID09PSBcInRpY2tzXCIgfHwgZiA9PT0gMSkgJiYgaG4oaCwgdSwgcCksIE9iamVjdC5rZXlzKGgpLnNvcnQoYW4pLm1hcChmdW5jdGlvbiAoZykge1xuICAgICAgICByZXR1cm4gK2c7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGFiZWxGb3JWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbEZvclZhbHVlKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fYWRhcHRlcixcbiAgICAgICAgcyA9IHRoaXMub3B0aW9ucy50aW1lO1xuICAgICAgcmV0dXJuIHMudG9vbHRpcEZvcm1hdCA/IGUuZm9ybWF0KHQsIHMudG9vbHRpcEZvcm1hdCkgOiBlLmZvcm1hdCh0LCBzLmRpc3BsYXlGb3JtYXRzLmRhdGV0aW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdCh0LCBlKSB7XG4gICAgICB2YXIgbiA9IHRoaXMub3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzLFxuICAgICAgICBvID0gdGhpcy5fdW5pdCxcbiAgICAgICAgciA9IGUgfHwgbltvXTtcbiAgICAgIHJldHVybiB0aGlzLl9hZGFwdGVyLmZvcm1hdCh0LCByKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3RpY2tGb3JtYXRGdW5jdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdGlja0Zvcm1hdEZ1bmN0aW9uKHQsIGUsIHMsIG4pIHtcbiAgICAgIHZhciBvID0gdGhpcy5vcHRpb25zLFxuICAgICAgICByID0gby50aWNrcy5jYWxsYmFjaztcbiAgICAgIGlmIChyKSByZXR1cm4gSShyLCBbdCwgZSwgc10sIHRoaXMpO1xuICAgICAgdmFyIGEgPSBvLnRpbWUuZGlzcGxheUZvcm1hdHMsXG4gICAgICAgIGwgPSB0aGlzLl91bml0LFxuICAgICAgICBjID0gdGhpcy5fbWFqb3JVbml0LFxuICAgICAgICBoID0gbCAmJiBhW2xdLFxuICAgICAgICBkID0gYyAmJiBhW2NdLFxuICAgICAgICB1ID0gc1tlXSxcbiAgICAgICAgZiA9IGMgJiYgZCAmJiB1ICYmIHUubWFqb3I7XG4gICAgICByZXR1cm4gdGhpcy5fYWRhcHRlci5mb3JtYXQodCwgbiB8fCAoZiA/IGQgOiBoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlVGlja0xhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZVRpY2tMYWJlbHModCkge1xuICAgICAgdmFyIGUsIHMsIG47XG4gICAgICBmb3IgKGUgPSAwLCBzID0gdC5sZW5ndGg7IGUgPCBzOyArK2UpIG4gPSB0W2VdLCBuLmxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKG4udmFsdWUsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREZWNpbWFsRm9yVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVjaW1hbEZvclZhbHVlKHQpIHtcbiAgICAgIHJldHVybiB0ID09PSBudWxsID8gTmFOIDogKHQgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBpeGVsRm9yVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGl4ZWxGb3JWYWx1ZSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX29mZnNldHMsXG4gICAgICAgIHMgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0KTtcbiAgICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgoZS5zdGFydCArIHMpICogZS5mYWN0b3IpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWYWx1ZUZvclBpeGVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlRm9yUGl4ZWwodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9vZmZzZXRzLFxuICAgICAgICBzID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwodCkgLyBlLmZhY3RvciAtIGUuZW5kO1xuICAgICAgcmV0dXJuIHRoaXMubWluICsgcyAqICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldExhYmVsU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TGFiZWxTaXplKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5vcHRpb25zLnRpY2tzLFxuICAgICAgICBzID0gdGhpcy5jdHgubWVhc3VyZVRleHQodCkud2lkdGgsXG4gICAgICAgIG4gPSBidCh0aGlzLmlzSG9yaXpvbnRhbCgpID8gZS5tYXhSb3RhdGlvbiA6IGUubWluUm90YXRpb24pLFxuICAgICAgICBvID0gTWF0aC5jb3MobiksXG4gICAgICAgIHIgPSBNYXRoLnNpbihuKSxcbiAgICAgICAgYSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkuc2l6ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHc6IHMgKiBvICsgYSAqIHIsXG4gICAgICAgIGg6IHMgKiByICsgYSAqIG9cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRMYWJlbENhcGFjaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRMYWJlbENhcGFjaXR5KHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5vcHRpb25zLnRpbWUsXG4gICAgICAgIHMgPSBlLmRpc3BsYXlGb3JtYXRzLFxuICAgICAgICBuID0gc1tlLnVuaXRdIHx8IHMubWlsbGlzZWNvbmQsXG4gICAgICAgIG8gPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24odCwgMCwgZG4odGhpcywgW3RdLCB0aGlzLl9tYWpvclVuaXQpLCBuKSxcbiAgICAgICAgciA9IHRoaXMuX2dldExhYmVsU2l6ZShvKSxcbiAgICAgICAgYSA9IE1hdGguZmxvb3IodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggLyByLncgOiB0aGlzLmhlaWdodCAvIHIuaCkgLSAxO1xuICAgICAgcmV0dXJuIGEgPiAwID8gYSA6IDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERhdGFUaW1lc3RhbXBzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERhdGFUaW1lc3RhbXBzKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9jYWNoZS5kYXRhIHx8IFtdLFxuICAgICAgICBlLFxuICAgICAgICBzO1xuICAgICAgaWYgKHQubGVuZ3RoKSByZXR1cm4gdDtcbiAgICAgIHZhciBuID0gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuICAgICAgaWYgKHRoaXMuX25vcm1hbGl6ZWQgJiYgbi5sZW5ndGgpIHJldHVybiB0aGlzLl9jYWNoZS5kYXRhID0gblswXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKTtcbiAgICAgIGZvciAoZSA9IDAsIHMgPSBuLmxlbmd0aDsgZSA8IHM7ICsrZSkgdCA9IHQuY29uY2F0KG5bZV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlLmRhdGEgPSB0aGlzLm5vcm1hbGl6ZSh0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGFiZWxUaW1lc3RhbXBzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhYmVsVGltZXN0YW1wcygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY2FjaGUubGFiZWxzIHx8IFtdO1xuICAgICAgdmFyIGUsIHM7XG4gICAgICBpZiAodC5sZW5ndGgpIHJldHVybiB0O1xuICAgICAgdmFyIG4gPSB0aGlzLmdldExhYmVscygpO1xuICAgICAgZm9yIChlID0gMCwgcyA9IG4ubGVuZ3RoOyBlIDwgczsgKytlKSB0LnB1c2gobG4odGhpcywgbltlXSkpO1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlLmxhYmVscyA9IHRoaXMuX25vcm1hbGl6ZWQgPyB0IDogdGhpcy5ub3JtYWxpemUodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vcm1hbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemUodCkge1xuICAgICAgcmV0dXJuIE1uKHQuc29ydChhbikpO1xuICAgIH1cbiAgfV0pO1xufShHdCk7XG53KEdlLCBcImlkXCIsIFwidGltZVwiKSwgdyhHZSwgXCJkZWZhdWx0c1wiLCB7XG4gIGJvdW5kczogXCJkYXRhXCIsXG4gIGFkYXB0ZXJzOiB7fSxcbiAgdGltZToge1xuICAgIHBhcnNlcjogITEsXG4gICAgdW5pdDogITEsXG4gICAgcm91bmQ6ICExLFxuICAgIGlzb1dlZWtkYXk6ICExLFxuICAgIG1pblVuaXQ6IFwibWlsbGlzZWNvbmRcIixcbiAgICBkaXNwbGF5Rm9ybWF0czoge31cbiAgfSxcbiAgdGlja3M6IHtcbiAgICBzb3VyY2U6IFwiYXV0b1wiLFxuICAgIGNhbGxiYWNrOiAhMSxcbiAgICBtYWpvcjoge1xuICAgICAgZW5hYmxlZDogITFcbiAgICB9XG4gIH1cbn0pO1xuZnVuY3Rpb24gTGUoaSwgdCwgZSkge1xuICB2YXIgX0V0LCBfaSRzLCBfaSRuLCBfRXQyLCBfaSRzMiwgX2kkbjI7XG4gIHZhciBzID0gMCxcbiAgICBuID0gaS5sZW5ndGggLSAxLFxuICAgIG8sXG4gICAgcixcbiAgICBhLFxuICAgIGw7XG4gIGUgPyAodCA+PSBpW3NdLnBvcyAmJiB0IDw9IGlbbl0ucG9zICYmIChfRXQgPSBFdChpLCBcInBvc1wiLCB0KSwgcyA9IF9FdC5sbywgbiA9IF9FdC5oaSwgX0V0KSwgX2kkcyA9IGlbc10sIG8gPSBfaSRzLnBvcywgYSA9IF9pJHMudGltZSwgX2kkbiA9IGlbbl0sIHIgPSBfaSRuLnBvcywgbCA9IF9pJG4udGltZSkgOiAodCA+PSBpW3NdLnRpbWUgJiYgdCA8PSBpW25dLnRpbWUgJiYgKF9FdDIgPSBFdChpLCBcInRpbWVcIiwgdCksIHMgPSBfRXQyLmxvLCBuID0gX0V0Mi5oaSwgX0V0MiksIF9pJHMyID0gaVtzXSwgbyA9IF9pJHMyLnRpbWUsIGEgPSBfaSRzMi5wb3MsIF9pJG4yID0gaVtuXSwgciA9IF9pJG4yLnRpbWUsIGwgPSBfaSRuMi5wb3MpO1xuICB2YXIgYyA9IHIgLSBvO1xuICByZXR1cm4gYyA/IGEgKyAobCAtIGEpICogKHQgLSBvKSAvIGMgOiBhO1xufVxudmFyIHVuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfR2UpIHtcbiAgZnVuY3Rpb24gdW4odCkge1xuICAgIHZhciBfdGhpczM2O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCB1bik7XG4gICAgX3RoaXMzNiA9IF9jYWxsU3VwZXIodGhpcywgdW4sIFt0XSksIF90aGlzMzYuX3RhYmxlID0gW10sIF90aGlzMzYuX21pblBvcyA9IHZvaWQgMCwgX3RoaXMzNi5fdGFibGVSYW5nZSA9IHZvaWQgMDtcbiAgICByZXR1cm4gX3RoaXMzNjtcbiAgfVxuICBfaW5oZXJpdHModW4sIF9HZSk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3ModW4sIFt7XG4gICAga2V5OiBcImluaXRPZmZzZXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRPZmZzZXRzKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKSxcbiAgICAgICAgZSA9IHRoaXMuX3RhYmxlID0gdGhpcy5idWlsZExvb2t1cFRhYmxlKHQpO1xuICAgICAgdGhpcy5fbWluUG9zID0gTGUoZSwgdGhpcy5taW4pLCB0aGlzLl90YWJsZVJhbmdlID0gTGUoZSwgdGhpcy5tYXgpIC0gdGhpcy5fbWluUG9zLCBfc3VwZXJQcm9wR2V0KHVuLCBcImluaXRPZmZzZXRzXCIsIHRoaXMsIDMpKFt0XSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkTG9va3VwVGFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRMb29rdXBUYWJsZSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMubWluLFxuICAgICAgICBzID0gdGhpcy5tYXgsXG4gICAgICAgIG4gPSBbXSxcbiAgICAgICAgbyA9IFtdO1xuICAgICAgdmFyIHIsIGEsIGwsIGMsIGg7XG4gICAgICBmb3IgKHIgPSAwLCBhID0gdC5sZW5ndGg7IHIgPCBhOyArK3IpIGMgPSB0W3JdLCBjID49IGUgJiYgYyA8PSBzICYmIG4ucHVzaChjKTtcbiAgICAgIGlmIChuLmxlbmd0aCA8IDIpIHJldHVybiBbe1xuICAgICAgICB0aW1lOiBlLFxuICAgICAgICBwb3M6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgdGltZTogcyxcbiAgICAgICAgcG9zOiAxXG4gICAgICB9XTtcbiAgICAgIGZvciAociA9IDAsIGEgPSBuLmxlbmd0aDsgciA8IGE7ICsrcikgaCA9IG5bciArIDFdLCBsID0gbltyIC0gMV0sIGMgPSBuW3JdLCBNYXRoLnJvdW5kKChoICsgbCkgLyAyKSAhPT0gYyAmJiBvLnB1c2goe1xuICAgICAgICB0aW1lOiBjLFxuICAgICAgICBwb3M6IHIgLyAoYSAtIDEpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2VuZXJhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLm1pbixcbiAgICAgICAgZSA9IHRoaXMubWF4O1xuICAgICAgdmFyIHMgPSBfc3VwZXJQcm9wR2V0KHVuLCBcImdldERhdGFUaW1lc3RhbXBzXCIsIHRoaXMsIDMpKFtdKTtcbiAgICAgIHJldHVybiAoIXMuaW5jbHVkZXModCkgfHwgIXMubGVuZ3RoKSAmJiBzLnNwbGljZSgwLCAwLCB0KSwgKCFzLmluY2x1ZGVzKGUpIHx8IHMubGVuZ3RoID09PSAxKSAmJiBzLnB1c2goZSksIHMuc29ydChmdW5jdGlvbiAobiwgbykge1xuICAgICAgICByZXR1cm4gbiAtIG87XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFRpbWVzdGFtcHNGb3JUYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9jYWNoZS5hbGwgfHwgW107XG4gICAgICBpZiAodC5sZW5ndGgpIHJldHVybiB0O1xuICAgICAgdmFyIGUgPSB0aGlzLmdldERhdGFUaW1lc3RhbXBzKCksXG4gICAgICAgIHMgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgICAgcmV0dXJuIGUubGVuZ3RoICYmIHMubGVuZ3RoID8gdCA9IHRoaXMubm9ybWFsaXplKGUuY29uY2F0KHMpKSA6IHQgPSBlLmxlbmd0aCA/IGUgOiBzLCB0ID0gdGhpcy5fY2FjaGUuYWxsID0gdCwgdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGVjaW1hbEZvclZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlY2ltYWxGb3JWYWx1ZSh0KSB7XG4gICAgICByZXR1cm4gKExlKHRoaXMuX3RhYmxlLCB0KSAtIHRoaXMuX21pblBvcykgLyB0aGlzLl90YWJsZVJhbmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWYWx1ZUZvclBpeGVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlRm9yUGl4ZWwodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9vZmZzZXRzLFxuICAgICAgICBzID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwodCkgLyBlLmZhY3RvciAtIGUuZW5kO1xuICAgICAgcmV0dXJuIExlKHRoaXMuX3RhYmxlLCBzICogdGhpcy5fdGFibGVSYW5nZSArIHRoaXMuX21pblBvcywgITApO1xuICAgIH1cbiAgfV0pO1xufShHZSk7XG53KHVuLCBcImlkXCIsIFwidGltZXNlcmllc1wiKSwgdyh1biwgXCJkZWZhdWx0c1wiLCBHZS5kZWZhdWx0cyk7XG5tdC5yZWdpc3RlcihUaSwgQWksIEVlLCBXZSwgRmUsIHZ0LCBIZSwga2ksIGp0LCByZSwgSWUsIHhjLCB3YywgRGMsIEZjKTtcbnZhciBmbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGZuKHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgZm4pO1xuICAgIHRoaXMuY2hhcnQgPSBudWxsLCB0aGlzLmNhbnZhcyA9IHQ7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhmbiwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcih0KSB7XG4gICAgICB2YXIgX3JlZjEyLCBfcmVmMTM7XG4gICAgICB2YXIgciwgYTtcbiAgICAgIHRoaXMuY2hhcnQgJiYgKHRoaXMuY2hhcnQuZGVzdHJveSgpLCB0aGlzLmNoYXJ0ID0gbnVsbCk7XG4gICAgICB2YXIgZSA9IHQuY2hhcnRTcGVjLFxuICAgICAgICBzID0gdC5kYXRhLFxuICAgICAgICBuID0gdGhpcy5tYXBDaGFydFR5cGUoZS50eXBlKSxcbiAgICAgICAgbyA9IHtcbiAgICAgICAgICB0eXBlOiBuLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGxhYmVsczogcy5sYWJlbHMsXG4gICAgICAgICAgICBkYXRhc2V0czogcy5kYXRhc2V0cy5tYXAoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbCksIHt9LCB7XG4gICAgICAgICAgICAgICAgZmlsbDogZS50eXBlID09PSBcImFyZWFcIixcbiAgICAgICAgICAgICAgICB0ZW5zaW9uOiBlLnR5cGUgPT09IFwibGluZVwiIHx8IGUudHlwZSA9PT0gXCJhcmVhXCIgPyAwLjMgOiAwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgICAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogITEsXG4gICAgICAgICAgICBwbHVnaW5zOiB7XG4gICAgICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogISFlLnRpdGxlLFxuICAgICAgICAgICAgICAgIHRleHQ6IGUudGl0bGUsXG4gICAgICAgICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgICAgICAgc2l6ZTogMTYsXG4gICAgICAgICAgICAgICAgICB3ZWlnaHQ6IFwiYm9sZFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAoX3JlZjEyID0gKHIgPSBlLmxlZ2VuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IHIuZGlzcGxheSkgIT09IG51bGwgJiYgX3JlZjEyICE9PSB2b2lkIDAgPyBfcmVmMTIgOiAhMCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogKF9yZWYxMyA9IChhID0gZS5sZWdlbmQpID09IG51bGwgPyB2b2lkIDAgOiBhLnBvc2l0aW9uKSAhPT0gbnVsbCAmJiBfcmVmMTMgIT09IHZvaWQgMCA/IF9yZWYxMyA6IFwidG9wXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6ICEwXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY2FsZXM6IHRoaXMuYnVpbGRTY2FsZXMoZSwgbilcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB0aGlzLmNoYXJ0ID0gbmV3IG10KHRoaXMuY2FudmFzLCBvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwQ2hhcnRUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcENoYXJ0VHlwZSh0KSB7XG4gICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcImFyZWFcIjpcbiAgICAgICAgICByZXR1cm4gXCJsaW5lXCI7XG4gICAgICAgIGNhc2UgXCJiYXJcIjpcbiAgICAgICAgY2FzZSBcImxpbmVcIjpcbiAgICAgICAgY2FzZSBcInBpZVwiOlxuICAgICAgICBjYXNlIFwiZG91Z2hudXRcIjpcbiAgICAgICAgY2FzZSBcInNjYXR0ZXJcIjpcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gXCJiYXJcIjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRTY2FsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRTY2FsZXModCwgZSkge1xuICAgICAgdmFyIHMsIG4sIG8sIHI7XG4gICAgICBpZiAoIShlID09PSBcInBpZVwiIHx8IGUgPT09IFwiZG91Z2hudXRcIikpIHJldHVybiB7XG4gICAgICAgIHg6IHtcbiAgICAgICAgICBkaXNwbGF5OiAhMCxcbiAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgZGlzcGxheTogISEoKHMgPSB0LnhBeGlzKSAhPSBudWxsICYmIHMubGFiZWwpLFxuICAgICAgICAgICAgdGV4dDogKG4gPSB0LnhBeGlzKSA9PSBudWxsID8gdm9pZCAwIDogbi5sYWJlbFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgIGRpc3BsYXk6ICEwLFxuICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAhISgobyA9IHQueUF4aXMpICE9IG51bGwgJiYgby5sYWJlbCksXG4gICAgICAgICAgICB0ZXh0OiAociA9IHQueUF4aXMpID09IG51bGwgPyB2b2lkIDAgOiByLmxhYmVsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBiZWdpbkF0WmVybzogITBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5jaGFydCAmJiAodGhpcy5jaGFydC5kZXN0cm95KCksIHRoaXMuY2hhcnQgPSBudWxsKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbnZhciAkYyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uICRjKHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgJGMpO1xuICAgIHRoaXMuX2NoYXJ0UmVuZGVyZXJzID0gW10sIHRoaXMuX2NvbnRhaW5lciA9IHQ7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcygkYywgW3tcbiAgICBrZXk6IFwicmVuZGVyRW1wdHlTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJFbXB0eVN0YXRlKCkge1xuICAgICAgdGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IFwiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiZW1wdHktc3RhdGVcXFwiPlxcbiAgICAgICAgPHNwYW4+U2V0IGEgcHJvbXB0IHRvIGdlbmVyYXRlIGEgY2hhcnQ8L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaG93TG9hZGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93TG9hZGluZygpIHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImxvYWRpbmctb3ZlcmxheVxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzcGlubmVyXFxcIj48L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImxvYWRpbmctdGV4dFxcXCI+R2VuZXJhdGluZyBjaGFydC4uLjwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNoYXJ0LXdyYXBwZXJcXFwiPlxcbiAgICAgICAgPGNhbnZhcz48L2NhbnZhcz5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNob3dFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93RXJyb3IodCwgZSkge1xuICAgICAgdGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IFwiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiZXJyb3ItY29udGFpbmVyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImVycm9yLWljb25cXFwiPiE8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImVycm9yLW1lc3NhZ2VcXFwiPlwiLmNvbmNhdCh0aGlzLl9lc2NhcGVIdG1sKHQpLCBcIjwvZGl2PlxcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwicmV0cnktYnV0dG9uXFxcIj5SZXRyeTwvYnV0dG9uPlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIik7XG4gICAgICB2YXIgcyA9IHRoaXMuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLnJldHJ5LWJ1dHRvblwiKTtcbiAgICAgIHMgPT0gbnVsbCB8fCBzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQ2hhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQ2hhcnQodCkge1xuICAgICAgdmFyIF90aGlzMzcgPSB0aGlzO1xuICAgICAgdGhpcy5fZGVzdHJveVJlbmRlcmVycygpO1xuICAgICAgdmFyIGUgPSBBcnJheS5pc0FycmF5KHQpID8gdCA6IFt0XTtcbiAgICAgIGlmIChlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwiY2hhcnRzLWdyaWRcIj48L2Rpdj4nO1xuICAgICAgICB2YXIgbiA9IHRoaXMuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLmNoYXJ0cy1ncmlkXCIpO1xuICAgICAgICBlLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICB2YXIgciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgci5jbGFzc05hbWUgPSBcImNoYXJ0LXdyYXBwZXJcIiwgci5pbm5lckhUTUwgPSBcIjxjYW52YXM+PC9jYW52YXM+XCIsIG4uYXBwZW5kQ2hpbGQocik7XG4gICAgICAgICAgdmFyIGEgPSByLnF1ZXJ5U2VsZWN0b3IoXCJjYW52YXNcIiksXG4gICAgICAgICAgICBsID0gbmV3IGZuKGEpO1xuICAgICAgICAgIGwucmVuZGVyKG8pLCBfdGhpczM3Ll9jaGFydFJlbmRlcmVycy5wdXNoKGwpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBcIlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY2hhcnQtd3JhcHBlclxcXCI+XFxuICAgICAgICAgIDxjYW52YXM+PC9jYW52YXM+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICBcIjtcbiAgICAgICAgdmFyIF9uNCA9IHRoaXMuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiY2FudmFzXCIpO1xuICAgICAgICBpZiAoIV9uNCkgcmV0dXJuO1xuICAgICAgICB2YXIgbyA9IG5ldyBmbihfbjQpO1xuICAgICAgICBvLnJlbmRlcihlWzBdKSwgdGhpcy5fY2hhcnRSZW5kZXJlcnMucHVzaChvKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5fZGVzdHJveVJlbmRlcmVycygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVJlbmRlcmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveVJlbmRlcmVycygpIHtcbiAgICAgIHRoaXMuX2NoYXJ0UmVuZGVyZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuZGVzdHJveSgpO1xuICAgICAgfSksIHRoaXMuX2NoYXJ0UmVuZGVyZXJzID0gW107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9lc2NhcGVIdG1sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lc2NhcGVIdG1sKHQpIHtcbiAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHJldHVybiBlLnRleHRDb250ZW50ID0gdCwgZS5pbm5lckhUTUw7XG4gICAgfVxuICB9XSk7XG59KCk7XG52YXIgWWMgPSBcIlxcbiAgOmhvc3Qge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NlZ29lIFVJJywgUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgc2Fucy1zZXJpZjtcXG4gIH1cXG5cXG4gIC5wcm9tcHQtY2hhcnQtY29udGFpbmVyIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBtaW4taGVpZ2h0OiAzMDBweDtcXG4gIH1cXG5cXG4gIC5jaGFydC13cmFwcGVyIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgbWluLWhlaWdodDogMzAwcHg7XFxuICB9XFxuXFxuICAuY2hhcnRzLWdyaWQge1xcbiAgICBkaXNwbGF5OiBncmlkO1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdChhdXRvLWZpdCwgbWlubWF4KDQwMHB4LCAxZnIpKTtcXG4gICAgZ2FwOiAyMHB4O1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgfVxcblxcbiAgLmNoYXJ0cy1ncmlkIC5jaGFydC13cmFwcGVyIHtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2U1ZTdlYjtcXG4gICAgYm9yZGVyLXJhZGl1czogOHB4O1xcbiAgICBwYWRkaW5nOiAxNnB4O1xcbiAgICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgfVxcblxcbiAgLmxvYWRpbmctb3ZlcmxheSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpO1xcbiAgICB6LWluZGV4OiAxMDtcXG4gIH1cXG5cXG4gIC5zcGlubmVyIHtcXG4gICAgd2lkdGg6IDQwcHg7XFxuICAgIGhlaWdodDogNDBweDtcXG4gICAgYm9yZGVyOiAzcHggc29saWQgI2U1ZTdlYjtcXG4gICAgYm9yZGVyLXRvcC1jb2xvcjogIzNiODJmNjtcXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgICBhbmltYXRpb246IHNwaW4gMXMgbGluZWFyIGluZmluaXRlO1xcbiAgfVxcblxcbiAgQGtleWZyYW1lcyBzcGluIHtcXG4gICAgdG8ge1xcbiAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC5sb2FkaW5nLXRleHQge1xcbiAgICBtYXJnaW4tdG9wOiAxMnB4O1xcbiAgICBjb2xvcjogIzZiNzI4MDtcXG4gICAgZm9udC1zaXplOiAxNHB4O1xcbiAgfVxcblxcbiAgLmVycm9yLWNvbnRhaW5lciB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIG1pbi1oZWlnaHQ6IDIwMHB4O1xcbiAgICBwYWRkaW5nOiAyMHB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGNvbG9yOiAjZGMyNjI2O1xcbiAgfVxcblxcbiAgLmVycm9yLWljb24ge1xcbiAgICBmb250LXNpemU6IDQ4cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICB9XFxuXFxuICAuZXJyb3ItbWVzc2FnZSB7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgbWF4LXdpZHRoOiA0MDBweDtcXG4gIH1cXG5cXG4gIC5yZXRyeS1idXR0b24ge1xcbiAgICBtYXJnaW4tdG9wOiAxNnB4O1xcbiAgICBwYWRkaW5nOiA4cHggMTZweDtcXG4gICAgYmFja2dyb3VuZDogIzNiODJmNjtcXG4gICAgY29sb3I6IHdoaXRlO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGJvcmRlci1yYWRpdXM6IDZweDtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBmb250LXNpemU6IDE0cHg7XFxuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQgMC4ycztcXG4gIH1cXG5cXG4gIC5yZXRyeS1idXR0b246aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kOiAjMjU2M2ViO1xcbiAgfVxcblxcbiAgLmVtcHR5LXN0YXRlIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgbWluLWhlaWdodDogMjAwcHg7XFxuICAgIGNvbG9yOiAjOWNhM2FmO1xcbiAgICBmb250LXNpemU6IDE0cHg7XFxuICB9XFxuXCI7XG52YXIgVWMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksXG4gIGh0ID0gZnVuY3Rpb24gaHQoaSwgdCwgZSwgcykge1xuICAgIGZvciAodmFyIG4gPSB2b2lkIDAsIG8gPSBpLmxlbmd0aCAtIDEsIHI7IG8gPj0gMDsgby0tKSAociA9IGlbb10pICYmIChuID0gcih0LCBlLCBuKSB8fCBuKTtcbiAgICByZXR1cm4gbiAmJiBVYyh0LCBlLCBuKSwgbjtcbiAgfTtcbnZhciBudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2k1KSB7XG4gIGZ1bmN0aW9uIG50KCkge1xuICAgIHZhciBfdGhpczM4O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBudCk7XG4gICAgX3RoaXMzOCA9IF9jYWxsU3VwZXIodGhpcywgbnQpLCBfdGhpczM4Ll9oYXNCZWVuUmVuZGVyZWQgPSAhMSwgX3RoaXMzOC5fYWJvcnRDb250cm9sbGVyID0gbnVsbCwgX3RoaXMzOC5fc2hhZG93ID0gX3RoaXMzOC5hdHRhY2hTaGFkb3coe1xuICAgICAgbW9kZTogXCJvcGVuXCJcbiAgICB9KTtcbiAgICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdC5jbGFzc05hbWUgPSBcInByb21wdC1jaGFydC1jb250YWluZXJcIiwgX3RoaXMzOC5fc2hhZG93LmlubmVySFRNTCA9IFwiPHN0eWxlPlwiLmNvbmNhdChZYywgXCI8L3N0eWxlPlwiKSwgX3RoaXMzOC5fc2hhZG93LmFwcGVuZENoaWxkKHQpLCBfdGhpczM4Ll9zdGF0ZVJlbmRlcmVyID0gbmV3ICRjKHQpLCBfdGhpczM4Ll9kZW1vRGF0YUdlbmVyYXRvciA9IG5ldyBjbygpLCBfdGhpczM4Ll9zdGF0ZVJlbmRlcmVyLnJlbmRlckVtcHR5U3RhdGUoKSwgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczM4Ll9oYXNCZWVuUmVuZGVyZWQgfHwgX3RoaXMzOC5vblJlbmRlcigpO1xuICAgIH0sIDIwKTtcbiAgICByZXR1cm4gX3RoaXMzODtcbiAgfVxuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgX2luaGVyaXRzKG50LCBfaTUpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKG50LCBbe1xuICAgIGtleTogXCJvblJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlbmRlcigpIHtcbiAgICAgIE5lLmF0dGVtcHRBcHBlbmRTdHlsZVNoZWV0VG9IZWFkKHRoaXMuc3R5bGUpLCBiaS5hcHBseURlZmF1bHRTdHlsZVRvQ29tcG9uZW50KHRoaXMuc3R5bGUsIHRoaXMuY29udGFpbmVyU3R5bGUpLCB0aGlzLl9oYXNCZWVuUmVuZGVyZWQgPSAhMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29ubmVjdGVkQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICB2YXIgdDtcbiAgICAgIHRoaXMuZGF0YSA/IHRoaXMuX3JlbmRlckRhdGEoKSA6IHRoaXMuYXV0b0ZldGNoICYmIHRoaXMucHJvbXB0ICYmICgodCA9IHRoaXMuY29ubmVjdCkgIT0gbnVsbCAmJiB0LnVybCB8fCB0aGlzLmRlbW8pICYmIHRoaXMuZmV0Y2hDaGFydCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNjb25uZWN0ZWRDYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICB9XG4gICAgLy8gb3ZlcnJpZGUgb25Qcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eTogc3RyaW5nLCBfdmFsdWU6IHVua25vd24pOiB2b2lkIHtcbiAgICAvLyAgIGlmIChwcm9wZXJ0eSA9PT0gJ2RhdGEnICYmIHRoaXMuZGF0YSkge1xuICAgIC8vICAgICB0aGlzLl9yZW5kZXJEYXRhKCk7XG4gICAgLy8gICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSAncHJvbXB0JyAmJiB0aGlzLmF1dG9GZXRjaCAmJiB0aGlzLnByb21wdCAmJiAodGhpcy5jb25uZWN0Py51cmwgfHwgdGhpcy5kZW1vKSkge1xuICAgIC8vICAgICB0aGlzLmZldGNoQ2hhcnQoKTtcbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbmRlckRhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlckRhdGEoKSB7XG4gICAgICB2YXIgdDtcbiAgICAgIHRoaXMuZGF0YSAmJiAodGhpcy5fc3RhdGVSZW5kZXJlci5yZW5kZXJDaGFydCh0aGlzLmRhdGEpLCB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiY2hhcnQtbG9hZGVkXCIsIHtcbiAgICAgICAgZGV0YWlsOiB0aGlzLmRhdGEsXG4gICAgICAgIGJ1YmJsZXM6ICEwLFxuICAgICAgICBjb21wb3NlZDogITBcbiAgICAgIH0pKSwgKHQgPSB0aGlzLm9uQ2hhcnRMb2FkZWQpID09IG51bGwgfHwgdC5jYWxsKHRoaXMsIHRoaXMuZGF0YSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhbmQgcmVuZGVyIGEgY2hhcnQgYmFzZWQgb24gdGhlIGN1cnJlbnQgcHJvbXB0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZmV0Y2hDaGFydFwiLFxuICAgIHZhbHVlOiAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9mZXRjaENoYXJ0ID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvcigpLm0oZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgdmFyIF90aGlzMzkgPSB0aGlzO1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcigpLncoZnVuY3Rpb24gKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQubikge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAodGhpcy5wcm9tcHQpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9zdGF0ZVJlbmRlcmVyLnNob3dFcnJvcihcIk1pc3NpbmcgcHJvbXB0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzOS5mZXRjaENoYXJ0KCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYSgyKTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgaWYgKCEoIXRoaXMuZGVtbyAmJiAhKCh0ID0gdGhpcy5jb25uZWN0KSAhPSBudWxsICYmIHQudXJsKSkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9zdGF0ZVJlbmRlcmVyLnNob3dFcnJvcihcIk1pc3NpbmcgY29ubmVjdC51cmxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczM5LmZldGNoQ2hhcnQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hKDIpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVtbykge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm4gPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm4gPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hEZW1vQ2hhcnQoKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmEoMik7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm4gPSA1O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hSZW1vdGVDaGFydCgpO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYSgyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZmV0Y2hDaGFydCgpIHtcbiAgICAgICAgcmV0dXJuIF9mZXRjaENoYXJ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmV0Y2hDaGFydDtcbiAgICB9KCkpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZldGNoRGVtb0NoYXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZmV0Y2hEZW1vQ2hhcnQyID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvcigpLm0oZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciBlLCB0O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yKCkudyhmdW5jdGlvbiAoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyLm4pIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgdGhpcy5fc3RhdGVSZW5kZXJlci5zaG93TG9hZGluZygpO1xuICAgICAgICAgICAgICBfY29udGV4dDIubiA9IDE7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHMsIDUwMCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICB0ID0gdGhpcy5fZGVtb0RhdGFHZW5lcmF0b3IuZ2VuZXJhdGUodGhpcy5wcm9tcHQpO1xuICAgICAgICAgICAgICB0aGlzLl9zdGF0ZVJlbmRlcmVyLnJlbmRlckNoYXJ0KHQpLCB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiY2hhcnQtbG9hZGVkXCIsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHQsXG4gICAgICAgICAgICAgICAgYnViYmxlczogITAsXG4gICAgICAgICAgICAgICAgY29tcG9zZWQ6ICEwXG4gICAgICAgICAgICAgIH0pKSwgKGUgPSB0aGlzLm9uQ2hhcnRMb2FkZWQpID09IG51bGwgfHwgZS5jYWxsKHRoaXMsIHQpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmEoMik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBfZmV0Y2hEZW1vQ2hhcnQoKSB7XG4gICAgICAgIHJldHVybiBfZmV0Y2hEZW1vQ2hhcnQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2ZldGNoRGVtb0NoYXJ0O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9mZXRjaFJlbW90ZUNoYXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZmV0Y2hSZW1vdGVDaGFydDIgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yKCkubShmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICAgICAgdmFyIF90aGlzNDAgPSB0aGlzO1xuICAgICAgICB2YXIgdCwgZSwgcywgX3RoaXMkY29ubmVjdCRtZXRob2QsIG4sIG8sIGwsIHIsIGEsIF9vNCwgX3Q0LCBfdDUsIF90NjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcigpLncoZnVuY3Rpb24gKF9jb250ZXh0Mykge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0My5wID0gX2NvbnRleHQzLm4pIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgKHQgPSB0aGlzLl9hYm9ydENvbnRyb2xsZXIpID09IG51bGwgfHwgdC5hYm9ydCgpLCB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCksIHRoaXMuX3N0YXRlUmVuZGVyZXIuc2hvd0xvYWRpbmcoKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLnAgPSAxO1xuICAgICAgICAgICAgICBuID0ge1xuICAgICAgICAgICAgICAgIGVuZHBvaW50OiB0aGlzLmNvbm5lY3QudXJsLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogKF90aGlzJGNvbm5lY3QkbWV0aG9kID0gdGhpcy5jb25uZWN0Lm1ldGhvZCkgIT09IG51bGwgJiYgX3RoaXMkY29ubmVjdCRtZXRob2QgIT09IHZvaWQgMCA/IF90aGlzJGNvbm5lY3QkbWV0aG9kIDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgICAgIH0sIHRoaXMuY29ubmVjdC5oZWFkZXJzKSxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICBwcm9tcHQ6IHRoaXMucHJvbXB0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBfdDQgPSB0aGlzLnJlcXVlc3RJbnRlcmNlcHRvcjtcbiAgICAgICAgICAgICAgaWYgKCFfdDQpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubiA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NvbnRleHQzLm4gPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0SW50ZXJjZXB0b3Iobik7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIG4gPSBfY29udGV4dDMudjtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm4gPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gZmV0Y2gobi5lbmRwb2ludCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogbi5tZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogbi5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG4uYm9keSksXG4gICAgICAgICAgICAgICAgc2lnbmFsOiB0aGlzLl9hYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBvID0gX2NvbnRleHQzLnY7XG4gICAgICAgICAgICAgIGlmIChvLm9rKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm4gPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uID0gNTtcbiAgICAgICAgICAgICAgcmV0dXJuIG8uanNvbigpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBlcnJvcjogXCJSZXF1ZXN0IGZhaWxlZFwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGwgPSBfY29udGV4dDMudjtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGwuZXJyb3IgfHwgXCJIVFRQIFwiLmNvbmNhdChvLnN0YXR1cykpO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBfY29udGV4dDMubiA9IDc7XG4gICAgICAgICAgICAgIHJldHVybiBvLmpzb24oKTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgciA9IF9jb250ZXh0My52O1xuICAgICAgICAgICAgICBpZiAoIXRoaXMucmVzcG9uc2VJbnRlcmNlcHRvcikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uID0gOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dDMubiA9IDg7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlSW50ZXJjZXB0b3Iocik7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIF90NSA9IF9jb250ZXh0My52O1xuICAgICAgICAgICAgICBfY29udGV4dDMubiA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgX3Q1ID0gcjtcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIGEgPSBfdDU7XG4gICAgICAgICAgICAgIHRoaXMuX3N0YXRlUmVuZGVyZXIucmVuZGVyQ2hhcnQoYSksIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJjaGFydC1sb2FkZWRcIiwge1xuICAgICAgICAgICAgICAgIGRldGFpbDogYSxcbiAgICAgICAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICAgICAgICBjb21wb3NlZDogITBcbiAgICAgICAgICAgICAgfSkpLCAoZSA9IHRoaXMub25DaGFydExvYWRlZCkgPT0gbnVsbCB8fCBlLmNhbGwodGhpcywgYSk7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uID0gMTM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgX2NvbnRleHQzLnAgPSAxMTtcbiAgICAgICAgICAgICAgX3Q2ID0gX2NvbnRleHQzLnY7XG4gICAgICAgICAgICAgIGlmICghKF90NiBpbnN0YW5jZW9mIEVycm9yICYmIF90Ni5uYW1lID09PSBcIkFib3J0RXJyb3JcIikpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubiA9IDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYSgyKTtcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIF9vNCA9IF90NiBpbnN0YW5jZW9mIEVycm9yID8gX3Q2Lm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIjtcbiAgICAgICAgICAgICAgdGhpcy5fc3RhdGVSZW5kZXJlci5zaG93RXJyb3IoX280LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNDAuZmV0Y2hDaGFydCgpO1xuICAgICAgICAgICAgICB9KSwgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImNoYXJ0LWVycm9yXCIsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBfbzRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJ1YmJsZXM6ICEwLFxuICAgICAgICAgICAgICAgIGNvbXBvc2VkOiAhMFxuICAgICAgICAgICAgICB9KSksIChzID0gdGhpcy5vbkNoYXJ0RXJyb3IpID09IG51bGwgfHwgcy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hKDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMsIFtbMSwgMTFdXSk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBfZmV0Y2hSZW1vdGVDaGFydCgpIHtcbiAgICAgICAgcmV0dXJuIF9mZXRjaFJlbW90ZUNoYXJ0Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9mZXRjaFJlbW90ZUNoYXJ0O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9jbGVhbnVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbnVwKCkge1xuICAgICAgdmFyIHQ7XG4gICAgICAodCA9IHRoaXMuX2Fib3J0Q29udHJvbGxlcikgPT0gbnVsbCB8fCB0LmFib3J0KCksIHRoaXMuX3N0YXRlUmVuZGVyZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgfV0pO1xufShfaSk7XG5odChbY3QoXCJvYmplY3RcIildLCBudC5wcm90b3R5cGUsIFwiY29ubmVjdFwiKTtcbmh0KFtjdChcInN0cmluZ1wiKV0sIG50LnByb3RvdHlwZSwgXCJwcm9tcHRcIik7XG5odChbY3QoXCJib29sZWFuXCIpXSwgbnQucHJvdG90eXBlLCBcImF1dG9GZXRjaFwiKTtcbmh0KFtjdChcIm9iamVjdFwiKV0sIG50LnByb3RvdHlwZSwgXCJjb250YWluZXJTdHlsZVwiKTtcbmh0KFtjdChcImZ1bmN0aW9uXCIpXSwgbnQucHJvdG90eXBlLCBcIm9uQ2hhcnRMb2FkZWRcIik7XG5odChbY3QoXCJmdW5jdGlvblwiKV0sIG50LnByb3RvdHlwZSwgXCJvbkNoYXJ0RXJyb3JcIik7XG5odChbY3QoXCJmdW5jdGlvblwiKV0sIG50LnByb3RvdHlwZSwgXCJyZXF1ZXN0SW50ZXJjZXB0b3JcIik7XG5odChbY3QoXCJmdW5jdGlvblwiKV0sIG50LnByb3RvdHlwZSwgXCJyZXNwb25zZUludGVyY2VwdG9yXCIpO1xuaHQoW2N0KFwiYm9vbGVhblwiKV0sIG50LnByb3RvdHlwZSwgXCJkZW1vXCIpO1xuaHQoW2N0KFwib2JqZWN0XCIpXSwgbnQucHJvdG90eXBlLCBcImRhdGFcIik7XG5jdXN0b21FbGVtZW50cy5nZXQoXCJwcm9tcHQtY2hhcnRcIikgfHwgY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwicHJvbXB0LWNoYXJ0XCIsIG50KTtcbmV4cG9ydCB7IGZuIGFzIENoYXJ0UmVuZGVyZXIsIG50IGFzIFByb21wdENoYXJ0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prompt-chart/dist/promptChart.js\n"));

/***/ })

}]);