"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_prompt-chart-react_dist_promptChart_js"],{

/***/ "./node_modules/@lit/react/development/create-component.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lit/react/development/create-component.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createComponent: function() { return /* binding */ createComponent; }\n/* harmony export */ });\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst NODE_MODE = false;\nconst DEV_MODE = true;\nconst reservedReactProperties = new Set([\n    'children',\n    'localName',\n    'ref',\n    'style',\n    'className',\n]);\nconst listenedEvents = new WeakMap();\n/**\n * Adds an event listener for the specified event to the given node. In the\n * React setup, there should only ever be one event listener. Thus, for\n * efficiency only one listener is added and the handler for that listener is\n * updated to point to the given listener function.\n */\nconst addOrUpdateEventListener = (node, event, listener) => {\n    let events = listenedEvents.get(node);\n    if (events === undefined) {\n        listenedEvents.set(node, (events = new Map()));\n    }\n    let handler = events.get(event);\n    if (listener !== undefined) {\n        // If necessary, add listener and track handler\n        if (handler === undefined) {\n            events.set(event, (handler = { handleEvent: listener }));\n            node.addEventListener(event, handler);\n            // Otherwise just update the listener with new value\n        }\n        else {\n            handler.handleEvent = listener;\n        }\n        // Remove listener if one exists and value is undefined\n    }\n    else if (handler !== undefined) {\n        events.delete(event);\n        node.removeEventListener(event, handler);\n    }\n};\n/**\n * Sets properties and events on custom elements. These properties and events\n * have been pre-filtered so we know they should apply to the custom element.\n */\nconst setProperty = (node, name, value, old, events) => {\n    const event = events?.[name];\n    // Dirty check event value.\n    if (event !== undefined) {\n        if (value !== old) {\n            addOrUpdateEventListener(node, event, value);\n        }\n        return;\n    }\n    // But don't dirty check properties; elements are assumed to do this.\n    node[name] = value;\n    // This block is to replicate React's behavior for attributes of native\n    // elements where `undefined` or `null` values result in attributes being\n    // removed.\n    // https://github.com/facebook/react/blob/899cb95f52cc83ab5ca1eb1e268c909d3f0961e7/packages/react-dom-bindings/src/client/DOMPropertyOperations.js#L107-L141\n    //\n    // It's only needed here for native HTMLElement properties that reflect\n    // attributes of the same name but don't have that behavior like \"id\" or\n    // \"draggable\".\n    if ((value === undefined || value === null) &&\n        name in HTMLElement.prototype) {\n        node.removeAttribute(name);\n    }\n};\n/**\n * Creates a React component for a custom element. Properties are distinguished\n * from attributes automatically, and events can be configured so they are added\n * to the custom element as event listeners.\n *\n * @param options An options bag containing the parameters needed to generate a\n * wrapped web component.\n *\n * @param options.react The React module, typically imported from the `react`\n * npm package.\n * @param options.tagName The custom element tag name registered via\n * `customElements.define`.\n * @param options.elementClass The custom element class registered via\n * `customElements.define`.\n * @param options.events An object listing events to which the component can\n * listen. The object keys are the event property names passed in via React\n * props and the object values are the names of the corresponding events\n * generated by the custom element. For example, given `{onactivate:\n * 'activate'}` an event function may be passed via the component's `onactivate`\n * prop and will be called when the custom element fires its `activate` event.\n * @param options.displayName A React component display name, used in debugging\n * messages. Default value is inferred from the name of custom element class\n * registered via `customElements.define`.\n */\nconst createComponent = ({ react: React, tagName, elementClass, events, displayName, }) => {\n    const eventProps = new Set(Object.keys(events ?? {}));\n    if (DEV_MODE && !NODE_MODE) {\n        for (const p of reservedReactProperties) {\n            if (p in elementClass.prototype && !(p in HTMLElement.prototype)) {\n                // Note, this effectively warns only for `ref` since the other\n                // reserved props are on HTMLElement.prototype. To address this\n                // would require crawling down the prototype, which doesn't feel worth\n                // it since implementing these properties on an element is extremely\n                // rare.\n                console.warn(`${tagName} contains property ${p} which is a React reserved ` +\n                    `property. It will be used by React and not set on the element.`);\n            }\n        }\n    }\n    const ReactComponent = React.forwardRef((props, ref) => {\n        const prevElemPropsRef = React.useRef(new Map());\n        const elementRef = React.useRef(null);\n        // Props to be passed to React.createElement\n        const reactProps = {};\n        // Props to be set on element with setProperty\n        const elementProps = {};\n        for (const [k, v] of Object.entries(props)) {\n            if (reservedReactProperties.has(k)) {\n                // React does *not* handle `className` for custom elements so\n                // coerce it to `class` so it's handled correctly.\n                reactProps[k === 'className' ? 'class' : k] = v;\n                continue;\n            }\n            if (eventProps.has(k) || k in elementClass.prototype) {\n                elementProps[k] = v;\n                continue;\n            }\n            reactProps[k] = v;\n        }\n        // useLayoutEffect produces warnings during server rendering.\n        if (!NODE_MODE) {\n            // This one has no dependency array so it'll run on every re-render.\n            React.useLayoutEffect(() => {\n                if (elementRef.current === null) {\n                    return;\n                }\n                const newElemProps = new Map();\n                for (const key in elementProps) {\n                    setProperty(elementRef.current, key, props[key], prevElemPropsRef.current.get(key), events);\n                    prevElemPropsRef.current.delete(key);\n                    newElemProps.set(key, props[key]);\n                }\n                // \"Unset\" any props from previous render that no longer exist.\n                // Setting to `undefined` seems like the correct thing to \"unset\"\n                // but currently React will set it as `null`.\n                // See https://github.com/facebook/react/issues/28203\n                for (const [key, value] of prevElemPropsRef.current) {\n                    setProperty(elementRef.current, key, undefined, value, events);\n                }\n                prevElemPropsRef.current = newElemProps;\n            });\n            // Empty dependency array so this will only run once after first render.\n            React.useLayoutEffect(() => {\n                elementRef.current?.removeAttribute('defer-hydration');\n            }, []);\n        }\n        if (NODE_MODE) {\n            // If component is to be server rendered with `@lit/ssr-react`, pass\n            // element properties in a special bag to be set by the server-side\n            // element renderer.\n            if ((React.createElement.name === 'litPatchedCreateElement' ||\n                globalThis.litSsrReactEnabled) &&\n                Object.keys(elementProps).length) {\n                // This property needs to remain unminified.\n                reactProps['_$litProps$'] = elementProps;\n            }\n        }\n        else {\n            // Suppress hydration warning for server-rendered attributes.\n            // This property needs to remain unminified.\n            reactProps['suppressHydrationWarning'] = true;\n        }\n        return React.createElement(tagName, {\n            ...reactProps,\n            ref: React.useCallback((node) => {\n                elementRef.current = node;\n                if (typeof ref === 'function') {\n                    ref(node);\n                }\n                else if (ref !== null) {\n                    ref.current = node;\n                }\n            }, [ref]),\n        });\n    });\n    ReactComponent.displayName = displayName ?? elementClass.name;\n    return ReactComponent;\n};\n//# sourceMappingURL=create-component.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdC9kZXZlbG9wbWVudC9jcmVhdGUtY29tcG9uZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQkFBMkIsMkRBQTJEO0FBQzdGLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVMsb0JBQW9CLEdBQUc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdC9kZXZlbG9wbWVudC9jcmVhdGUtY29tcG9uZW50LmpzPzliZDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5jb25zdCBOT0RFX01PREUgPSBmYWxzZTtcbmNvbnN0IERFVl9NT0RFID0gdHJ1ZTtcbmNvbnN0IHJlc2VydmVkUmVhY3RQcm9wZXJ0aWVzID0gbmV3IFNldChbXG4gICAgJ2NoaWxkcmVuJyxcbiAgICAnbG9jYWxOYW1lJyxcbiAgICAncmVmJyxcbiAgICAnc3R5bGUnLFxuICAgICdjbGFzc05hbWUnLFxuXSk7XG5jb25zdCBsaXN0ZW5lZEV2ZW50cyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQgdG8gdGhlIGdpdmVuIG5vZGUuIEluIHRoZVxuICogUmVhY3Qgc2V0dXAsIHRoZXJlIHNob3VsZCBvbmx5IGV2ZXIgYmUgb25lIGV2ZW50IGxpc3RlbmVyLiBUaHVzLCBmb3JcbiAqIGVmZmljaWVuY3kgb25seSBvbmUgbGlzdGVuZXIgaXMgYWRkZWQgYW5kIHRoZSBoYW5kbGVyIGZvciB0aGF0IGxpc3RlbmVyIGlzXG4gKiB1cGRhdGVkIHRvIHBvaW50IHRvIHRoZSBnaXZlbiBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqL1xuY29uc3QgYWRkT3JVcGRhdGVFdmVudExpc3RlbmVyID0gKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikgPT4ge1xuICAgIGxldCBldmVudHMgPSBsaXN0ZW5lZEV2ZW50cy5nZXQobm9kZSk7XG4gICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpc3RlbmVkRXZlbnRzLnNldChub2RlLCAoZXZlbnRzID0gbmV3IE1hcCgpKSk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVyID0gZXZlbnRzLmdldChldmVudCk7XG4gICAgaWYgKGxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgbmVjZXNzYXJ5LCBhZGQgbGlzdGVuZXIgYW5kIHRyYWNrIGhhbmRsZXJcbiAgICAgICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXZlbnRzLnNldChldmVudCwgKGhhbmRsZXIgPSB7IGhhbmRsZUV2ZW50OiBsaXN0ZW5lciB9KSk7XG4gICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGp1c3QgdXBkYXRlIHRoZSBsaXN0ZW5lciB3aXRoIG5ldyB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlci5oYW5kbGVFdmVudCA9IGxpc3RlbmVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBsaXN0ZW5lciBpZiBvbmUgZXhpc3RzIGFuZCB2YWx1ZSBpcyB1bmRlZmluZWRcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGV2ZW50cy5kZWxldGUoZXZlbnQpO1xuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgIH1cbn07XG4vKipcbiAqIFNldHMgcHJvcGVydGllcyBhbmQgZXZlbnRzIG9uIGN1c3RvbSBlbGVtZW50cy4gVGhlc2UgcHJvcGVydGllcyBhbmQgZXZlbnRzXG4gKiBoYXZlIGJlZW4gcHJlLWZpbHRlcmVkIHNvIHdlIGtub3cgdGhleSBzaG91bGQgYXBwbHkgdG8gdGhlIGN1c3RvbSBlbGVtZW50LlxuICovXG5jb25zdCBzZXRQcm9wZXJ0eSA9IChub2RlLCBuYW1lLCB2YWx1ZSwgb2xkLCBldmVudHMpID0+IHtcbiAgICBjb25zdCBldmVudCA9IGV2ZW50cz8uW25hbWVdO1xuICAgIC8vIERpcnR5IGNoZWNrIGV2ZW50IHZhbHVlLlxuICAgIGlmIChldmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gb2xkKSB7XG4gICAgICAgICAgICBhZGRPclVwZGF0ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEJ1dCBkb24ndCBkaXJ0eSBjaGVjayBwcm9wZXJ0aWVzOyBlbGVtZW50cyBhcmUgYXNzdW1lZCB0byBkbyB0aGlzLlxuICAgIG5vZGVbbmFtZV0gPSB2YWx1ZTtcbiAgICAvLyBUaGlzIGJsb2NrIGlzIHRvIHJlcGxpY2F0ZSBSZWFjdCdzIGJlaGF2aW9yIGZvciBhdHRyaWJ1dGVzIG9mIG5hdGl2ZVxuICAgIC8vIGVsZW1lbnRzIHdoZXJlIGB1bmRlZmluZWRgIG9yIGBudWxsYCB2YWx1ZXMgcmVzdWx0IGluIGF0dHJpYnV0ZXMgYmVpbmdcbiAgICAvLyByZW1vdmVkLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iLzg5OWNiOTVmNTJjYzgzYWI1Y2ExZWIxZTI2OGM5MDlkM2YwOTYxZTcvcGFja2FnZXMvcmVhY3QtZG9tLWJpbmRpbmdzL3NyYy9jbGllbnQvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzI0wxMDctTDE0MVxuICAgIC8vXG4gICAgLy8gSXQncyBvbmx5IG5lZWRlZCBoZXJlIGZvciBuYXRpdmUgSFRNTEVsZW1lbnQgcHJvcGVydGllcyB0aGF0IHJlZmxlY3RcbiAgICAvLyBhdHRyaWJ1dGVzIG9mIHRoZSBzYW1lIG5hbWUgYnV0IGRvbid0IGhhdmUgdGhhdCBiZWhhdmlvciBsaWtlIFwiaWRcIiBvclxuICAgIC8vIFwiZHJhZ2dhYmxlXCIuXG4gICAgaWYgKCh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSAmJlxuICAgICAgICBuYW1lIGluIEhUTUxFbGVtZW50LnByb3RvdHlwZSkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgUmVhY3QgY29tcG9uZW50IGZvciBhIGN1c3RvbSBlbGVtZW50LiBQcm9wZXJ0aWVzIGFyZSBkaXN0aW5ndWlzaGVkXG4gKiBmcm9tIGF0dHJpYnV0ZXMgYXV0b21hdGljYWxseSwgYW5kIGV2ZW50cyBjYW4gYmUgY29uZmlndXJlZCBzbyB0aGV5IGFyZSBhZGRlZFxuICogdG8gdGhlIGN1c3RvbSBlbGVtZW50IGFzIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyBBbiBvcHRpb25zIGJhZyBjb250YWluaW5nIHRoZSBwYXJhbWV0ZXJzIG5lZWRlZCB0byBnZW5lcmF0ZSBhXG4gKiB3cmFwcGVkIHdlYiBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMucmVhY3QgVGhlIFJlYWN0IG1vZHVsZSwgdHlwaWNhbGx5IGltcG9ydGVkIGZyb20gdGhlIGByZWFjdGBcbiAqIG5wbSBwYWNrYWdlLlxuICogQHBhcmFtIG9wdGlvbnMudGFnTmFtZSBUaGUgY3VzdG9tIGVsZW1lbnQgdGFnIG5hbWUgcmVnaXN0ZXJlZCB2aWFcbiAqIGBjdXN0b21FbGVtZW50cy5kZWZpbmVgLlxuICogQHBhcmFtIG9wdGlvbnMuZWxlbWVudENsYXNzIFRoZSBjdXN0b20gZWxlbWVudCBjbGFzcyByZWdpc3RlcmVkIHZpYVxuICogYGN1c3RvbUVsZW1lbnRzLmRlZmluZWAuXG4gKiBAcGFyYW0gb3B0aW9ucy5ldmVudHMgQW4gb2JqZWN0IGxpc3RpbmcgZXZlbnRzIHRvIHdoaWNoIHRoZSBjb21wb25lbnQgY2FuXG4gKiBsaXN0ZW4uIFRoZSBvYmplY3Qga2V5cyBhcmUgdGhlIGV2ZW50IHByb3BlcnR5IG5hbWVzIHBhc3NlZCBpbiB2aWEgUmVhY3RcbiAqIHByb3BzIGFuZCB0aGUgb2JqZWN0IHZhbHVlcyBhcmUgdGhlIG5hbWVzIG9mIHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50c1xuICogZ2VuZXJhdGVkIGJ5IHRoZSBjdXN0b20gZWxlbWVudC4gRm9yIGV4YW1wbGUsIGdpdmVuIGB7b25hY3RpdmF0ZTpcbiAqICdhY3RpdmF0ZSd9YCBhbiBldmVudCBmdW5jdGlvbiBtYXkgYmUgcGFzc2VkIHZpYSB0aGUgY29tcG9uZW50J3MgYG9uYWN0aXZhdGVgXG4gKiBwcm9wIGFuZCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBjdXN0b20gZWxlbWVudCBmaXJlcyBpdHMgYGFjdGl2YXRlYCBldmVudC5cbiAqIEBwYXJhbSBvcHRpb25zLmRpc3BsYXlOYW1lIEEgUmVhY3QgY29tcG9uZW50IGRpc3BsYXkgbmFtZSwgdXNlZCBpbiBkZWJ1Z2dpbmdcbiAqIG1lc3NhZ2VzLiBEZWZhdWx0IHZhbHVlIGlzIGluZmVycmVkIGZyb20gdGhlIG5hbWUgb2YgY3VzdG9tIGVsZW1lbnQgY2xhc3NcbiAqIHJlZ2lzdGVyZWQgdmlhIGBjdXN0b21FbGVtZW50cy5kZWZpbmVgLlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQ29tcG9uZW50ID0gKHsgcmVhY3Q6IFJlYWN0LCB0YWdOYW1lLCBlbGVtZW50Q2xhc3MsIGV2ZW50cywgZGlzcGxheU5hbWUsIH0pID0+IHtcbiAgICBjb25zdCBldmVudFByb3BzID0gbmV3IFNldChPYmplY3Qua2V5cyhldmVudHMgPz8ge30pKTtcbiAgICBpZiAoREVWX01PREUgJiYgIU5PREVfTU9ERSkge1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcmVzZXJ2ZWRSZWFjdFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwIGluIGVsZW1lbnRDbGFzcy5wcm90b3R5cGUgJiYgIShwIGluIEhUTUxFbGVtZW50LnByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlLCB0aGlzIGVmZmVjdGl2ZWx5IHdhcm5zIG9ubHkgZm9yIGByZWZgIHNpbmNlIHRoZSBvdGhlclxuICAgICAgICAgICAgICAgIC8vIHJlc2VydmVkIHByb3BzIGFyZSBvbiBIVE1MRWxlbWVudC5wcm90b3R5cGUuIFRvIGFkZHJlc3MgdGhpc1xuICAgICAgICAgICAgICAgIC8vIHdvdWxkIHJlcXVpcmUgY3Jhd2xpbmcgZG93biB0aGUgcHJvdG90eXBlLCB3aGljaCBkb2Vzbid0IGZlZWwgd29ydGhcbiAgICAgICAgICAgICAgICAvLyBpdCBzaW5jZSBpbXBsZW1lbnRpbmcgdGhlc2UgcHJvcGVydGllcyBvbiBhbiBlbGVtZW50IGlzIGV4dHJlbWVseVxuICAgICAgICAgICAgICAgIC8vIHJhcmUuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGAke3RhZ05hbWV9IGNvbnRhaW5zIHByb3BlcnR5ICR7cH0gd2hpY2ggaXMgYSBSZWFjdCByZXNlcnZlZCBgICtcbiAgICAgICAgICAgICAgICAgICAgYHByb3BlcnR5LiBJdCB3aWxsIGJlIHVzZWQgYnkgUmVhY3QgYW5kIG5vdCBzZXQgb24gdGhlIGVsZW1lbnQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgUmVhY3RDb21wb25lbnQgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZFbGVtUHJvcHNSZWYgPSBSZWFjdC51c2VSZWYobmV3IE1hcCgpKTtcbiAgICAgICAgY29uc3QgZWxlbWVudFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICAgICAgLy8gUHJvcHMgdG8gYmUgcGFzc2VkIHRvIFJlYWN0LmNyZWF0ZUVsZW1lbnRcbiAgICAgICAgY29uc3QgcmVhY3RQcm9wcyA9IHt9O1xuICAgICAgICAvLyBQcm9wcyB0byBiZSBzZXQgb24gZWxlbWVudCB3aXRoIHNldFByb3BlcnR5XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQcm9wcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhwcm9wcykpIHtcbiAgICAgICAgICAgIGlmIChyZXNlcnZlZFJlYWN0UHJvcGVydGllcy5oYXMoaykpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWFjdCBkb2VzICpub3QqIGhhbmRsZSBgY2xhc3NOYW1lYCBmb3IgY3VzdG9tIGVsZW1lbnRzIHNvXG4gICAgICAgICAgICAgICAgLy8gY29lcmNlIGl0IHRvIGBjbGFzc2Agc28gaXQncyBoYW5kbGVkIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICByZWFjdFByb3BzW2sgPT09ICdjbGFzc05hbWUnID8gJ2NsYXNzJyA6IGtdID0gdjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmVudFByb3BzLmhhcyhrKSB8fCBrIGluIGVsZW1lbnRDbGFzcy5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50UHJvcHNba10gPSB2O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhY3RQcm9wc1trXSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXNlTGF5b3V0RWZmZWN0IHByb2R1Y2VzIHdhcm5pbmdzIGR1cmluZyBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgICBpZiAoIU5PREVfTU9ERSkge1xuICAgICAgICAgICAgLy8gVGhpcyBvbmUgaGFzIG5vIGRlcGVuZGVuY3kgYXJyYXkgc28gaXQnbGwgcnVuIG9uIGV2ZXJ5IHJlLXJlbmRlci5cbiAgICAgICAgICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VsZW1Qcm9wcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBlbGVtZW50UHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0UHJvcGVydHkoZWxlbWVudFJlZi5jdXJyZW50LCBrZXksIHByb3BzW2tleV0sIHByZXZFbGVtUHJvcHNSZWYuY3VycmVudC5nZXQoa2V5KSwgZXZlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJldkVsZW1Qcm9wc1JlZi5jdXJyZW50LmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICBuZXdFbGVtUHJvcHMuc2V0KGtleSwgcHJvcHNba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFwiVW5zZXRcIiBhbnkgcHJvcHMgZnJvbSBwcmV2aW91cyByZW5kZXIgdGhhdCBubyBsb25nZXIgZXhpc3QuXG4gICAgICAgICAgICAgICAgLy8gU2V0dGluZyB0byBgdW5kZWZpbmVkYCBzZWVtcyBsaWtlIHRoZSBjb3JyZWN0IHRoaW5nIHRvIFwidW5zZXRcIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCBjdXJyZW50bHkgUmVhY3Qgd2lsbCBzZXQgaXQgYXMgYG51bGxgLlxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzI4MjAzXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgcHJldkVsZW1Qcm9wc1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFByb3BlcnR5KGVsZW1lbnRSZWYuY3VycmVudCwga2V5LCB1bmRlZmluZWQsIHZhbHVlLCBldmVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2RWxlbVByb3BzUmVmLmN1cnJlbnQgPSBuZXdFbGVtUHJvcHM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEVtcHR5IGRlcGVuZGVuY3kgYXJyYXkgc28gdGhpcyB3aWxsIG9ubHkgcnVuIG9uY2UgYWZ0ZXIgZmlyc3QgcmVuZGVyLlxuICAgICAgICAgICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50UmVmLmN1cnJlbnQ/LnJlbW92ZUF0dHJpYnV0ZSgnZGVmZXItaHlkcmF0aW9uJyk7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE5PREVfTU9ERSkge1xuICAgICAgICAgICAgLy8gSWYgY29tcG9uZW50IGlzIHRvIGJlIHNlcnZlciByZW5kZXJlZCB3aXRoIGBAbGl0L3Nzci1yZWFjdGAsIHBhc3NcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgcHJvcGVydGllcyBpbiBhIHNwZWNpYWwgYmFnIHRvIGJlIHNldCBieSB0aGUgc2VydmVyLXNpZGVcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgcmVuZGVyZXIuXG4gICAgICAgICAgICBpZiAoKFJlYWN0LmNyZWF0ZUVsZW1lbnQubmFtZSA9PT0gJ2xpdFBhdGNoZWRDcmVhdGVFbGVtZW50JyB8fFxuICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMubGl0U3NyUmVhY3RFbmFibGVkKSAmJlxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGVsZW1lbnRQcm9wcykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBuZWVkcyB0byByZW1haW4gdW5taW5pZmllZC5cbiAgICAgICAgICAgICAgICByZWFjdFByb3BzWydfJGxpdFByb3BzJCddID0gZWxlbWVudFByb3BzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU3VwcHJlc3MgaHlkcmF0aW9uIHdhcm5pbmcgZm9yIHNlcnZlci1yZW5kZXJlZCBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBuZWVkcyB0byByZW1haW4gdW5taW5pZmllZC5cbiAgICAgICAgICAgIHJlYWN0UHJvcHNbJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCh0YWdOYW1lLCB7XG4gICAgICAgICAgICAuLi5yZWFjdFByb3BzLFxuICAgICAgICAgICAgcmVmOiBSZWFjdC51c2VDYWxsYmFjaygobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtyZWZdKSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgUmVhY3RDb21wb25lbnQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZSA/PyBlbGVtZW50Q2xhc3MubmFtZTtcbiAgICByZXR1cm4gUmVhY3RDb21wb25lbnQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlLWNvbXBvbmVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit/react/development/create-component.js\n"));

/***/ }),

/***/ "./node_modules/@lit/react/development/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@lit/react/development/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _create_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create-component.js */ \"./node_modules/@lit/react/development/create-component.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _create_component_js__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _create_component_js__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdC9kZXZlbG9wbWVudC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0M7QUFDdEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsaXQvcmVhY3QvZGV2ZWxvcG1lbnQvaW5kZXguanM/NzM3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cbmV4cG9ydCAqIGZyb20gJy4vY3JlYXRlLWNvbXBvbmVudC5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit/react/development/index.js\n"));

/***/ }),

/***/ "./node_modules/prompt-chart-react/dist/promptChart.js":
/*!*************************************************************!*\
  !*** ./node_modules/prompt-chart-react/dist/promptChart.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("var react__WEBPACK_IMPORTED_MODULE_2___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PromptChart: function() { return /* binding */ PromptChart; }\n/* harmony export */ });\n/* harmony import */ var prompt_chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prompt-chart */ \"./node_modules/prompt-chart/dist/promptChart.js\");\n/* harmony import */ var _lit_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lit/react */ \"./node_modules/@lit/react/development/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n\n\nconst PromptChart = (0,_lit_react__WEBPACK_IMPORTED_MODULE_1__.createComponent)({\n    tagName: 'prompt-chart',\n    elementClass: prompt_chart__WEBPACK_IMPORTED_MODULE_0__.PromptChart,\n    react: /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_2__, 2))),\n    events: {\n        onactivate: 'activate',\n        onchange: 'change',\n    },\n});\n//# sourceMappingURL=promptChart.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvbXB0LWNoYXJ0LXJlYWN0L2Rpc3QvcHJvbXB0Q2hhcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBOEQ7QUFDakI7QUFDZDtBQUN4QixvQkFBb0IsMkRBQWU7QUFDMUM7QUFDQSxrQkFBa0IscURBQWU7QUFDakMsV0FBVyx5TEFBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9tcHQtY2hhcnQtcmVhY3QvZGlzdC9wcm9tcHRDaGFydC5qcz8yOTU0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByb21wdENoYXJ0IGFzIFByb21wdENoYXJ0Q29yZSB9IGZyb20gJ3Byb21wdC1jaGFydCc7XG5pbXBvcnQgeyBjcmVhdGVDb21wb25lbnQgfSBmcm9tICdAbGl0L3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBjb25zdCBQcm9tcHRDaGFydCA9IGNyZWF0ZUNvbXBvbmVudCh7XG4gICAgdGFnTmFtZTogJ3Byb21wdC1jaGFydCcsXG4gICAgZWxlbWVudENsYXNzOiBQcm9tcHRDaGFydENvcmUsXG4gICAgcmVhY3Q6IFJlYWN0LFxuICAgIGV2ZW50czoge1xuICAgICAgICBvbmFjdGl2YXRlOiAnYWN0aXZhdGUnLFxuICAgICAgICBvbmNoYW5nZTogJ2NoYW5nZScsXG4gICAgfSxcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvbXB0Q2hhcnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prompt-chart-react/dist/promptChart.js\n"));

/***/ }),

/***/ "./node_modules/prompt-chart/dist/promptChart.js":
/*!*******************************************************!*\
  !*** ./node_modules/prompt-chart/dist/promptChart.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChartRenderer: function() { return /* binding */ fn; },\n/* harmony export */   PromptChart: function() { return /* binding */ nt; }\n/* harmony export */ });\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2)); }, _regeneratorDefine2(e, r, n, t); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n5 = 0, F = function F() {}; return { s: F, n: function n() { return _n5 >= r.length ? { done: !0 } : { done: !1, value: r[_n5++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _wrapNativeSuper(t) { var r = \"function\" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }\nfunction _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf(\"[native code]\"); } catch (n) { return \"function\" == typeof t; } }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar ao = Object.defineProperty;\nvar lo = function lo(i, t, e) {\n  return t in i ? ao(i, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : i[t] = e;\n};\nvar w = function w(i, t, e) {\n  return lo(i, _typeof(t) != \"symbol\" ? t + \"\" : t, e);\n};\nvar Lt = /*#__PURE__*/function () {\n  function Lt() {\n    _classCallCheck(this, Lt);\n  }\n  return _createClass(Lt, null, [{\n    key: \"attemptAppendStyleSheetToHead\",\n    value: function attemptAppendStyleSheetToHead(t) {\n      if (t.fontFamily && t.fontFamily !== Lt.DEFAULT_FONT_FAMILY) return;\n      var e = document.getElementsByTagName(\"head\")[0];\n      if (!Array.from(e.getElementsByTagName(\"link\")).some(function (n) {\n        return n.getAttribute(\"href\") === Lt.FONT_URL;\n      })) {\n        var n = document.createElement(\"link\");\n        n.rel = \"stylesheet\", n.href = Lt.FONT_URL, e.appendChild(n);\n      }\n    }\n  }]);\n}();\nLt.FONT_URL = \"https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap\", Lt.DEFAULT_FONT_FAMILY = \"'Inter', sans-serif, Avenir, Helvetica, Arial\";\nvar Ne = Lt;\nvar $t = /*#__PURE__*/function () {\n  function $t() {\n    _classCallCheck(this, $t);\n  }\n  return _createClass($t, null, [{\n    key: \"applyToStyleIfNotDefined\",\n    value: function applyToStyleIfNotDefined(t, e) {\n      for (var s in e) {\n        var n = s,\n          o = e[n];\n        t[n] === \"\" && o && (t[n] = o);\n      }\n    }\n  }, {\n    key: \"applyDefaultStyleToComponent\",\n    value: function applyDefaultStyleToComponent(t, e) {\n      e && $t.applyToStyleIfNotDefined(t, e), $t.applyToStyleIfNotDefined(t, $t.DEFAULT_COMPONENT_STYLE);\n    }\n  }]);\n}();\n$t.DEFAULT_COMPONENT_STYLE = {\n  height: \"350px\",\n  width: \"100%\",\n  fontFamily: Ne.DEFAULT_FONT_FAMILY,\n  fontSize: \"0.9rem\",\n  backgroundColor: \"white\",\n  position: \"relative\",\n  overflow: \"hidden\"\n};\nvar bi = $t;\nvar Ve = /*#__PURE__*/function () {\n  function Ve() {\n    _classCallCheck(this, Ve);\n  }\n  return _createClass(Ve, null, [{\n    key: \"waitForPropertiesToBeUpdatedBeforeRender\",\n    value: function waitForPropertiesToBeUpdatedBeforeRender(t) {\n      t._propUpdated_ = !1, setTimeout(function () {\n        t._propUpdated_ ? Ve.waitForPropertiesToBeUpdatedBeforeRender(t) : (t._waitingToRender_ = !1, t.onRender());\n      });\n    }\n  }, {\n    key: \"attemptRender\",\n    value: function attemptRender(t) {\n      t._propUpdated_ = !0, t._waitingToRender_ || (t._waitingToRender_ = !0, Ve.waitForPropertiesToBeUpdatedBeforeRender(t));\n    }\n  }]);\n}();\nvar gt = /*#__PURE__*/function (_HTMLElement) {\n  // If this is not working, try using propertyName directly\n  function gt() {\n    var _this;\n    _classCallCheck(this, gt);\n    _this = _callSuper(this, gt), _this._waitingToRender_ = !1, _this._propUpdated_ = !1, Object.keys(gt._attributeToProperty_).forEach(function (t) {\n      var e = gt._attributeToProperty_[t];\n      _this.constructPropertyAccessors(e), _this.hasOwnProperty(t) || _this.constructPropertyAccessors(e, t);\n    });\n    return _this;\n  }\n  _inherits(gt, _HTMLElement);\n  return _createClass(gt, [{\n    key: \"constructPropertyAccessors\",\n    value:\n    // need to be called here as accessors need to be set for the class instance\n    function constructPropertyAccessors(t, e) {\n      var s;\n      Object.defineProperty(this, e || t, {\n        get: function get() {\n          return s;\n        },\n        set: function set(r) {\n          s = r, e ? this[t] = r : Ve.attemptRender(this);\n        }\n      });\n    }\n  }, {\n    key: \"attributeChangedCallback\",\n    value: function attributeChangedCallback(t, e, s) {\n      if (e === s) return;\n      var n = gt._attributes_[t](s),\n        o = gt._attributeToProperty_[t];\n      this[o] = n;\n    }\n  }, {\n    key: \"onRender\",\n    value: function onRender() {}\n  }], [{\n    key: \"observedAttributes\",\n    get: function get() {\n      return Object.keys(gt._attributes_) || [];\n    }\n  }]);\n}(/*#__PURE__*/_wrapNativeSuper(HTMLElement));\ngt._attributes_ = {}, gt._attributeToProperty_ = {};\nvar _i = gt;\nvar co = /*#__PURE__*/function () {\n  function co() {\n    _classCallCheck(this, co);\n  }\n  return _createClass(co, [{\n    key: \"generate\",\n    value: function generate(t) {\n      var e = t.toLowerCase(),\n        s = this.detectChartType(e),\n        n = t.charAt(0).toUpperCase() + t.slice(1),\n        _this$generateDataset = this.generateDataset(e),\n        o = _this$generateDataset.labels,\n        r = _this$generateDataset.datasets,\n        a = _this$generateDataset.dataset;\n      return {\n        chartSpec: {\n          type: s,\n          title: n,\n          xAxis: {\n            label: \"Category\"\n          },\n          yAxis: {\n            label: \"Value\"\n          },\n          legend: {\n            display: r.length > 1 || s === \"pie\" || s === \"doughnut\",\n            position: \"top\"\n          }\n        },\n        data: {\n          labels: o,\n          datasets: r\n        },\n        metadata: {\n          generatedAt: (/* @__PURE__ */new Date()).toISOString(),\n          dataset: a,\n          recordCount: o.length\n        }\n      };\n    }\n  }, {\n    key: \"detectChartType\",\n    value: function detectChartType(t) {\n      return t.includes(\"pie\") ? \"pie\" : t.includes(\"doughnut\") || t.includes(\"donut\") ? \"doughnut\" : t.includes(\"line\") || t.includes(\"trend\") ? \"line\" : t.includes(\"area\") ? \"area\" : t.includes(\"scatter\") ? \"scatter\" : \"bar\";\n    }\n  }, {\n    key: \"generateDataset\",\n    value: function generateDataset(t) {\n      return t.includes(\"month\") || t.includes(\"year\") ? this.generateMonthlyData(t) : t.includes(\"product\") || t.includes(\"revenue\") ? this.generateProductRevenueData() : t.includes(\"status\") || t.includes(\"order\") ? this.generateOrderStatusData() : t.includes(\"signup\") || t.includes(\"user\") ? this.generateUserSignupData() : t.includes(\"profit\") || t.includes(\"top\") ? this.generateProfitData() : this.generateDefaultData();\n    }\n  }, {\n    key: \"generateMonthlyData\",\n    value: function generateMonthlyData(t) {\n      var e = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n      return t.includes(\"region\") ? {\n        labels: e,\n        datasets: [{\n          label: \"North\",\n          data: [65, 78, 90, 81, 96, 105, 110, 102, 95, 88, 92, 108],\n          backgroundColor: \"#3b82f6\",\n          borderColor: \"#3b82f6\"\n        }, {\n          label: \"South\",\n          data: [45, 52, 60, 55, 70, 82, 88, 80, 72, 65, 70, 85],\n          backgroundColor: \"#10b981\",\n          borderColor: \"#10b981\"\n        }, {\n          label: \"East\",\n          data: [35, 40, 48, 45, 55, 62, 68, 60, 55, 50, 52, 65],\n          backgroundColor: \"#f59e0b\",\n          borderColor: \"#f59e0b\"\n        }],\n        dataset: \"sales_by_region\"\n      } : {\n        labels: e,\n        datasets: [{\n          label: \"Value\",\n          data: [65, 78, 90, 81, 96, 105, 110, 102, 95, 88, 92, 108],\n          backgroundColor: \"#3b82f6\",\n          borderColor: \"#3b82f6\"\n        }],\n        dataset: \"monthly_data\"\n      };\n    }\n  }, {\n    key: \"generateProductRevenueData\",\n    value: function generateProductRevenueData() {\n      var t = [\"Product A\", \"Product B\", \"Product C\", \"Product D\", \"Product E\"],\n        e = [\"#3b82f6\", \"#10b981\", \"#f59e0b\", \"#ef4444\", \"#8b5cf6\"];\n      return {\n        labels: t,\n        datasets: [{\n          label: \"Revenue\",\n          data: [42e3, 35e3, 28e3, 21e3, 15e3],\n          backgroundColor: e,\n          borderColor: e\n        }],\n        dataset: \"product_revenue\"\n      };\n    }\n  }, {\n    key: \"generateOrderStatusData\",\n    value: function generateOrderStatusData() {\n      var t = [\"Completed\", \"Pending\", \"Processing\", \"Cancelled\"],\n        e = [\"#10b981\", \"#f59e0b\", \"#3b82f6\", \"#ef4444\"];\n      return {\n        labels: t,\n        datasets: [{\n          label: \"Orders\",\n          data: [245, 89, 56, 23],\n          backgroundColor: e,\n          borderColor: e\n        }],\n        dataset: \"order_status\"\n      };\n    }\n  }, {\n    key: \"generateUserSignupData\",\n    value: function generateUserSignupData() {\n      return {\n        labels: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n        datasets: [{\n          label: \"Signups\",\n          data: [120, 145, 180, 220, 290, 350, 420, 480, 520, 580, 650, 720],\n          backgroundColor: \"#8b5cf6\",\n          borderColor: \"#8b5cf6\"\n        }],\n        dataset: \"user_signups\"\n      };\n    }\n  }, {\n    key: \"generateProfitData\",\n    value: function generateProfitData() {\n      var t = [\"Widget Pro\", \"Gadget X\", \"Tool Master\", \"Device Plus\", \"Smart Kit\"],\n        e = [\"#3b82f6\", \"#10b981\", \"#f59e0b\", \"#ef4444\", \"#8b5cf6\"];\n      return {\n        labels: t,\n        datasets: [{\n          label: \"Profit\",\n          data: [18500, 15200, 12800, 9500, 7200],\n          backgroundColor: e,\n          borderColor: e\n        }],\n        dataset: \"product_profit\"\n      };\n    }\n  }, {\n    key: \"generateDefaultData\",\n    value: function generateDefaultData() {\n      var t = [\"Category A\", \"Category B\", \"Category C\", \"Category D\", \"Category E\"],\n        e = [\"#3b82f6\", \"#10b981\", \"#f59e0b\", \"#ef4444\", \"#8b5cf6\"];\n      return {\n        labels: t,\n        datasets: [{\n          label: \"Value\",\n          data: [42, 35, 28, 21, 15],\n          backgroundColor: e,\n          borderColor: e\n        }],\n        dataset: \"demo_data\"\n      };\n    }\n  }]);\n}();\nvar Xi = /*#__PURE__*/_createClass(function Xi() {\n  _classCallCheck(this, Xi);\n});\nXi.attibutes = {\n  string: function string(t) {\n    return t;\n  },\n  number: function number(t) {\n    return parseFloat(t);\n  },\n  \"boolean\": function boolean(t) {\n    return t === \"true\";\n  },\n  object: function object(t) {\n    return JSON.parse(t);\n  },\n  array: function array(t) {\n    return JSON.parse(t);\n  },\n  \"function\": function _function(t) {\n    return new Function(\"return \".concat(t))();\n  }\n};\nvar xi = Xi;\nfunction ct(i) {\n  return function (t, e) {\n    Object.defineProperty(t, e, {});\n    var s = t.constructor,\n      n = e.toLocaleLowerCase();\n    s._attributes_[n] = xi.attibutes[i], s._attributeToProperty_[n] = e;\n  };\n}\n/*!\n * @kurkle/color v0.3.4\n * https://github.com/kurkle/color#readme\n * (c) 2024 Jukka Kurkela\n * Released under the MIT License\n */\nfunction xe(i) {\n  return i + 0.5 | 0;\n}\nvar xt = function xt(i, t, e) {\n  return Math.max(Math.min(i, e), t);\n};\nfunction ne(i) {\n  return xt(xe(i * 2.55), 0, 255);\n}\nfunction St(i) {\n  return xt(xe(i * 255), 0, 255);\n}\nfunction pt(i) {\n  return xt(xe(i / 2.55) / 100, 0, 1);\n}\nfunction qi(i) {\n  return xt(xe(i * 100), 0, 100);\n}\nvar Q = {\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 4,\n    5: 5,\n    6: 6,\n    7: 7,\n    8: 8,\n    9: 9,\n    A: 10,\n    B: 11,\n    C: 12,\n    D: 13,\n    E: 14,\n    F: 15,\n    a: 10,\n    b: 11,\n    c: 12,\n    d: 13,\n    e: 14,\n    f: 15\n  },\n  yi = _toConsumableArray(\"0123456789ABCDEF\"),\n  ho = function ho(i) {\n    return yi[i & 15];\n  },\n  uo = function uo(i) {\n    return yi[(i & 240) >> 4] + yi[i & 15];\n  },\n  ve = function ve(i) {\n    return (i & 240) >> 4 === (i & 15);\n  },\n  fo = function fo(i) {\n    return ve(i.r) && ve(i.g) && ve(i.b) && ve(i.a);\n  };\nfunction go(i) {\n  var t = i.length,\n    e;\n  return i[0] === \"#\" && (t === 4 || t === 5 ? e = {\n    r: 255 & Q[i[1]] * 17,\n    g: 255 & Q[i[2]] * 17,\n    b: 255 & Q[i[3]] * 17,\n    a: t === 5 ? Q[i[4]] * 17 : 255\n  } : (t === 7 || t === 9) && (e = {\n    r: Q[i[1]] << 4 | Q[i[2]],\n    g: Q[i[3]] << 4 | Q[i[4]],\n    b: Q[i[5]] << 4 | Q[i[6]],\n    a: t === 9 ? Q[i[7]] << 4 | Q[i[8]] : 255\n  })), e;\n}\nvar po = function po(i, t) {\n  return i < 255 ? t(i) : \"\";\n};\nfunction mo(i) {\n  var t = fo(i) ? ho : uo;\n  return i ? \"#\" + t(i.r) + t(i.g) + t(i.b) + po(i.a, t) : void 0;\n}\nvar bo = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction gn(i, t, e) {\n  var s = t * Math.min(e, 1 - e),\n    n = function n(o) {\n      var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (o + i / 30) % 12;\n      return e - s * Math.max(Math.min(r - 3, 9 - r, 1), -1);\n    };\n  return [n(0), n(8), n(4)];\n}\nfunction _o(i, t, e) {\n  var s = function s(n) {\n    var o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n + i / 60) % 6;\n    return e - e * t * Math.max(Math.min(o, 4 - o, 1), 0);\n  };\n  return [s(5), s(3), s(1)];\n}\nfunction xo(i, t, e) {\n  var s = gn(i, 1, 0.5);\n  var n;\n  for (t + e > 1 && (n = 1 / (t + e), t *= n, e *= n), n = 0; n < 3; n++) s[n] *= 1 - t - e, s[n] += t;\n  return s;\n}\nfunction yo(i, t, e, s, n) {\n  return i === n ? (t - e) / s + (t < e ? 6 : 0) : t === n ? (e - i) / s + 2 : (i - t) / s + 4;\n}\nfunction Ri(i) {\n  var e = i.r / 255,\n    s = i.g / 255,\n    n = i.b / 255,\n    o = Math.max(e, s, n),\n    r = Math.min(e, s, n),\n    a = (o + r) / 2;\n  var l, c, h;\n  return o !== r && (h = o - r, c = a > 0.5 ? h / (2 - o - r) : h / (o + r), l = yo(e, s, n, h, o), l = l * 60 + 0.5), [l | 0, c || 0, a];\n}\nfunction Li(i, t, e, s) {\n  return (Array.isArray(t) ? i(t[0], t[1], t[2]) : i(t, e, s)).map(St);\n}\nfunction Ei(i, t, e) {\n  return Li(gn, i, t, e);\n}\nfunction vo(i, t, e) {\n  return Li(xo, i, t, e);\n}\nfunction Mo(i, t, e) {\n  return Li(_o, i, t, e);\n}\nfunction pn(i) {\n  return (i % 360 + 360) % 360;\n}\nfunction So(i) {\n  var t = bo.exec(i);\n  var e = 255,\n    s;\n  if (!t) return;\n  t[5] !== s && (e = t[6] ? ne(+t[5]) : St(+t[5]));\n  var n = pn(+t[2]),\n    o = +t[3] / 100,\n    r = +t[4] / 100;\n  return t[1] === \"hwb\" ? s = vo(n, o, r) : t[1] === \"hsv\" ? s = Mo(n, o, r) : s = Ei(n, o, r), {\n    r: s[0],\n    g: s[1],\n    b: s[2],\n    a: e\n  };\n}\nfunction ko(i, t) {\n  var e = Ri(i);\n  e[0] = pn(e[0] + t), e = Ei(e), i.r = e[0], i.g = e[1], i.b = e[2];\n}\nfunction wo(i) {\n  if (!i) return;\n  var t = Ri(i),\n    e = t[0],\n    s = qi(t[1]),\n    n = qi(t[2]);\n  return i.a < 255 ? \"hsla(\".concat(e, \", \").concat(s, \"%, \").concat(n, \"%, \").concat(pt(i.a), \")\") : \"hsl(\".concat(e, \", \").concat(s, \"%, \").concat(n, \"%)\");\n}\nvar Ki = {\n    x: \"dark\",\n    Z: \"light\",\n    Y: \"re\",\n    X: \"blu\",\n    W: \"gr\",\n    V: \"medium\",\n    U: \"slate\",\n    A: \"ee\",\n    T: \"ol\",\n    S: \"or\",\n    B: \"ra\",\n    C: \"lateg\",\n    D: \"ights\",\n    R: \"in\",\n    Q: \"turquois\",\n    E: \"hi\",\n    P: \"ro\",\n    O: \"al\",\n    N: \"le\",\n    M: \"de\",\n    L: \"yello\",\n    F: \"en\",\n    K: \"ch\",\n    G: \"arks\",\n    H: \"ea\",\n    I: \"ightg\",\n    J: \"wh\"\n  },\n  Gi = {\n    OiceXe: \"f0f8ff\",\n    antiquewEte: \"faebd7\",\n    aqua: \"ffff\",\n    aquamarRe: \"7fffd4\",\n    azuY: \"f0ffff\",\n    beige: \"f5f5dc\",\n    bisque: \"ffe4c4\",\n    black: \"0\",\n    blanKedOmond: \"ffebcd\",\n    Xe: \"ff\",\n    XeviTet: \"8a2be2\",\n    bPwn: \"a52a2a\",\n    burlywood: \"deb887\",\n    caMtXe: \"5f9ea0\",\n    KartYuse: \"7fff00\",\n    KocTate: \"d2691e\",\n    cSO: \"ff7f50\",\n    cSnflowerXe: \"6495ed\",\n    cSnsilk: \"fff8dc\",\n    crimson: \"dc143c\",\n    cyan: \"ffff\",\n    xXe: \"8b\",\n    xcyan: \"8b8b\",\n    xgTMnPd: \"b8860b\",\n    xWay: \"a9a9a9\",\n    xgYF: \"6400\",\n    xgYy: \"a9a9a9\",\n    xkhaki: \"bdb76b\",\n    xmagFta: \"8b008b\",\n    xTivegYF: \"556b2f\",\n    xSange: \"ff8c00\",\n    xScEd: \"9932cc\",\n    xYd: \"8b0000\",\n    xsOmon: \"e9967a\",\n    xsHgYF: \"8fbc8f\",\n    xUXe: \"483d8b\",\n    xUWay: \"2f4f4f\",\n    xUgYy: \"2f4f4f\",\n    xQe: \"ced1\",\n    xviTet: \"9400d3\",\n    dAppRk: \"ff1493\",\n    dApskyXe: \"bfff\",\n    dimWay: \"696969\",\n    dimgYy: \"696969\",\n    dodgerXe: \"1e90ff\",\n    fiYbrick: \"b22222\",\n    flSOwEte: \"fffaf0\",\n    foYstWAn: \"228b22\",\n    fuKsia: \"ff00ff\",\n    gaRsbSo: \"dcdcdc\",\n    ghostwEte: \"f8f8ff\",\n    gTd: \"ffd700\",\n    gTMnPd: \"daa520\",\n    Way: \"808080\",\n    gYF: \"8000\",\n    gYFLw: \"adff2f\",\n    gYy: \"808080\",\n    honeyMw: \"f0fff0\",\n    hotpRk: \"ff69b4\",\n    RdianYd: \"cd5c5c\",\n    Rdigo: \"4b0082\",\n    ivSy: \"fffff0\",\n    khaki: \"f0e68c\",\n    lavFMr: \"e6e6fa\",\n    lavFMrXsh: \"fff0f5\",\n    lawngYF: \"7cfc00\",\n    NmoncEffon: \"fffacd\",\n    ZXe: \"add8e6\",\n    ZcSO: \"f08080\",\n    Zcyan: \"e0ffff\",\n    ZgTMnPdLw: \"fafad2\",\n    ZWay: \"d3d3d3\",\n    ZgYF: \"90ee90\",\n    ZgYy: \"d3d3d3\",\n    ZpRk: \"ffb6c1\",\n    ZsOmon: \"ffa07a\",\n    ZsHgYF: \"20b2aa\",\n    ZskyXe: \"87cefa\",\n    ZUWay: \"778899\",\n    ZUgYy: \"778899\",\n    ZstAlXe: \"b0c4de\",\n    ZLw: \"ffffe0\",\n    lime: \"ff00\",\n    limegYF: \"32cd32\",\n    lRF: \"faf0e6\",\n    magFta: \"ff00ff\",\n    maPon: \"800000\",\n    VaquamarRe: \"66cdaa\",\n    VXe: \"cd\",\n    VScEd: \"ba55d3\",\n    VpurpN: \"9370db\",\n    VsHgYF: \"3cb371\",\n    VUXe: \"7b68ee\",\n    VsprRggYF: \"fa9a\",\n    VQe: \"48d1cc\",\n    VviTetYd: \"c71585\",\n    midnightXe: \"191970\",\n    mRtcYam: \"f5fffa\",\n    mistyPse: \"ffe4e1\",\n    moccasR: \"ffe4b5\",\n    navajowEte: \"ffdead\",\n    navy: \"80\",\n    Tdlace: \"fdf5e6\",\n    Tive: \"808000\",\n    TivedBb: \"6b8e23\",\n    Sange: \"ffa500\",\n    SangeYd: \"ff4500\",\n    ScEd: \"da70d6\",\n    pOegTMnPd: \"eee8aa\",\n    pOegYF: \"98fb98\",\n    pOeQe: \"afeeee\",\n    pOeviTetYd: \"db7093\",\n    papayawEp: \"ffefd5\",\n    pHKpuff: \"ffdab9\",\n    peru: \"cd853f\",\n    pRk: \"ffc0cb\",\n    plum: \"dda0dd\",\n    powMrXe: \"b0e0e6\",\n    purpN: \"800080\",\n    YbeccapurpN: \"663399\",\n    Yd: \"ff0000\",\n    Psybrown: \"bc8f8f\",\n    PyOXe: \"4169e1\",\n    saddNbPwn: \"8b4513\",\n    sOmon: \"fa8072\",\n    sandybPwn: \"f4a460\",\n    sHgYF: \"2e8b57\",\n    sHshell: \"fff5ee\",\n    siFna: \"a0522d\",\n    silver: \"c0c0c0\",\n    skyXe: \"87ceeb\",\n    UXe: \"6a5acd\",\n    UWay: \"708090\",\n    UgYy: \"708090\",\n    snow: \"fffafa\",\n    sprRggYF: \"ff7f\",\n    stAlXe: \"4682b4\",\n    tan: \"d2b48c\",\n    teO: \"8080\",\n    tEstN: \"d8bfd8\",\n    tomato: \"ff6347\",\n    Qe: \"40e0d0\",\n    viTet: \"ee82ee\",\n    JHt: \"f5deb3\",\n    wEte: \"ffffff\",\n    wEtesmoke: \"f5f5f5\",\n    Lw: \"ffff00\",\n    LwgYF: \"9acd32\"\n  };\nfunction Po() {\n  var i = {},\n    t = Object.keys(Gi),\n    e = Object.keys(Ki);\n  var s, n, o, r, a;\n  for (s = 0; s < t.length; s++) {\n    for (r = a = t[s], n = 0; n < e.length; n++) o = e[n], a = a.replace(o, Ki[o]);\n    o = parseInt(Gi[r], 16), i[a] = [o >> 16 & 255, o >> 8 & 255, o & 255];\n  }\n  return i;\n}\nvar Me;\nfunction Do(i) {\n  Me || (Me = Po(), Me.transparent = [0, 0, 0, 0]);\n  var t = Me[i.toLowerCase()];\n  return t && {\n    r: t[0],\n    g: t[1],\n    b: t[2],\n    a: t.length === 4 ? t[3] : 255\n  };\n}\nvar Co = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction Oo(i) {\n  var t = Co.exec(i);\n  var e = 255,\n    s,\n    n,\n    o;\n  if (t) {\n    if (t[7] !== s) {\n      var r = +t[7];\n      e = t[8] ? ne(r) : xt(r * 255, 0, 255);\n    }\n    return s = +t[1], n = +t[3], o = +t[5], s = 255 & (t[2] ? ne(s) : xt(s, 0, 255)), n = 255 & (t[4] ? ne(n) : xt(n, 0, 255)), o = 255 & (t[6] ? ne(o) : xt(o, 0, 255)), {\n      r: s,\n      g: n,\n      b: o,\n      a: e\n    };\n  }\n}\nfunction To(i) {\n  return i && (i.a < 255 ? \"rgba(\".concat(i.r, \", \").concat(i.g, \", \").concat(i.b, \", \").concat(pt(i.a), \")\") : \"rgb(\".concat(i.r, \", \").concat(i.g, \", \").concat(i.b, \")\"));\n}\nvar si = function si(i) {\n    return i <= 31308e-7 ? i * 12.92 : Math.pow(i, 1 / 2.4) * 1.055 - 0.055;\n  },\n  Nt = function Nt(i) {\n    return i <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);\n  };\nfunction Ao(i, t, e) {\n  var s = Nt(pt(i.r)),\n    n = Nt(pt(i.g)),\n    o = Nt(pt(i.b));\n  return {\n    r: St(si(s + e * (Nt(pt(t.r)) - s))),\n    g: St(si(n + e * (Nt(pt(t.g)) - n))),\n    b: St(si(o + e * (Nt(pt(t.b)) - o))),\n    a: i.a + e * (t.a - i.a)\n  };\n}\nfunction Se(i, t, e) {\n  if (i) {\n    var s = Ri(i);\n    s[t] = Math.max(0, Math.min(s[t] + s[t] * e, t === 0 ? 360 : 1)), s = Ei(s), i.r = s[0], i.g = s[1], i.b = s[2];\n  }\n}\nfunction mn(i, t) {\n  return i && Object.assign(t || {}, i);\n}\nfunction Ji(i) {\n  var t = {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 255\n  };\n  return Array.isArray(i) ? i.length >= 3 && (t = {\n    r: i[0],\n    g: i[1],\n    b: i[2],\n    a: 255\n  }, i.length > 3 && (t.a = St(i[3]))) : (t = mn(i, {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 1\n  }), t.a = St(t.a)), t;\n}\nfunction Ro(i) {\n  return i.charAt(0) === \"r\" ? Oo(i) : So(i);\n}\nvar ue = /*#__PURE__*/function () {\n  function ue(t) {\n    _classCallCheck(this, ue);\n    if (t instanceof ue) return t;\n    var e = _typeof(t);\n    var s;\n    e === \"object\" ? s = Ji(t) : e === \"string\" && (s = go(t) || Do(t) || Ro(t)), this._rgb = s, this._valid = !!s;\n  }\n  return _createClass(ue, [{\n    key: \"valid\",\n    get: function get() {\n      return this._valid;\n    }\n  }, {\n    key: \"rgb\",\n    get: function get() {\n      var t = mn(this._rgb);\n      return t && (t.a = pt(t.a)), t;\n    },\n    set: function set(t) {\n      this._rgb = Ji(t);\n    }\n  }, {\n    key: \"rgbString\",\n    value: function rgbString() {\n      return this._valid ? To(this._rgb) : void 0;\n    }\n  }, {\n    key: \"hexString\",\n    value: function hexString() {\n      return this._valid ? mo(this._rgb) : void 0;\n    }\n  }, {\n    key: \"hslString\",\n    value: function hslString() {\n      return this._valid ? wo(this._rgb) : void 0;\n    }\n  }, {\n    key: \"mix\",\n    value: function mix(t, e) {\n      if (t) {\n        var s = this.rgb,\n          n = t.rgb;\n        var o;\n        var r = e === o ? 0.5 : e,\n          a = 2 * r - 1,\n          l = s.a - n.a,\n          c = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2;\n        o = 1 - c, s.r = 255 & c * s.r + o * n.r + 0.5, s.g = 255 & c * s.g + o * n.g + 0.5, s.b = 255 & c * s.b + o * n.b + 0.5, s.a = r * s.a + (1 - r) * n.a, this.rgb = s;\n      }\n      return this;\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(t, e) {\n      return t && (this._rgb = Ao(this._rgb, t._rgb, e)), this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new ue(this.rgb);\n    }\n  }, {\n    key: \"alpha\",\n    value: function alpha(t) {\n      return this._rgb.a = St(t), this;\n    }\n  }, {\n    key: \"clearer\",\n    value: function clearer(t) {\n      var e = this._rgb;\n      return e.a *= 1 - t, this;\n    }\n  }, {\n    key: \"greyscale\",\n    value: function greyscale() {\n      var t = this._rgb,\n        e = xe(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);\n      return t.r = t.g = t.b = e, this;\n    }\n  }, {\n    key: \"opaquer\",\n    value: function opaquer(t) {\n      var e = this._rgb;\n      return e.a *= 1 + t, this;\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      var t = this._rgb;\n      return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;\n    }\n  }, {\n    key: \"lighten\",\n    value: function lighten(t) {\n      return Se(this._rgb, 2, t), this;\n    }\n  }, {\n    key: \"darken\",\n    value: function darken(t) {\n      return Se(this._rgb, 2, -t), this;\n    }\n  }, {\n    key: \"saturate\",\n    value: function saturate(t) {\n      return Se(this._rgb, 1, t), this;\n    }\n  }, {\n    key: \"desaturate\",\n    value: function desaturate(t) {\n      return Se(this._rgb, 1, -t), this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(t) {\n      return ko(this._rgb, t), this;\n    }\n  }]);\n}();\n/*!\n * Chart.js v4.5.1\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */\nfunction dt() {}\nvar Lo = /* @__PURE__ */function () {\n  var i = 0;\n  return function () {\n    return i++;\n  };\n}();\nfunction R(i) {\n  return i == null;\n}\nfunction N(i) {\n  if (Array.isArray && Array.isArray(i)) return !0;\n  var t = Object.prototype.toString.call(i);\n  return t.slice(0, 7) === \"[object\" && t.slice(-6) === \"Array]\";\n}\nfunction T(i) {\n  return i !== null && Object.prototype.toString.call(i) === \"[object Object]\";\n}\nfunction q(i) {\n  return (typeof i == \"number\" || i instanceof Number) && isFinite(+i);\n}\nfunction ot(i, t) {\n  return q(i) ? i : t;\n}\nfunction D(i, t) {\n  return _typeof(i) > \"u\" ? t : i;\n}\nvar Eo = function Eo(i, t) {\n    return typeof i == \"string\" && i.endsWith(\"%\") ? parseFloat(i) / 100 : +i / t;\n  },\n  bn = function bn(i, t) {\n    return typeof i == \"string\" && i.endsWith(\"%\") ? parseFloat(i) / 100 * t : +i;\n  };\nfunction I(i, t, e) {\n  if (i && typeof i.call == \"function\") return i.apply(e, t);\n}\nfunction L(i, t, e, s) {\n  var n, o, r;\n  if (N(i)) for (o = i.length, n = 0; n < o; n++) t.call(e, i[n], n);else if (T(i)) for (r = Object.keys(i), o = r.length, n = 0; n < o; n++) t.call(e, i[r[n]], r[n]);\n}\nfunction je(i, t) {\n  var e, s, n, o;\n  if (!i || !t || i.length !== t.length) return !1;\n  for (e = 0, s = i.length; e < s; ++e) if (n = i[e], o = t[e], n.datasetIndex !== o.datasetIndex || n.index !== o.index) return !1;\n  return !0;\n}\nfunction $e(i) {\n  if (N(i)) return i.map($e);\n  if (T(i)) {\n    var t = /* @__PURE__ */Object.create(null),\n      e = Object.keys(i),\n      s = e.length;\n    var n = 0;\n    for (; n < s; ++n) t[e[n]] = $e(i[e[n]]);\n    return t;\n  }\n  return i;\n}\nfunction _n(i) {\n  return [\"__proto__\", \"prototype\", \"constructor\"].indexOf(i) === -1;\n}\nfunction Fo(i, t, e, s) {\n  if (!_n(i)) return;\n  var n = t[i],\n    o = e[i];\n  T(n) && T(o) ? fe(n, o, s) : t[i] = $e(o);\n}\nfunction fe(i, t, e) {\n  var s = N(t) ? t : [t],\n    n = s.length;\n  if (!T(i)) return i;\n  e = e || {};\n  var o = e.merger || Fo;\n  var r;\n  for (var a = 0; a < n; ++a) {\n    if (r = s[a], !T(r)) continue;\n    var l = Object.keys(r);\n    for (var c = 0, h = l.length; c < h; ++c) o(l[c], i, r, e);\n  }\n  return i;\n}\nfunction le(i, t) {\n  return fe(i, t, {\n    merger: Io\n  });\n}\nfunction Io(i, t, e) {\n  if (!_n(i)) return;\n  var s = t[i],\n    n = e[i];\n  T(s) && T(n) ? le(s, n) : Object.prototype.hasOwnProperty.call(t, i) || (t[i] = $e(n));\n}\nvar Zi = {\n  // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n  \"\": function _(i) {\n    return i;\n  },\n  // default resolvers\n  x: function x(i) {\n    return i.x;\n  },\n  y: function y(i) {\n    return i.y;\n  }\n};\nfunction zo(i) {\n  var t = i.split(\".\"),\n    e = [];\n  var s = \"\";\n  var _iterator = _createForOfIteratorHelper(t),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var n = _step.value;\n      s += n, s.endsWith(\"\\\\\") ? s = s.slice(0, -1) + \".\" : (e.push(s), s = \"\");\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return e;\n}\nfunction Bo(i) {\n  var t = zo(i);\n  return function (e) {\n    var _iterator2 = _createForOfIteratorHelper(t),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var s = _step2.value;\n        if (s === \"\") break;\n        e = e && e[s];\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return e;\n  };\n}\nfunction It(i, t) {\n  return (Zi[t] || (Zi[t] = Bo(t)))(i);\n}\nfunction Fi(i) {\n  return i.charAt(0).toUpperCase() + i.slice(1);\n}\nvar ge = function ge(i) {\n    return _typeof(i) < \"u\";\n  },\n  wt = function wt(i) {\n    return typeof i == \"function\";\n  },\n  Qi = function Qi(i, t) {\n    if (i.size !== t.size) return !1;\n    var _iterator3 = _createForOfIteratorHelper(i),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var e = _step3.value;\n        if (!t.has(e)) return !1;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return !0;\n  };\nfunction Ho(i) {\n  return i.type === \"mouseup\" || i.type === \"click\" || i.type === \"contextmenu\";\n}\nvar E = Math.PI,\n  B = 2 * E,\n  Wo = B + E,\n  Ye = Number.POSITIVE_INFINITY,\n  No = E / 180,\n  V = E / 2,\n  Ct = E / 4,\n  ts = E * 2 / 3,\n  xn = Math.log10,\n  lt = Math.sign;\nfunction ce(i, t, e) {\n  return Math.abs(i - t) < e;\n}\nfunction es(i) {\n  var t = Math.round(i);\n  i = ce(i, t, i / 1e3) ? t : i;\n  var e = Math.pow(10, Math.floor(xn(i))),\n    s = i / e;\n  return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * e;\n}\nfunction Vo(i) {\n  var t = [],\n    e = Math.sqrt(i);\n  var s;\n  for (s = 1; s < e; s++) i % s === 0 && (t.push(s), t.push(i / s));\n  return e === (e | 0) && t.push(e), t.sort(function (n, o) {\n    return n - o;\n  }).pop(), t;\n}\nfunction jo(i) {\n  return _typeof(i) == \"symbol\" || _typeof(i) == \"object\" && i !== null && !(Symbol.toPrimitive in i || \"toString\" in i || \"valueOf\" in i);\n}\nfunction Xt(i) {\n  return !jo(i) && !isNaN(parseFloat(i)) && isFinite(i);\n}\nfunction $o(i, t) {\n  var e = Math.round(i);\n  return e - t <= i && e + t >= i;\n}\nfunction Yo(i, t, e) {\n  var s, n, o;\n  for (s = 0, n = i.length; s < n; s++) o = i[s][e], isNaN(o) || (t.min = Math.min(t.min, o), t.max = Math.max(t.max, o));\n}\nfunction bt(i) {\n  return i * (E / 180);\n}\nfunction Uo(i) {\n  return i * (180 / E);\n}\nfunction is(i) {\n  if (!q(i)) return;\n  var t = 1,\n    e = 0;\n  for (; Math.round(i * t) / t !== i;) t *= 10, e++;\n  return e;\n}\nfunction yn(i, t) {\n  var e = t.x - i.x,\n    s = t.y - i.y,\n    n = Math.sqrt(e * e + s * s);\n  var o = Math.atan2(s, e);\n  return o < -0.5 * E && (o += B), {\n    angle: o,\n    distance: n\n  };\n}\nfunction vi(i, t) {\n  return Math.sqrt(Math.pow(t.x - i.x, 2) + Math.pow(t.y - i.y, 2));\n}\nfunction Xo(i, t) {\n  return (i - t + Wo) % B - E;\n}\nfunction Z(i) {\n  return (i % B + B) % B;\n}\nfunction pe(i, t, e, s) {\n  var n = Z(i),\n    o = Z(t),\n    r = Z(e),\n    a = Z(o - n),\n    l = Z(r - n),\n    c = Z(n - o),\n    h = Z(n - r);\n  return n === o || n === r || s && o === r || a > l && c < h;\n}\nfunction U(i, t, e) {\n  return Math.max(t, Math.min(e, i));\n}\nfunction qo(i) {\n  return U(i, -32768, 32767);\n}\nfunction _t(i, t, e) {\n  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-6;\n  return i >= Math.min(t, e) - s && i <= Math.max(t, e) + s;\n}\nfunction Ii(i, t, e) {\n  e = e || function (r) {\n    return i[r] < t;\n  };\n  var s = i.length - 1,\n    n = 0,\n    o;\n  for (; s - n > 1;) o = n + s >> 1, e(o) ? n = o : s = o;\n  return {\n    lo: n,\n    hi: s\n  };\n}\nvar Et = function Et(i, t, e, s) {\n    return Ii(i, e, s ? function (n) {\n      var o = i[n][t];\n      return o < e || o === e && i[n + 1][t] === e;\n    } : function (n) {\n      return i[n][t] < e;\n    });\n  },\n  Ko = function Ko(i, t, e) {\n    return Ii(i, e, function (s) {\n      return i[s][t] >= e;\n    });\n  };\nfunction Go(i, t, e) {\n  var s = 0,\n    n = i.length;\n  for (; s < n && i[s] < t;) s++;\n  for (; n > s && i[n - 1] > e;) n--;\n  return s > 0 || n < i.length ? i.slice(s, n) : i;\n}\nvar vn = [\"push\", \"pop\", \"shift\", \"splice\", \"unshift\"];\nfunction Jo(i, t) {\n  if (i._chartjs) {\n    i._chartjs.listeners.push(t);\n    return;\n  }\n  Object.defineProperty(i, \"_chartjs\", {\n    configurable: !0,\n    enumerable: !1,\n    value: {\n      listeners: [t]\n    }\n  }), vn.forEach(function (e) {\n    var s = \"_onData\" + Fi(e),\n      n = i[e];\n    Object.defineProperty(i, e, {\n      configurable: !0,\n      enumerable: !1,\n      value: function value() {\n        for (var _len = arguments.length, o = new Array(_len), _key = 0; _key < _len; _key++) {\n          o[_key] = arguments[_key];\n        }\n        var r = n.apply(this, o);\n        return i._chartjs.listeners.forEach(function (a) {\n          typeof a[s] == \"function\" && a[s].apply(a, o);\n        }), r;\n      }\n    });\n  });\n}\nfunction ss(i, t) {\n  var e = i._chartjs;\n  if (!e) return;\n  var s = e.listeners,\n    n = s.indexOf(t);\n  n !== -1 && s.splice(n, 1), !(s.length > 0) && (vn.forEach(function (o) {\n    delete i[o];\n  }), delete i._chartjs);\n}\nfunction Mn(i) {\n  var t = new Set(i);\n  return t.size === i.length ? i : Array.from(t);\n}\nvar Sn = function () {\n  return (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) > \"u\" ? function (i) {\n    return i();\n  } : window.requestAnimationFrame;\n}();\nfunction kn(i, t) {\n  var e = [],\n    s = !1;\n  return function () {\n    for (var _len2 = arguments.length, n = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      n[_key2] = arguments[_key2];\n    }\n    e = n, s || (s = !0, Sn.call(window, function () {\n      s = !1, i.apply(t, e);\n    }));\n  };\n}\nfunction Zo(i, t) {\n  var e;\n  return function () {\n    for (var _len3 = arguments.length, s = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      s[_key3] = arguments[_key3];\n    }\n    return t ? (clearTimeout(e), e = setTimeout(i, t, s)) : i.apply(this, s), t;\n  };\n}\nvar zi = function zi(i) {\n    return i === \"start\" ? \"left\" : i === \"end\" ? \"right\" : \"center\";\n  },\n  Y = function Y(i, t, e) {\n    return i === \"start\" ? t : i === \"end\" ? e : (t + e) / 2;\n  },\n  Qo = function Qo(i, t, e, s) {\n    return i === (s ? \"left\" : \"right\") ? e : i === \"center\" ? (t + e) / 2 : t;\n  };\nfunction wn(i, t, e) {\n  var s = t.length;\n  var n = 0,\n    o = s;\n  if (i._sorted) {\n    var r = i.iScale,\n      a = i.vScale,\n      l = i._parsed,\n      c = i.dataset && i.dataset.options ? i.dataset.options.spanGaps : null,\n      h = r.axis,\n      _r$getUserBounds = r.getUserBounds(),\n      d = _r$getUserBounds.min,\n      u = _r$getUserBounds.max,\n      f = _r$getUserBounds.minDefined,\n      p = _r$getUserBounds.maxDefined;\n    if (f) {\n      if (n = Math.min(\n      // @ts-expect-error Need to type _parsed\n      Et(l, h, d).lo,\n      // @ts-expect-error Need to fix types on _lookupByKey\n      e ? s : Et(t, h, r.getPixelForValue(d)).lo), c) {\n        var g = l.slice(0, n + 1).reverse().findIndex(function (m) {\n          return !R(m[a.axis]);\n        });\n        n -= Math.max(0, g);\n      }\n      n = U(n, 0, s - 1);\n    }\n    if (p) {\n      var _g = Math.max(\n      // @ts-expect-error Need to type _parsed\n      Et(l, r.axis, u, !0).hi + 1,\n      // @ts-expect-error Need to fix types on _lookupByKey\n      e ? 0 : Et(t, h, r.getPixelForValue(u), !0).hi + 1);\n      if (c) {\n        var m = l.slice(_g - 1).findIndex(function (b) {\n          return !R(b[a.axis]);\n        });\n        _g += Math.max(0, m);\n      }\n      o = U(_g, n, s) - n;\n    } else o = s - n;\n  }\n  return {\n    start: n,\n    count: o\n  };\n}\nfunction Pn(i) {\n  var t = i.xScale,\n    e = i.yScale,\n    s = i._scaleRanges,\n    n = {\n      xmin: t.min,\n      xmax: t.max,\n      ymin: e.min,\n      ymax: e.max\n    };\n  if (!s) return i._scaleRanges = n, !0;\n  var o = s.xmin !== t.min || s.xmax !== t.max || s.ymin !== e.min || s.ymax !== e.max;\n  return Object.assign(s, n), o;\n}\nvar ke = function ke(i) {\n    return i === 0 || i === 1;\n  },\n  ns = function ns(i, t, e) {\n    return -(Math.pow(2, 10 * (i -= 1)) * Math.sin((i - t) * B / e));\n  },\n  os = function os(i, t, e) {\n    return Math.pow(2, -10 * i) * Math.sin((i - t) * B / e) + 1;\n  },\n  he = {\n    linear: function linear(i) {\n      return i;\n    },\n    easeInQuad: function easeInQuad(i) {\n      return i * i;\n    },\n    easeOutQuad: function easeOutQuad(i) {\n      return -i * (i - 2);\n    },\n    easeInOutQuad: function easeInOutQuad(i) {\n      return (i /= 0.5) < 1 ? 0.5 * i * i : -0.5 * (--i * (i - 2) - 1);\n    },\n    easeInCubic: function easeInCubic(i) {\n      return i * i * i;\n    },\n    easeOutCubic: function easeOutCubic(i) {\n      return (i -= 1) * i * i + 1;\n    },\n    easeInOutCubic: function easeInOutCubic(i) {\n      return (i /= 0.5) < 1 ? 0.5 * i * i * i : 0.5 * ((i -= 2) * i * i + 2);\n    },\n    easeInQuart: function easeInQuart(i) {\n      return i * i * i * i;\n    },\n    easeOutQuart: function easeOutQuart(i) {\n      return -((i -= 1) * i * i * i - 1);\n    },\n    easeInOutQuart: function easeInOutQuart(i) {\n      return (i /= 0.5) < 1 ? 0.5 * i * i * i * i : -0.5 * ((i -= 2) * i * i * i - 2);\n    },\n    easeInQuint: function easeInQuint(i) {\n      return i * i * i * i * i;\n    },\n    easeOutQuint: function easeOutQuint(i) {\n      return (i -= 1) * i * i * i * i + 1;\n    },\n    easeInOutQuint: function easeInOutQuint(i) {\n      return (i /= 0.5) < 1 ? 0.5 * i * i * i * i * i : 0.5 * ((i -= 2) * i * i * i * i + 2);\n    },\n    easeInSine: function easeInSine(i) {\n      return -Math.cos(i * V) + 1;\n    },\n    easeOutSine: function easeOutSine(i) {\n      return Math.sin(i * V);\n    },\n    easeInOutSine: function easeInOutSine(i) {\n      return -0.5 * (Math.cos(E * i) - 1);\n    },\n    easeInExpo: function easeInExpo(i) {\n      return i === 0 ? 0 : Math.pow(2, 10 * (i - 1));\n    },\n    easeOutExpo: function easeOutExpo(i) {\n      return i === 1 ? 1 : -Math.pow(2, -10 * i) + 1;\n    },\n    easeInOutExpo: function easeInOutExpo(i) {\n      return ke(i) ? i : i < 0.5 ? 0.5 * Math.pow(2, 10 * (i * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (i * 2 - 1)) + 2);\n    },\n    easeInCirc: function easeInCirc(i) {\n      return i >= 1 ? i : -(Math.sqrt(1 - i * i) - 1);\n    },\n    easeOutCirc: function easeOutCirc(i) {\n      return Math.sqrt(1 - (i -= 1) * i);\n    },\n    easeInOutCirc: function easeInOutCirc(i) {\n      return (i /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - i * i) - 1) : 0.5 * (Math.sqrt(1 - (i -= 2) * i) + 1);\n    },\n    easeInElastic: function easeInElastic(i) {\n      return ke(i) ? i : ns(i, 0.075, 0.3);\n    },\n    easeOutElastic: function easeOutElastic(i) {\n      return ke(i) ? i : os(i, 0.075, 0.3);\n    },\n    easeInOutElastic: function easeInOutElastic(i) {\n      return ke(i) ? i : i < 0.5 ? 0.5 * ns(i * 2, 0.1125, 0.45) : 0.5 + 0.5 * os(i * 2 - 1, 0.1125, 0.45);\n    },\n    easeInBack: function easeInBack(i) {\n      return i * i * ((1.70158 + 1) * i - 1.70158);\n    },\n    easeOutBack: function easeOutBack(i) {\n      return (i -= 1) * i * ((1.70158 + 1) * i + 1.70158) + 1;\n    },\n    easeInOutBack: function easeInOutBack(i) {\n      var t = 1.70158;\n      return (i /= 0.5) < 1 ? 0.5 * (i * i * (((t *= 1.525) + 1) * i - t)) : 0.5 * ((i -= 2) * i * (((t *= 1.525) + 1) * i + t) + 2);\n    },\n    easeInBounce: function easeInBounce(i) {\n      return 1 - he.easeOutBounce(1 - i);\n    },\n    easeOutBounce: function easeOutBounce(i) {\n      return i < 1 / 2.75 ? 7.5625 * i * i : i < 2 / 2.75 ? 7.5625 * (i -= 1.5 / 2.75) * i + 0.75 : i < 2.5 / 2.75 ? 7.5625 * (i -= 2.25 / 2.75) * i + 0.9375 : 7.5625 * (i -= 2.625 / 2.75) * i + 0.984375;\n    },\n    easeInOutBounce: function easeInOutBounce(i) {\n      return i < 0.5 ? he.easeInBounce(i * 2) * 0.5 : he.easeOutBounce(i * 2 - 1) * 0.5 + 0.5;\n    }\n  };\nfunction Bi(i) {\n  if (i && _typeof(i) == \"object\") {\n    var t = i.toString();\n    return t === \"[object CanvasPattern]\" || t === \"[object CanvasGradient]\";\n  }\n  return !1;\n}\nfunction rs(i) {\n  return Bi(i) ? i : new ue(i);\n}\nfunction ni(i) {\n  return Bi(i) ? i : new ue(i).saturate(0.5).darken(0.1).hexString();\n}\nvar tr = [\"x\", \"y\", \"borderWidth\", \"radius\", \"tension\"],\n  er = [\"color\", \"borderColor\", \"backgroundColor\"];\nfunction ir(i) {\n  i.set(\"animation\", {\n    delay: void 0,\n    duration: 1e3,\n    easing: \"easeOutQuart\",\n    fn: void 0,\n    from: void 0,\n    loop: void 0,\n    to: void 0,\n    type: void 0\n  }), i.describe(\"animation\", {\n    _fallback: !1,\n    _indexable: !1,\n    _scriptable: function _scriptable(t) {\n      return t !== \"onProgress\" && t !== \"onComplete\" && t !== \"fn\";\n    }\n  }), i.set(\"animations\", {\n    colors: {\n      type: \"color\",\n      properties: er\n    },\n    numbers: {\n      type: \"number\",\n      properties: tr\n    }\n  }), i.describe(\"animations\", {\n    _fallback: \"animation\"\n  }), i.set(\"transitions\", {\n    active: {\n      animation: {\n        duration: 400\n      }\n    },\n    resize: {\n      animation: {\n        duration: 0\n      }\n    },\n    show: {\n      animations: {\n        colors: {\n          from: \"transparent\"\n        },\n        visible: {\n          type: \"boolean\",\n          duration: 0\n        }\n      }\n    },\n    hide: {\n      animations: {\n        colors: {\n          to: \"transparent\"\n        },\n        visible: {\n          type: \"boolean\",\n          easing: \"linear\",\n          fn: function fn(t) {\n            return t | 0;\n          }\n        }\n      }\n    }\n  });\n}\nfunction sr(i) {\n  i.set(\"layout\", {\n    autoPadding: !0,\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  });\n}\nvar as = /* @__PURE__ */new Map();\nfunction nr(i, t) {\n  t = t || {};\n  var e = i + JSON.stringify(t);\n  var s = as.get(e);\n  return s || (s = new Intl.NumberFormat(i, t), as.set(e, s)), s;\n}\nfunction Hi(i, t, e) {\n  return nr(t, e).format(i);\n}\nvar or = {\n  values: function values(i) {\n    return N(i) ? i : \"\" + i;\n  },\n  numeric: function numeric(i, t, e) {\n    if (i === 0) return \"0\";\n    var s = this.chart.options.locale;\n    var n,\n      o = i;\n    if (e.length > 1) {\n      var c = Math.max(Math.abs(e[0].value), Math.abs(e[e.length - 1].value));\n      (c < 1e-4 || c > 1e15) && (n = \"scientific\"), o = rr(i, e);\n    }\n    var r = xn(Math.abs(o)),\n      a = isNaN(r) ? 1 : Math.max(Math.min(-1 * Math.floor(r), 20), 0),\n      l = {\n        notation: n,\n        minimumFractionDigits: a,\n        maximumFractionDigits: a\n      };\n    return Object.assign(l, this.options.ticks.format), Hi(i, s, l);\n  }\n};\nfunction rr(i, t) {\n  var e = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;\n  return Math.abs(e) >= 1 && i !== Math.floor(i) && (e = i - Math.floor(i)), e;\n}\nvar Dn = {\n  formatters: or\n};\nfunction ar(i) {\n  i.set(\"scale\", {\n    display: !0,\n    offset: !1,\n    reverse: !1,\n    beginAtZero: !1,\n    bounds: \"ticks\",\n    clip: !0,\n    grace: 0,\n    grid: {\n      display: !0,\n      lineWidth: 1,\n      drawOnChartArea: !0,\n      drawTicks: !0,\n      tickLength: 8,\n      tickWidth: function tickWidth(t, e) {\n        return e.lineWidth;\n      },\n      tickColor: function tickColor(t, e) {\n        return e.color;\n      },\n      offset: !1\n    },\n    border: {\n      display: !0,\n      dash: [],\n      dashOffset: 0,\n      width: 1\n    },\n    title: {\n      display: !1,\n      text: \"\",\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n    ticks: {\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: !1,\n      textStrokeWidth: 0,\n      textStrokeColor: \"\",\n      padding: 3,\n      display: !0,\n      autoSkip: !0,\n      autoSkipPadding: 3,\n      labelOffset: 0,\n      callback: Dn.formatters.values,\n      minor: {},\n      major: {},\n      align: \"center\",\n      crossAlign: \"near\",\n      showLabelBackdrop: !1,\n      backdropColor: \"rgba(255, 255, 255, 0.75)\",\n      backdropPadding: 2\n    }\n  }), i.route(\"scale.ticks\", \"color\", \"\", \"color\"), i.route(\"scale.grid\", \"color\", \"\", \"borderColor\"), i.route(\"scale.border\", \"color\", \"\", \"borderColor\"), i.route(\"scale.title\", \"color\", \"\", \"color\"), i.describe(\"scale\", {\n    _fallback: !1,\n    _scriptable: function _scriptable(t) {\n      return !t.startsWith(\"before\") && !t.startsWith(\"after\") && t !== \"callback\" && t !== \"parser\";\n    },\n    _indexable: function _indexable(t) {\n      return t !== \"borderDash\" && t !== \"tickBorderDash\" && t !== \"dash\";\n    }\n  }), i.describe(\"scales\", {\n    _fallback: \"scale\"\n  }), i.describe(\"scale.ticks\", {\n    _scriptable: function _scriptable(t) {\n      return t !== \"backdropPadding\" && t !== \"callback\";\n    },\n    _indexable: function _indexable(t) {\n      return t !== \"backdropPadding\";\n    }\n  });\n}\nvar zt = /* @__PURE__ */Object.create(null),\n  Mi = /* @__PURE__ */Object.create(null);\nfunction de(i, t) {\n  if (!t) return i;\n  var e = t.split(\".\");\n  for (var s = 0, n = e.length; s < n; ++s) {\n    var o = e[s];\n    i = i[o] || (i[o] = /* @__PURE__ */Object.create(null));\n  }\n  return i;\n}\nfunction oi(i, t, e) {\n  return typeof t == \"string\" ? fe(de(i, t), e) : fe(de(i, \"\"), t);\n}\nvar lr = /*#__PURE__*/function () {\n  function lr(t, e) {\n    _classCallCheck(this, lr);\n    this.animation = void 0, this.backgroundColor = \"rgba(0,0,0,0.1)\", this.borderColor = \"rgba(0,0,0,0.1)\", this.color = \"#666\", this.datasets = {}, this.devicePixelRatio = function (s) {\n      return s.chart.platform.getDevicePixelRatio();\n    }, this.elements = {}, this.events = [\"mousemove\", \"mouseout\", \"click\", \"touchstart\", \"touchmove\"], this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: \"normal\",\n      lineHeight: 1.2,\n      weight: null\n    }, this.hover = {}, this.hoverBackgroundColor = function (s, n) {\n      return ni(n.backgroundColor);\n    }, this.hoverBorderColor = function (s, n) {\n      return ni(n.borderColor);\n    }, this.hoverColor = function (s, n) {\n      return ni(n.color);\n    }, this.indexAxis = \"x\", this.interaction = {\n      mode: \"nearest\",\n      intersect: !0,\n      includeInvisible: !1\n    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(e);\n  }\n  return _createClass(lr, [{\n    key: \"set\",\n    value: function set(t, e) {\n      return oi(this, t, e);\n    }\n  }, {\n    key: \"get\",\n    value: function get(t) {\n      return de(this, t);\n    }\n  }, {\n    key: \"describe\",\n    value: function describe(t, e) {\n      return oi(Mi, t, e);\n    }\n  }, {\n    key: \"override\",\n    value: function override(t, e) {\n      return oi(zt, t, e);\n    }\n  }, {\n    key: \"route\",\n    value: function route(t, e, s, n) {\n      var o = de(this, t),\n        r = de(this, s),\n        a = \"_\" + e;\n      Object.defineProperties(o, _defineProperty(_defineProperty({}, a, {\n        value: o[e],\n        writable: !0\n      }), e, {\n        enumerable: !0,\n        get: function get() {\n          var l = this[a],\n            c = r[n];\n          return T(l) ? Object.assign({}, c, l) : D(l, c);\n        },\n        set: function set(l) {\n          this[a] = l;\n        }\n      }));\n    }\n  }, {\n    key: \"apply\",\n    value: function apply(t) {\n      var _this2 = this;\n      t.forEach(function (e) {\n        return e(_this2);\n      });\n    }\n  }]);\n}();\nvar W = /* @__PURE__ */new lr({\n  _scriptable: function _scriptable(i) {\n    return !i.startsWith(\"on\");\n  },\n  _indexable: function _indexable(i) {\n    return i !== \"events\";\n  },\n  hover: {\n    _fallback: \"interaction\"\n  },\n  interaction: {\n    _scriptable: !1,\n    _indexable: !1\n  }\n}, [ir, sr, ar]);\nfunction cr(i) {\n  return !i || R(i.size) || R(i.family) ? null : (i.style ? i.style + \" \" : \"\") + (i.weight ? i.weight + \" \" : \"\") + i.size + \"px \" + i.family;\n}\nfunction ls(i, t, e, s, n) {\n  var o = t[n];\n  return o || (o = t[n] = i.measureText(n).width, e.push(n)), o > s && (s = o), s;\n}\nfunction Ot(i, t, e) {\n  var s = i.currentDevicePixelRatio,\n    n = e !== 0 ? Math.max(e / 2, 0.5) : 0;\n  return Math.round((t - n) * s) / s + n;\n}\nfunction cs(i, t) {\n  !t && !i || (t = t || i.getContext(\"2d\"), t.save(), t.resetTransform(), t.clearRect(0, 0, i.width, i.height), t.restore());\n}\nfunction Si(i, t, e, s) {\n  Cn(i, t, e, s, null);\n}\nfunction Cn(i, t, e, s, n) {\n  var o, r, a, l, c, h, d, u;\n  var f = t.pointStyle,\n    p = t.rotation,\n    g = t.radius;\n  var m = (p || 0) * No;\n  if (f && _typeof(f) == \"object\" && (o = f.toString(), o === \"[object HTMLImageElement]\" || o === \"[object HTMLCanvasElement]\")) {\n    i.save(), i.translate(e, s), i.rotate(m), i.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), i.restore();\n    return;\n  }\n  if (!(isNaN(g) || g <= 0)) {\n    switch (i.beginPath(), f) {\n      // Default includes circle\n      default:\n        n ? i.ellipse(e, s, n / 2, g, 0, 0, B) : i.arc(e, s, g, 0, B), i.closePath();\n        break;\n      case \"triangle\":\n        h = n ? n / 2 : g, i.moveTo(e + Math.sin(m) * h, s - Math.cos(m) * g), m += ts, i.lineTo(e + Math.sin(m) * h, s - Math.cos(m) * g), m += ts, i.lineTo(e + Math.sin(m) * h, s - Math.cos(m) * g), i.closePath();\n        break;\n      case \"rectRounded\":\n        c = g * 0.516, l = g - c, r = Math.cos(m + Ct) * l, d = Math.cos(m + Ct) * (n ? n / 2 - c : l), a = Math.sin(m + Ct) * l, u = Math.sin(m + Ct) * (n ? n / 2 - c : l), i.arc(e - d, s - a, c, m - E, m - V), i.arc(e + u, s - r, c, m - V, m), i.arc(e + d, s + a, c, m, m + V), i.arc(e - u, s + r, c, m + V, m + E), i.closePath();\n        break;\n      case \"rect\":\n        if (!p) {\n          l = Math.SQRT1_2 * g, h = n ? n / 2 : l, i.rect(e - h, s - l, 2 * h, 2 * l);\n          break;\n        }\n        m += Ct;\n      /* falls through */\n      case \"rectRot\":\n        d = Math.cos(m) * (n ? n / 2 : g), r = Math.cos(m) * g, a = Math.sin(m) * g, u = Math.sin(m) * (n ? n / 2 : g), i.moveTo(e - d, s - a), i.lineTo(e + u, s - r), i.lineTo(e + d, s + a), i.lineTo(e - u, s + r), i.closePath();\n        break;\n      case \"crossRot\":\n        m += Ct;\n      /* falls through */\n      case \"cross\":\n        d = Math.cos(m) * (n ? n / 2 : g), r = Math.cos(m) * g, a = Math.sin(m) * g, u = Math.sin(m) * (n ? n / 2 : g), i.moveTo(e - d, s - a), i.lineTo(e + d, s + a), i.moveTo(e + u, s - r), i.lineTo(e - u, s + r);\n        break;\n      case \"star\":\n        d = Math.cos(m) * (n ? n / 2 : g), r = Math.cos(m) * g, a = Math.sin(m) * g, u = Math.sin(m) * (n ? n / 2 : g), i.moveTo(e - d, s - a), i.lineTo(e + d, s + a), i.moveTo(e + u, s - r), i.lineTo(e - u, s + r), m += Ct, d = Math.cos(m) * (n ? n / 2 : g), r = Math.cos(m) * g, a = Math.sin(m) * g, u = Math.sin(m) * (n ? n / 2 : g), i.moveTo(e - d, s - a), i.lineTo(e + d, s + a), i.moveTo(e + u, s - r), i.lineTo(e - u, s + r);\n        break;\n      case \"line\":\n        r = n ? n / 2 : Math.cos(m) * g, a = Math.sin(m) * g, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a);\n        break;\n      case \"dash\":\n        i.moveTo(e, s), i.lineTo(e + Math.cos(m) * (n ? n / 2 : g), s + Math.sin(m) * g);\n        break;\n      case !1:\n        i.closePath();\n        break;\n    }\n    i.fill(), t.borderWidth > 0 && i.stroke();\n  }\n}\nfunction me(i, t, e) {\n  return e = e || 0.5, !t || i && i.x > t.left - e && i.x < t.right + e && i.y > t.top - e && i.y < t.bottom + e;\n}\nfunction Je(i, t) {\n  i.save(), i.beginPath(), i.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), i.clip();\n}\nfunction Ze(i) {\n  i.restore();\n}\nfunction hr(i, t, e, s, n) {\n  if (!t) return i.lineTo(e.x, e.y);\n  if (n === \"middle\") {\n    var o = (t.x + e.x) / 2;\n    i.lineTo(o, t.y), i.lineTo(o, e.y);\n  } else n === \"after\" != !!s ? i.lineTo(t.x, e.y) : i.lineTo(e.x, t.y);\n  i.lineTo(e.x, e.y);\n}\nfunction dr(i, t, e, s) {\n  if (!t) return i.lineTo(e.x, e.y);\n  i.bezierCurveTo(s ? t.cp1x : t.cp2x, s ? t.cp1y : t.cp2y, s ? e.cp2x : e.cp1x, s ? e.cp2y : e.cp1y, e.x, e.y);\n}\nfunction ur(i, t) {\n  t.translation && i.translate(t.translation[0], t.translation[1]), R(t.rotation) || i.rotate(t.rotation), t.color && (i.fillStyle = t.color), t.textAlign && (i.textAlign = t.textAlign), t.textBaseline && (i.textBaseline = t.textBaseline);\n}\nfunction fr(i, t, e, s, n) {\n  if (n.strikethrough || n.underline) {\n    var o = i.measureText(s),\n      r = t - o.actualBoundingBoxLeft,\n      a = t + o.actualBoundingBoxRight,\n      l = e - o.actualBoundingBoxAscent,\n      c = e + o.actualBoundingBoxDescent,\n      h = n.strikethrough ? (l + c) / 2 : c;\n    i.strokeStyle = i.fillStyle, i.beginPath(), i.lineWidth = n.decorationWidth || 2, i.moveTo(r, h), i.lineTo(a, h), i.stroke();\n  }\n}\nfunction gr(i, t) {\n  var e = i.fillStyle;\n  i.fillStyle = t.color, i.fillRect(t.left, t.top, t.width, t.height), i.fillStyle = e;\n}\nfunction be(i, t, e, s, n) {\n  var o = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n  var r = N(t) ? t : [t],\n    a = o.strokeWidth > 0 && o.strokeColor !== \"\";\n  var l, c;\n  for (i.save(), i.font = n.string, ur(i, o), l = 0; l < r.length; ++l) c = r[l], o.backdrop && gr(i, o.backdrop), a && (o.strokeColor && (i.strokeStyle = o.strokeColor), R(o.strokeWidth) || (i.lineWidth = o.strokeWidth), i.strokeText(c, e, s, o.maxWidth)), i.fillText(c, e, s, o.maxWidth), fr(i, e, s, c, o), s += Number(n.lineHeight);\n  i.restore();\n}\nfunction Ue(i, t) {\n  var e = t.x,\n    s = t.y,\n    n = t.w,\n    o = t.h,\n    r = t.radius;\n  i.arc(e + r.topLeft, s + r.topLeft, r.topLeft, 1.5 * E, E, !0), i.lineTo(e, s + o - r.bottomLeft), i.arc(e + r.bottomLeft, s + o - r.bottomLeft, r.bottomLeft, E, V, !0), i.lineTo(e + n - r.bottomRight, s + o), i.arc(e + n - r.bottomRight, s + o - r.bottomRight, r.bottomRight, V, 0, !0), i.lineTo(e + n, s + r.topRight), i.arc(e + n - r.topRight, s + r.topRight, r.topRight, 0, -V, !0), i.lineTo(e + r.topLeft, s);\n}\nvar pr = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/,\n  mr = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\nfunction br(i, t) {\n  var e = (\"\" + i).match(pr);\n  if (!e || e[1] === \"normal\") return t * 1.2;\n  switch (i = +e[2], e[3]) {\n    case \"px\":\n      return i;\n    case \"%\":\n      i /= 100;\n      break;\n  }\n  return t * i;\n}\nvar _r = function _r(i) {\n  return +i || 0;\n};\nfunction Wi(i, t) {\n  var e = {},\n    s = T(t),\n    n = s ? Object.keys(t) : t,\n    o = T(i) ? s ? function (r) {\n      return D(i[r], i[t[r]]);\n    } : function (r) {\n      return i[r];\n    } : function () {\n      return i;\n    };\n  var _iterator4 = _createForOfIteratorHelper(n),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var r = _step4.value;\n      e[r] = _r(o(r));\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return e;\n}\nfunction On(i) {\n  return Wi(i, {\n    top: \"y\",\n    right: \"x\",\n    bottom: \"y\",\n    left: \"x\"\n  });\n}\nfunction Yt(i) {\n  return Wi(i, [\"topLeft\", \"topRight\", \"bottomLeft\", \"bottomRight\"]);\n}\nfunction et(i) {\n  var t = On(i);\n  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;\n}\nfunction X(i, t) {\n  i = i || {}, t = t || W.font;\n  var e = D(i.size, t.size);\n  typeof e == \"string\" && (e = parseInt(e, 10));\n  var s = D(i.style, t.style);\n  s && !(\"\" + s).match(mr) && (console.warn('Invalid font style specified: \"' + s + '\"'), s = void 0);\n  var n = {\n    family: D(i.family, t.family),\n    lineHeight: br(D(i.lineHeight, t.lineHeight), e),\n    size: e,\n    style: s,\n    weight: D(i.weight, t.weight),\n    string: \"\"\n  };\n  return n.string = cr(n), n;\n}\nfunction we(i, t, e, s) {\n  var n, o, r;\n  for (n = 0, o = i.length; n < o; ++n) if (r = i[n], r !== void 0 && r !== void 0) return r;\n}\nfunction xr(i, t, e) {\n  var s = i.min,\n    n = i.max,\n    o = bn(t, (n - s) / 2),\n    r = function r(a, l) {\n      return e && a === 0 ? 0 : a + l;\n    };\n  return {\n    min: r(s, -Math.abs(o)),\n    max: r(n, o)\n  };\n}\nfunction Bt(i, t) {\n  return Object.assign(Object.create(i), t);\n}\nfunction Ni(i) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [\"\"];\n  var e = arguments.length > 2 ? arguments[2] : undefined;\n  var s = arguments.length > 3 ? arguments[3] : undefined;\n  var n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {\n    return i[0];\n  };\n  var o = e || i;\n  _typeof(s) > \"u\" && (s = Ln(\"_fallback\", i));\n  var r = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, Symbol.toStringTag, \"Object\"), \"_cacheable\", !0), \"_scopes\", i), \"_rootScopes\", o), \"_fallback\", s), \"_getTarget\", n), \"override\", function override(a) {\n    return Ni([a].concat(_toConsumableArray(i)), t, o, s);\n  });\n  return new Proxy(r, {\n    /**\n    * A trap for the delete operator.\n    */\n    deleteProperty: function deleteProperty(a, l) {\n      return delete a[l], delete a._keys, delete i[0][l], !0;\n    },\n    /**\n    * A trap for getting property values.\n    */\n    get: function get(a, l) {\n      return An(a, l, function () {\n        return Dr(l, t, i, a);\n      });\n    },\n    /**\n    * A trap for Object.getOwnPropertyDescriptor.\n    * Also used by Object.hasOwnProperty.\n    */\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(a, l) {\n      return Reflect.getOwnPropertyDescriptor(a._scopes[0], l);\n    },\n    /**\n    * A trap for Object.getPrototypeOf.\n    */\n    getPrototypeOf: function getPrototypeOf() {\n      return Reflect.getPrototypeOf(i[0]);\n    },\n    /**\n    * A trap for the in operator.\n    */\n    has: function has(a, l) {\n      return ds(a).includes(l);\n    },\n    /**\n    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n    */\n    ownKeys: function ownKeys(a) {\n      return ds(a);\n    },\n    /**\n    * A trap for setting property values.\n    */\n    set: function set(a, l, c) {\n      var h = a._storage || (a._storage = n());\n      return a[l] = h[l] = c, delete a._keys, !0;\n    }\n  });\n}\nfunction qt(i, t, e, s) {\n  var n = {\n    _cacheable: !1,\n    _proxy: i,\n    _context: t,\n    _subProxy: e,\n    _stack: /* @__PURE__ */new Set(),\n    _descriptors: Tn(i, s),\n    setContext: function setContext(o) {\n      return qt(i, o, e, s);\n    },\n    override: function override(o) {\n      return qt(i.override(o), t, e, s);\n    }\n  };\n  return new Proxy(n, {\n    /**\n    * A trap for the delete operator.\n    */\n    deleteProperty: function deleteProperty(o, r) {\n      return delete o[r], delete i[r], !0;\n    },\n    /**\n    * A trap for getting property values.\n    */\n    get: function get(o, r, a) {\n      return An(o, r, function () {\n        return vr(o, r, a);\n      });\n    },\n    /**\n    * A trap for Object.getOwnPropertyDescriptor.\n    * Also used by Object.hasOwnProperty.\n    */\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(o, r) {\n      return o._descriptors.allKeys ? Reflect.has(i, r) ? {\n        enumerable: !0,\n        configurable: !0\n      } : void 0 : Reflect.getOwnPropertyDescriptor(i, r);\n    },\n    /**\n    * A trap for Object.getPrototypeOf.\n    */\n    getPrototypeOf: function getPrototypeOf() {\n      return Reflect.getPrototypeOf(i);\n    },\n    /**\n    * A trap for the in operator.\n    */\n    has: function has(o, r) {\n      return Reflect.has(i, r);\n    },\n    /**\n    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n    */\n    ownKeys: function ownKeys() {\n      return Reflect.ownKeys(i);\n    },\n    /**\n    * A trap for setting property values.\n    */\n    set: function set(o, r, a) {\n      return i[r] = a, delete o[r], !0;\n    }\n  });\n}\nfunction Tn(i) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    scriptable: !0,\n    indexable: !0\n  };\n  var _i$_scriptable = i._scriptable,\n    e = _i$_scriptable === void 0 ? t.scriptable : _i$_scriptable,\n    _i$_indexable = i._indexable,\n    s = _i$_indexable === void 0 ? t.indexable : _i$_indexable,\n    _i$_allKeys = i._allKeys,\n    n = _i$_allKeys === void 0 ? t.allKeys : _i$_allKeys;\n  return {\n    allKeys: n,\n    scriptable: e,\n    indexable: s,\n    isScriptable: wt(e) ? e : function () {\n      return e;\n    },\n    isIndexable: wt(s) ? s : function () {\n      return s;\n    }\n  };\n}\nvar yr = function yr(i, t) {\n    return i ? i + Fi(t) : t;\n  },\n  Vi = function Vi(i, t) {\n    return T(t) && i !== \"adapters\" && (Object.getPrototypeOf(t) === null || t.constructor === Object);\n  };\nfunction An(i, t, e) {\n  if (Object.prototype.hasOwnProperty.call(i, t) || t === \"constructor\") return i[t];\n  var s = e();\n  return i[t] = s, s;\n}\nfunction vr(i, t, e) {\n  var s = i._proxy,\n    n = i._context,\n    o = i._subProxy,\n    r = i._descriptors;\n  var a = s[t];\n  return wt(a) && r.isScriptable(t) && (a = Mr(t, a, i, e)), N(a) && a.length && (a = Sr(t, a, i, r.isIndexable)), Vi(t, a) && (a = qt(a, n, o && o[t], r)), a;\n}\nfunction Mr(i, t, e, s) {\n  var n = e._proxy,\n    o = e._context,\n    r = e._subProxy,\n    a = e._stack;\n  if (a.has(i)) throw new Error(\"Recursion detected: \" + Array.from(a).join(\"->\") + \"->\" + i);\n  a.add(i);\n  var l = t(o, r || s);\n  return a[\"delete\"](i), Vi(i, l) && (l = ji(n._scopes, n, i, l)), l;\n}\nfunction Sr(i, t, e, s) {\n  var n = e._proxy,\n    o = e._context,\n    r = e._subProxy,\n    a = e._descriptors;\n  if (_typeof(o.index) < \"u\" && s(i)) return t[o.index % t.length];\n  if (T(t[0])) {\n    var l = t,\n      c = n._scopes.filter(function (h) {\n        return h !== l;\n      });\n    t = [];\n    var _iterator5 = _createForOfIteratorHelper(l),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var h = _step5.value;\n        var d = ji(c, n, i, h);\n        t.push(qt(d, o, r && r[i], a));\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  }\n  return t;\n}\nfunction Rn(i, t, e) {\n  return wt(i) ? i(t, e) : i;\n}\nvar kr = function kr(i, t) {\n  return i === !0 ? t : typeof i == \"string\" ? It(t, i) : void 0;\n};\nfunction wr(i, t, e, s, n) {\n  var _iterator6 = _createForOfIteratorHelper(t),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var o = _step6.value;\n      var r = kr(e, o);\n      if (r) {\n        i.add(r);\n        var a = Rn(r._fallback, e, n);\n        if (_typeof(a) < \"u\" && a !== e && a !== s) return a;\n      } else if (r === !1 && _typeof(s) < \"u\" && e !== s) return null;\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  return !1;\n}\nfunction ji(i, t, e, s) {\n  var n = t._rootScopes,\n    o = Rn(t._fallback, e, s),\n    r = [].concat(_toConsumableArray(i), _toConsumableArray(n)),\n    a = /* @__PURE__ */new Set();\n  a.add(s);\n  var l = hs(a, r, e, o || e, s);\n  return l === null || _typeof(o) < \"u\" && o !== e && (l = hs(a, r, o, l, s), l === null) ? !1 : Ni(Array.from(a), [\"\"], n, o, function () {\n    return Pr(t, e, s);\n  });\n}\nfunction hs(i, t, e, s, n) {\n  for (; e;) e = wr(i, t, e, s, n);\n  return e;\n}\nfunction Pr(i, t, e) {\n  var s = i._getTarget();\n  t in s || (s[t] = {});\n  var n = s[t];\n  return N(n) && T(e) ? e : n || {};\n}\nfunction Dr(i, t, e, s) {\n  var n;\n  var _iterator7 = _createForOfIteratorHelper(t),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var o = _step7.value;\n      if (n = Ln(yr(o, i), e), _typeof(n) < \"u\") return Vi(i, n) ? ji(e, s, i, n) : n;\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n}\nfunction Ln(i, t) {\n  var _iterator8 = _createForOfIteratorHelper(t),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var e = _step8.value;\n      if (!e) continue;\n      var s = e[i];\n      if (_typeof(s) < \"u\") return s;\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n}\nfunction ds(i) {\n  var t = i._keys;\n  return t || (t = i._keys = Cr(i._scopes)), t;\n}\nfunction Cr(i) {\n  var t = /* @__PURE__ */new Set();\n  var _iterator9 = _createForOfIteratorHelper(i),\n    _step9;\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var e = _step9.value;\n      var _iterator0 = _createForOfIteratorHelper(Object.keys(e).filter(function (n) {\n          return !n.startsWith(\"_\");\n        })),\n        _step0;\n      try {\n        for (_iterator0.s(); !(_step0 = _iterator0.n()).done;) {\n          var s = _step0.value;\n          t.add(s);\n        }\n      } catch (err) {\n        _iterator0.e(err);\n      } finally {\n        _iterator0.f();\n      }\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n  return Array.from(t);\n}\nvar Or = Number.EPSILON || 1e-14,\n  Kt = function Kt(i, t) {\n    return t < i.length && !i[t].skip && i[t];\n  },\n  En = function En(i) {\n    return i === \"x\" ? \"y\" : \"x\";\n  };\nfunction Tr(i, t, e, s) {\n  var n = i.skip ? t : i,\n    o = t,\n    r = e.skip ? t : e,\n    a = vi(o, n),\n    l = vi(r, o);\n  var c = a / (a + l),\n    h = l / (a + l);\n  c = isNaN(c) ? 0 : c, h = isNaN(h) ? 0 : h;\n  var d = s * c,\n    u = s * h;\n  return {\n    previous: {\n      x: o.x - d * (r.x - n.x),\n      y: o.y - d * (r.y - n.y)\n    },\n    next: {\n      x: o.x + u * (r.x - n.x),\n      y: o.y + u * (r.y - n.y)\n    }\n  };\n}\nfunction Ar(i, t, e) {\n  var s = i.length;\n  var n,\n    o,\n    r,\n    a,\n    l,\n    c = Kt(i, 0);\n  for (var h = 0; h < s - 1; ++h) if (l = c, c = Kt(i, h + 1), !(!l || !c)) {\n    if (ce(t[h], 0, Or)) {\n      e[h] = e[h + 1] = 0;\n      continue;\n    }\n    n = e[h] / t[h], o = e[h + 1] / t[h], a = Math.pow(n, 2) + Math.pow(o, 2), !(a <= 9) && (r = 3 / Math.sqrt(a), e[h] = n * r * t[h], e[h + 1] = o * r * t[h]);\n  }\n}\nfunction Rr(i, t) {\n  var e = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"x\";\n  var s = En(e),\n    n = i.length;\n  var o,\n    r,\n    a,\n    l = Kt(i, 0);\n  for (var c = 0; c < n; ++c) {\n    if (r = a, a = l, l = Kt(i, c + 1), !a) continue;\n    var h = a[e],\n      d = a[s];\n    r && (o = (h - r[e]) / 3, a[\"cp1\".concat(e)] = h - o, a[\"cp1\".concat(s)] = d - o * t[c]), l && (o = (l[e] - h) / 3, a[\"cp2\".concat(e)] = h + o, a[\"cp2\".concat(s)] = d + o * t[c]);\n  }\n}\nfunction Lr(i) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"x\";\n  var e = En(t),\n    s = i.length,\n    n = Array(s).fill(0),\n    o = Array(s);\n  var r,\n    a,\n    l,\n    c = Kt(i, 0);\n  for (r = 0; r < s; ++r) if (a = l, l = c, c = Kt(i, r + 1), !!l) {\n    if (c) {\n      var h = c[t] - l[t];\n      n[r] = h !== 0 ? (c[e] - l[e]) / h : 0;\n    }\n    o[r] = a ? c ? lt(n[r - 1]) !== lt(n[r]) ? 0 : (n[r - 1] + n[r]) / 2 : n[r - 1] : n[r];\n  }\n  Ar(i, n, o), Rr(i, o, t);\n}\nfunction Pe(i, t, e) {\n  return Math.max(Math.min(i, e), t);\n}\nfunction Er(i, t) {\n  var e,\n    s,\n    n,\n    o,\n    r,\n    a = me(i[0], t);\n  for (e = 0, s = i.length; e < s; ++e) r = o, o = a, a = e < s - 1 && me(i[e + 1], t), o && (n = i[e], r && (n.cp1x = Pe(n.cp1x, t.left, t.right), n.cp1y = Pe(n.cp1y, t.top, t.bottom)), a && (n.cp2x = Pe(n.cp2x, t.left, t.right), n.cp2y = Pe(n.cp2y, t.top, t.bottom)));\n}\nfunction Fr(i, t, e, s, n) {\n  var o, r, a, l;\n  if (t.spanGaps && (i = i.filter(function (c) {\n    return !c.skip;\n  })), t.cubicInterpolationMode === \"monotone\") Lr(i, n);else {\n    var c = s ? i[i.length - 1] : i[0];\n    for (o = 0, r = i.length; o < r; ++o) a = i[o], l = Tr(c, a, i[Math.min(o + 1, r - (s ? 0 : 1)) % r], t.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, c = a;\n  }\n  t.capBezierPoints && Er(i, e);\n}\nfunction $i() {\n  return (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) < \"u\" && (typeof document === \"undefined\" ? \"undefined\" : _typeof(document)) < \"u\";\n}\nfunction Yi(i) {\n  var t = i.parentNode;\n  return t && t.toString() === \"[object ShadowRoot]\" && (t = t.host), t;\n}\nfunction Xe(i, t, e) {\n  var s;\n  return typeof i == \"string\" ? (s = parseInt(i, 10), i.indexOf(\"%\") !== -1 && (s = s / 100 * t.parentNode[e])) : s = i, s;\n}\nvar Qe = function Qe(i) {\n  return i.ownerDocument.defaultView.getComputedStyle(i, null);\n};\nfunction Ir(i, t) {\n  return Qe(i).getPropertyValue(t);\n}\nvar zr = [\"top\", \"right\", \"bottom\", \"left\"];\nfunction Ft(i, t, e) {\n  var s = {};\n  e = e ? \"-\" + e : \"\";\n  for (var n = 0; n < 4; n++) {\n    var o = zr[n];\n    s[o] = parseFloat(i[t + \"-\" + o + e]) || 0;\n  }\n  return s.width = s.left + s.right, s.height = s.top + s.bottom, s;\n}\nvar Br = function Br(i, t, e) {\n  return (i > 0 || t > 0) && (!e || !e.shadowRoot);\n};\nfunction Hr(i, t) {\n  var e = i.touches,\n    s = e && e.length ? e[0] : i,\n    n = s.offsetX,\n    o = s.offsetY;\n  var r = !1,\n    a,\n    l;\n  if (Br(n, o, i.target)) a = n, l = o;else {\n    var c = t.getBoundingClientRect();\n    a = s.clientX - c.left, l = s.clientY - c.top, r = !0;\n  }\n  return {\n    x: a,\n    y: l,\n    box: r\n  };\n}\nfunction At(i, t) {\n  if (\"native\" in i) return i;\n  var e = t.canvas,\n    s = t.currentDevicePixelRatio,\n    n = Qe(e),\n    o = n.boxSizing === \"border-box\",\n    r = Ft(n, \"padding\"),\n    a = Ft(n, \"border\", \"width\"),\n    _Hr = Hr(i, e),\n    l = _Hr.x,\n    c = _Hr.y,\n    h = _Hr.box,\n    d = r.left + (h && a.left),\n    u = r.top + (h && a.top);\n  var f = t.width,\n    p = t.height;\n  return o && (f -= r.width + a.width, p -= r.height + a.height), {\n    x: Math.round((l - d) / f * e.width / s),\n    y: Math.round((c - u) / p * e.height / s)\n  };\n}\nfunction Wr(i, t, e) {\n  var s, n;\n  if (t === void 0 || e === void 0) {\n    var o = i && Yi(i);\n    if (!o) t = i.clientWidth, e = i.clientHeight;else {\n      var r = o.getBoundingClientRect(),\n        a = Qe(o),\n        l = Ft(a, \"border\", \"width\"),\n        c = Ft(a, \"padding\");\n      t = r.width - c.width - l.width, e = r.height - c.height - l.height, s = Xe(a.maxWidth, o, \"clientWidth\"), n = Xe(a.maxHeight, o, \"clientHeight\");\n    }\n  }\n  return {\n    width: t,\n    height: e,\n    maxWidth: s || Ye,\n    maxHeight: n || Ye\n  };\n}\nvar yt = function yt(i) {\n  return Math.round(i * 10) / 10;\n};\nfunction Nr(i, t, e, s) {\n  var n = Qe(i),\n    o = Ft(n, \"margin\"),\n    r = Xe(n.maxWidth, i, \"clientWidth\") || Ye,\n    a = Xe(n.maxHeight, i, \"clientHeight\") || Ye,\n    l = Wr(i, t, e);\n  var c = l.width,\n    h = l.height;\n  if (n.boxSizing === \"content-box\") {\n    var u = Ft(n, \"border\", \"width\"),\n      f = Ft(n, \"padding\");\n    c -= f.width + u.width, h -= f.height + u.height;\n  }\n  return c = Math.max(0, c - o.width), h = Math.max(0, s ? c / s : h - o.height), c = yt(Math.min(c, r, l.maxWidth)), h = yt(Math.min(h, a, l.maxHeight)), c && !h && (h = yt(c / 2)), (t !== void 0 || e !== void 0) && s && l.height && h > l.height && (h = l.height, c = yt(Math.floor(h * s))), {\n    width: c,\n    height: h\n  };\n}\nfunction us(i, t, e) {\n  var s = t || 1,\n    n = yt(i.height * s),\n    o = yt(i.width * s);\n  i.height = yt(i.height), i.width = yt(i.width);\n  var r = i.canvas;\n  return r.style && (e || !r.style.height && !r.style.width) && (r.style.height = \"\".concat(i.height, \"px\"), r.style.width = \"\".concat(i.width, \"px\")), i.currentDevicePixelRatio !== s || r.height !== n || r.width !== o ? (i.currentDevicePixelRatio = s, r.height = n, r.width = o, i.ctx.setTransform(s, 0, 0, s, 0, 0), !0) : !1;\n}\nvar Vr = function () {\n  var i = !1;\n  try {\n    var t = {\n      get passive() {\n        return i = !0, !1;\n      }\n    };\n    $i() && (window.addEventListener(\"test\", null, t), window.removeEventListener(\"test\", null, t));\n  } catch (_unused) {}\n  return i;\n}();\nfunction fs(i, t) {\n  var e = Ir(i, t),\n    s = e && e.match(/^(\\d+)(\\.\\d+)?px$/);\n  return s ? +s[1] : void 0;\n}\nfunction Rt(i, t, e, s) {\n  return {\n    x: i.x + e * (t.x - i.x),\n    y: i.y + e * (t.y - i.y)\n  };\n}\nfunction jr(i, t, e, s) {\n  return {\n    x: i.x + e * (t.x - i.x),\n    y: s === \"middle\" ? e < 0.5 ? i.y : t.y : s === \"after\" ? e < 1 ? i.y : t.y : e > 0 ? t.y : i.y\n  };\n}\nfunction $r(i, t, e, s) {\n  var n = {\n      x: i.cp2x,\n      y: i.cp2y\n    },\n    o = {\n      x: t.cp1x,\n      y: t.cp1y\n    },\n    r = Rt(i, n, e),\n    a = Rt(n, o, e),\n    l = Rt(o, t, e),\n    c = Rt(r, a, e),\n    h = Rt(a, l, e);\n  return Rt(c, h, e);\n}\nvar Yr = function Yr(i, t) {\n    return {\n      x: function x(e) {\n        return i + i + t - e;\n      },\n      setWidth: function setWidth(e) {\n        t = e;\n      },\n      textAlign: function textAlign(e) {\n        return e === \"center\" ? e : e === \"right\" ? \"left\" : \"right\";\n      },\n      xPlus: function xPlus(e, s) {\n        return e - s;\n      },\n      leftForLtr: function leftForLtr(e, s) {\n        return e - s;\n      }\n    };\n  },\n  Ur = function Ur() {\n    return {\n      x: function x(i) {\n        return i;\n      },\n      setWidth: function setWidth(i) {},\n      textAlign: function textAlign(i) {\n        return i;\n      },\n      xPlus: function xPlus(i, t) {\n        return i + t;\n      },\n      leftForLtr: function leftForLtr(i, t) {\n        return i;\n      }\n    };\n  };\nfunction Ut(i, t, e) {\n  return i ? Yr(t, e) : Ur();\n}\nfunction Fn(i, t) {\n  var e, s;\n  (t === \"ltr\" || t === \"rtl\") && (e = i.canvas.style, s = [e.getPropertyValue(\"direction\"), e.getPropertyPriority(\"direction\")], e.setProperty(\"direction\", t, \"important\"), i.prevTextDirection = s);\n}\nfunction In(i, t) {\n  t !== void 0 && (delete i.prevTextDirection, i.canvas.style.setProperty(\"direction\", t[0], t[1]));\n}\nfunction zn(i) {\n  return i === \"angle\" ? {\n    between: pe,\n    compare: Xo,\n    normalize: Z\n  } : {\n    between: _t,\n    compare: function compare(t, e) {\n      return t - e;\n    },\n    normalize: function normalize(t) {\n      return t;\n    }\n  };\n}\nfunction gs(_ref) {\n  var i = _ref.start,\n    t = _ref.end,\n    e = _ref.count,\n    s = _ref.loop,\n    n = _ref.style;\n  return {\n    start: i % e,\n    end: t % e,\n    loop: s && (t - i + 1) % e === 0,\n    style: n\n  };\n}\nfunction Xr(i, t, e) {\n  var s = e.property,\n    n = e.start,\n    o = e.end,\n    _zn = zn(s),\n    r = _zn.between,\n    a = _zn.normalize,\n    l = t.length;\n  var c = i.start,\n    h = i.end,\n    d = i.loop,\n    u,\n    f;\n  if (d) {\n    for (c += l, h += l, u = 0, f = l; u < f && r(a(t[c % l][s]), n, o); ++u) c--, h--;\n    c %= l, h %= l;\n  }\n  return h < c && (h += l), {\n    start: c,\n    end: h,\n    loop: d,\n    style: i.style\n  };\n}\nfunction Bn(i, t, e) {\n  if (!e) return [i];\n  var s = e.property,\n    n = e.start,\n    o = e.end,\n    r = t.length,\n    _zn2 = zn(s),\n    a = _zn2.compare,\n    l = _zn2.between,\n    c = _zn2.normalize,\n    _Xr = Xr(i, t, e),\n    h = _Xr.start,\n    d = _Xr.end,\n    u = _Xr.loop,\n    f = _Xr.style,\n    p = [];\n  var g = !1,\n    m = null,\n    b,\n    _,\n    v;\n  var y = function y() {\n      return l(n, v, b) && a(n, v) !== 0;\n    },\n    x = function x() {\n      return a(o, b) === 0 || l(o, v, b);\n    },\n    M = function M() {\n      return g || y();\n    },\n    S = function S() {\n      return !g || x();\n    };\n  for (var k = h, P = h; k <= d; ++k) _ = t[k % r], !_.skip && (b = c(_[s]), b !== v && (g = l(b, n, o), m === null && M() && (m = a(b, n) === 0 ? k : P), m !== null && S() && (p.push(gs({\n    start: m,\n    end: k,\n    loop: u,\n    count: r,\n    style: f\n  })), m = null), P = k, v = b));\n  return m !== null && p.push(gs({\n    start: m,\n    end: d,\n    loop: u,\n    count: r,\n    style: f\n  })), p;\n}\nfunction Hn(i, t) {\n  var e = [],\n    s = i.segments;\n  for (var n = 0; n < s.length; n++) {\n    var o = Bn(s[n], i.points, t);\n    o.length && e.push.apply(e, _toConsumableArray(o));\n  }\n  return e;\n}\nfunction qr(i, t, e, s) {\n  var n = 0,\n    o = t - 1;\n  if (e && !s) for (; n < t && !i[n].skip;) n++;\n  for (; n < t && i[n].skip;) n++;\n  for (n %= t, e && (o += n); o > n && i[o % t].skip;) o--;\n  return o %= t, {\n    start: n,\n    end: o\n  };\n}\nfunction Kr(i, t, e, s) {\n  var n = i.length,\n    o = [];\n  var r = t,\n    a = i[t],\n    l;\n  for (l = t + 1; l <= e; ++l) {\n    var c = i[l % n];\n    c.skip || c.stop ? a.skip || (s = !1, o.push({\n      start: t % n,\n      end: (l - 1) % n,\n      loop: s\n    }), t = r = c.stop ? l : null) : (r = l, a.skip && (t = l)), a = c;\n  }\n  return r !== null && o.push({\n    start: t % n,\n    end: r % n,\n    loop: s\n  }), o;\n}\nfunction Gr(i, t) {\n  var e = i.points,\n    s = i.options.spanGaps,\n    n = e.length;\n  if (!n) return [];\n  var o = !!i._loop,\n    _qr = qr(e, n, o, s),\n    r = _qr.start,\n    a = _qr.end;\n  if (s === !0) return ps(i, [{\n    start: r,\n    end: a,\n    loop: o\n  }], e, t);\n  var l = a < r ? a + n : a,\n    c = !!i._fullLoop && r === 0 && a === n - 1;\n  return ps(i, Kr(e, r, l, c), e, t);\n}\nfunction ps(i, t, e, s) {\n  return !s || !s.setContext || !e ? t : Jr(i, t, e, s);\n}\nfunction Jr(i, t, e, s) {\n  var n = i._chart.getContext(),\n    o = ms(i.options),\n    r = i._datasetIndex,\n    a = i.options.spanGaps,\n    l = e.length,\n    c = [];\n  var h = o,\n    d = t[0].start,\n    u = d;\n  function f(p, g, m, b) {\n    var _ = a ? -1 : 1;\n    if (p !== g) {\n      for (p += l; e[p % l].skip;) p -= _;\n      for (; e[g % l].skip;) g += _;\n      p % l !== g % l && (c.push({\n        start: p % l,\n        end: g % l,\n        loop: m,\n        style: b\n      }), h = b, d = g % l);\n    }\n  }\n  var _iterator1 = _createForOfIteratorHelper(t),\n    _step1;\n  try {\n    for (_iterator1.s(); !(_step1 = _iterator1.n()).done;) {\n      var p = _step1.value;\n      d = a ? d : p.start;\n      var g = e[d % l],\n        m = void 0;\n      for (u = d + 1; u <= p.end; u++) {\n        var b = e[u % l];\n        m = ms(s.setContext(Bt(n, {\n          type: \"segment\",\n          p0: g,\n          p1: b,\n          p0DataIndex: (u - 1) % l,\n          p1DataIndex: u % l,\n          datasetIndex: r\n        }))), Zr(m, h) && f(d, u - 1, p.loop, h), g = b, h = m;\n      }\n      d < u - 1 && f(d, u - 1, p.loop, h);\n    }\n  } catch (err) {\n    _iterator1.e(err);\n  } finally {\n    _iterator1.f();\n  }\n  return c;\n}\nfunction ms(i) {\n  return {\n    backgroundColor: i.backgroundColor,\n    borderCapStyle: i.borderCapStyle,\n    borderDash: i.borderDash,\n    borderDashOffset: i.borderDashOffset,\n    borderJoinStyle: i.borderJoinStyle,\n    borderWidth: i.borderWidth,\n    borderColor: i.borderColor\n  };\n}\nfunction Zr(i, t) {\n  if (!t) return !1;\n  var e = [],\n    s = function s(n, o) {\n      return Bi(o) ? (e.includes(o) || e.push(o), e.indexOf(o)) : o;\n    };\n  return JSON.stringify(i, s) !== JSON.stringify(t, s);\n}\nfunction De(i, t, e) {\n  return i.options.clip ? i[e] : t[e];\n}\nfunction Qr(i, t) {\n  var e = i.xScale,\n    s = i.yScale;\n  return e && s ? {\n    left: De(e, t, \"left\"),\n    right: De(e, t, \"right\"),\n    top: De(s, t, \"top\"),\n    bottom: De(s, t, \"bottom\")\n  } : t;\n}\nfunction Wn(i, t) {\n  var e = t._clip;\n  if (e.disabled) return !1;\n  var s = Qr(t, i.chartArea);\n  return {\n    left: e.left === !1 ? 0 : s.left - (e.left === !0 ? 0 : e.left),\n    right: e.right === !1 ? i.width : s.right + (e.right === !0 ? 0 : e.right),\n    top: e.top === !1 ? 0 : s.top - (e.top === !0 ? 0 : e.top),\n    bottom: e.bottom === !1 ? i.height : s.bottom + (e.bottom === !0 ? 0 : e.bottom)\n  };\n}\n/*!\n * Chart.js v4.5.1\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */\nvar ta = /*#__PURE__*/function () {\n  function ta() {\n    _classCallCheck(this, ta);\n    this._request = null, this._charts = /* @__PURE__ */new Map(), this._running = !1, this._lastDate = void 0;\n  }\n  return _createClass(ta, [{\n    key: \"_notify\",\n    value: function _notify(t, e, s, n) {\n      var o = e.listeners[n],\n        r = e.duration;\n      o.forEach(function (a) {\n        return a({\n          chart: t,\n          initial: e.initial,\n          numSteps: r,\n          currentStep: Math.min(s - e.start, r)\n        });\n      });\n    }\n  }, {\n    key: \"_refresh\",\n    value: function _refresh() {\n      var _this3 = this;\n      this._request || (this._running = !0, this._request = Sn.call(window, function () {\n        _this3._update(), _this3._request = null, _this3._running && _this3._refresh();\n      }));\n    }\n  }, {\n    key: \"_update\",\n    value: function _update() {\n      var _this4 = this;\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Date.now();\n      var e = 0;\n      this._charts.forEach(function (s, n) {\n        if (!s.running || !s.items.length) return;\n        var o = s.items;\n        var r = o.length - 1,\n          a = !1,\n          l;\n        for (; r >= 0; --r) l = o[r], l._active ? (l._total > s.duration && (s.duration = l._total), l.tick(t), a = !0) : (o[r] = o[o.length - 1], o.pop());\n        a && (n.draw(), _this4._notify(n, s, t, \"progress\")), o.length || (s.running = !1, _this4._notify(n, s, t, \"complete\"), s.initial = !1), e += o.length;\n      }), this._lastDate = t, e === 0 && (this._running = !1);\n    }\n  }, {\n    key: \"_getAnims\",\n    value: function _getAnims(t) {\n      var e = this._charts;\n      var s = e.get(t);\n      return s || (s = {\n        running: !1,\n        initial: !0,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      }, e.set(t, s)), s;\n    }\n  }, {\n    key: \"listen\",\n    value: function listen(t, e, s) {\n      this._getAnims(t).listeners[e].push(s);\n    }\n  }, {\n    key: \"add\",\n    value: function add(t, e) {\n      var _this$_getAnims$items;\n      !e || !e.length || (_this$_getAnims$items = this._getAnims(t).items).push.apply(_this$_getAnims$items, _toConsumableArray(e));\n    }\n  }, {\n    key: \"has\",\n    value: function has(t) {\n      return this._getAnims(t).items.length > 0;\n    }\n  }, {\n    key: \"start\",\n    value: function start(t) {\n      var e = this._charts.get(t);\n      e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(function (s, n) {\n        return Math.max(s, n._duration);\n      }, 0), this._refresh());\n    }\n  }, {\n    key: \"running\",\n    value: function running(t) {\n      if (!this._running) return !1;\n      var e = this._charts.get(t);\n      return !(!e || !e.running || !e.items.length);\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(t) {\n      var e = this._charts.get(t);\n      if (!e || !e.items.length) return;\n      var s = e.items;\n      var n = s.length - 1;\n      for (; n >= 0; --n) s[n].cancel();\n      e.items = [], this._notify(t, e, Date.now(), \"complete\");\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(t) {\n      return this._charts[\"delete\"](t);\n    }\n  }]);\n}();\nvar ut = /* @__PURE__ */new ta();\nvar bs = \"transparent\",\n  ea = {\n    \"boolean\": function boolean(i, t, e) {\n      return e > 0.5 ? t : i;\n    },\n    color: function color(i, t, e) {\n      var s = rs(i || bs),\n        n = s.valid && rs(t || bs);\n      return n && n.valid ? n.mix(s, e).hexString() : t;\n    },\n    number: function number(i, t, e) {\n      return i + (t - i) * e;\n    }\n  };\nvar ia = /*#__PURE__*/function () {\n  function ia(t, e, s, n) {\n    _classCallCheck(this, ia);\n    var o = e[s];\n    n = we([t.to, n, o, t.from]);\n    var r = we([t.from, o, n]);\n    this._active = !0, this._fn = t.fn || ea[t.type || _typeof(r)], this._easing = he[t.easing] || he.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = s, this._from = r, this._to = n, this._promises = void 0;\n  }\n  return _createClass(ia, [{\n    key: \"active\",\n    value: function active() {\n      return this._active;\n    }\n  }, {\n    key: \"update\",\n    value: function update(t, e, s) {\n      if (this._active) {\n        this._notify(!1);\n        var n = this._target[this._prop],\n          o = s - this._start,\n          r = this._duration - o;\n        this._start = s, this._duration = Math.floor(Math.max(r, t.duration)), this._total += o, this._loop = !!t.loop, this._to = we([t.to, e, n, t.from]), this._from = we([t.from, n, e]);\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));\n    }\n  }, {\n    key: \"tick\",\n    value: function tick(t) {\n      var e = t - this._start,\n        s = this._duration,\n        n = this._prop,\n        o = this._from,\n        r = this._loop,\n        a = this._to;\n      var l;\n      if (this._active = o !== a && (r || e < s), !this._active) {\n        this._target[n] = a, this._notify(!0);\n        return;\n      }\n      if (e < 0) {\n        this._target[n] = o;\n        return;\n      }\n      l = e / s % 2, l = r && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[n] = this._fn(o, a, l);\n    }\n  }, {\n    key: \"wait\",\n    value: function wait() {\n      var t = this._promises || (this._promises = []);\n      return new Promise(function (e, s) {\n        t.push({\n          res: e,\n          rej: s\n        });\n      });\n    }\n  }, {\n    key: \"_notify\",\n    value: function _notify(t) {\n      var e = t ? \"res\" : \"rej\",\n        s = this._promises || [];\n      for (var n = 0; n < s.length; n++) s[n][e]();\n    }\n  }]);\n}();\nvar Nn = /*#__PURE__*/function () {\n  function Nn(t, e) {\n    _classCallCheck(this, Nn);\n    this._chart = t, this._properties = /* @__PURE__ */new Map(), this.configure(e);\n  }\n  return _createClass(Nn, [{\n    key: \"configure\",\n    value: function configure(t) {\n      if (!T(t)) return;\n      var e = Object.keys(W.animation),\n        s = this._properties;\n      Object.getOwnPropertyNames(t).forEach(function (n) {\n        var o = t[n];\n        if (!T(o)) return;\n        var r = {};\n        for (var _i2 = 0, _e2 = e; _i2 < _e2.length; _i2++) {\n          var a = _e2[_i2];\n          r[a] = o[a];\n        }\n        (N(o.properties) && o.properties || [n]).forEach(function (a) {\n          (a === n || !s.has(a)) && s.set(a, r);\n        });\n      });\n    }\n  }, {\n    key: \"_animateOptions\",\n    value: function _animateOptions(t, e) {\n      var s = e.options,\n        n = na(t, s);\n      if (!n) return [];\n      var o = this._createAnimations(n, s);\n      return s.$shared && sa(t.options.$animations, s).then(function () {\n        t.options = s;\n      }, function () {}), o;\n    }\n  }, {\n    key: \"_createAnimations\",\n    value: function _createAnimations(t, e) {\n      var s = this._properties,\n        n = [],\n        o = t.$animations || (t.$animations = {}),\n        r = Object.keys(e),\n        a = Date.now();\n      var l;\n      for (l = r.length - 1; l >= 0; --l) {\n        var c = r[l];\n        if (c.charAt(0) === \"$\") continue;\n        if (c === \"options\") {\n          n.push.apply(n, _toConsumableArray(this._animateOptions(t, e)));\n          continue;\n        }\n        var h = e[c];\n        var d = o[c];\n        var u = s.get(c);\n        if (d) if (u && d.active()) {\n          d.update(u, h, a);\n          continue;\n        } else d.cancel();\n        if (!u || !u.duration) {\n          t[c] = h;\n          continue;\n        }\n        o[c] = d = new ia(u, t, c, h), n.push(d);\n      }\n      return n;\n    }\n  }, {\n    key: \"update\",\n    value: function update(t, e) {\n      if (this._properties.size === 0) {\n        Object.assign(t, e);\n        return;\n      }\n      var s = this._createAnimations(t, e);\n      if (s.length) return ut.add(this._chart, s), !0;\n    }\n  }]);\n}();\nfunction sa(i, t) {\n  var e = [],\n    s = Object.keys(t);\n  for (var n = 0; n < s.length; n++) {\n    var o = i[s[n]];\n    o && o.active() && e.push(o.wait());\n  }\n  return Promise.all(e);\n}\nfunction na(i, t) {\n  if (!t) return;\n  var e = i.options;\n  if (!e) {\n    i.options = t;\n    return;\n  }\n  return e.$shared && (i.options = e = Object.assign({}, e, {\n    $shared: !1,\n    $animations: {}\n  })), e;\n}\nfunction _s(i, t) {\n  var e = i && i.options || {},\n    s = e.reverse,\n    n = e.min === void 0 ? t : 0,\n    o = e.max === void 0 ? t : 0;\n  return {\n    start: s ? o : n,\n    end: s ? n : o\n  };\n}\nfunction oa(i, t, e) {\n  if (e === !1) return !1;\n  var s = _s(i, e),\n    n = _s(t, e);\n  return {\n    top: n.end,\n    right: s.end,\n    bottom: n.start,\n    left: s.start\n  };\n}\nfunction ra(i) {\n  var t, e, s, n;\n  return T(i) ? (t = i.top, e = i.right, s = i.bottom, n = i.left) : t = e = s = n = i, {\n    top: t,\n    right: e,\n    bottom: s,\n    left: n,\n    disabled: i === !1\n  };\n}\nfunction Vn(i, t) {\n  var e = [],\n    s = i._getSortedDatasetMetas(t);\n  var n, o;\n  for (n = 0, o = s.length; n < o; ++n) e.push(s[n].index);\n  return e;\n}\nfunction xs(i, t, e) {\n  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var n = i.keys,\n    o = s.mode === \"single\";\n  var r, a, l, c;\n  if (t === null) return;\n  var h = !1;\n  for (r = 0, a = n.length; r < a; ++r) {\n    if (l = +n[r], l === e) {\n      if (h = !0, s.all) continue;\n      break;\n    }\n    c = i.values[l], q(c) && (o || t === 0 || lt(t) === lt(c)) && (t += c);\n  }\n  return !h && !s.all ? 0 : t;\n}\nfunction aa(i, t) {\n  var e = t.iScale,\n    s = t.vScale,\n    n = e.axis === \"x\" ? \"x\" : \"y\",\n    o = s.axis === \"x\" ? \"x\" : \"y\",\n    r = Object.keys(i),\n    a = new Array(r.length);\n  var l, c, h;\n  for (l = 0, c = r.length; l < c; ++l) h = r[l], a[l] = _defineProperty(_defineProperty({}, n, h), o, i[h]);\n  return a;\n}\nfunction ri(i, t) {\n  var e = i && i.options.stacked;\n  return e || e === void 0 && t.stack !== void 0;\n}\nfunction la(i, t, e) {\n  return \"\".concat(i.id, \".\").concat(t.id, \".\").concat(e.stack || e.type);\n}\nfunction ca(i) {\n  var _i$getUserBounds = i.getUserBounds(),\n    t = _i$getUserBounds.min,\n    e = _i$getUserBounds.max,\n    s = _i$getUserBounds.minDefined,\n    n = _i$getUserBounds.maxDefined;\n  return {\n    min: s ? t : Number.NEGATIVE_INFINITY,\n    max: n ? e : Number.POSITIVE_INFINITY\n  };\n}\nfunction ha(i, t, e) {\n  var s = i[t] || (i[t] = {});\n  return s[e] || (s[e] = {});\n}\nfunction ys(i, t, e, s) {\n  var _iterator10 = _createForOfIteratorHelper(t.getMatchingVisibleMetas(s).reverse()),\n    _step10;\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var n = _step10.value;\n      var o = i[n.index];\n      if (e && o > 0 || !e && o < 0) return n.index;\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n  return null;\n}\nfunction vs(i, t) {\n  var e = i.chart,\n    s = i._cachedMeta,\n    n = e._stacks || (e._stacks = {}),\n    o = s.iScale,\n    r = s.vScale,\n    a = s.index,\n    l = o.axis,\n    c = r.axis,\n    h = la(o, r, s),\n    d = t.length;\n  var u;\n  for (var f = 0; f < d; ++f) {\n    var p = t[f],\n      g = p[l],\n      m = p[c],\n      b = p._stacks || (p._stacks = {});\n    u = b[c] = ha(n, h, g), u[a] = m, u._top = ys(u, r, !0, s.type), u._bottom = ys(u, r, !1, s.type);\n    var _ = u._visualValues || (u._visualValues = {});\n    _[a] = m;\n  }\n}\nfunction ai(i, t) {\n  var e = i.scales;\n  return Object.keys(e).filter(function (s) {\n    return e[s].axis === t;\n  }).shift();\n}\nfunction da(i, t) {\n  return Bt(i, {\n    active: !1,\n    dataset: void 0,\n    datasetIndex: t,\n    index: t,\n    mode: \"default\",\n    type: \"dataset\"\n  });\n}\nfunction ua(i, t, e) {\n  return Bt(i, {\n    active: !1,\n    dataIndex: t,\n    parsed: void 0,\n    raw: void 0,\n    element: e,\n    index: t,\n    mode: \"default\",\n    type: \"data\"\n  });\n}\nfunction Qt(i, t) {\n  var e = i.controller.index,\n    s = i.vScale && i.vScale.axis;\n  if (s) {\n    t = t || i._parsed;\n    var _iterator11 = _createForOfIteratorHelper(t),\n      _step11;\n    try {\n      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n        var n = _step11.value;\n        var o = n._stacks;\n        if (!o || o[s] === void 0 || o[s][e] === void 0) return;\n        delete o[s][e], o[s]._visualValues !== void 0 && o[s]._visualValues[e] !== void 0 && delete o[s]._visualValues[e];\n      }\n    } catch (err) {\n      _iterator11.e(err);\n    } finally {\n      _iterator11.f();\n    }\n  }\n}\nvar li = function li(i) {\n    return i === \"reset\" || i === \"none\";\n  },\n  Ms = function Ms(i, t) {\n    return t ? i : Object.assign({}, i);\n  },\n  fa = function fa(i, t, e) {\n    return i && !t.hidden && t._stacked && {\n      keys: Vn(e, !0),\n      values: null\n    };\n  };\nvar kt = /*#__PURE__*/function () {\n  function kt(t, e) {\n    _classCallCheck(this, kt);\n    this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = (this instanceof kt ? this.constructor : void 0).datasetElementType, this.dataElementType = (this instanceof kt ? this.constructor : void 0).dataElementType, this.initialize();\n  }\n  return _createClass(kt, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var t = this._cachedMeta;\n      this.configure(), this.linkScales(), t._stacked = ri(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled(\"filler\") && console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n    }\n  }, {\n    key: \"updateIndex\",\n    value: function updateIndex(t) {\n      this.index !== t && Qt(this._cachedMeta), this.index = t;\n    }\n  }, {\n    key: \"linkScales\",\n    value: function linkScales() {\n      var t = this.chart,\n        e = this._cachedMeta,\n        s = this.getDataset(),\n        n = function n(d, u, f, p) {\n          return d === \"x\" ? u : d === \"r\" ? p : f;\n        },\n        o = e.xAxisID = D(s.xAxisID, ai(t, \"x\")),\n        r = e.yAxisID = D(s.yAxisID, ai(t, \"y\")),\n        a = e.rAxisID = D(s.rAxisID, ai(t, \"r\")),\n        l = e.indexAxis,\n        c = e.iAxisID = n(l, o, r, a),\n        h = e.vAxisID = n(l, r, o, a);\n      e.xScale = this.getScaleForId(o), e.yScale = this.getScaleForId(r), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(c), e.vScale = this.getScaleForId(h);\n    }\n  }, {\n    key: \"getDataset\",\n    value: function getDataset() {\n      return this.chart.data.datasets[this.index];\n    }\n  }, {\n    key: \"getMeta\",\n    value: function getMeta() {\n      return this.chart.getDatasetMeta(this.index);\n    }\n  }, {\n    key: \"getScaleForId\",\n    value: function getScaleForId(t) {\n      return this.chart.scales[t];\n    }\n  }, {\n    key: \"_getOtherScale\",\n    value: function _getOtherScale(t) {\n      var e = this._cachedMeta;\n      return t === e.iScale ? e.vScale : e.iScale;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._update(\"reset\");\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      var t = this._cachedMeta;\n      this._data && ss(this._data, this), t._stacked && Qt(t);\n    }\n  }, {\n    key: \"_dataCheck\",\n    value: function _dataCheck() {\n      var t = this.getDataset(),\n        e = t.data || (t.data = []),\n        s = this._data;\n      if (T(e)) {\n        var n = this._cachedMeta;\n        this._data = aa(e, n);\n      } else if (s !== e) {\n        if (s) {\n          ss(s, this);\n          var _n2 = this._cachedMeta;\n          Qt(_n2), _n2._parsed = [];\n        }\n        e && Object.isExtensible(e) && Jo(e, this), this._syncList = [], this._data = e;\n      }\n    }\n  }, {\n    key: \"addElements\",\n    value: function addElements() {\n      var t = this._cachedMeta;\n      this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());\n    }\n  }, {\n    key: \"buildOrUpdateElements\",\n    value: function buildOrUpdateElements(t) {\n      var e = this._cachedMeta,\n        s = this.getDataset();\n      var n = !1;\n      this._dataCheck();\n      var o = e._stacked;\n      e._stacked = ri(e.vScale, e), e.stack !== s.stack && (n = !0, Qt(e), e.stack = s.stack), this._resyncElements(t), (n || o !== e._stacked) && (vs(this, e._parsed), e._stacked = ri(e.vScale, e));\n    }\n  }, {\n    key: \"configure\",\n    value: function configure() {\n      var t = this.chart.config,\n        e = t.datasetScopeKeys(this._type),\n        s = t.getOptionScopes(this.getDataset(), e, !0);\n      this.options = t.createResolver(s, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(t, e) {\n      var s = this._cachedMeta,\n        n = this._data,\n        o = s.iScale,\n        r = s._stacked,\n        a = o.axis;\n      var l = t === 0 && e === n.length ? !0 : s._sorted,\n        c = t > 0 && s._parsed[t - 1],\n        h,\n        d,\n        u;\n      if (this._parsing === !1) s._parsed = n, s._sorted = !0, u = n;else {\n        N(n[t]) ? u = this.parseArrayData(s, n, t, e) : T(n[t]) ? u = this.parseObjectData(s, n, t, e) : u = this.parsePrimitiveData(s, n, t, e);\n        var f = function f() {\n          return d[a] === null || c && d[a] < c[a];\n        };\n        for (h = 0; h < e; ++h) s._parsed[h + t] = d = u[h], l && (f() && (l = !1), c = d);\n        s._sorted = l;\n      }\n      r && vs(this, u);\n    }\n  }, {\n    key: \"parsePrimitiveData\",\n    value: function parsePrimitiveData(t, e, s, n) {\n      var o = t.iScale,\n        r = t.vScale,\n        a = o.axis,\n        l = r.axis,\n        c = o.getLabels(),\n        h = o === r,\n        d = new Array(n);\n      var u, f, p;\n      for (u = 0, f = n; u < f; ++u) p = u + s, d[u] = _defineProperty(_defineProperty({}, a, h || o.parse(c[p], p)), l, r.parse(e[p], p));\n      return d;\n    }\n  }, {\n    key: \"parseArrayData\",\n    value: function parseArrayData(t, e, s, n) {\n      var o = t.xScale,\n        r = t.yScale,\n        a = new Array(n);\n      var l, c, h, d;\n      for (l = 0, c = n; l < c; ++l) h = l + s, d = e[h], a[l] = {\n        x: o.parse(d[0], h),\n        y: r.parse(d[1], h)\n      };\n      return a;\n    }\n  }, {\n    key: \"parseObjectData\",\n    value: function parseObjectData(t, e, s, n) {\n      var o = t.xScale,\n        r = t.yScale,\n        _this$_parsing = this._parsing,\n        _this$_parsing$xAxisK = _this$_parsing.xAxisKey,\n        a = _this$_parsing$xAxisK === void 0 ? \"x\" : _this$_parsing$xAxisK,\n        _this$_parsing$yAxisK = _this$_parsing.yAxisKey,\n        l = _this$_parsing$yAxisK === void 0 ? \"y\" : _this$_parsing$yAxisK,\n        c = new Array(n);\n      var h, d, u, f;\n      for (h = 0, d = n; h < d; ++h) u = h + s, f = e[u], c[h] = {\n        x: o.parse(It(f, a), u),\n        y: r.parse(It(f, l), u)\n      };\n      return c;\n    }\n  }, {\n    key: \"getParsed\",\n    value: function getParsed(t) {\n      return this._cachedMeta._parsed[t];\n    }\n  }, {\n    key: \"getDataElement\",\n    value: function getDataElement(t) {\n      return this._cachedMeta.data[t];\n    }\n  }, {\n    key: \"applyStack\",\n    value: function applyStack(t, e, s) {\n      var n = this.chart,\n        o = this._cachedMeta,\n        r = e[t.axis],\n        a = {\n          keys: Vn(n, !0),\n          values: e._stacks[t.axis]._visualValues\n        };\n      return xs(a, r, o.index, {\n        mode: s\n      });\n    }\n  }, {\n    key: \"updateRangeFromParsed\",\n    value: function updateRangeFromParsed(t, e, s, n) {\n      var o = s[e.axis];\n      var r = o === null ? NaN : o;\n      var a = n && s._stacks[e.axis];\n      n && a && (n.values = a, r = xs(n, o, this._cachedMeta.index)), t.min = Math.min(t.min, r), t.max = Math.max(t.max, r);\n    }\n  }, {\n    key: \"getMinMax\",\n    value: function getMinMax(t, e) {\n      var s = this._cachedMeta,\n        n = s._parsed,\n        o = s._sorted && t === s.iScale,\n        r = n.length,\n        a = this._getOtherScale(t),\n        l = fa(e, s, this.chart),\n        c = {\n          min: Number.POSITIVE_INFINITY,\n          max: Number.NEGATIVE_INFINITY\n        },\n        _ca = ca(a),\n        h = _ca.min,\n        d = _ca.max;\n      var u, f;\n      function p() {\n        f = n[u];\n        var g = f[a.axis];\n        return !q(f[t.axis]) || h > g || d < g;\n      }\n      for (u = 0; u < r && !(!p() && (this.updateRangeFromParsed(c, t, f, l), o)); ++u);\n      if (o) {\n        for (u = r - 1; u >= 0; --u) if (!p()) {\n          this.updateRangeFromParsed(c, t, f, l);\n          break;\n        }\n      }\n      return c;\n    }\n  }, {\n    key: \"getAllParsedValues\",\n    value: function getAllParsedValues(t) {\n      var e = this._cachedMeta._parsed,\n        s = [];\n      var n, o, r;\n      for (n = 0, o = e.length; n < o; ++n) r = e[n][t.axis], q(r) && s.push(r);\n      return s;\n    }\n  }, {\n    key: \"getMaxOverflow\",\n    value: function getMaxOverflow() {\n      return !1;\n    }\n  }, {\n    key: \"getLabelAndValue\",\n    value: function getLabelAndValue(t) {\n      var e = this._cachedMeta,\n        s = e.iScale,\n        n = e.vScale,\n        o = this.getParsed(t);\n      return {\n        label: s ? \"\" + s.getLabelForValue(o[s.axis]) : \"\",\n        value: n ? \"\" + n.getLabelForValue(o[n.axis]) : \"\"\n      };\n    }\n  }, {\n    key: \"_update\",\n    value: function _update(t) {\n      var e = this._cachedMeta;\n      this.update(t || \"default\"), e._clip = ra(D(this.options.clip, oa(e.xScale, e.yScale, this.getMaxOverflow())));\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {}\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var t = this._ctx,\n        e = this.chart,\n        s = this._cachedMeta,\n        n = s.data || [],\n        o = e.chartArea,\n        r = [],\n        a = this._drawStart || 0,\n        l = this._drawCount || n.length - a,\n        c = this.options.drawActiveElementsOnTop;\n      var h;\n      for (s.dataset && s.dataset.draw(t, o, a, l), h = a; h < a + l; ++h) {\n        var d = n[h];\n        d.hidden || (d.active && c ? r.push(d) : d.draw(t, o));\n      }\n      for (h = 0; h < r.length; ++h) r[h].draw(t, o);\n    }\n  }, {\n    key: \"getStyle\",\n    value: function getStyle(t, e) {\n      var s = e ? \"active\" : \"default\";\n      return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(s) : this.resolveDataElementOptions(t || 0, s);\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext(t, e, s) {\n      var n = this.getDataset();\n      var o;\n      if (t >= 0 && t < this._cachedMeta.data.length) {\n        var r = this._cachedMeta.data[t];\n        o = r.$context || (r.$context = ua(this.getContext(), t, r)), o.parsed = this.getParsed(t), o.raw = n.data[t], o.index = o.dataIndex = t;\n      } else o = this.$context || (this.$context = da(this.chart.getContext(), this.index)), o.dataset = n, o.index = o.datasetIndex = this.index;\n      return o.active = !!e, o.mode = s, o;\n    }\n  }, {\n    key: \"resolveDatasetElementOptions\",\n    value: function resolveDatasetElementOptions(t) {\n      return this._resolveElementOptions(this.datasetElementType.id, t);\n    }\n  }, {\n    key: \"resolveDataElementOptions\",\n    value: function resolveDataElementOptions(t, e) {\n      return this._resolveElementOptions(this.dataElementType.id, e, t);\n    }\n  }, {\n    key: \"_resolveElementOptions\",\n    value: function _resolveElementOptions(t) {\n      var _this5 = this;\n      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"default\";\n      var s = arguments.length > 2 ? arguments[2] : undefined;\n      var n = e === \"active\",\n        o = this._cachedDataOpts,\n        r = t + \"-\" + e,\n        a = o[r],\n        l = this.enableOptionSharing && ge(s);\n      if (a) return Ms(a, l);\n      var c = this.chart.config,\n        h = c.datasetElementScopeKeys(this._type, t),\n        d = n ? [\"\".concat(t, \"Hover\"), \"hover\", t, \"\"] : [t, \"\"],\n        u = c.getOptionScopes(this.getDataset(), h),\n        f = Object.keys(W.elements[t]),\n        p = function p() {\n          return _this5.getContext(s, n, e);\n        },\n        g = c.resolveNamedOptions(u, f, p, d);\n      return g.$shared && (g.$shared = l, o[r] = Object.freeze(Ms(g, l))), g;\n    }\n  }, {\n    key: \"_resolveAnimations\",\n    value: function _resolveAnimations(t, e, s) {\n      var n = this.chart,\n        o = this._cachedDataOpts,\n        r = \"animation-\".concat(e),\n        a = o[r];\n      if (a) return a;\n      var l;\n      if (n.options.animation !== !1) {\n        var h = this.chart.config,\n          d = h.datasetAnimationScopeKeys(this._type, e),\n          u = h.getOptionScopes(this.getDataset(), d);\n        l = h.createResolver(u, this.getContext(t, s, e));\n      }\n      var c = new Nn(n, l && l.animations);\n      return l && l._cacheable && (o[r] = Object.freeze(c)), c;\n    }\n  }, {\n    key: \"getSharedOptions\",\n    value: function getSharedOptions(t) {\n      if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));\n    }\n  }, {\n    key: \"includeOptions\",\n    value: function includeOptions(t, e) {\n      return !e || li(t) || this.chart._animationsDisabled;\n    }\n  }, {\n    key: \"_getSharedOptions\",\n    value: function _getSharedOptions(t, e) {\n      var s = this.resolveDataElementOptions(t, e),\n        n = this._sharedOptions,\n        o = this.getSharedOptions(s),\n        r = this.includeOptions(e, o) || o !== n;\n      return this.updateSharedOptions(o, e, s), {\n        sharedOptions: o,\n        includeOptions: r\n      };\n    }\n  }, {\n    key: \"updateElement\",\n    value: function updateElement(t, e, s, n) {\n      li(n) ? Object.assign(t, s) : this._resolveAnimations(e, n).update(t, s);\n    }\n  }, {\n    key: \"updateSharedOptions\",\n    value: function updateSharedOptions(t, e, s) {\n      t && !li(e) && this._resolveAnimations(void 0, e).update(t, s);\n    }\n  }, {\n    key: \"_setStyle\",\n    value: function _setStyle(t, e, s, n) {\n      t.active = n;\n      var o = this.getStyle(e, n);\n      this._resolveAnimations(e, s, n).update(t, {\n        options: !n && this.getSharedOptions(o) || o\n      });\n    }\n  }, {\n    key: \"removeHoverStyle\",\n    value: function removeHoverStyle(t, e, s) {\n      this._setStyle(t, s, \"active\", !1);\n    }\n  }, {\n    key: \"setHoverStyle\",\n    value: function setHoverStyle(t, e, s) {\n      this._setStyle(t, s, \"active\", !0);\n    }\n  }, {\n    key: \"_removeDatasetHoverStyle\",\n    value: function _removeDatasetHoverStyle() {\n      var t = this._cachedMeta.dataset;\n      t && this._setStyle(t, void 0, \"active\", !1);\n    }\n  }, {\n    key: \"_setDatasetHoverStyle\",\n    value: function _setDatasetHoverStyle() {\n      var t = this._cachedMeta.dataset;\n      t && this._setStyle(t, void 0, \"active\", !0);\n    }\n  }, {\n    key: \"_resyncElements\",\n    value: function _resyncElements(t) {\n      var e = this._data,\n        s = this._cachedMeta.data;\n      var _iterator12 = _createForOfIteratorHelper(this._syncList),\n        _step12;\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var _step12$value = _slicedToArray(_step12.value, 3),\n            a = _step12$value[0],\n            l = _step12$value[1],\n            c = _step12$value[2];\n          this[a](l, c);\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n      this._syncList = [];\n      var n = s.length,\n        o = e.length,\n        r = Math.min(o, n);\n      r && this.parse(0, r), o > n ? this._insertElements(n, o - n, t) : o < n && this._removeElements(o, n - o);\n    }\n  }, {\n    key: \"_insertElements\",\n    value: function _insertElements(t, e) {\n      var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;\n      var n = this._cachedMeta,\n        o = n.data,\n        r = t + e;\n      var a;\n      var l = function l(c) {\n        for (c.length += e, a = c.length - 1; a >= r; a--) c[a] = c[a - e];\n      };\n      for (l(o), a = t; a < r; ++a) o[a] = new this.dataElementType();\n      this._parsing && l(n._parsed), this.parse(t, e), s && this.updateElements(o, t, e, \"reset\");\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {}\n  }, {\n    key: \"_removeElements\",\n    value: function _removeElements(t, e) {\n      var s = this._cachedMeta;\n      if (this._parsing) {\n        var n = s._parsed.splice(t, e);\n        s._stacked && Qt(s, n);\n      }\n      s.data.splice(t, e);\n    }\n  }, {\n    key: \"_sync\",\n    value: function _sync(t) {\n      if (this._parsing) this._syncList.push(t);else {\n        var _t2 = _slicedToArray(t, 3),\n          e = _t2[0],\n          s = _t2[1],\n          n = _t2[2];\n        this[e](s, n);\n      }\n      this.chart._dataChanges.push([this.index].concat(_toConsumableArray(t)));\n    }\n  }, {\n    key: \"_onDataPush\",\n    value: function _onDataPush() {\n      var t = arguments.length;\n      this._sync([\"_insertElements\", this.getDataset().data.length - t, t]);\n    }\n  }, {\n    key: \"_onDataPop\",\n    value: function _onDataPop() {\n      this._sync([\"_removeElements\", this._cachedMeta.data.length - 1, 1]);\n    }\n  }, {\n    key: \"_onDataShift\",\n    value: function _onDataShift() {\n      this._sync([\"_removeElements\", 0, 1]);\n    }\n  }, {\n    key: \"_onDataSplice\",\n    value: function _onDataSplice(t, e) {\n      e && this._sync([\"_removeElements\", t, e]);\n      var s = arguments.length - 2;\n      s && this._sync([\"_insertElements\", t, s]);\n    }\n  }, {\n    key: \"_onDataUnshift\",\n    value: function _onDataUnshift() {\n      this._sync([\"_insertElements\", 0, arguments.length]);\n    }\n  }]);\n}();\nw(kt, \"defaults\", {}), w(kt, \"datasetElementType\", null), w(kt, \"dataElementType\", null);\nfunction ga(i, t) {\n  if (!i._cache.$bar) {\n    var e = i.getMatchingVisibleMetas(t);\n    var s = [];\n    for (var n = 0, o = e.length; n < o; n++) s = s.concat(e[n].controller.getAllParsedValues(i));\n    i._cache.$bar = Mn(s.sort(function (n, o) {\n      return n - o;\n    }));\n  }\n  return i._cache.$bar;\n}\nfunction pa(i) {\n  var t = i.iScale,\n    e = ga(t, i.type);\n  var s = t._length,\n    n,\n    o,\n    r,\n    a;\n  var l = function l() {\n    r === 32767 || r === -32768 || (ge(a) && (s = Math.min(s, Math.abs(r - a) || s)), a = r);\n  };\n  for (n = 0, o = e.length; n < o; ++n) r = t.getPixelForValue(e[n]), l();\n  for (a = void 0, n = 0, o = t.ticks.length; n < o; ++n) r = t.getPixelForTick(n), l();\n  return s;\n}\nfunction ma(i, t, e, s) {\n  var n = e.barThickness;\n  var o, r;\n  return R(n) ? (o = t.min * e.categoryPercentage, r = e.barPercentage) : (o = n * s, r = 1), {\n    chunk: o / s,\n    ratio: r,\n    start: t.pixels[i] - o / 2\n  };\n}\nfunction ba(i, t, e, s) {\n  var n = t.pixels,\n    o = n[i];\n  var r = i > 0 ? n[i - 1] : null,\n    a = i < n.length - 1 ? n[i + 1] : null;\n  var l = e.categoryPercentage;\n  r === null && (r = o - (a === null ? t.end - t.start : a - o)), a === null && (a = o + o - r);\n  var c = o - (o - Math.min(r, a)) / 2 * l;\n  return {\n    chunk: Math.abs(a - r) / 2 * l / s,\n    ratio: e.barPercentage,\n    start: c\n  };\n}\nfunction _a(i, t, e, s) {\n  var n = e.parse(i[0], s),\n    o = e.parse(i[1], s),\n    r = Math.min(n, o),\n    a = Math.max(n, o);\n  var l = r,\n    c = a;\n  Math.abs(r) > Math.abs(a) && (l = a, c = r), t[e.axis] = c, t._custom = {\n    barStart: l,\n    barEnd: c,\n    start: n,\n    end: o,\n    min: r,\n    max: a\n  };\n}\nfunction jn(i, t, e, s) {\n  return N(i) ? _a(i, t, e, s) : t[e.axis] = e.parse(i, s), t;\n}\nfunction Ss(i, t, e, s) {\n  var n = i.iScale,\n    o = i.vScale,\n    r = n.getLabels(),\n    a = n === o,\n    l = [];\n  var c, h, d, u;\n  for (c = e, h = e + s; c < h; ++c) u = t[c], d = {}, d[n.axis] = a || n.parse(r[c], c), l.push(jn(u, d, o, c));\n  return l;\n}\nfunction ci(i) {\n  return i && i.barStart !== void 0 && i.barEnd !== void 0;\n}\nfunction xa(i, t, e) {\n  return i !== 0 ? lt(i) : (t.isHorizontal() ? 1 : -1) * (t.min >= e ? 1 : -1);\n}\nfunction ya(i) {\n  var t, e, s, n, o;\n  return i.horizontal ? (t = i.base > i.x, e = \"left\", s = \"right\") : (t = i.base < i.y, e = \"bottom\", s = \"top\"), t ? (n = \"end\", o = \"start\") : (n = \"start\", o = \"end\"), {\n    start: e,\n    end: s,\n    reverse: t,\n    top: n,\n    bottom: o\n  };\n}\nfunction va(i, t, e, s) {\n  var n = t.borderSkipped;\n  var o = {};\n  if (!n) {\n    i.borderSkipped = o;\n    return;\n  }\n  if (n === !0) {\n    i.borderSkipped = {\n      top: !0,\n      right: !0,\n      bottom: !0,\n      left: !0\n    };\n    return;\n  }\n  var _ya = ya(i),\n    r = _ya.start,\n    a = _ya.end,\n    l = _ya.reverse,\n    c = _ya.top,\n    h = _ya.bottom;\n  n === \"middle\" && e && (i.enableBorderRadius = !0, (e._top || 0) === s ? n = c : (e._bottom || 0) === s ? n = h : (o[ks(h, r, a, l)] = !0, n = c)), o[ks(n, r, a, l)] = !0, i.borderSkipped = o;\n}\nfunction ks(i, t, e, s) {\n  return s ? (i = Ma(i, t, e), i = ws(i, e, t)) : i = ws(i, t, e), i;\n}\nfunction Ma(i, t, e) {\n  return i === t ? e : i === e ? t : i;\n}\nfunction ws(i, t, e) {\n  return i === \"start\" ? t : i === \"end\" ? e : i;\n}\nfunction Sa(i, _ref2, e) {\n  var t = _ref2.inflateAmount;\n  i.inflateAmount = t === \"auto\" ? e === 1 ? 0.33 : 0 : t;\n}\nvar Ee = /*#__PURE__*/function (_kt) {\n  function Ee() {\n    _classCallCheck(this, Ee);\n    return _callSuper(this, Ee, arguments);\n  }\n  _inherits(Ee, _kt);\n  return _createClass(Ee, [{\n    key: \"parsePrimitiveData\",\n    value: function parsePrimitiveData(t, e, s, n) {\n      return Ss(t, e, s, n);\n    }\n  }, {\n    key: \"parseArrayData\",\n    value: function parseArrayData(t, e, s, n) {\n      return Ss(t, e, s, n);\n    }\n  }, {\n    key: \"parseObjectData\",\n    value: function parseObjectData(t, e, s, n) {\n      var o = t.iScale,\n        r = t.vScale,\n        _this$_parsing2 = this._parsing,\n        _this$_parsing2$xAxis = _this$_parsing2.xAxisKey,\n        a = _this$_parsing2$xAxis === void 0 ? \"x\" : _this$_parsing2$xAxis,\n        _this$_parsing2$yAxis = _this$_parsing2.yAxisKey,\n        l = _this$_parsing2$yAxis === void 0 ? \"y\" : _this$_parsing2$yAxis,\n        c = o.axis === \"x\" ? a : l,\n        h = r.axis === \"x\" ? a : l,\n        d = [];\n      var u, f, p, g;\n      for (u = s, f = s + n; u < f; ++u) g = e[u], p = {}, p[o.axis] = o.parse(It(g, c), u), d.push(jn(It(g, h), p, r, u));\n      return d;\n    }\n  }, {\n    key: \"updateRangeFromParsed\",\n    value: function updateRangeFromParsed(t, e, s, n) {\n      _superPropGet(Ee, \"updateRangeFromParsed\", this, 3)([t, e, s, n]);\n      var o = s._custom;\n      o && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, o.min), t.max = Math.max(t.max, o.max));\n    }\n  }, {\n    key: \"getMaxOverflow\",\n    value: function getMaxOverflow() {\n      return 0;\n    }\n  }, {\n    key: \"getLabelAndValue\",\n    value: function getLabelAndValue(t) {\n      var e = this._cachedMeta,\n        s = e.iScale,\n        n = e.vScale,\n        o = this.getParsed(t),\n        r = o._custom,\n        a = ci(r) ? \"[\" + r.start + \", \" + r.end + \"]\" : \"\" + n.getLabelForValue(o[n.axis]);\n      return {\n        label: \"\" + s.getLabelForValue(o[s.axis]),\n        value: a\n      };\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      this.enableOptionSharing = !0, _superPropGet(Ee, \"initialize\", this, 3)([]);\n      var t = this._cachedMeta;\n      t.stack = this.getDataset().stack;\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = this._cachedMeta;\n      this.updateElements(e.data, 0, e.data.length, t);\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {\n      var o = n === \"reset\",\n        r = this.index,\n        a = this._cachedMeta.vScale,\n        l = a.getBasePixel(),\n        c = a.isHorizontal(),\n        h = this._getRuler(),\n        _this$_getSharedOptio = this._getSharedOptions(e, n),\n        d = _this$_getSharedOptio.sharedOptions,\n        u = _this$_getSharedOptio.includeOptions;\n      for (var f = e; f < e + s; f++) {\n        var p = this.getParsed(f),\n          g = o || R(p[a.axis]) ? {\n            base: l,\n            head: l\n          } : this._calculateBarValuePixels(f),\n          m = this._calculateBarIndexPixels(f, h),\n          b = (p._stacks || {})[a.axis],\n          _ = {\n            horizontal: c,\n            base: g.base,\n            enableBorderRadius: !b || ci(p._custom) || r === b._top || r === b._bottom,\n            x: c ? g.head : m.center,\n            y: c ? m.center : g.head,\n            height: c ? m.size : Math.abs(g.size),\n            width: c ? Math.abs(g.size) : m.size\n          };\n        u && (_.options = d || this.resolveDataElementOptions(f, t[f].active ? \"active\" : n));\n        var v = _.options || t[f].options;\n        va(_, v, b, r), Sa(_, v, h.ratio), this.updateElement(t[f], f, _, n);\n      }\n    }\n  }, {\n    key: \"_getStacks\",\n    value: function _getStacks(t, e) {\n      var s = this._cachedMeta.iScale,\n        n = s.getMatchingVisibleMetas(this._type).filter(function (h) {\n          return h.controller.options.grouped;\n        }),\n        o = s.options.stacked,\n        r = [],\n        a = this._cachedMeta.controller.getParsed(e),\n        l = a && a[s.axis],\n        c = function c(h) {\n          var d = h._parsed.find(function (f) {\n              return f[s.axis] === l;\n            }),\n            u = d && d[h.vScale.axis];\n          if (R(u) || isNaN(u)) return !0;\n        };\n      var _iterator13 = _createForOfIteratorHelper(n),\n        _step13;\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var h = _step13.value;\n          if (!(e !== void 0 && c(h)) && ((o === !1 || r.indexOf(h.stack) === -1 || o === void 0 && h.stack === void 0) && r.push(h.stack), h.index === t)) break;\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n      return r.length || r.push(void 0), r;\n    }\n  }, {\n    key: \"_getStackCount\",\n    value: function _getStackCount(t) {\n      return this._getStacks(void 0, t).length;\n    }\n  }, {\n    key: \"_getAxisCount\",\n    value: function _getAxisCount() {\n      return this._getAxis().length;\n    }\n  }, {\n    key: \"getFirstScaleIdForIndexAxis\",\n    value: function getFirstScaleIdForIndexAxis() {\n      var t = this.chart.scales,\n        e = this.chart.options.indexAxis;\n      return Object.keys(t).filter(function (s) {\n        return t[s].axis === e;\n      }).shift();\n    }\n  }, {\n    key: \"_getAxis\",\n    value: function _getAxis() {\n      var t = {},\n        e = this.getFirstScaleIdForIndexAxis();\n      var _iterator14 = _createForOfIteratorHelper(this.chart.data.datasets),\n        _step14;\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var s = _step14.value;\n          t[D(this.chart.options.indexAxis === \"x\" ? s.xAxisID : s.yAxisID, e)] = !0;\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n      return Object.keys(t);\n    }\n  }, {\n    key: \"_getStackIndex\",\n    value: function _getStackIndex(t, e, s) {\n      var n = this._getStacks(t, s),\n        o = e !== void 0 ? n.indexOf(e) : -1;\n      return o === -1 ? n.length - 1 : o;\n    }\n  }, {\n    key: \"_getRuler\",\n    value: function _getRuler() {\n      var t = this.options,\n        e = this._cachedMeta,\n        s = e.iScale,\n        n = [];\n      var o, r;\n      for (o = 0, r = e.data.length; o < r; ++o) n.push(s.getPixelForValue(this.getParsed(o)[s.axis], o));\n      var a = t.barThickness;\n      return {\n        min: a || pa(e),\n        pixels: n,\n        start: s._startPixel,\n        end: s._endPixel,\n        stackCount: this._getStackCount(),\n        scale: s,\n        grouped: t.grouped,\n        ratio: a ? 1 : t.categoryPercentage * t.barPercentage\n      };\n    }\n  }, {\n    key: \"_calculateBarValuePixels\",\n    value: function _calculateBarValuePixels(t) {\n      var _this$_cachedMeta = this._cachedMeta,\n        e = _this$_cachedMeta.vScale,\n        s = _this$_cachedMeta._stacked,\n        n = _this$_cachedMeta.index,\n        _this$options = this.options,\n        o = _this$options.base,\n        r = _this$options.minBarLength,\n        a = o || 0,\n        l = this.getParsed(t),\n        c = l._custom,\n        h = ci(c);\n      var d = l[e.axis],\n        u = 0,\n        f = s ? this.applyStack(e, l, s) : d,\n        p,\n        g;\n      f !== d && (u = f - d, f = d), h && (d = c.barStart, f = c.barEnd - c.barStart, d !== 0 && lt(d) !== lt(c.barEnd) && (u = 0), u += d);\n      var m = !R(o) && !h ? o : u;\n      var b = e.getPixelForValue(m);\n      if (this.chart.getDataVisibility(t) ? p = e.getPixelForValue(u + f) : p = b, g = p - b, Math.abs(g) < r) {\n        g = xa(g, e, a) * r, d === a && (b -= g / 2);\n        var _ = e.getPixelForDecimal(0),\n          v = e.getPixelForDecimal(1),\n          y = Math.min(_, v),\n          x = Math.max(_, v);\n        b = Math.max(Math.min(b, x), y), p = b + g, s && !h && (l._stacks[e.axis]._visualValues[n] = e.getValueForPixel(p) - e.getValueForPixel(b));\n      }\n      if (b === e.getPixelForValue(a)) {\n        var _2 = lt(g) * e.getLineWidthForValue(a) / 2;\n        b += _2, g -= _2;\n      }\n      return {\n        size: g,\n        base: b,\n        head: p,\n        center: p + g / 2\n      };\n    }\n  }, {\n    key: \"_calculateBarIndexPixels\",\n    value: function _calculateBarIndexPixels(t, e) {\n      var s = e.scale,\n        n = this.options,\n        o = n.skipNull,\n        r = D(n.maxBarThickness, 1 / 0);\n      var a, l;\n      var c = this._getAxisCount();\n      if (e.grouped) {\n        var h = o ? this._getStackCount(t) : e.stackCount,\n          d = n.barThickness === \"flex\" ? ba(t, e, n, h * c) : ma(t, e, n, h * c),\n          u = this.chart.options.indexAxis === \"x\" ? this.getDataset().xAxisID : this.getDataset().yAxisID,\n          f = this._getAxis().indexOf(D(u, this.getFirstScaleIdForIndexAxis())),\n          p = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0) + f;\n        a = d.start + d.chunk * p + d.chunk / 2, l = Math.min(r, d.chunk * d.ratio);\n      } else a = s.getPixelForValue(this.getParsed(t)[s.axis], t), l = Math.min(r, e.min * e.ratio);\n      return {\n        base: a - l / 2,\n        head: a + l / 2,\n        center: a,\n        size: l\n      };\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var t = this._cachedMeta,\n        e = t.vScale,\n        s = t.data,\n        n = s.length;\n      var o = 0;\n      for (; o < n; ++o) this.getParsed(o)[e.axis] !== null && !s[o].hidden && s[o].draw(this._ctx);\n    }\n  }]);\n}(kt);\nw(Ee, \"id\", \"bar\"), w(Ee, \"defaults\", {\n  datasetElementType: !1,\n  dataElementType: \"bar\",\n  categoryPercentage: 0.8,\n  barPercentage: 0.9,\n  grouped: !0,\n  animations: {\n    numbers: {\n      type: \"number\",\n      properties: [\"x\", \"y\", \"base\", \"width\", \"height\"]\n    }\n  }\n}), w(Ee, \"overrides\", {\n  scales: {\n    _index_: {\n      type: \"category\",\n      offset: !0,\n      grid: {\n        offset: !0\n      }\n    },\n    _value_: {\n      type: \"linear\",\n      beginAtZero: !0\n    }\n  }\n});\nfunction ka(i, t, e) {\n  var s = 1,\n    n = 1,\n    o = 0,\n    r = 0;\n  if (t < B) {\n    var a = i,\n      l = a + t,\n      c = Math.cos(a),\n      h = Math.sin(a),\n      d = Math.cos(l),\n      u = Math.sin(l),\n      f = function f(v, y, x) {\n        return pe(v, a, l, !0) ? 1 : Math.max(y, y * e, x, x * e);\n      },\n      p = function p(v, y, x) {\n        return pe(v, a, l, !0) ? -1 : Math.min(y, y * e, x, x * e);\n      },\n      g = f(0, c, d),\n      m = f(V, h, u),\n      b = p(E, c, d),\n      _ = p(E + V, h, u);\n    s = (g - b) / 2, n = (m - _) / 2, o = -(g + b) / 2, r = -(m + _) / 2;\n  }\n  return {\n    ratioX: s,\n    ratioY: n,\n    offsetX: o,\n    offsetY: r\n  };\n}\nvar jt = /*#__PURE__*/function (_kt2) {\n  function jt(t, e) {\n    var _this6;\n    _classCallCheck(this, jt);\n    _this6 = _callSuper(this, jt, [t, e]), _this6.enableOptionSharing = !0, _this6.innerRadius = void 0, _this6.outerRadius = void 0, _this6.offsetX = void 0, _this6.offsetY = void 0;\n    return _this6;\n  }\n  _inherits(jt, _kt2);\n  return _createClass(jt, [{\n    key: \"linkScales\",\n    value: function linkScales() {}\n  }, {\n    key: \"parse\",\n    value: function parse(t, e) {\n      var s = this.getDataset().data,\n        n = this._cachedMeta;\n      if (this._parsing === !1) n._parsed = s;else {\n        var o = function o(l) {\n          return +s[l];\n        };\n        if (T(s[t])) {\n          var _this$_parsing$key = this._parsing.key,\n            l = _this$_parsing$key === void 0 ? \"value\" : _this$_parsing$key;\n          o = function o(c) {\n            return +It(s[c], l);\n          };\n        }\n        var r, a;\n        for (r = t, a = t + e; r < a; ++r) n._parsed[r] = o(r);\n      }\n    }\n  }, {\n    key: \"_getRotation\",\n    value: function _getRotation() {\n      return bt(this.options.rotation - 90);\n    }\n  }, {\n    key: \"_getCircumference\",\n    value: function _getCircumference() {\n      return bt(this.options.circumference);\n    }\n  }, {\n    key: \"_getRotationExtents\",\n    value: function _getRotationExtents() {\n      var t = B,\n        e = -B;\n      for (var s = 0; s < this.chart.data.datasets.length; ++s) if (this.chart.isDatasetVisible(s) && this.chart.getDatasetMeta(s).type === this._type) {\n        var n = this.chart.getDatasetMeta(s).controller,\n          o = n._getRotation(),\n          r = n._getCircumference();\n        t = Math.min(t, o), e = Math.max(e, o + r);\n      }\n      return {\n        rotation: t,\n        circumference: e - t\n      };\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = this.chart,\n        s = e.chartArea,\n        n = this._cachedMeta,\n        o = n.data,\n        r = this.getMaxBorderWidth() + this.getMaxOffset(o) + this.options.spacing,\n        a = Math.max((Math.min(s.width, s.height) - r) / 2, 0),\n        l = Math.min(Eo(this.options.cutout, a), 1),\n        c = this._getRingWeight(this.index),\n        _this$_getRotationExt = this._getRotationExtents(),\n        h = _this$_getRotationExt.circumference,\n        d = _this$_getRotationExt.rotation,\n        _ka = ka(d, h, l),\n        u = _ka.ratioX,\n        f = _ka.ratioY,\n        p = _ka.offsetX,\n        g = _ka.offsetY,\n        m = (s.width - r) / u,\n        b = (s.height - r) / f,\n        _ = Math.max(Math.min(m, b) / 2, 0),\n        v = bn(this.options.radius, _),\n        y = Math.max(v * l, 0),\n        x = (v - y) / this._getVisibleDatasetWeightTotal();\n      this.offsetX = p * v, this.offsetY = g * v, n.total = this.calculateTotal(), this.outerRadius = v - x * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - x * c, 0), this.updateElements(o, 0, o.length, t);\n    }\n  }, {\n    key: \"_circumference\",\n    value: function _circumference(t, e) {\n      var s = this.options,\n        n = this._cachedMeta,\n        o = this._getCircumference();\n      return e && s.animation.animateRotate || !this.chart.getDataVisibility(t) || n._parsed[t] === null || n.data[t].hidden ? 0 : this.calculateCircumference(n._parsed[t] * o / B);\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {\n      var o = n === \"reset\",\n        r = this.chart,\n        a = r.chartArea,\n        c = r.options.animation,\n        h = (a.left + a.right) / 2,\n        d = (a.top + a.bottom) / 2,\n        u = o && c.animateScale,\n        f = u ? 0 : this.innerRadius,\n        p = u ? 0 : this.outerRadius,\n        _this$_getSharedOptio2 = this._getSharedOptions(e, n),\n        g = _this$_getSharedOptio2.sharedOptions,\n        m = _this$_getSharedOptio2.includeOptions;\n      var b = this._getRotation(),\n        _;\n      for (_ = 0; _ < e; ++_) b += this._circumference(_, o);\n      for (_ = e; _ < e + s; ++_) {\n        var v = this._circumference(_, o),\n          y = t[_],\n          x = {\n            x: h + this.offsetX,\n            y: d + this.offsetY,\n            startAngle: b,\n            endAngle: b + v,\n            circumference: v,\n            outerRadius: p,\n            innerRadius: f\n          };\n        m && (x.options = g || this.resolveDataElementOptions(_, y.active ? \"active\" : n)), b += v, this.updateElement(y, _, x, n);\n      }\n    }\n  }, {\n    key: \"calculateTotal\",\n    value: function calculateTotal() {\n      var t = this._cachedMeta,\n        e = t.data;\n      var s = 0,\n        n;\n      for (n = 0; n < e.length; n++) {\n        var o = t._parsed[n];\n        o !== null && !isNaN(o) && this.chart.getDataVisibility(n) && !e[n].hidden && (s += Math.abs(o));\n      }\n      return s;\n    }\n  }, {\n    key: \"calculateCircumference\",\n    value: function calculateCircumference(t) {\n      var e = this._cachedMeta.total;\n      return e > 0 && !isNaN(t) ? B * (Math.abs(t) / e) : 0;\n    }\n  }, {\n    key: \"getLabelAndValue\",\n    value: function getLabelAndValue(t) {\n      var e = this._cachedMeta,\n        s = this.chart,\n        n = s.data.labels || [],\n        o = Hi(e._parsed[t], s.options.locale);\n      return {\n        label: n[t] || \"\",\n        value: o\n      };\n    }\n  }, {\n    key: \"getMaxBorderWidth\",\n    value: function getMaxBorderWidth(t) {\n      var e = 0;\n      var s = this.chart;\n      var n, o, r, a, l;\n      if (!t) {\n        for (n = 0, o = s.data.datasets.length; n < o; ++n) if (s.isDatasetVisible(n)) {\n          r = s.getDatasetMeta(n), t = r.data, a = r.controller;\n          break;\n        }\n      }\n      if (!t) return 0;\n      for (n = 0, o = t.length; n < o; ++n) l = a.resolveDataElementOptions(n), l.borderAlign !== \"inner\" && (e = Math.max(e, l.borderWidth || 0, l.hoverBorderWidth || 0));\n      return e;\n    }\n  }, {\n    key: \"getMaxOffset\",\n    value: function getMaxOffset(t) {\n      var e = 0;\n      for (var s = 0, n = t.length; s < n; ++s) {\n        var o = this.resolveDataElementOptions(s);\n        e = Math.max(e, o.offset || 0, o.hoverOffset || 0);\n      }\n      return e;\n    }\n  }, {\n    key: \"_getRingWeightOffset\",\n    value: function _getRingWeightOffset(t) {\n      var e = 0;\n      for (var s = 0; s < t; ++s) this.chart.isDatasetVisible(s) && (e += this._getRingWeight(s));\n      return e;\n    }\n  }, {\n    key: \"_getRingWeight\",\n    value: function _getRingWeight(t) {\n      return Math.max(D(this.chart.data.datasets[t].weight, 1), 0);\n    }\n  }, {\n    key: \"_getVisibleDatasetWeightTotal\",\n    value: function _getVisibleDatasetWeightTotal() {\n      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n    }\n  }]);\n}(kt);\nw(jt, \"id\", \"doughnut\"), w(jt, \"defaults\", {\n  datasetElementType: !1,\n  dataElementType: \"arc\",\n  animation: {\n    animateRotate: !0,\n    animateScale: !1\n  },\n  animations: {\n    numbers: {\n      type: \"number\",\n      properties: [\"circumference\", \"endAngle\", \"innerRadius\", \"outerRadius\", \"startAngle\", \"x\", \"y\", \"offset\", \"borderWidth\", \"spacing\"]\n    }\n  },\n  cutout: \"50%\",\n  rotation: 0,\n  circumference: 360,\n  radius: \"100%\",\n  spacing: 0,\n  indexAxis: \"r\"\n}), w(jt, \"descriptors\", {\n  _scriptable: function _scriptable(t) {\n    return t !== \"spacing\";\n  },\n  _indexable: function _indexable(t) {\n    return t !== \"spacing\" && !t.startsWith(\"borderDash\") && !t.startsWith(\"hoverBorderDash\");\n  }\n}), w(jt, \"overrides\", {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels: function generateLabels(t) {\n          var e = t.data,\n            _t$legend$options$lab = t.legend.options.labels,\n            s = _t$legend$options$lab.pointStyle,\n            n = _t$legend$options$lab.textAlign,\n            o = _t$legend$options$lab.color,\n            r = _t$legend$options$lab.useBorderRadius,\n            a = _t$legend$options$lab.borderRadius;\n          return e.labels.length && e.datasets.length ? e.labels.map(function (l, c) {\n            var d = t.getDatasetMeta(0).controller.getStyle(c);\n            return {\n              text: l,\n              fillStyle: d.backgroundColor,\n              fontColor: o,\n              hidden: !t.getDataVisibility(c),\n              lineDash: d.borderDash,\n              lineDashOffset: d.borderDashOffset,\n              lineJoin: d.borderJoinStyle,\n              lineWidth: d.borderWidth,\n              strokeStyle: d.borderColor,\n              textAlign: n,\n              pointStyle: s,\n              borderRadius: r && (a || d.borderRadius),\n              index: c\n            };\n          }) : [];\n        }\n      },\n      onClick: function onClick(t, e, s) {\n        s.chart.toggleDataVisibility(e.index), s.chart.update();\n      }\n    }\n  }\n});\nvar Fe = /*#__PURE__*/function (_kt3) {\n  function Fe() {\n    _classCallCheck(this, Fe);\n    return _callSuper(this, Fe, arguments);\n  }\n  _inherits(Fe, _kt3);\n  return _createClass(Fe, [{\n    key: \"initialize\",\n    value: function initialize() {\n      this.enableOptionSharing = !0, this.supportsDecimation = !0, _superPropGet(Fe, \"initialize\", this, 3)([]);\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = this._cachedMeta,\n        s = e.dataset,\n        _e$data = e.data,\n        n = _e$data === void 0 ? [] : _e$data,\n        o = e._dataset,\n        r = this.chart._animationsDisabled;\n      var _wn = wn(e, n, r),\n        a = _wn.start,\n        l = _wn.count;\n      this._drawStart = a, this._drawCount = l, Pn(e) && (a = 0, l = n.length), s._chart = this.chart, s._datasetIndex = this.index, s._decimated = !!o._decimated, s.points = n;\n      var c = this.resolveDatasetElementOptions(t);\n      this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(s, void 0, {\n        animated: !r,\n        options: c\n      }, t), this.updateElements(n, a, l, t);\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {\n      var o = n === \"reset\",\n        _this$_cachedMeta2 = this._cachedMeta,\n        r = _this$_cachedMeta2.iScale,\n        a = _this$_cachedMeta2.vScale,\n        l = _this$_cachedMeta2._stacked,\n        c = _this$_cachedMeta2._dataset,\n        _this$_getSharedOptio3 = this._getSharedOptions(e, n),\n        h = _this$_getSharedOptio3.sharedOptions,\n        d = _this$_getSharedOptio3.includeOptions,\n        u = r.axis,\n        f = a.axis,\n        _this$options2 = this.options,\n        p = _this$options2.spanGaps,\n        g = _this$options2.segment,\n        m = Xt(p) ? p : Number.POSITIVE_INFINITY,\n        b = this.chart._animationsDisabled || o || n === \"none\",\n        _ = e + s,\n        v = t.length;\n      var y = e > 0 && this.getParsed(e - 1);\n      for (var x = 0; x < v; ++x) {\n        var M = t[x],\n          S = b ? M : {};\n        if (x < e || x >= _) {\n          S.skip = !0;\n          continue;\n        }\n        var k = this.getParsed(x),\n          P = R(k[f]),\n          C = S[u] = r.getPixelForValue(k[u], x),\n          O = S[f] = o || P ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, k, l) : k[f], x);\n        S.skip = isNaN(C) || isNaN(O) || P, S.stop = x > 0 && Math.abs(k[u] - y[u]) > m, g && (S.parsed = k, S.raw = c.data[x]), d && (S.options = h || this.resolveDataElementOptions(x, M.active ? \"active\" : n)), b || this.updateElement(M, x, S, n), y = k;\n      }\n    }\n  }, {\n    key: \"getMaxOverflow\",\n    value: function getMaxOverflow() {\n      var t = this._cachedMeta,\n        e = t.dataset,\n        s = e.options && e.options.borderWidth || 0,\n        n = t.data || [];\n      if (!n.length) return s;\n      var o = n[0].size(this.resolveDataElementOptions(0)),\n        r = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1));\n      return Math.max(s, o, r) / 2;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var t = this._cachedMeta;\n      t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), _superPropGet(Fe, \"draw\", this, 3)([]);\n    }\n  }]);\n}(kt);\nw(Fe, \"id\", \"line\"), w(Fe, \"defaults\", {\n  datasetElementType: \"line\",\n  dataElementType: \"point\",\n  showLine: !0,\n  spanGaps: !1\n}), w(Fe, \"overrides\", {\n  scales: {\n    _index_: {\n      type: \"category\"\n    },\n    _value_: {\n      type: \"linear\"\n    }\n  }\n});\nvar ki = /*#__PURE__*/function (_jt) {\n  function ki() {\n    _classCallCheck(this, ki);\n    return _callSuper(this, ki, arguments);\n  }\n  _inherits(ki, _jt);\n  return _createClass(ki);\n}(jt);\nw(ki, \"id\", \"pie\"), w(ki, \"defaults\", {\n  cutout: 0,\n  rotation: 0,\n  circumference: 360,\n  radius: \"100%\"\n});\nvar Ie = /*#__PURE__*/function (_kt4) {\n  function Ie() {\n    _classCallCheck(this, Ie);\n    return _callSuper(this, Ie, arguments);\n  }\n  _inherits(Ie, _kt4);\n  return _createClass(Ie, [{\n    key: \"getLabelAndValue\",\n    value: function getLabelAndValue(t) {\n      var e = this._cachedMeta,\n        s = this.chart.data.labels || [],\n        n = e.xScale,\n        o = e.yScale,\n        r = this.getParsed(t),\n        a = n.getLabelForValue(r.x),\n        l = o.getLabelForValue(r.y);\n      return {\n        label: s[t] || \"\",\n        value: \"(\" + a + \", \" + l + \")\"\n      };\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = this._cachedMeta,\n        _e$data2 = e.data,\n        s = _e$data2 === void 0 ? [] : _e$data2,\n        n = this.chart._animationsDisabled;\n      var _wn2 = wn(e, s, n),\n        o = _wn2.start,\n        r = _wn2.count;\n      if (this._drawStart = o, this._drawCount = r, Pn(e) && (o = 0, r = s.length), this.options.showLine) {\n        this.datasetElementType || this.addElements();\n        var a = e.dataset,\n          l = e._dataset;\n        a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!l._decimated, a.points = s;\n        var c = this.resolveDatasetElementOptions(t);\n        c.segment = this.options.segment, this.updateElement(a, void 0, {\n          animated: !n,\n          options: c\n        }, t);\n      } else this.datasetElementType && (delete e.dataset, this.datasetElementType = !1);\n      this.updateElements(s, o, r, t);\n    }\n  }, {\n    key: \"addElements\",\n    value: function addElements() {\n      var t = this.options.showLine;\n      !this.datasetElementType && t && (this.datasetElementType = this.chart.registry.getElement(\"line\")), _superPropGet(Ie, \"addElements\", this, 3)([]);\n    }\n  }, {\n    key: \"updateElements\",\n    value: function updateElements(t, e, s, n) {\n      var o = n === \"reset\",\n        _this$_cachedMeta3 = this._cachedMeta,\n        r = _this$_cachedMeta3.iScale,\n        a = _this$_cachedMeta3.vScale,\n        l = _this$_cachedMeta3._stacked,\n        c = _this$_cachedMeta3._dataset,\n        h = this.resolveDataElementOptions(e, n),\n        d = this.getSharedOptions(h),\n        u = this.includeOptions(n, d),\n        f = r.axis,\n        p = a.axis,\n        _this$options3 = this.options,\n        g = _this$options3.spanGaps,\n        m = _this$options3.segment,\n        b = Xt(g) ? g : Number.POSITIVE_INFINITY,\n        _ = this.chart._animationsDisabled || o || n === \"none\";\n      var v = e > 0 && this.getParsed(e - 1);\n      for (var y = e; y < e + s; ++y) {\n        var x = t[y],\n          M = this.getParsed(y),\n          S = _ ? x : {},\n          k = R(M[p]),\n          P = S[f] = r.getPixelForValue(M[f], y),\n          C = S[p] = o || k ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, M, l) : M[p], y);\n        S.skip = isNaN(P) || isNaN(C) || k, S.stop = y > 0 && Math.abs(M[f] - v[f]) > b, m && (S.parsed = M, S.raw = c.data[y]), u && (S.options = d || this.resolveDataElementOptions(y, x.active ? \"active\" : n)), _ || this.updateElement(x, y, S, n), v = M;\n      }\n      this.updateSharedOptions(d, n, h);\n    }\n  }, {\n    key: \"getMaxOverflow\",\n    value: function getMaxOverflow() {\n      var t = this._cachedMeta,\n        e = t.data || [];\n      if (!this.options.showLine) {\n        var a = 0;\n        for (var l = e.length - 1; l >= 0; --l) a = Math.max(a, e[l].size(this.resolveDataElementOptions(l)) / 2);\n        return a > 0 && a;\n      }\n      var s = t.dataset,\n        n = s.options && s.options.borderWidth || 0;\n      if (!e.length) return n;\n      var o = e[0].size(this.resolveDataElementOptions(0)),\n        r = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));\n      return Math.max(n, o, r) / 2;\n    }\n  }]);\n}(kt);\nw(Ie, \"id\", \"scatter\"), w(Ie, \"defaults\", {\n  datasetElementType: !1,\n  dataElementType: \"point\",\n  showLine: !1,\n  fill: !1\n}), w(Ie, \"overrides\", {\n  interaction: {\n    mode: \"point\"\n  },\n  scales: {\n    x: {\n      type: \"linear\"\n    },\n    y: {\n      type: \"linear\"\n    }\n  }\n});\nfunction Tt() {\n  throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\");\n}\nvar Ui = /*#__PURE__*/function () {\n  function Ui(t) {\n    _classCallCheck(this, Ui);\n    w(this, \"options\");\n    this.options = t || {};\n  }\n  /**\n  * Override default date adapter methods.\n  * Accepts type parameter to define options type.\n  * @example\n  * Chart._adapters._date.override<{myAdapterOption: string}>({\n  *   init() {\n  *     console.log(this.options.myAdapterOption);\n  *   }\n  * })\n  */\n  return _createClass(Ui, [{\n    key: \"init\",\n    value:\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    function init() {}\n  }, {\n    key: \"formats\",\n    value: function formats() {\n      return Tt();\n    }\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      return Tt();\n    }\n  }, {\n    key: \"format\",\n    value: function format() {\n      return Tt();\n    }\n  }, {\n    key: \"add\",\n    value: function add() {\n      return Tt();\n    }\n  }, {\n    key: \"diff\",\n    value: function diff() {\n      return Tt();\n    }\n  }, {\n    key: \"startOf\",\n    value: function startOf() {\n      return Tt();\n    }\n  }, {\n    key: \"endOf\",\n    value: function endOf() {\n      return Tt();\n    }\n  }], [{\n    key: \"override\",\n    value: function override(t) {\n      Object.assign(Ui.prototype, t);\n    }\n  }]);\n}();\nvar wa = {\n  _date: Ui\n};\nfunction Pa(i, t, e, s) {\n  var n = i.controller,\n    o = i.data,\n    r = i._sorted,\n    a = n._cachedMeta.iScale,\n    l = i.dataset && i.dataset.options ? i.dataset.options.spanGaps : null;\n  if (a && t === a.axis && t !== \"r\" && r && o.length) {\n    var c = a._reversePixels ? Ko : Et;\n    if (s) {\n      if (n._sharedOptions) {\n        var h = o[0],\n          d = typeof h.getRange == \"function\" && h.getRange(t);\n        if (d) {\n          var u = c(o, t, e - d),\n            f = c(o, t, e + d);\n          return {\n            lo: u.lo,\n            hi: f.hi\n          };\n        }\n      }\n    } else {\n      var _h = c(o, t, e);\n      if (l) {\n        var _d = n._cachedMeta.vScale,\n          _u = i._parsed,\n          _f = _u.slice(0, _h.lo + 1).reverse().findIndex(function (g) {\n            return !R(g[_d.axis]);\n          });\n        _h.lo -= Math.max(0, _f);\n        var p = _u.slice(_h.hi).findIndex(function (g) {\n          return !R(g[_d.axis]);\n        });\n        _h.hi += Math.max(0, p);\n      }\n      return _h;\n    }\n  }\n  return {\n    lo: 0,\n    hi: o.length - 1\n  };\n}\nfunction ti(i, t, e, s, n) {\n  var o = i.getSortedVisibleDatasetMetas(),\n    r = e[t];\n  for (var a = 0, l = o.length; a < l; ++a) {\n    var _o$a = o[a],\n      c = _o$a.index,\n      h = _o$a.data,\n      _Pa = Pa(o[a], t, r, n),\n      d = _Pa.lo,\n      u = _Pa.hi;\n    for (var f = d; f <= u; ++f) {\n      var p = h[f];\n      p.skip || s(p, c, f);\n    }\n  }\n}\nfunction Da(i) {\n  var t = i.indexOf(\"x\") !== -1,\n    e = i.indexOf(\"y\") !== -1;\n  return function (s, n) {\n    var o = t ? Math.abs(s.x - n.x) : 0,\n      r = e ? Math.abs(s.y - n.y) : 0;\n    return Math.sqrt(Math.pow(o, 2) + Math.pow(r, 2));\n  };\n}\nfunction hi(i, t, e, s, n) {\n  var o = [];\n  return !n && !i.isPointInArea(t) || ti(i, e, t, function (a, l, c) {\n    !n && !me(a, i.chartArea, 0) || a.inRange(t.x, t.y, s) && o.push({\n      element: a,\n      datasetIndex: l,\n      index: c\n    });\n  }, !0), o;\n}\nfunction Ca(i, t, e, s) {\n  var n = [];\n  function o(r, a, l) {\n    var _r$getProps = r.getProps([\"startAngle\", \"endAngle\"], s),\n      c = _r$getProps.startAngle,\n      h = _r$getProps.endAngle,\n      _yn = yn(r, {\n        x: t.x,\n        y: t.y\n      }),\n      d = _yn.angle;\n    pe(d, c, h) && n.push({\n      element: r,\n      datasetIndex: a,\n      index: l\n    });\n  }\n  return ti(i, e, t, o), n;\n}\nfunction Oa(i, t, e, s, n, o) {\n  var r = [];\n  var a = Da(e);\n  var l = Number.POSITIVE_INFINITY;\n  function c(h, d, u) {\n    var f = h.inRange(t.x, t.y, n);\n    if (s && !f) return;\n    var p = h.getCenterPoint(n);\n    if (!(!!o || i.isPointInArea(p)) && !f) return;\n    var m = a(t, p);\n    m < l ? (r = [{\n      element: h,\n      datasetIndex: d,\n      index: u\n    }], l = m) : m === l && r.push({\n      element: h,\n      datasetIndex: d,\n      index: u\n    });\n  }\n  return ti(i, e, t, c), r;\n}\nfunction di(i, t, e, s, n, o) {\n  return !o && !i.isPointInArea(t) ? [] : e === \"r\" && !s ? Ca(i, t, e, n) : Oa(i, t, e, s, n, o);\n}\nfunction Ps(i, t, e, s, n) {\n  var o = [],\n    r = e === \"x\" ? \"inXRange\" : \"inYRange\";\n  var a = !1;\n  return ti(i, e, t, function (l, c, h) {\n    l[r] && l[r](t[e], n) && (o.push({\n      element: l,\n      datasetIndex: c,\n      index: h\n    }), a = a || l.inRange(t.x, t.y, n));\n  }), s && !a ? [] : o;\n}\nvar Ta = {\n  modes: {\n    index: function index(i, t, e, s) {\n      var n = At(t, i),\n        o = e.axis || \"x\",\n        r = e.includeInvisible || !1,\n        a = e.intersect ? hi(i, n, o, s, r) : di(i, n, o, !1, s, r),\n        l = [];\n      return a.length ? (i.getSortedVisibleDatasetMetas().forEach(function (c) {\n        var h = a[0].index,\n          d = c.data[h];\n        d && !d.skip && l.push({\n          element: d,\n          datasetIndex: c.index,\n          index: h\n        });\n      }), l) : [];\n    },\n    dataset: function dataset(i, t, e, s) {\n      var n = At(t, i),\n        o = e.axis || \"xy\",\n        r = e.includeInvisible || !1;\n      var a = e.intersect ? hi(i, n, o, s, r) : di(i, n, o, !1, s, r);\n      if (a.length > 0) {\n        var l = a[0].datasetIndex,\n          c = i.getDatasetMeta(l).data;\n        a = [];\n        for (var h = 0; h < c.length; ++h) a.push({\n          element: c[h],\n          datasetIndex: l,\n          index: h\n        });\n      }\n      return a;\n    },\n    point: function point(i, t, e, s) {\n      var n = At(t, i),\n        o = e.axis || \"xy\",\n        r = e.includeInvisible || !1;\n      return hi(i, n, o, s, r);\n    },\n    nearest: function nearest(i, t, e, s) {\n      var n = At(t, i),\n        o = e.axis || \"xy\",\n        r = e.includeInvisible || !1;\n      return di(i, n, o, e.intersect, s, r);\n    },\n    x: function x(i, t, e, s) {\n      var n = At(t, i);\n      return Ps(i, n, \"x\", e.intersect, s);\n    },\n    y: function y(i, t, e, s) {\n      var n = At(t, i);\n      return Ps(i, n, \"y\", e.intersect, s);\n    }\n  }\n};\nvar $n = [\"left\", \"top\", \"right\", \"bottom\"];\nfunction te(i, t) {\n  return i.filter(function (e) {\n    return e.pos === t;\n  });\n}\nfunction Ds(i, t) {\n  return i.filter(function (e) {\n    return $n.indexOf(e.pos) === -1 && e.box.axis === t;\n  });\n}\nfunction ee(i, t) {\n  return i.sort(function (e, s) {\n    var n = t ? s : e,\n      o = t ? e : s;\n    return n.weight === o.weight ? n.index - o.index : n.weight - o.weight;\n  });\n}\nfunction Aa(i) {\n  var t = [];\n  var e, s, n, o, r, a;\n  for (e = 0, s = (i || []).length; e < s; ++e) {\n    var _n3, _n3$options, _n3$options$stackWeig;\n    n = i[e], _n3 = n, o = _n3.position, _n3$options = _n3.options, r = _n3$options.stack, _n3$options$stackWeig = _n3$options.stackWeight, a = _n3$options$stackWeig === void 0 ? 1 : _n3$options$stackWeig, t.push({\n      index: e,\n      box: n,\n      pos: o,\n      horizontal: n.isHorizontal(),\n      weight: n.weight,\n      stack: r && o + r,\n      stackWeight: a\n    });\n  }\n  return t;\n}\nfunction Ra(i) {\n  var t = {};\n  var _iterator15 = _createForOfIteratorHelper(i),\n    _step15;\n  try {\n    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n      var e = _step15.value;\n      var s = e.stack,\n        n = e.pos,\n        o = e.stackWeight;\n      if (!s || !$n.includes(n)) continue;\n      var r = t[s] || (t[s] = {\n        count: 0,\n        placed: 0,\n        weight: 0,\n        size: 0\n      });\n      r.count++, r.weight += o;\n    }\n  } catch (err) {\n    _iterator15.e(err);\n  } finally {\n    _iterator15.f();\n  }\n  return t;\n}\nfunction La(i, t) {\n  var e = Ra(i),\n    s = t.vBoxMaxWidth,\n    n = t.hBoxMaxHeight;\n  var o, r, a;\n  for (o = 0, r = i.length; o < r; ++o) {\n    a = i[o];\n    var l = a.box.fullSize,\n      c = e[a.stack],\n      h = c && a.stackWeight / c.weight;\n    a.horizontal ? (a.width = h ? h * s : l && t.availableWidth, a.height = n) : (a.width = s, a.height = h ? h * n : l && t.availableHeight);\n  }\n  return e;\n}\nfunction Ea(i) {\n  var t = Aa(i),\n    e = ee(t.filter(function (c) {\n      return c.box.fullSize;\n    }), !0),\n    s = ee(te(t, \"left\"), !0),\n    n = ee(te(t, \"right\")),\n    o = ee(te(t, \"top\"), !0),\n    r = ee(te(t, \"bottom\")),\n    a = Ds(t, \"x\"),\n    l = Ds(t, \"y\");\n  return {\n    fullSize: e,\n    leftAndTop: s.concat(o),\n    rightAndBottom: n.concat(l).concat(r).concat(a),\n    chartArea: te(t, \"chartArea\"),\n    vertical: s.concat(n).concat(l),\n    horizontal: o.concat(r).concat(a)\n  };\n}\nfunction Cs(i, t, e, s) {\n  return Math.max(i[e], t[e]) + Math.max(i[s], t[s]);\n}\nfunction Yn(i, t) {\n  i.top = Math.max(i.top, t.top), i.left = Math.max(i.left, t.left), i.bottom = Math.max(i.bottom, t.bottom), i.right = Math.max(i.right, t.right);\n}\nfunction Fa(i, t, e, s) {\n  var n = e.pos,\n    o = e.box,\n    r = i.maxPadding;\n  if (!T(n)) {\n    e.size && (i[n] -= e.size);\n    var d = s[e.stack] || {\n      size: 0,\n      count: 1\n    };\n    d.size = Math.max(d.size, e.horizontal ? o.height : o.width), e.size = d.size / d.count, i[n] += e.size;\n  }\n  o.getPadding && Yn(r, o.getPadding());\n  var a = Math.max(0, t.outerWidth - Cs(r, i, \"left\", \"right\")),\n    l = Math.max(0, t.outerHeight - Cs(r, i, \"top\", \"bottom\")),\n    c = a !== i.w,\n    h = l !== i.h;\n  return i.w = a, i.h = l, e.horizontal ? {\n    same: c,\n    other: h\n  } : {\n    same: h,\n    other: c\n  };\n}\nfunction Ia(i) {\n  var t = i.maxPadding;\n  function e(s) {\n    var n = Math.max(t[s] - i[s], 0);\n    return i[s] += n, n;\n  }\n  i.y += e(\"top\"), i.x += e(\"left\"), e(\"right\"), e(\"bottom\");\n}\nfunction za(i, t) {\n  var e = t.maxPadding;\n  function s(n) {\n    var o = {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n    return n.forEach(function (r) {\n      o[r] = Math.max(t[r], e[r]);\n    }), o;\n  }\n  return s(i ? [\"left\", \"right\"] : [\"top\", \"bottom\"]);\n}\nfunction oe(i, t, e, s) {\n  var n = [];\n  var o, r, a, l, c, h;\n  for (o = 0, r = i.length, c = 0; o < r; ++o) {\n    a = i[o], l = a.box, l.update(a.width || t.w, a.height || t.h, za(a.horizontal, t));\n    var _Fa = Fa(t, e, a, s),\n      d = _Fa.same,\n      u = _Fa.other;\n    c |= d && n.length, h = h || u, l.fullSize || n.push(a);\n  }\n  return c && oe(n, t, e, s) || h;\n}\nfunction Ce(i, t, e, s, n) {\n  i.top = e, i.left = t, i.right = t + s, i.bottom = e + n, i.width = s, i.height = n;\n}\nfunction Os(i, t, e, s) {\n  var n = e.padding;\n  var o = t.x,\n    r = t.y;\n  var _iterator16 = _createForOfIteratorHelper(i),\n    _step16;\n  try {\n    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n      var a = _step16.value;\n      var l = a.box,\n        c = s[a.stack] || {\n          placed: 0,\n          weight: 1\n        },\n        h = a.stackWeight / c.weight || 1;\n      if (a.horizontal) {\n        var d = t.w * h,\n          u = c.size || l.height;\n        ge(c.start) && (r = c.start), l.fullSize ? Ce(l, n.left, r, e.outerWidth - n.right - n.left, u) : Ce(l, t.left + c.placed, r, d, u), c.start = r, c.placed += d, r = l.bottom;\n      } else {\n        var _d2 = t.h * h,\n          _u2 = c.size || l.width;\n        ge(c.start) && (o = c.start), l.fullSize ? Ce(l, o, n.top, _u2, e.outerHeight - n.bottom - n.top) : Ce(l, o, t.top + c.placed, _u2, _d2), c.start = o, c.placed += _d2, o = l.right;\n      }\n    }\n  } catch (err) {\n    _iterator16.e(err);\n  } finally {\n    _iterator16.f();\n  }\n  t.x = o, t.y = r;\n}\nvar tt = {\n  addBox: function addBox(i, t) {\n    i.boxes || (i.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || \"top\", t.weight = t.weight || 0, t._layers = t._layers || function () {\n      return [{\n        z: 0,\n        draw: function draw(e) {\n          t.draw(e);\n        }\n      }];\n    }, i.boxes.push(t);\n  },\n  removeBox: function removeBox(i, t) {\n    var e = i.boxes ? i.boxes.indexOf(t) : -1;\n    e !== -1 && i.boxes.splice(e, 1);\n  },\n  configure: function configure(i, t, e) {\n    t.fullSize = e.fullSize, t.position = e.position, t.weight = e.weight;\n  },\n  update: function update(i, t, e, s) {\n    if (!i) return;\n    var n = et(i.options.layout.padding),\n      o = Math.max(t - n.width, 0),\n      r = Math.max(e - n.height, 0),\n      a = Ea(i.boxes),\n      l = a.vertical,\n      c = a.horizontal;\n    L(i.boxes, function (g) {\n      typeof g.beforeLayout == \"function\" && g.beforeLayout();\n    });\n    var h = l.reduce(function (g, m) {\n        return m.box.options && m.box.options.display === !1 ? g : g + 1;\n      }, 0) || 1,\n      d = Object.freeze({\n        outerWidth: t,\n        outerHeight: e,\n        padding: n,\n        availableWidth: o,\n        availableHeight: r,\n        vBoxMaxWidth: o / 2 / h,\n        hBoxMaxHeight: r / 2\n      }),\n      u = Object.assign({}, n);\n    Yn(u, et(s));\n    var f = Object.assign({\n        maxPadding: u,\n        w: o,\n        h: r,\n        x: n.left,\n        y: n.top\n      }, n),\n      p = La(l.concat(c), d);\n    oe(a.fullSize, f, d, p), oe(l, f, d, p), oe(c, f, d, p) && oe(l, f, d, p), Ia(f), Os(a.leftAndTop, f, d, p), f.x += f.w, f.y += f.h, Os(a.rightAndBottom, f, d, p), i.chartArea = {\n      left: f.left,\n      top: f.top,\n      right: f.left + f.w,\n      bottom: f.top + f.h,\n      height: f.h,\n      width: f.w\n    }, L(a.chartArea, function (g) {\n      var m = g.box;\n      Object.assign(m, i.chartArea), m.update(f.w, f.h, {\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0\n      });\n    });\n  }\n};\nvar Un = /*#__PURE__*/function () {\n  function Un() {\n    _classCallCheck(this, Un);\n  }\n  return _createClass(Un, [{\n    key: \"acquireContext\",\n    value: function acquireContext(t, e) {}\n  }, {\n    key: \"releaseContext\",\n    value: function releaseContext(t) {\n      return !1;\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(t, e, s) {}\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(t, e, s) {}\n  }, {\n    key: \"getDevicePixelRatio\",\n    value: function getDevicePixelRatio() {\n      return 1;\n    }\n  }, {\n    key: \"getMaximumSize\",\n    value: function getMaximumSize(t, e, s, n) {\n      return e = Math.max(0, e || t.width), s = s || t.height, {\n        width: e,\n        height: Math.max(0, n ? Math.floor(e / n) : s)\n      };\n    }\n  }, {\n    key: \"isAttached\",\n    value: function isAttached(t) {\n      return !0;\n    }\n  }, {\n    key: \"updateConfig\",\n    value: function updateConfig(t) {}\n  }]);\n}();\nvar Ba = /*#__PURE__*/function (_Un) {\n  function Ba() {\n    _classCallCheck(this, Ba);\n    return _callSuper(this, Ba, arguments);\n  }\n  _inherits(Ba, _Un);\n  return _createClass(Ba, [{\n    key: \"acquireContext\",\n    value: function acquireContext(t) {\n      return t && t.getContext && t.getContext(\"2d\") || null;\n    }\n  }, {\n    key: \"updateConfig\",\n    value: function updateConfig(t) {\n      t.options.animation = !1;\n    }\n  }]);\n}(Un);\nvar ze = \"$chartjs\",\n  Ha = {\n    touchstart: \"mousedown\",\n    touchmove: \"mousemove\",\n    touchend: \"mouseup\",\n    pointerenter: \"mouseenter\",\n    pointerdown: \"mousedown\",\n    pointermove: \"mousemove\",\n    pointerup: \"mouseup\",\n    pointerleave: \"mouseout\",\n    pointerout: \"mouseout\"\n  },\n  Ts = function Ts(i) {\n    return i === null || i === \"\";\n  };\nfunction Wa(i, t) {\n  var e = i.style,\n    s = i.getAttribute(\"height\"),\n    n = i.getAttribute(\"width\");\n  if (i[ze] = {\n    initial: {\n      height: s,\n      width: n,\n      style: {\n        display: e.display,\n        height: e.height,\n        width: e.width\n      }\n    }\n  }, e.display = e.display || \"block\", e.boxSizing = e.boxSizing || \"border-box\", Ts(n)) {\n    var o = fs(i, \"width\");\n    o !== void 0 && (i.width = o);\n  }\n  if (Ts(s)) if (i.style.height === \"\") i.height = i.width / (t || 2);else {\n    var _o2 = fs(i, \"height\");\n    _o2 !== void 0 && (i.height = _o2);\n  }\n  return i;\n}\nvar Xn = Vr ? {\n  passive: !0\n} : !1;\nfunction Na(i, t, e) {\n  i && i.addEventListener(t, e, Xn);\n}\nfunction Va(i, t, e) {\n  i && i.canvas && i.canvas.removeEventListener(t, e, Xn);\n}\nfunction ja(i, t) {\n  var e = Ha[i.type] || i.type,\n    _At = At(i, t),\n    s = _At.x,\n    n = _At.y;\n  return {\n    type: e,\n    chart: t,\n    \"native\": i,\n    x: s !== void 0 ? s : null,\n    y: n !== void 0 ? n : null\n  };\n}\nfunction qe(i, t) {\n  var _iterator17 = _createForOfIteratorHelper(i),\n    _step17;\n  try {\n    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n      var e = _step17.value;\n      if (e === t || e.contains(t)) return !0;\n    }\n  } catch (err) {\n    _iterator17.e(err);\n  } finally {\n    _iterator17.f();\n  }\n}\nfunction $a(i, t, e) {\n  var s = i.canvas,\n    n = new MutationObserver(function (o) {\n      var r = !1;\n      var _iterator18 = _createForOfIteratorHelper(o),\n        _step18;\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var a = _step18.value;\n          r = r || qe(a.addedNodes, s), r = r && !qe(a.removedNodes, s);\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n      r && e();\n    });\n  return n.observe(document, {\n    childList: !0,\n    subtree: !0\n  }), n;\n}\nfunction Ya(i, t, e) {\n  var s = i.canvas,\n    n = new MutationObserver(function (o) {\n      var r = !1;\n      var _iterator19 = _createForOfIteratorHelper(o),\n        _step19;\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var a = _step19.value;\n          r = r || qe(a.removedNodes, s), r = r && !qe(a.addedNodes, s);\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n      r && e();\n    });\n  return n.observe(document, {\n    childList: !0,\n    subtree: !0\n  }), n;\n}\nvar _e = /* @__PURE__ */new Map();\nvar As = 0;\nfunction qn() {\n  var i = window.devicePixelRatio;\n  i !== As && (As = i, _e.forEach(function (t, e) {\n    e.currentDevicePixelRatio !== i && t();\n  }));\n}\nfunction Ua(i, t) {\n  _e.size || window.addEventListener(\"resize\", qn), _e.set(i, t);\n}\nfunction Xa(i) {\n  _e[\"delete\"](i), _e.size || window.removeEventListener(\"resize\", qn);\n}\nfunction qa(i, t, e) {\n  var s = i.canvas,\n    n = s && Yi(s);\n  if (!n) return;\n  var o = kn(function (a, l) {\n      var c = n.clientWidth;\n      e(a, l), c < n.clientWidth && e();\n    }, window),\n    r = new ResizeObserver(function (a) {\n      var l = a[0],\n        c = l.contentRect.width,\n        h = l.contentRect.height;\n      c === 0 && h === 0 || o(c, h);\n    });\n  return r.observe(n), Ua(i, o), r;\n}\nfunction ui(i, t, e) {\n  e && e.disconnect(), t === \"resize\" && Xa(i);\n}\nfunction Ka(i, t, e) {\n  var s = i.canvas,\n    n = kn(function (o) {\n      i.ctx !== null && e(ja(o, i));\n    }, i);\n  return Na(s, t, n), n;\n}\nvar Ga = /*#__PURE__*/function (_Un2) {\n  function Ga() {\n    _classCallCheck(this, Ga);\n    return _callSuper(this, Ga, arguments);\n  }\n  _inherits(Ga, _Un2);\n  return _createClass(Ga, [{\n    key: \"acquireContext\",\n    value: function acquireContext(t, e) {\n      var s = t && t.getContext && t.getContext(\"2d\");\n      return s && s.canvas === t ? (Wa(t, e), s) : null;\n    }\n  }, {\n    key: \"releaseContext\",\n    value: function releaseContext(t) {\n      var e = t.canvas;\n      if (!e[ze]) return !1;\n      var s = e[ze].initial;\n      [\"height\", \"width\"].forEach(function (o) {\n        var r = s[o];\n        R(r) ? e.removeAttribute(o) : e.setAttribute(o, r);\n      });\n      var n = s.style || {};\n      return Object.keys(n).forEach(function (o) {\n        e.style[o] = n[o];\n      }), e.width = e.width, delete e[ze], !0;\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(t, e, s) {\n      this.removeEventListener(t, e);\n      var n = t.$proxies || (t.$proxies = {}),\n        r = {\n          attach: $a,\n          detach: Ya,\n          resize: qa\n        }[e] || Ka;\n      n[e] = r(t, e, s);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(t, e) {\n      var s = t.$proxies || (t.$proxies = {}),\n        n = s[e];\n      if (!n) return;\n      ({\n        attach: ui,\n        detach: ui,\n        resize: ui\n      }[e] || Va)(t, e, n), s[e] = void 0;\n    }\n  }, {\n    key: \"getDevicePixelRatio\",\n    value: function getDevicePixelRatio() {\n      return window.devicePixelRatio;\n    }\n  }, {\n    key: \"getMaximumSize\",\n    value: function getMaximumSize(t, e, s, n) {\n      return Nr(t, e, s, n);\n    }\n  }, {\n    key: \"isAttached\",\n    value: function isAttached(t) {\n      var e = t && Yi(t);\n      return !!(e && e.isConnected);\n    }\n  }]);\n}(Un);\nfunction Ja(i) {\n  return !$i() || (typeof OffscreenCanvas === \"undefined\" ? \"undefined\" : _typeof(OffscreenCanvas)) < \"u\" && i instanceof OffscreenCanvas ? Ba : Ga;\n}\nvar st = /*#__PURE__*/function () {\n  function st() {\n    _classCallCheck(this, st);\n    w(this, \"x\");\n    w(this, \"y\");\n    w(this, \"active\", !1);\n    w(this, \"options\");\n    w(this, \"$animations\");\n  }\n  return _createClass(st, [{\n    key: \"tooltipPosition\",\n    value: function tooltipPosition(t) {\n      var _this$getProps = this.getProps([\"x\", \"y\"], t),\n        e = _this$getProps.x,\n        s = _this$getProps.y;\n      return {\n        x: e,\n        y: s\n      };\n    }\n  }, {\n    key: \"hasValue\",\n    value: function hasValue() {\n      return Xt(this.x) && Xt(this.y);\n    }\n  }, {\n    key: \"getProps\",\n    value: function getProps(t, e) {\n      var _this7 = this;\n      var s = this.$animations;\n      if (!e || !s) return this;\n      var n = {};\n      return t.forEach(function (o) {\n        n[o] = s[o] && s[o].active() ? s[o]._to : _this7[o];\n      }), n;\n    }\n  }]);\n}();\nw(st, \"defaults\", {}), w(st, \"defaultRoutes\");\nfunction Za(i, t) {\n  var e = i.options.ticks,\n    s = Qa(i),\n    n = Math.min(e.maxTicksLimit || s, s),\n    o = e.major.enabled ? el(t) : [],\n    r = o.length,\n    a = o[0],\n    l = o[r - 1],\n    c = [];\n  if (r > n) return il(t, c, o, r / n), c;\n  var h = tl(o, t, n);\n  if (r > 0) {\n    var d, u;\n    var f = r > 1 ? Math.round((l - a) / (r - 1)) : null;\n    for (Oe(t, c, h, R(f) ? 0 : a - f, a), d = 0, u = r - 1; d < u; d++) Oe(t, c, h, o[d], o[d + 1]);\n    return Oe(t, c, h, l, R(f) ? t.length : l + f), c;\n  }\n  return Oe(t, c, h), c;\n}\nfunction Qa(i) {\n  var t = i.options.offset,\n    e = i._tickSize(),\n    s = i._length / e + (t ? 0 : 1),\n    n = i._maxLength / e;\n  return Math.floor(Math.min(s, n));\n}\nfunction tl(i, t, e) {\n  var s = sl(i),\n    n = t.length / e;\n  if (!s) return Math.max(n, 1);\n  var o = Vo(s);\n  for (var r = 0, a = o.length - 1; r < a; r++) {\n    var l = o[r];\n    if (l > n) return l;\n  }\n  return Math.max(n, 1);\n}\nfunction el(i) {\n  var t = [];\n  var e, s;\n  for (e = 0, s = i.length; e < s; e++) i[e].major && t.push(e);\n  return t;\n}\nfunction il(i, t, e, s) {\n  var n = 0,\n    o = e[0],\n    r;\n  for (s = Math.ceil(s), r = 0; r < i.length; r++) r === o && (t.push(i[r]), n++, o = e[n * s]);\n}\nfunction Oe(i, t, e, s, n) {\n  var o = D(s, 0),\n    r = Math.min(D(n, i.length), i.length);\n  var a = 0,\n    l,\n    c,\n    h;\n  for (e = Math.ceil(e), n && (l = n - s, e = l / Math.floor(l / e)), h = o; h < 0;) a++, h = Math.round(o + a * e);\n  for (c = Math.max(o, 0); c < r; c++) c === h && (t.push(i[c]), a++, h = Math.round(o + a * e));\n}\nfunction sl(i) {\n  var t = i.length;\n  var e, s;\n  if (t < 2) return !1;\n  for (s = i[0], e = 1; e < t; ++e) if (i[e] - i[e - 1] !== s) return !1;\n  return s;\n}\nvar nl = function nl(i) {\n    return i === \"left\" ? \"right\" : i === \"right\" ? \"left\" : i;\n  },\n  Rs = function Rs(i, t, e) {\n    return t === \"top\" || t === \"left\" ? i[t] + e : i[t] - e;\n  },\n  Ls = function Ls(i, t) {\n    return Math.min(t || i, i);\n  };\nfunction Es(i, t) {\n  var e = [],\n    s = i.length / t,\n    n = i.length;\n  var o = 0;\n  for (; o < n; o += s) e.push(i[Math.floor(o)]);\n  return e;\n}\nfunction ol(i, t, e) {\n  var s = i.ticks.length,\n    n = Math.min(t, s - 1),\n    o = i._startPixel,\n    r = i._endPixel,\n    a = 1e-6;\n  var l = i.getPixelForTick(n),\n    c;\n  if (!(e && (s === 1 ? c = Math.max(l - o, r - l) : t === 0 ? c = (i.getPixelForTick(1) - l) / 2 : c = (l - i.getPixelForTick(n - 1)) / 2, l += n < t ? c : -c, l < o - a || l > r + a))) return l;\n}\nfunction rl(i, t) {\n  L(i, function (e) {\n    var s = e.gc,\n      n = s.length / 2;\n    var o;\n    if (n > t) {\n      for (o = 0; o < n; ++o) delete e.data[s[o]];\n      s.splice(0, n);\n    }\n  });\n}\nfunction ie(i) {\n  return i.drawTicks ? i.tickLength : 0;\n}\nfunction Fs(i, t) {\n  if (!i.display) return 0;\n  var e = X(i.font, t),\n    s = et(i.padding);\n  return (N(i.text) ? i.text.length : 1) * e.lineHeight + s.height;\n}\nfunction al(i, t) {\n  return Bt(i, {\n    scale: t,\n    type: \"scale\"\n  });\n}\nfunction ll(i, t, e) {\n  return Bt(i, {\n    tick: e,\n    index: t,\n    type: \"tick\"\n  });\n}\nfunction cl(i, t, e) {\n  var s = zi(i);\n  return (e && t !== \"right\" || !e && t === \"right\") && (s = nl(s)), s;\n}\nfunction hl(i, t, e, s) {\n  var n = i.top,\n    o = i.left,\n    r = i.bottom,\n    a = i.right,\n    l = i.chart,\n    c = l.chartArea,\n    h = l.scales;\n  var d = 0,\n    u,\n    f,\n    p;\n  var g = r - n,\n    m = a - o;\n  if (i.isHorizontal()) {\n    if (f = Y(s, o, a), T(e)) {\n      var b = Object.keys(e)[0],\n        _ = e[b];\n      p = h[b].getPixelForValue(_) + g - t;\n    } else e === \"center\" ? p = (c.bottom + c.top) / 2 + g - t : p = Rs(i, e, t);\n    u = a - o;\n  } else {\n    if (T(e)) {\n      var _b = Object.keys(e)[0],\n        _3 = e[_b];\n      f = h[_b].getPixelForValue(_3) - m + t;\n    } else e === \"center\" ? f = (c.left + c.right) / 2 - m + t : f = Rs(i, e, t);\n    p = Y(s, r, n), d = e === \"left\" ? -V : V;\n  }\n  return {\n    titleX: f,\n    titleY: p,\n    maxWidth: u,\n    rotation: d\n  };\n}\nvar Gt = /*#__PURE__*/function (_st) {\n  function Gt(t) {\n    var _this8;\n    _classCallCheck(this, Gt);\n    _this8 = _callSuper(this, Gt), _this8.id = t.id, _this8.type = t.type, _this8.options = void 0, _this8.ctx = t.ctx, _this8.chart = t.chart, _this8.top = void 0, _this8.bottom = void 0, _this8.left = void 0, _this8.right = void 0, _this8.width = void 0, _this8.height = void 0, _this8._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, _this8.maxWidth = void 0, _this8.maxHeight = void 0, _this8.paddingTop = void 0, _this8.paddingBottom = void 0, _this8.paddingLeft = void 0, _this8.paddingRight = void 0, _this8.axis = void 0, _this8.labelRotation = void 0, _this8.min = void 0, _this8.max = void 0, _this8._range = void 0, _this8.ticks = [], _this8._gridLineItems = null, _this8._labelItems = null, _this8._labelSizes = null, _this8._length = 0, _this8._maxLength = 0, _this8._longestTextCache = {}, _this8._startPixel = void 0, _this8._endPixel = void 0, _this8._reversePixels = !1, _this8._userMax = void 0, _this8._userMin = void 0, _this8._suggestedMax = void 0, _this8._suggestedMin = void 0, _this8._ticksLength = 0, _this8._borderValue = 0, _this8._cache = {}, _this8._dataLimitsCached = !1, _this8.$context = void 0;\n    return _this8;\n  }\n  _inherits(Gt, _st);\n  return _createClass(Gt, [{\n    key: \"init\",\n    value: function init(t) {\n      this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(t, e) {\n      return t;\n    }\n  }, {\n    key: \"getUserBounds\",\n    value: function getUserBounds() {\n      var t = this._userMin,\n        e = this._userMax,\n        s = this._suggestedMin,\n        n = this._suggestedMax;\n      return t = ot(t, Number.POSITIVE_INFINITY), e = ot(e, Number.NEGATIVE_INFINITY), s = ot(s, Number.POSITIVE_INFINITY), n = ot(n, Number.NEGATIVE_INFINITY), {\n        min: ot(t, s),\n        max: ot(e, n),\n        minDefined: q(t),\n        maxDefined: q(e)\n      };\n    }\n  }, {\n    key: \"getMinMax\",\n    value: function getMinMax(t) {\n      var _this$getUserBounds = this.getUserBounds(),\n        e = _this$getUserBounds.min,\n        s = _this$getUserBounds.max,\n        n = _this$getUserBounds.minDefined,\n        o = _this$getUserBounds.maxDefined,\n        r;\n      if (n && o) return {\n        min: e,\n        max: s\n      };\n      var a = this.getMatchingVisibleMetas();\n      for (var l = 0, c = a.length; l < c; ++l) r = a[l].controller.getMinMax(this, t), n || (e = Math.min(e, r.min)), o || (s = Math.max(s, r.max));\n      return e = o && e > s ? s : e, s = n && e > s ? e : s, {\n        min: ot(e, ot(s, e)),\n        max: ot(s, ot(e, s))\n      };\n    }\n  }, {\n    key: \"getPadding\",\n    value: function getPadding() {\n      return {\n        left: this.paddingLeft || 0,\n        top: this.paddingTop || 0,\n        right: this.paddingRight || 0,\n        bottom: this.paddingBottom || 0\n      };\n    }\n  }, {\n    key: \"getTicks\",\n    value: function getTicks() {\n      return this.ticks;\n    }\n  }, {\n    key: \"getLabels\",\n    value: function getLabels() {\n      var t = this.chart.data;\n      return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];\n    }\n  }, {\n    key: \"getLabelItems\",\n    value: function getLabelItems() {\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.chart.chartArea;\n      return this._labelItems || (this._labelItems = this._computeLabelItems(t));\n    }\n  }, {\n    key: \"beforeLayout\",\n    value: function beforeLayout() {\n      this._cache = {}, this._dataLimitsCached = !1;\n    }\n  }, {\n    key: \"beforeUpdate\",\n    value: function beforeUpdate() {\n      I(this.options.beforeUpdate, [this]);\n    }\n  }, {\n    key: \"update\",\n    value: function update(t, e, s) {\n      var _this$options4 = this.options,\n        n = _this$options4.beginAtZero,\n        o = _this$options4.grace,\n        r = _this$options4.ticks,\n        a = r.sampleSize;\n      this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = s = Object.assign({\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }, s), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + s.left + s.right : this.height + s.top + s.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = xr(this, o, n), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();\n      var l = a < this.ticks.length;\n      this._convertTicksToLabels(l ? Es(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), r.display && (r.autoSkip || r.source === \"auto\") && (this.ticks = Za(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();\n    }\n  }, {\n    key: \"configure\",\n    value: function configure() {\n      var t = this.options.reverse,\n        e,\n        s;\n      this.isHorizontal() ? (e = this.left, s = this.right) : (e = this.top, s = this.bottom, t = !t), this._startPixel = e, this._endPixel = s, this._reversePixels = t, this._length = s - e, this._alignToPixels = this.options.alignToPixels;\n    }\n  }, {\n    key: \"afterUpdate\",\n    value: function afterUpdate() {\n      I(this.options.afterUpdate, [this]);\n    }\n  }, {\n    key: \"beforeSetDimensions\",\n    value: function beforeSetDimensions() {\n      I(this.options.beforeSetDimensions, [this]);\n    }\n  }, {\n    key: \"setDimensions\",\n    value: function setDimensions() {\n      this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;\n    }\n  }, {\n    key: \"afterSetDimensions\",\n    value: function afterSetDimensions() {\n      I(this.options.afterSetDimensions, [this]);\n    }\n  }, {\n    key: \"_callHooks\",\n    value: function _callHooks(t) {\n      this.chart.notifyPlugins(t, this.getContext()), I(this.options[t], [this]);\n    }\n  }, {\n    key: \"beforeDataLimits\",\n    value: function beforeDataLimits() {\n      this._callHooks(\"beforeDataLimits\");\n    }\n  }, {\n    key: \"determineDataLimits\",\n    value: function determineDataLimits() {}\n  }, {\n    key: \"afterDataLimits\",\n    value: function afterDataLimits() {\n      this._callHooks(\"afterDataLimits\");\n    }\n  }, {\n    key: \"beforeBuildTicks\",\n    value: function beforeBuildTicks() {\n      this._callHooks(\"beforeBuildTicks\");\n    }\n  }, {\n    key: \"buildTicks\",\n    value: function buildTicks() {\n      return [];\n    }\n  }, {\n    key: \"afterBuildTicks\",\n    value: function afterBuildTicks() {\n      this._callHooks(\"afterBuildTicks\");\n    }\n  }, {\n    key: \"beforeTickToLabelConversion\",\n    value: function beforeTickToLabelConversion() {\n      I(this.options.beforeTickToLabelConversion, [this]);\n    }\n  }, {\n    key: \"generateTickLabels\",\n    value: function generateTickLabels(t) {\n      var e = this.options.ticks;\n      var s, n, o;\n      for (s = 0, n = t.length; s < n; s++) o = t[s], o.label = I(e.callback, [o.value, s, t], this);\n    }\n  }, {\n    key: \"afterTickToLabelConversion\",\n    value: function afterTickToLabelConversion() {\n      I(this.options.afterTickToLabelConversion, [this]);\n    }\n  }, {\n    key: \"beforeCalculateLabelRotation\",\n    value: function beforeCalculateLabelRotation() {\n      I(this.options.beforeCalculateLabelRotation, [this]);\n    }\n  }, {\n    key: \"calculateLabelRotation\",\n    value: function calculateLabelRotation() {\n      var t = this.options,\n        e = t.ticks,\n        s = Ls(this.ticks.length, t.ticks.maxTicksLimit),\n        n = e.minRotation || 0,\n        o = e.maxRotation;\n      var r = n,\n        a,\n        l,\n        c;\n      if (!this._isVisible() || !e.display || n >= o || s <= 1 || !this.isHorizontal()) {\n        this.labelRotation = n;\n        return;\n      }\n      var h = this._getLabelSizes(),\n        d = h.widest.width,\n        u = h.highest.height,\n        f = U(this.chart.width - d, 0, this.maxWidth);\n      a = t.offset ? this.maxWidth / s : f / (s - 1), d + 6 > a && (a = f / (s - (t.offset ? 0.5 : 1)), l = this.maxHeight - ie(t.grid) - e.padding - Fs(t.title, this.chart.options.font), c = Math.sqrt(d * d + u * u), r = Uo(Math.min(Math.asin(U((h.highest.height + 6) / a, -1, 1)), Math.asin(U(l / c, -1, 1)) - Math.asin(U(u / c, -1, 1)))), r = Math.max(n, Math.min(o, r))), this.labelRotation = r;\n    }\n  }, {\n    key: \"afterCalculateLabelRotation\",\n    value: function afterCalculateLabelRotation() {\n      I(this.options.afterCalculateLabelRotation, [this]);\n    }\n  }, {\n    key: \"afterAutoSkip\",\n    value: function afterAutoSkip() {}\n  }, {\n    key: \"beforeFit\",\n    value: function beforeFit() {\n      I(this.options.beforeFit, [this]);\n    }\n  }, {\n    key: \"fit\",\n    value: function fit() {\n      var t = {\n          width: 0,\n          height: 0\n        },\n        e = this.chart,\n        _this$options5 = this.options,\n        s = _this$options5.ticks,\n        n = _this$options5.title,\n        o = _this$options5.grid,\n        r = this._isVisible(),\n        a = this.isHorizontal();\n      if (r) {\n        var l = Fs(n, e.options.font);\n        if (a ? (t.width = this.maxWidth, t.height = ie(o) + l) : (t.height = this.maxHeight, t.width = ie(o) + l), s.display && this.ticks.length) {\n          var _this$_getLabelSizes = this._getLabelSizes(),\n            c = _this$_getLabelSizes.first,\n            h = _this$_getLabelSizes.last,\n            d = _this$_getLabelSizes.widest,\n            u = _this$_getLabelSizes.highest,\n            f = s.padding * 2,\n            p = bt(this.labelRotation),\n            g = Math.cos(p),\n            m = Math.sin(p);\n          if (a) {\n            var b = s.mirror ? 0 : m * d.width + g * u.height;\n            t.height = Math.min(this.maxHeight, t.height + b + f);\n          } else {\n            var _b2 = s.mirror ? 0 : g * d.width + m * u.height;\n            t.width = Math.min(this.maxWidth, t.width + _b2 + f);\n          }\n          this._calculatePadding(c, h, m, g);\n        }\n      }\n      this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom);\n    }\n  }, {\n    key: \"_calculatePadding\",\n    value: function _calculatePadding(t, e, s, n) {\n      var _this$options6 = this.options,\n        _this$options6$ticks = _this$options6.ticks,\n        o = _this$options6$ticks.align,\n        r = _this$options6$ticks.padding,\n        a = _this$options6.position,\n        l = this.labelRotation !== 0,\n        c = a !== \"top\" && this.axis === \"x\";\n      if (this.isHorizontal()) {\n        var h = this.getPixelForTick(0) - this.left,\n          d = this.right - this.getPixelForTick(this.ticks.length - 1);\n        var u = 0,\n          f = 0;\n        l ? c ? (u = n * t.width, f = s * e.height) : (u = s * t.height, f = n * e.width) : o === \"start\" ? f = e.width : o === \"end\" ? u = t.width : o !== \"inner\" && (u = t.width / 2, f = e.width / 2), this.paddingLeft = Math.max((u - h + r) * this.width / (this.width - h), 0), this.paddingRight = Math.max((f - d + r) * this.width / (this.width - d), 0);\n      } else {\n        var _h2 = e.height / 2,\n          _d3 = t.height / 2;\n        o === \"start\" ? (_h2 = 0, _d3 = t.height) : o === \"end\" && (_h2 = e.height, _d3 = 0), this.paddingTop = _h2 + r, this.paddingBottom = _d3 + r;\n      }\n    }\n  }, {\n    key: \"_handleMargins\",\n    value: function _handleMargins() {\n      this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));\n    }\n  }, {\n    key: \"afterFit\",\n    value: function afterFit() {\n      I(this.options.afterFit, [this]);\n    }\n  }, {\n    key: \"isHorizontal\",\n    value: function isHorizontal() {\n      var _this$options7 = this.options,\n        t = _this$options7.axis,\n        e = _this$options7.position;\n      return e === \"top\" || e === \"bottom\" || t === \"x\";\n    }\n  }, {\n    key: \"isFullSize\",\n    value: function isFullSize() {\n      return this.options.fullSize;\n    }\n  }, {\n    key: \"_convertTicksToLabels\",\n    value: function _convertTicksToLabels(t) {\n      this.beforeTickToLabelConversion(), this.generateTickLabels(t);\n      var e, s;\n      for (e = 0, s = t.length; e < s; e++) R(t[e].label) && (t.splice(e, 1), s--, e--);\n      this.afterTickToLabelConversion();\n    }\n  }, {\n    key: \"_getLabelSizes\",\n    value: function _getLabelSizes() {\n      var t = this._labelSizes;\n      if (!t) {\n        var e = this.options.ticks.sampleSize;\n        var s = this.ticks;\n        e < s.length && (s = Es(s, e)), this._labelSizes = t = this._computeLabelSizes(s, s.length, this.options.ticks.maxTicksLimit);\n      }\n      return t;\n    }\n  }, {\n    key: \"_computeLabelSizes\",\n    value: function _computeLabelSizes(t, e, s) {\n      var n = this.ctx,\n        o = this._longestTextCache,\n        r = [],\n        a = [],\n        l = Math.floor(e / Ls(e, s));\n      var c = 0,\n        h = 0,\n        d,\n        u,\n        f,\n        p,\n        g,\n        m,\n        b,\n        _,\n        v,\n        y,\n        x;\n      for (d = 0; d < e; d += l) {\n        if (p = t[d].label, g = this._resolveTickFontOptions(d), n.font = m = g.string, b = o[m] = o[m] || {\n          data: {},\n          gc: []\n        }, _ = g.lineHeight, v = y = 0, !R(p) && !N(p)) v = ls(n, b.data, b.gc, v, p), y = _;else if (N(p)) for (u = 0, f = p.length; u < f; ++u) x = p[u], !R(x) && !N(x) && (v = ls(n, b.data, b.gc, v, x), y += _);\n        r.push(v), a.push(y), c = Math.max(v, c), h = Math.max(y, h);\n      }\n      rl(o, e);\n      var M = r.indexOf(c),\n        S = a.indexOf(h),\n        k = function k(P) {\n          return {\n            width: r[P] || 0,\n            height: a[P] || 0\n          };\n        };\n      return {\n        first: k(0),\n        last: k(e - 1),\n        widest: k(M),\n        highest: k(S),\n        widths: r,\n        heights: a\n      };\n    }\n  }, {\n    key: \"getLabelForValue\",\n    value: function getLabelForValue(t) {\n      return t;\n    }\n  }, {\n    key: \"getPixelForValue\",\n    value: function getPixelForValue(t, e) {\n      return NaN;\n    }\n  }, {\n    key: \"getValueForPixel\",\n    value: function getValueForPixel(t) {}\n  }, {\n    key: \"getPixelForTick\",\n    value: function getPixelForTick(t) {\n      var e = this.ticks;\n      return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n    }\n  }, {\n    key: \"getPixelForDecimal\",\n    value: function getPixelForDecimal(t) {\n      this._reversePixels && (t = 1 - t);\n      var e = this._startPixel + t * this._length;\n      return qo(this._alignToPixels ? Ot(this.chart, e, 0) : e);\n    }\n  }, {\n    key: \"getDecimalForPixel\",\n    value: function getDecimalForPixel(t) {\n      var e = (t - this._startPixel) / this._length;\n      return this._reversePixels ? 1 - e : e;\n    }\n  }, {\n    key: \"getBasePixel\",\n    value: function getBasePixel() {\n      return this.getPixelForValue(this.getBaseValue());\n    }\n  }, {\n    key: \"getBaseValue\",\n    value: function getBaseValue() {\n      var t = this.min,\n        e = this.max;\n      return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext(t) {\n      var e = this.ticks || [];\n      if (t >= 0 && t < e.length) {\n        var s = e[t];\n        return s.$context || (s.$context = ll(this.getContext(), t, s));\n      }\n      return this.$context || (this.$context = al(this.chart.getContext(), this));\n    }\n  }, {\n    key: \"_tickSize\",\n    value: function _tickSize() {\n      var t = this.options.ticks,\n        e = bt(this.labelRotation),\n        s = Math.abs(Math.cos(e)),\n        n = Math.abs(Math.sin(e)),\n        o = this._getLabelSizes(),\n        r = t.autoSkipPadding || 0,\n        a = o ? o.widest.width + r : 0,\n        l = o ? o.highest.height + r : 0;\n      return this.isHorizontal() ? l * s > a * n ? a / s : l / n : l * n < a * s ? l / s : a / n;\n    }\n  }, {\n    key: \"_isVisible\",\n    value: function _isVisible() {\n      var t = this.options.display;\n      return t !== \"auto\" ? !!t : this.getMatchingVisibleMetas().length > 0;\n    }\n  }, {\n    key: \"_computeGridLineItems\",\n    value: function _computeGridLineItems(t) {\n      var e = this.axis,\n        s = this.chart,\n        n = this.options,\n        o = n.grid,\n        r = n.position,\n        a = n.border,\n        l = o.offset,\n        c = this.isHorizontal(),\n        d = this.ticks.length + (l ? 1 : 0),\n        u = ie(o),\n        f = [],\n        p = a.setContext(this.getContext()),\n        g = p.display ? p.width : 0,\n        m = g / 2,\n        b = function b(z) {\n          return Ot(s, z, g);\n        };\n      var _, v, y, x, M, S, k, P, C, O, A, j;\n      if (r === \"top\") _ = b(this.bottom), S = this.bottom - u, P = _ - m, O = b(t.top) + m, j = t.bottom;else if (r === \"bottom\") _ = b(this.top), O = t.top, j = b(t.bottom) - m, S = _ + m, P = this.top + u;else if (r === \"left\") _ = b(this.right), M = this.right - u, k = _ - m, C = b(t.left) + m, A = t.right;else if (r === \"right\") _ = b(this.left), C = t.left, A = b(t.right) - m, M = _ + m, k = this.left + u;else if (e === \"x\") {\n        if (r === \"center\") _ = b((t.top + t.bottom) / 2 + 0.5);else if (T(r)) {\n          var z = Object.keys(r)[0],\n            H = r[z];\n          _ = b(this.chart.scales[z].getPixelForValue(H));\n        }\n        O = t.top, j = t.bottom, S = _ + m, P = S + u;\n      } else if (e === \"y\") {\n        if (r === \"center\") _ = b((t.left + t.right) / 2);else if (T(r)) {\n          var _z = Object.keys(r)[0],\n            _H = r[_z];\n          _ = b(this.chart.scales[_z].getPixelForValue(_H));\n        }\n        M = _ - m, k = M - u, C = t.left, A = t.right;\n      }\n      var J = D(n.ticks.maxTicksLimit, d),\n        F = Math.max(1, Math.ceil(d / J));\n      for (v = 0; v < d; v += F) {\n        var _z2 = this.getContext(v),\n          _H2 = o.setContext(_z2),\n          it = a.setContext(_z2),\n          $ = _H2.lineWidth,\n          Ht = _H2.color,\n          ye = it.dash || [],\n          Wt = it.dashOffset,\n          Jt = _H2.tickWidth,\n          Pt = _H2.tickColor,\n          Zt = _H2.tickBorderDash || [],\n          Dt = _H2.tickBorderDashOffset;\n        y = ol(this, v, l), y !== void 0 && (x = Ot(s, y, $), c ? M = k = C = A = x : S = P = O = j = x, f.push({\n          tx1: M,\n          ty1: S,\n          tx2: k,\n          ty2: P,\n          x1: C,\n          y1: O,\n          x2: A,\n          y2: j,\n          width: $,\n          color: Ht,\n          borderDash: ye,\n          borderDashOffset: Wt,\n          tickWidth: Jt,\n          tickColor: Pt,\n          tickBorderDash: Zt,\n          tickBorderDashOffset: Dt\n        }));\n      }\n      return this._ticksLength = d, this._borderValue = _, f;\n    }\n  }, {\n    key: \"_computeLabelItems\",\n    value: function _computeLabelItems(t) {\n      var e = this.axis,\n        s = this.options,\n        n = s.position,\n        o = s.ticks,\n        r = this.isHorizontal(),\n        a = this.ticks,\n        l = o.align,\n        c = o.crossAlign,\n        h = o.padding,\n        d = o.mirror,\n        u = ie(s.grid),\n        f = u + h,\n        p = d ? -h : f,\n        g = -bt(this.labelRotation),\n        m = [];\n      var b,\n        _,\n        v,\n        y,\n        x,\n        M,\n        S,\n        k,\n        P,\n        C,\n        O,\n        A,\n        j = \"middle\";\n      if (n === \"top\") M = this.bottom - p, S = this._getXAxisLabelAlignment();else if (n === \"bottom\") M = this.top + p, S = this._getXAxisLabelAlignment();else if (n === \"left\") {\n        var F = this._getYAxisLabelAlignment(u);\n        S = F.textAlign, x = F.x;\n      } else if (n === \"right\") {\n        var _F = this._getYAxisLabelAlignment(u);\n        S = _F.textAlign, x = _F.x;\n      } else if (e === \"x\") {\n        if (n === \"center\") M = (t.top + t.bottom) / 2 + f;else if (T(n)) {\n          var _F2 = Object.keys(n)[0],\n            z = n[_F2];\n          M = this.chart.scales[_F2].getPixelForValue(z) + f;\n        }\n        S = this._getXAxisLabelAlignment();\n      } else if (e === \"y\") {\n        if (n === \"center\") x = (t.left + t.right) / 2 - f;else if (T(n)) {\n          var _F3 = Object.keys(n)[0],\n            _z3 = n[_F3];\n          x = this.chart.scales[_F3].getPixelForValue(_z3);\n        }\n        S = this._getYAxisLabelAlignment(u).textAlign;\n      }\n      e === \"y\" && (l === \"start\" ? j = \"top\" : l === \"end\" && (j = \"bottom\"));\n      var J = this._getLabelSizes();\n      for (b = 0, _ = a.length; b < _; ++b) {\n        v = a[b], y = v.label;\n        var _F4 = o.setContext(this.getContext(b));\n        k = this.getPixelForTick(b) + o.labelOffset, P = this._resolveTickFontOptions(b), C = P.lineHeight, O = N(y) ? y.length : 1;\n        var _z4 = O / 2,\n          H = _F4.color,\n          it = _F4.textStrokeColor,\n          $ = _F4.textStrokeWidth;\n        var Ht = S;\n        r ? (x = k, S === \"inner\" && (b === _ - 1 ? Ht = this.options.reverse ? \"left\" : \"right\" : b === 0 ? Ht = this.options.reverse ? \"right\" : \"left\" : Ht = \"center\"), n === \"top\" ? c === \"near\" || g !== 0 ? A = -O * C + C / 2 : c === \"center\" ? A = -J.highest.height / 2 - _z4 * C + C : A = -J.highest.height + C / 2 : c === \"near\" || g !== 0 ? A = C / 2 : c === \"center\" ? A = J.highest.height / 2 - _z4 * C : A = J.highest.height - O * C, d && (A *= -1), g !== 0 && !_F4.showLabelBackdrop && (x += C / 2 * Math.sin(g))) : (M = k, A = (1 - O) * C / 2);\n        var ye = void 0;\n        if (_F4.showLabelBackdrop) {\n          var Wt = et(_F4.backdropPadding),\n            Jt = J.heights[b],\n            Pt = J.widths[b];\n          var Zt = A - Wt.top,\n            Dt = 0 - Wt.left;\n          switch (j) {\n            case \"middle\":\n              Zt -= Jt / 2;\n              break;\n            case \"bottom\":\n              Zt -= Jt;\n              break;\n          }\n          switch (S) {\n            case \"center\":\n              Dt -= Pt / 2;\n              break;\n            case \"right\":\n              Dt -= Pt;\n              break;\n            case \"inner\":\n              b === _ - 1 ? Dt -= Pt : b > 0 && (Dt -= Pt / 2);\n              break;\n          }\n          ye = {\n            left: Dt,\n            top: Zt,\n            width: Pt + Wt.width,\n            height: Jt + Wt.height,\n            color: _F4.backdropColor\n          };\n        }\n        m.push({\n          label: y,\n          font: P,\n          textOffset: A,\n          options: {\n            rotation: g,\n            color: H,\n            strokeColor: it,\n            strokeWidth: $,\n            textAlign: Ht,\n            textBaseline: j,\n            translation: [x, M],\n            backdrop: ye\n          }\n        });\n      }\n      return m;\n    }\n  }, {\n    key: \"_getXAxisLabelAlignment\",\n    value: function _getXAxisLabelAlignment() {\n      var _this$options8 = this.options,\n        t = _this$options8.position,\n        e = _this$options8.ticks;\n      if (-bt(this.labelRotation)) return t === \"top\" ? \"left\" : \"right\";\n      var n = \"center\";\n      return e.align === \"start\" ? n = \"left\" : e.align === \"end\" ? n = \"right\" : e.align === \"inner\" && (n = \"inner\"), n;\n    }\n  }, {\n    key: \"_getYAxisLabelAlignment\",\n    value: function _getYAxisLabelAlignment(t) {\n      var _this$options9 = this.options,\n        e = _this$options9.position,\n        _this$options9$ticks = _this$options9.ticks,\n        s = _this$options9$ticks.crossAlign,\n        n = _this$options9$ticks.mirror,\n        o = _this$options9$ticks.padding,\n        r = this._getLabelSizes(),\n        a = t + o,\n        l = r.widest.width;\n      var c, h;\n      return e === \"left\" ? n ? (h = this.right + o, s === \"near\" ? c = \"left\" : s === \"center\" ? (c = \"center\", h += l / 2) : (c = \"right\", h += l)) : (h = this.right - a, s === \"near\" ? c = \"right\" : s === \"center\" ? (c = \"center\", h -= l / 2) : (c = \"left\", h = this.left)) : e === \"right\" ? n ? (h = this.left + o, s === \"near\" ? c = \"right\" : s === \"center\" ? (c = \"center\", h -= l / 2) : (c = \"left\", h -= l)) : (h = this.left + a, s === \"near\" ? c = \"left\" : s === \"center\" ? (c = \"center\", h += l / 2) : (c = \"right\", h = this.right)) : c = \"right\", {\n        textAlign: c,\n        x: h\n      };\n    }\n  }, {\n    key: \"_computeLabelArea\",\n    value: function _computeLabelArea() {\n      if (this.options.ticks.mirror) return;\n      var t = this.chart,\n        e = this.options.position;\n      if (e === \"left\" || e === \"right\") return {\n        top: 0,\n        left: this.left,\n        bottom: t.height,\n        right: this.right\n      };\n      if (e === \"top\" || e === \"bottom\") return {\n        top: this.top,\n        left: 0,\n        bottom: this.bottom,\n        right: t.width\n      };\n    }\n  }, {\n    key: \"drawBackground\",\n    value: function drawBackground() {\n      var t = this.ctx,\n        e = this.options.backgroundColor,\n        s = this.left,\n        n = this.top,\n        o = this.width,\n        r = this.height;\n      e && (t.save(), t.fillStyle = e, t.fillRect(s, n, o, r), t.restore());\n    }\n  }, {\n    key: \"getLineWidthForValue\",\n    value: function getLineWidthForValue(t) {\n      var e = this.options.grid;\n      if (!this._isVisible() || !e.display) return 0;\n      var n = this.ticks.findIndex(function (o) {\n        return o.value === t;\n      });\n      return n >= 0 ? e.setContext(this.getContext(n)).lineWidth : 0;\n    }\n  }, {\n    key: \"drawGrid\",\n    value: function drawGrid(t) {\n      var e = this.options.grid,\n        s = this.ctx,\n        n = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));\n      var o, r;\n      var a = function a(l, c, h) {\n        !h.width || !h.color || (s.save(), s.lineWidth = h.width, s.strokeStyle = h.color, s.setLineDash(h.borderDash || []), s.lineDashOffset = h.borderDashOffset, s.beginPath(), s.moveTo(l.x, l.y), s.lineTo(c.x, c.y), s.stroke(), s.restore());\n      };\n      if (e.display) for (o = 0, r = n.length; o < r; ++o) {\n        var l = n[o];\n        e.drawOnChartArea && a({\n          x: l.x1,\n          y: l.y1\n        }, {\n          x: l.x2,\n          y: l.y2\n        }, l), e.drawTicks && a({\n          x: l.tx1,\n          y: l.ty1\n        }, {\n          x: l.tx2,\n          y: l.ty2\n        }, {\n          color: l.tickColor,\n          width: l.tickWidth,\n          borderDash: l.tickBorderDash,\n          borderDashOffset: l.tickBorderDashOffset\n        });\n      }\n    }\n  }, {\n    key: \"drawBorder\",\n    value: function drawBorder() {\n      var t = this.chart,\n        e = this.ctx,\n        _this$options0 = this.options,\n        s = _this$options0.border,\n        n = _this$options0.grid,\n        o = s.setContext(this.getContext()),\n        r = s.display ? o.width : 0;\n      if (!r) return;\n      var a = n.setContext(this.getContext(0)).lineWidth,\n        l = this._borderValue;\n      var c, h, d, u;\n      this.isHorizontal() ? (c = Ot(t, this.left, r) - r / 2, h = Ot(t, this.right, a) + a / 2, d = u = l) : (d = Ot(t, this.top, r) - r / 2, u = Ot(t, this.bottom, a) + a / 2, c = h = l), e.save(), e.lineWidth = o.width, e.strokeStyle = o.color, e.beginPath(), e.moveTo(c, d), e.lineTo(h, u), e.stroke(), e.restore();\n    }\n  }, {\n    key: \"drawLabels\",\n    value: function drawLabels(t) {\n      if (!this.options.ticks.display) return;\n      var s = this.ctx,\n        n = this._computeLabelArea();\n      n && Je(s, n);\n      var o = this.getLabelItems(t);\n      var _iterator20 = _createForOfIteratorHelper(o),\n        _step20;\n      try {\n        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n          var r = _step20.value;\n          var a = r.options,\n            l = r.font,\n            c = r.label,\n            h = r.textOffset;\n          be(s, c, 0, h, l, a);\n        }\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n      n && Ze(s);\n    }\n  }, {\n    key: \"drawTitle\",\n    value: function drawTitle() {\n      var t = this.ctx,\n        _this$options1 = this.options,\n        e = _this$options1.position,\n        s = _this$options1.title,\n        n = _this$options1.reverse;\n      if (!s.display) return;\n      var o = X(s.font),\n        r = et(s.padding),\n        a = s.align;\n      var l = o.lineHeight / 2;\n      e === \"bottom\" || e === \"center\" || T(e) ? (l += r.bottom, N(s.text) && (l += o.lineHeight * (s.text.length - 1))) : l += r.top;\n      var _hl = hl(this, l, e, a),\n        c = _hl.titleX,\n        h = _hl.titleY,\n        d = _hl.maxWidth,\n        u = _hl.rotation;\n      be(t, s.text, 0, 0, o, {\n        color: s.color,\n        maxWidth: d,\n        rotation: u,\n        textAlign: cl(a, e, n),\n        textBaseline: \"middle\",\n        translation: [c, h]\n      });\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(t) {\n      this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));\n    }\n  }, {\n    key: \"_layers\",\n    value: function _layers() {\n      var _this9 = this;\n      var t = this.options,\n        e = t.ticks && t.ticks.z || 0,\n        s = D(t.grid && t.grid.z, -1),\n        n = D(t.border && t.border.z, 0);\n      return !this._isVisible() || this.draw !== Gt.prototype.draw ? [{\n        z: e,\n        draw: function draw(o) {\n          _this9.draw(o);\n        }\n      }] : [{\n        z: s,\n        draw: function draw(o) {\n          _this9.drawBackground(), _this9.drawGrid(o), _this9.drawTitle();\n        }\n      }, {\n        z: n,\n        draw: function draw() {\n          _this9.drawBorder();\n        }\n      }, {\n        z: e,\n        draw: function draw(o) {\n          _this9.drawLabels(o);\n        }\n      }];\n    }\n  }, {\n    key: \"getMatchingVisibleMetas\",\n    value: function getMatchingVisibleMetas(t) {\n      var e = this.chart.getSortedVisibleDatasetMetas(),\n        s = this.axis + \"AxisID\",\n        n = [];\n      var o, r;\n      for (o = 0, r = e.length; o < r; ++o) {\n        var a = e[o];\n        a[s] === this.id && (!t || a.type === t) && n.push(a);\n      }\n      return n;\n    }\n  }, {\n    key: \"_resolveTickFontOptions\",\n    value: function _resolveTickFontOptions(t) {\n      var e = this.options.ticks.setContext(this.getContext(t));\n      return X(e.font);\n    }\n  }, {\n    key: \"_maxDigits\",\n    value: function _maxDigits() {\n      var t = this._resolveTickFontOptions(0).lineHeight;\n      return (this.isHorizontal() ? this.width : this.height) / t;\n    }\n  }]);\n}(st);\nvar Te = /*#__PURE__*/function () {\n  function Te(t, e, s) {\n    _classCallCheck(this, Te);\n    this.type = t, this.scope = e, this.override = s, this.items = /* @__PURE__ */Object.create(null);\n  }\n  return _createClass(Te, [{\n    key: \"isForType\",\n    value: function isForType(t) {\n      return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);\n    }\n  }, {\n    key: \"register\",\n    value: function register(t) {\n      var e = Object.getPrototypeOf(t);\n      var s;\n      fl(e) && (s = this.register(e));\n      var n = this.items,\n        o = t.id,\n        r = this.scope + \".\" + o;\n      if (!o) throw new Error(\"class does not have id: \" + t);\n      return o in n || (n[o] = t, dl(t, r, s), this.override && W.override(t.id, t.overrides)), r;\n    }\n  }, {\n    key: \"get\",\n    value: function get(t) {\n      return this.items[t];\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister(t) {\n      var e = this.items,\n        s = t.id,\n        n = this.scope;\n      s in e && delete e[s], n && s in W[n] && (delete W[n][s], this.override && delete zt[s]);\n    }\n  }]);\n}();\nfunction dl(i, t, e) {\n  var s = fe(/* @__PURE__ */Object.create(null), [e ? W.get(e) : {}, W.get(t), i.defaults]);\n  W.set(t, s), i.defaultRoutes && ul(t, i.defaultRoutes), i.descriptors && W.describe(t, i.descriptors);\n}\nfunction ul(i, t) {\n  Object.keys(t).forEach(function (e) {\n    var s = e.split(\".\"),\n      n = s.pop(),\n      o = [i].concat(s).join(\".\"),\n      r = t[e].split(\".\"),\n      a = r.pop(),\n      l = r.join(\".\");\n    W.route(o, n, l, a);\n  });\n}\nfunction fl(i) {\n  return \"id\" in i && \"defaults\" in i;\n}\nvar gl = /*#__PURE__*/function () {\n  function gl() {\n    _classCallCheck(this, gl);\n    this.controllers = new Te(kt, \"datasets\", !0), this.elements = new Te(st, \"elements\"), this.plugins = new Te(Object, \"plugins\"), this.scales = new Te(Gt, \"scales\"), this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n  return _createClass(gl, [{\n    key: \"add\",\n    value: function add() {\n      for (var _len4 = arguments.length, t = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        t[_key4] = arguments[_key4];\n      }\n      this._each(\"register\", t);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      for (var _len5 = arguments.length, t = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        t[_key5] = arguments[_key5];\n      }\n      this._each(\"unregister\", t);\n    }\n  }, {\n    key: \"addControllers\",\n    value: function addControllers() {\n      for (var _len6 = arguments.length, t = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        t[_key6] = arguments[_key6];\n      }\n      this._each(\"register\", t, this.controllers);\n    }\n  }, {\n    key: \"addElements\",\n    value: function addElements() {\n      for (var _len7 = arguments.length, t = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        t[_key7] = arguments[_key7];\n      }\n      this._each(\"register\", t, this.elements);\n    }\n  }, {\n    key: \"addPlugins\",\n    value: function addPlugins() {\n      for (var _len8 = arguments.length, t = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        t[_key8] = arguments[_key8];\n      }\n      this._each(\"register\", t, this.plugins);\n    }\n  }, {\n    key: \"addScales\",\n    value: function addScales() {\n      for (var _len9 = arguments.length, t = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        t[_key9] = arguments[_key9];\n      }\n      this._each(\"register\", t, this.scales);\n    }\n  }, {\n    key: \"getController\",\n    value: function getController(t) {\n      return this._get(t, this.controllers, \"controller\");\n    }\n  }, {\n    key: \"getElement\",\n    value: function getElement(t) {\n      return this._get(t, this.elements, \"element\");\n    }\n  }, {\n    key: \"getPlugin\",\n    value: function getPlugin(t) {\n      return this._get(t, this.plugins, \"plugin\");\n    }\n  }, {\n    key: \"getScale\",\n    value: function getScale(t) {\n      return this._get(t, this.scales, \"scale\");\n    }\n  }, {\n    key: \"removeControllers\",\n    value: function removeControllers() {\n      for (var _len0 = arguments.length, t = new Array(_len0), _key0 = 0; _key0 < _len0; _key0++) {\n        t[_key0] = arguments[_key0];\n      }\n      this._each(\"unregister\", t, this.controllers);\n    }\n  }, {\n    key: \"removeElements\",\n    value: function removeElements() {\n      for (var _len1 = arguments.length, t = new Array(_len1), _key1 = 0; _key1 < _len1; _key1++) {\n        t[_key1] = arguments[_key1];\n      }\n      this._each(\"unregister\", t, this.elements);\n    }\n  }, {\n    key: \"removePlugins\",\n    value: function removePlugins() {\n      for (var _len10 = arguments.length, t = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        t[_key10] = arguments[_key10];\n      }\n      this._each(\"unregister\", t, this.plugins);\n    }\n  }, {\n    key: \"removeScales\",\n    value: function removeScales() {\n      for (var _len11 = arguments.length, t = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        t[_key11] = arguments[_key11];\n      }\n      this._each(\"unregister\", t, this.scales);\n    }\n  }, {\n    key: \"_each\",\n    value: function _each(t, e, s) {\n      var _this0 = this;\n      _toConsumableArray(e).forEach(function (n) {\n        var o = s || _this0._getRegistryForType(n);\n        s || o.isForType(n) || o === _this0.plugins && n.id ? _this0._exec(t, o, n) : L(n, function (r) {\n          var a = s || _this0._getRegistryForType(r);\n          _this0._exec(t, a, r);\n        });\n      });\n    }\n  }, {\n    key: \"_exec\",\n    value: function _exec(t, e, s) {\n      var n = Fi(t);\n      I(s[\"before\" + n], [], s), e[t](s), I(s[\"after\" + n], [], s);\n    }\n  }, {\n    key: \"_getRegistryForType\",\n    value: function _getRegistryForType(t) {\n      for (var e = 0; e < this._typedRegistries.length; e++) {\n        var s = this._typedRegistries[e];\n        if (s.isForType(t)) return s;\n      }\n      return this.plugins;\n    }\n  }, {\n    key: \"_get\",\n    value: function _get(t, e, s) {\n      var n = e.get(t);\n      if (n === void 0) throw new Error('\"' + t + '\" is not a registered ' + s + \".\");\n      return n;\n    }\n  }]);\n}();\nvar at = /* @__PURE__ */new gl();\nvar pl = /*#__PURE__*/function () {\n  function pl() {\n    _classCallCheck(this, pl);\n    this._init = void 0;\n  }\n  return _createClass(pl, [{\n    key: \"notify\",\n    value: function notify(t, e, s, n) {\n      if (e === \"beforeInit\" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, \"install\")), this._init === void 0) return;\n      var o = n ? this._descriptors(t).filter(n) : this._descriptors(t),\n        r = this._notify(o, t, e, s);\n      return e === \"afterDestroy\" && (this._notify(o, t, \"stop\"), this._notify(this._init, t, \"uninstall\"), this._init = void 0), r;\n    }\n  }, {\n    key: \"_notify\",\n    value: function _notify(t, e, s, n) {\n      n = n || {};\n      var _iterator21 = _createForOfIteratorHelper(t),\n        _step21;\n      try {\n        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n          var o = _step21.value;\n          var r = o.plugin,\n            a = r[s],\n            l = [e, n, o.options];\n          if (I(a, l, r) === !1 && n.cancelable) return !1;\n        }\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n      return !0;\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate() {\n      R(this._cache) || (this._oldCache = this._cache, this._cache = void 0);\n    }\n  }, {\n    key: \"_descriptors\",\n    value: function _descriptors(t) {\n      if (this._cache) return this._cache;\n      var e = this._cache = this._createDescriptors(t);\n      return this._notifyStateChanges(t), e;\n    }\n  }, {\n    key: \"_createDescriptors\",\n    value: function _createDescriptors(t, e) {\n      var s = t && t.config,\n        n = D(s.options && s.options.plugins, {}),\n        o = ml(s);\n      return n === !1 && !e ? [] : _l(t, o, n, e);\n    }\n  }, {\n    key: \"_notifyStateChanges\",\n    value: function _notifyStateChanges(t) {\n      var e = this._oldCache || [],\n        s = this._cache,\n        n = function n(o, r) {\n          return o.filter(function (a) {\n            return !r.some(function (l) {\n              return a.plugin.id === l.plugin.id;\n            });\n          });\n        };\n      this._notify(n(e, s), t, \"stop\"), this._notify(n(s, e), t, \"start\");\n    }\n  }]);\n}();\nfunction ml(i) {\n  var t = {},\n    e = [],\n    s = Object.keys(at.plugins.items);\n  for (var o = 0; o < s.length; o++) e.push(at.getPlugin(s[o]));\n  var n = i.plugins || [];\n  for (var _o3 = 0; _o3 < n.length; _o3++) {\n    var r = n[_o3];\n    e.indexOf(r) === -1 && (e.push(r), t[r.id] = !0);\n  }\n  return {\n    plugins: e,\n    localIds: t\n  };\n}\nfunction bl(i, t) {\n  return !t && i === !1 ? null : i === !0 ? {} : i;\n}\nfunction _l(i, _ref3, s, n) {\n  var t = _ref3.plugins,\n    e = _ref3.localIds;\n  var o = [],\n    r = i.getContext();\n  var _iterator22 = _createForOfIteratorHelper(t),\n    _step22;\n  try {\n    for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n      var a = _step22.value;\n      var l = a.id,\n        c = bl(s[l], n);\n      c !== null && o.push({\n        plugin: a,\n        options: xl(i.config, {\n          plugin: a,\n          local: e[l]\n        }, c, r)\n      });\n    }\n  } catch (err) {\n    _iterator22.e(err);\n  } finally {\n    _iterator22.f();\n  }\n  return o;\n}\nfunction xl(i, _ref4, s, n) {\n  var t = _ref4.plugin,\n    e = _ref4.local;\n  var o = i.pluginScopeKeys(t),\n    r = i.getOptionScopes(s, o);\n  return e && t.defaults && r.push(t.defaults), i.createResolver(r, n, [\"\"], {\n    scriptable: !1,\n    indexable: !1,\n    allKeys: !0\n  });\n}\nfunction wi(i, t) {\n  var e = W.datasets[i] || {};\n  return ((t.datasets || {})[i] || {}).indexAxis || t.indexAxis || e.indexAxis || \"x\";\n}\nfunction yl(i, t) {\n  var e = i;\n  return i === \"_index_\" ? e = t : i === \"_value_\" && (e = t === \"x\" ? \"y\" : \"x\"), e;\n}\nfunction vl(i, t) {\n  return i === t ? \"_index_\" : \"_value_\";\n}\nfunction Is(i) {\n  if (i === \"x\" || i === \"y\" || i === \"r\") return i;\n}\nfunction Ml(i) {\n  if (i === \"top\" || i === \"bottom\") return \"x\";\n  if (i === \"left\" || i === \"right\") return \"y\";\n}\nfunction Pi(i) {\n  if (Is(i)) return i;\n  for (var _len12 = arguments.length, t = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {\n    t[_key12 - 1] = arguments[_key12];\n  }\n  for (var _i3 = 0, _t3 = t; _i3 < _t3.length; _i3++) {\n    var e = _t3[_i3];\n    var s = e.axis || Ml(e.position) || i.length > 1 && Is(i[0].toLowerCase());\n    if (s) return s;\n  }\n  throw new Error(\"Cannot determine type of '\".concat(i, \"' axis. Please provide 'axis' or 'position' option.\"));\n}\nfunction zs(i, t, e) {\n  if (e[t + \"AxisID\"] === i) return {\n    axis: t\n  };\n}\nfunction Sl(i, t) {\n  if (t.data && t.data.datasets) {\n    var e = t.data.datasets.filter(function (s) {\n      return s.xAxisID === i || s.yAxisID === i;\n    });\n    if (e.length) return zs(i, \"x\", e[0]) || zs(i, \"y\", e[0]);\n  }\n  return {};\n}\nfunction kl(i, t) {\n  var e = zt[i.type] || {\n      scales: {}\n    },\n    s = t.scales || {},\n    n = wi(i.type, t),\n    o = /* @__PURE__ */Object.create(null);\n  return Object.keys(s).forEach(function (r) {\n    var a = s[r];\n    if (!T(a)) return console.error(\"Invalid scale configuration for scale: \".concat(r));\n    if (a._proxy) return console.warn(\"Ignoring resolver passed as options for scale: \".concat(r));\n    var l = Pi(r, a, Sl(r, i), W.scales[a.type]),\n      c = vl(l, n),\n      h = e.scales || {};\n    o[r] = le(/* @__PURE__ */Object.create(null), [{\n      axis: l\n    }, a, h[l], h[c]]);\n  }), i.data.datasets.forEach(function (r) {\n    var a = r.type || i.type,\n      l = r.indexAxis || wi(a, t),\n      h = (zt[a] || {}).scales || {};\n    Object.keys(h).forEach(function (d) {\n      var u = yl(d, l),\n        f = r[u + \"AxisID\"] || u;\n      o[f] = o[f] || /* @__PURE__ */Object.create(null), le(o[f], [{\n        axis: u\n      }, s[f], h[d]]);\n    });\n  }), Object.keys(o).forEach(function (r) {\n    var a = o[r];\n    le(a, [W.scales[a.type], W.scale]);\n  }), o;\n}\nfunction Kn(i) {\n  var t = i.options || (i.options = {});\n  t.plugins = D(t.plugins, {}), t.scales = kl(i, t);\n}\nfunction Gn(i) {\n  return i = i || {}, i.datasets = i.datasets || [], i.labels = i.labels || [], i;\n}\nfunction wl(i) {\n  return i = i || {}, i.data = Gn(i.data), Kn(i), i;\n}\nvar Bs = /* @__PURE__ */new Map(),\n  Jn = /* @__PURE__ */new Set();\nfunction Ae(i, t) {\n  var e = Bs.get(i);\n  return e || (e = t(), Bs.set(i, e), Jn.add(e)), e;\n}\nvar se = function se(i, t, e) {\n  var s = It(t, e);\n  s !== void 0 && i.add(s);\n};\nvar Pl = /*#__PURE__*/function () {\n  function Pl(t) {\n    _classCallCheck(this, Pl);\n    this._config = wl(t), this._scopeCache = /* @__PURE__ */new Map(), this._resolverCache = /* @__PURE__ */new Map();\n  }\n  return _createClass(Pl, [{\n    key: \"platform\",\n    get: function get() {\n      return this._config.platform;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._config.type;\n    },\n    set: function set(t) {\n      this._config.type = t;\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this._config.data;\n    },\n    set: function set(t) {\n      this._config.data = Gn(t);\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this._config.options;\n    },\n    set: function set(t) {\n      this._config.options = t;\n    }\n  }, {\n    key: \"plugins\",\n    get: function get() {\n      return this._config.plugins;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var t = this._config;\n      this.clearCache(), Kn(t);\n    }\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      this._scopeCache.clear(), this._resolverCache.clear();\n    }\n  }, {\n    key: \"datasetScopeKeys\",\n    value: function datasetScopeKeys(t) {\n      return Ae(t, function () {\n        return [[\"datasets.\".concat(t), \"\"]];\n      });\n    }\n  }, {\n    key: \"datasetAnimationScopeKeys\",\n    value: function datasetAnimationScopeKeys(t, e) {\n      return Ae(\"\".concat(t, \".transition.\").concat(e), function () {\n        return [[\"datasets.\".concat(t, \".transitions.\").concat(e), \"transitions.\".concat(e)], [\"datasets.\".concat(t), \"\"]];\n      });\n    }\n  }, {\n    key: \"datasetElementScopeKeys\",\n    value: function datasetElementScopeKeys(t, e) {\n      return Ae(\"\".concat(t, \"-\").concat(e), function () {\n        return [[\"datasets.\".concat(t, \".elements.\").concat(e), \"datasets.\".concat(t), \"elements.\".concat(e), \"\"]];\n      });\n    }\n  }, {\n    key: \"pluginScopeKeys\",\n    value: function pluginScopeKeys(t) {\n      var e = t.id,\n        s = this.type;\n      return Ae(\"\".concat(s, \"-plugin-\").concat(e), function () {\n        return [[\"plugins.\".concat(e)].concat(_toConsumableArray(t.additionalOptionScopes || []))];\n      });\n    }\n  }, {\n    key: \"_cachedScopes\",\n    value: function _cachedScopes(t, e) {\n      var s = this._scopeCache;\n      var n = s.get(t);\n      return (!n || e) && (n = /* @__PURE__ */new Map(), s.set(t, n)), n;\n    }\n  }, {\n    key: \"getOptionScopes\",\n    value: function getOptionScopes(t, e, s) {\n      var n = this.options,\n        o = this.type,\n        r = this._cachedScopes(t, s),\n        a = r.get(e);\n      if (a) return a;\n      var l = /* @__PURE__ */new Set();\n      e.forEach(function (h) {\n        t && (l.add(t), h.forEach(function (d) {\n          return se(l, t, d);\n        })), h.forEach(function (d) {\n          return se(l, n, d);\n        }), h.forEach(function (d) {\n          return se(l, zt[o] || {}, d);\n        }), h.forEach(function (d) {\n          return se(l, W, d);\n        }), h.forEach(function (d) {\n          return se(l, Mi, d);\n        });\n      });\n      var c = Array.from(l);\n      return c.length === 0 && c.push(/* @__PURE__ */Object.create(null)), Jn.has(e) && r.set(e, c), c;\n    }\n  }, {\n    key: \"chartOptionScopes\",\n    value: function chartOptionScopes() {\n      var t = this.options,\n        e = this.type;\n      return [t, zt[e] || {}, W.datasets[e] || {}, {\n        type: e\n      }, W, Mi];\n    }\n  }, {\n    key: \"resolveNamedOptions\",\n    value: function resolveNamedOptions(t, e, s) {\n      var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [\"\"];\n      var o = {\n          $shared: !0\n        },\n        _Hs = Hs(this._resolverCache, t, n),\n        r = _Hs.resolver,\n        a = _Hs.subPrefixes;\n      var l = r;\n      if (Cl(r, e)) {\n        o.$shared = !1, s = wt(s) ? s() : s;\n        var c = this.createResolver(t, s, a);\n        l = qt(r, s, c);\n      }\n      var _iterator23 = _createForOfIteratorHelper(e),\n        _step23;\n      try {\n        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n          var _c2 = _step23.value;\n          o[_c2] = l[_c2];\n        }\n      } catch (err) {\n        _iterator23.e(err);\n      } finally {\n        _iterator23.f();\n      }\n      return o;\n    }\n  }, {\n    key: \"createResolver\",\n    value: function createResolver(t, e) {\n      var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [\"\"];\n      var n = arguments.length > 3 ? arguments[3] : undefined;\n      var _Hs2 = Hs(this._resolverCache, t, s),\n        o = _Hs2.resolver;\n      return T(e) ? qt(o, e, void 0, n) : o;\n    }\n  }]);\n}();\nfunction Hs(i, t, e) {\n  var s = i.get(t);\n  s || (s = /* @__PURE__ */new Map(), i.set(t, s));\n  var n = e.join();\n  var o = s.get(n);\n  return o || (o = {\n    resolver: Ni(t, e),\n    subPrefixes: e.filter(function (a) {\n      return !a.toLowerCase().includes(\"hover\");\n    })\n  }, s.set(n, o)), o;\n}\nvar Dl = function Dl(i) {\n  return T(i) && Object.getOwnPropertyNames(i).some(function (t) {\n    return wt(i[t]);\n  });\n};\nfunction Cl(i, t) {\n  var _Tn = Tn(i),\n    e = _Tn.isScriptable,\n    s = _Tn.isIndexable;\n  var _iterator24 = _createForOfIteratorHelper(t),\n    _step24;\n  try {\n    for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n      var n = _step24.value;\n      var o = e(n),\n        r = s(n),\n        a = (r || o) && i[n];\n      if (o && (wt(a) || Dl(a)) || r && N(a)) return !0;\n    }\n  } catch (err) {\n    _iterator24.e(err);\n  } finally {\n    _iterator24.f();\n  }\n  return !1;\n}\nvar Ol = \"4.5.1\";\nvar Tl = [\"top\", \"bottom\", \"left\", \"right\", \"chartArea\"];\nfunction Ws(i, t) {\n  return i === \"top\" || i === \"bottom\" || Tl.indexOf(i) === -1 && t === \"x\";\n}\nfunction Ns(i, t) {\n  return function (e, s) {\n    return e[i] === s[i] ? e[t] - s[t] : e[i] - s[i];\n  };\n}\nfunction Vs(i) {\n  var t = i.chart,\n    e = t.options.animation;\n  t.notifyPlugins(\"afterRender\"), I(e && e.onComplete, [i], t);\n}\nfunction Al(i) {\n  var t = i.chart,\n    e = t.options.animation;\n  I(e && e.onProgress, [i], t);\n}\nfunction Zn(i) {\n  return $i() && typeof i == \"string\" ? i = document.getElementById(i) : i && i.length && (i = i[0]), i && i.canvas && (i = i.canvas), i;\n}\nvar Be = {},\n  js = function js(i) {\n    var t = Zn(i);\n    return Object.values(Be).filter(function (e) {\n      return e.canvas === t;\n    }).pop();\n  };\nfunction Rl(i, t, e) {\n  var s = Object.keys(i);\n  for (var _i4 = 0, _s2 = s; _i4 < _s2.length; _i4++) {\n    var n = _s2[_i4];\n    var o = +n;\n    if (o >= t) {\n      var r = i[n];\n      delete i[n], (e > 0 || o > t) && (i[o + e] = r);\n    }\n  }\n}\nfunction Ll(i, t, e, s) {\n  return !e || i.type === \"mouseout\" ? null : s ? t : i;\n}\nvar mt = /*#__PURE__*/function () {\n  function mt(t, e) {\n    var _this1 = this;\n    _classCallCheck(this, mt);\n    var s = this.config = new Pl(e),\n      n = Zn(t),\n      o = js(n);\n    if (o) throw new Error(\"Canvas is already in use. Chart with ID '\" + o.id + \"' must be destroyed before the canvas with ID '\" + o.canvas.id + \"' can be reused.\");\n    var r = s.createResolver(s.chartOptionScopes(), this.getContext());\n    this.platform = new (s.platform || Ja(n))(), this.platform.updateConfig(s);\n    var a = this.platform.acquireContext(n, r.aspectRatio),\n      l = a && a.canvas,\n      c = l && l.height,\n      h = l && l.width;\n    if (this.id = Lo(), this.ctx = a, this.canvas = l, this.width = h, this.height = c, this._options = r, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new pl(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = Zo(function (d) {\n      return _this1.update(d);\n    }, r.resizeDelay || 0), this._dataChanges = [], Be[this.id] = this, !a || !l) {\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n    ut.listen(this, \"complete\", Vs), ut.listen(this, \"progress\", Al), this._initialize(), this.attached && this.update();\n  }\n  return _createClass(mt, [{\n    key: \"aspectRatio\",\n    get: function get() {\n      var _this$options10 = this.options,\n        t = _this$options10.aspectRatio,\n        e = _this$options10.maintainAspectRatio,\n        s = this.width,\n        n = this.height,\n        o = this._aspectRatio;\n      return R(t) ? e && o ? o : n ? s / n : null : t;\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this.config.data;\n    },\n    set: function set(t) {\n      this.config.data = t;\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this._options;\n    },\n    set: function set(t) {\n      this.config.options = t;\n    }\n  }, {\n    key: \"registry\",\n    get: function get() {\n      return at;\n    }\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      return this.notifyPlugins(\"beforeInit\"), this.options.responsive ? this.resize() : us(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins(\"afterInit\"), this;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      return cs(this.canvas, this.ctx), this;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      return ut.stop(this), this;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(t, e) {\n      ut.running(this) ? this._resizeBeforeDraw = {\n        width: t,\n        height: e\n      } : this._resize(t, e);\n    }\n  }, {\n    key: \"_resize\",\n    value: function _resize(t, e) {\n      var s = this.options,\n        n = this.canvas,\n        o = s.maintainAspectRatio && this.aspectRatio,\n        r = this.platform.getMaximumSize(n, t, e, o),\n        a = s.devicePixelRatio || this.platform.getDevicePixelRatio(),\n        l = this.width ? \"resize\" : \"attach\";\n      this.width = r.width, this.height = r.height, this._aspectRatio = this.aspectRatio, us(this, a, !0) && (this.notifyPlugins(\"resize\", {\n        size: r\n      }), I(s.onResize, [this, r], this), this.attached && this._doResize(l) && this.render());\n    }\n  }, {\n    key: \"ensureScalesHaveIDs\",\n    value: function ensureScalesHaveIDs() {\n      var e = this.options.scales || {};\n      L(e, function (s, n) {\n        s.id = n;\n      });\n    }\n  }, {\n    key: \"buildOrUpdateScales\",\n    value: function buildOrUpdateScales() {\n      var _this10 = this;\n      var t = this.options,\n        e = t.scales,\n        s = this.scales,\n        n = Object.keys(s).reduce(function (r, a) {\n          return r[a] = !1, r;\n        }, {});\n      var o = [];\n      e && (o = o.concat(Object.keys(e).map(function (r) {\n        var a = e[r],\n          l = Pi(r, a),\n          c = l === \"r\",\n          h = l === \"x\";\n        return {\n          options: a,\n          dposition: c ? \"chartArea\" : h ? \"bottom\" : \"left\",\n          dtype: c ? \"radialLinear\" : h ? \"category\" : \"linear\"\n        };\n      }))), L(o, function (r) {\n        var a = r.options,\n          l = a.id,\n          c = Pi(l, a),\n          h = D(a.type, r.dtype);\n        (a.position === void 0 || Ws(a.position, c) !== Ws(r.dposition)) && (a.position = r.dposition), n[l] = !0;\n        var d = null;\n        if (l in s && s[l].type === h) d = s[l];else {\n          var u = at.getScale(h);\n          d = new u({\n            id: l,\n            type: h,\n            ctx: _this10.ctx,\n            chart: _this10\n          }), s[d.id] = d;\n        }\n        d.init(a, t);\n      }), L(n, function (r, a) {\n        r || delete s[a];\n      }), L(s, function (r) {\n        tt.configure(_this10, r, r.options), tt.addBox(_this10, r);\n      });\n    }\n  }, {\n    key: \"_updateMetasets\",\n    value: function _updateMetasets() {\n      var t = this._metasets,\n        e = this.data.datasets.length,\n        s = t.length;\n      if (t.sort(function (n, o) {\n        return n.index - o.index;\n      }), s > e) {\n        for (var n = e; n < s; ++n) this._destroyDatasetMeta(n);\n        t.splice(e, s - e);\n      }\n      this._sortedMetasets = t.slice(0).sort(Ns(\"order\", \"index\"));\n    }\n  }, {\n    key: \"_removeUnreferencedMetasets\",\n    value: function _removeUnreferencedMetasets() {\n      var _this11 = this;\n      var t = this._metasets,\n        e = this.data.datasets;\n      t.length > e.length && delete this._stacks, t.forEach(function (s, n) {\n        e.filter(function (o) {\n          return o === s._dataset;\n        }).length === 0 && _this11._destroyDatasetMeta(n);\n      });\n    }\n  }, {\n    key: \"buildOrUpdateControllers\",\n    value: function buildOrUpdateControllers() {\n      var t = [],\n        e = this.data.datasets;\n      var s, n;\n      for (this._removeUnreferencedMetasets(), s = 0, n = e.length; s < n; s++) {\n        var o = e[s];\n        var r = this.getDatasetMeta(s);\n        var a = o.type || this.config.type;\n        if (r.type && r.type !== a && (this._destroyDatasetMeta(s), r = this.getDatasetMeta(s)), r.type = a, r.indexAxis = o.indexAxis || wi(a, this.options), r.order = o.order || 0, r.index = s, r.label = \"\" + o.label, r.visible = this.isDatasetVisible(s), r.controller) r.controller.updateIndex(s), r.controller.linkScales();else {\n          var l = at.getController(a),\n            _W$datasets$a = W.datasets[a],\n            c = _W$datasets$a.datasetElementType,\n            h = _W$datasets$a.dataElementType;\n          Object.assign(l, {\n            dataElementType: at.getElement(h),\n            datasetElementType: c && at.getElement(c)\n          }), r.controller = new l(this, s), t.push(r.controller);\n        }\n      }\n      return this._updateMetasets(), t;\n    }\n  }, {\n    key: \"_resetElements\",\n    value: function _resetElements() {\n      var _this12 = this;\n      L(this.data.datasets, function (t, e) {\n        _this12.getDatasetMeta(e).controller.reset();\n      }, this);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._resetElements(), this.notifyPlugins(\"reset\");\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = this.config;\n      e.update();\n      var s = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()),\n        n = this._animationsDisabled = !s.animation;\n      if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins(\"beforeUpdate\", {\n        mode: t,\n        cancelable: !0\n      }) === !1) return;\n      var o = this.buildOrUpdateControllers();\n      this.notifyPlugins(\"beforeElementsUpdate\");\n      var r = 0;\n      for (var c = 0, h = this.data.datasets.length; c < h; c++) {\n        var _this$getDatasetMeta = this.getDatasetMeta(c),\n          d = _this$getDatasetMeta.controller,\n          u = !n && o.indexOf(d) === -1;\n        d.buildOrUpdateElements(u), r = Math.max(+d.getMaxOverflow(), r);\n      }\n      r = this._minPadding = s.layout.autoPadding ? r : 0, this._updateLayout(r), n || L(o, function (c) {\n        c.reset();\n      }), this._updateDatasets(t), this.notifyPlugins(\"afterUpdate\", {\n        mode: t\n      }), this._layers.sort(Ns(\"z\", \"_idx\"));\n      var a = this._active,\n        l = this._lastEvent;\n      l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render();\n    }\n  }, {\n    key: \"_updateScales\",\n    value: function _updateScales() {\n      var _this13 = this;\n      L(this.scales, function (t) {\n        tt.removeBox(_this13, t);\n      }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();\n    }\n  }, {\n    key: \"_checkEventBindings\",\n    value: function _checkEventBindings() {\n      var t = this.options,\n        e = new Set(Object.keys(this._listeners)),\n        s = new Set(t.events);\n      (!Qi(e, s) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());\n    }\n  }, {\n    key: \"_updateHiddenIndices\",\n    value: function _updateHiddenIndices() {\n      var t = this._hiddenIndices,\n        e = this._getUniformDataChanges() || [];\n      var _iterator25 = _createForOfIteratorHelper(e),\n        _step25;\n      try {\n        for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n          var _step25$value = _step25.value,\n            s = _step25$value.method,\n            n = _step25$value.start,\n            o = _step25$value.count;\n          var r = s === \"_removeElements\" ? -o : o;\n          Rl(t, n, r);\n        }\n      } catch (err) {\n        _iterator25.e(err);\n      } finally {\n        _iterator25.f();\n      }\n    }\n  }, {\n    key: \"_getUniformDataChanges\",\n    value: function _getUniformDataChanges() {\n      var t = this._dataChanges;\n      if (!t || !t.length) return;\n      this._dataChanges = [];\n      var e = this.data.datasets.length,\n        s = function s(o) {\n          return new Set(t.filter(function (r) {\n            return r[0] === o;\n          }).map(function (r, a) {\n            return a + \",\" + r.splice(1).join(\",\");\n          }));\n        },\n        n = s(0);\n      for (var o = 1; o < e; o++) if (!Qi(n, s(o))) return;\n      return Array.from(n).map(function (o) {\n        return o.split(\",\");\n      }).map(function (o) {\n        return {\n          method: o[1],\n          start: +o[2],\n          count: +o[3]\n        };\n      });\n    }\n  }, {\n    key: \"_updateLayout\",\n    value: function _updateLayout(t) {\n      var _this14 = this;\n      if (this.notifyPlugins(\"beforeLayout\", {\n        cancelable: !0\n      }) === !1) return;\n      tt.update(this, this.width, this.height, t);\n      var e = this.chartArea,\n        s = e.width <= 0 || e.height <= 0;\n      this._layers = [], L(this.boxes, function (n) {\n        var _this14$_layers;\n        s && n.position === \"chartArea\" || (n.configure && n.configure(), (_this14$_layers = _this14._layers).push.apply(_this14$_layers, _toConsumableArray(n._layers())));\n      }, this), this._layers.forEach(function (n, o) {\n        n._idx = o;\n      }), this.notifyPlugins(\"afterLayout\");\n    }\n  }, {\n    key: \"_updateDatasets\",\n    value: function _updateDatasets(t) {\n      if (this.notifyPlugins(\"beforeDatasetsUpdate\", {\n        mode: t,\n        cancelable: !0\n      }) !== !1) {\n        for (var e = 0, s = this.data.datasets.length; e < s; ++e) this.getDatasetMeta(e).controller.configure();\n        for (var _e3 = 0, _s3 = this.data.datasets.length; _e3 < _s3; ++_e3) this._updateDataset(_e3, wt(t) ? t({\n          datasetIndex: _e3\n        }) : t);\n        this.notifyPlugins(\"afterDatasetsUpdate\", {\n          mode: t\n        });\n      }\n    }\n  }, {\n    key: \"_updateDataset\",\n    value: function _updateDataset(t, e) {\n      var s = this.getDatasetMeta(t),\n        n = {\n          meta: s,\n          index: t,\n          mode: e,\n          cancelable: !0\n        };\n      this.notifyPlugins(\"beforeDatasetUpdate\", n) !== !1 && (s.controller._update(e), n.cancelable = !1, this.notifyPlugins(\"afterDatasetUpdate\", n));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.notifyPlugins(\"beforeRender\", {\n        cancelable: !0\n      }) !== !1 && (ut.has(this) ? this.attached && !ut.running(this) && ut.start(this) : (this.draw(), Vs({\n        chart: this\n      })));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var t;\n      if (this._resizeBeforeDraw) {\n        var _this$_resizeBeforeDr = this._resizeBeforeDraw,\n          s = _this$_resizeBeforeDr.width,\n          n = _this$_resizeBeforeDr.height;\n        this._resizeBeforeDraw = null, this._resize(s, n);\n      }\n      if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins(\"beforeDraw\", {\n        cancelable: !0\n      }) === !1) return;\n      var e = this._layers;\n      for (t = 0; t < e.length && e[t].z <= 0; ++t) e[t].draw(this.chartArea);\n      for (this._drawDatasets(); t < e.length; ++t) e[t].draw(this.chartArea);\n      this.notifyPlugins(\"afterDraw\");\n    }\n  }, {\n    key: \"_getSortedDatasetMetas\",\n    value: function _getSortedDatasetMetas(t) {\n      var e = this._sortedMetasets,\n        s = [];\n      var n, o;\n      for (n = 0, o = e.length; n < o; ++n) {\n        var r = e[n];\n        (!t || r.visible) && s.push(r);\n      }\n      return s;\n    }\n  }, {\n    key: \"getSortedVisibleDatasetMetas\",\n    value: function getSortedVisibleDatasetMetas() {\n      return this._getSortedDatasetMetas(!0);\n    }\n  }, {\n    key: \"_drawDatasets\",\n    value: function _drawDatasets() {\n      if (this.notifyPlugins(\"beforeDatasetsDraw\", {\n        cancelable: !0\n      }) === !1) return;\n      var t = this.getSortedVisibleDatasetMetas();\n      for (var e = t.length - 1; e >= 0; --e) this._drawDataset(t[e]);\n      this.notifyPlugins(\"afterDatasetsDraw\");\n    }\n  }, {\n    key: \"_drawDataset\",\n    value: function _drawDataset(t) {\n      var e = this.ctx,\n        s = {\n          meta: t,\n          index: t.index,\n          cancelable: !0\n        },\n        n = Wn(this, t);\n      this.notifyPlugins(\"beforeDatasetDraw\", s) !== !1 && (n && Je(e, n), t.controller.draw(), n && Ze(e), s.cancelable = !1, this.notifyPlugins(\"afterDatasetDraw\", s));\n    }\n  }, {\n    key: \"isPointInArea\",\n    value: function isPointInArea(t) {\n      return me(t, this.chartArea, this._minPadding);\n    }\n  }, {\n    key: \"getElementsAtEventForMode\",\n    value: function getElementsAtEventForMode(t, e, s, n) {\n      var o = Ta.modes[e];\n      return typeof o == \"function\" ? o(this, t, s, n) : [];\n    }\n  }, {\n    key: \"getDatasetMeta\",\n    value: function getDatasetMeta(t) {\n      var e = this.data.datasets[t],\n        s = this._metasets;\n      var n = s.filter(function (o) {\n        return o && o._dataset === e;\n      }).pop();\n      return n || (n = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\n        xAxisID: null,\n        yAxisID: null,\n        order: e && e.order || 0,\n        index: t,\n        _dataset: e,\n        _parsed: [],\n        _sorted: !1\n      }, s.push(n)), n;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.$context || (this.$context = Bt(null, {\n        chart: this,\n        type: \"chart\"\n      }));\n    }\n  }, {\n    key: \"getVisibleDatasetCount\",\n    value: function getVisibleDatasetCount() {\n      return this.getSortedVisibleDatasetMetas().length;\n    }\n  }, {\n    key: \"isDatasetVisible\",\n    value: function isDatasetVisible(t) {\n      var e = this.data.datasets[t];\n      if (!e) return !1;\n      var s = this.getDatasetMeta(t);\n      return typeof s.hidden == \"boolean\" ? !s.hidden : !e.hidden;\n    }\n  }, {\n    key: \"setDatasetVisibility\",\n    value: function setDatasetVisibility(t, e) {\n      var s = this.getDatasetMeta(t);\n      s.hidden = !e;\n    }\n  }, {\n    key: \"toggleDataVisibility\",\n    value: function toggleDataVisibility(t) {\n      this._hiddenIndices[t] = !this._hiddenIndices[t];\n    }\n  }, {\n    key: \"getDataVisibility\",\n    value: function getDataVisibility(t) {\n      return !this._hiddenIndices[t];\n    }\n  }, {\n    key: \"_updateVisibility\",\n    value: function _updateVisibility(t, e, s) {\n      var n = s ? \"show\" : \"hide\",\n        o = this.getDatasetMeta(t),\n        r = o.controller._resolveAnimations(void 0, n);\n      ge(e) ? (o.data[e].hidden = !s, this.update()) : (this.setDatasetVisibility(t, s), r.update(o, {\n        visible: s\n      }), this.update(function (a) {\n        return a.datasetIndex === t ? n : void 0;\n      }));\n    }\n  }, {\n    key: \"hide\",\n    value: function hide(t, e) {\n      this._updateVisibility(t, e, !1);\n    }\n  }, {\n    key: \"show\",\n    value: function show(t, e) {\n      this._updateVisibility(t, e, !0);\n    }\n  }, {\n    key: \"_destroyDatasetMeta\",\n    value: function _destroyDatasetMeta(t) {\n      var e = this._metasets[t];\n      e && e.controller && e.controller._destroy(), delete this._metasets[t];\n    }\n  }, {\n    key: \"_stop\",\n    value: function _stop() {\n      var t, e;\n      for (this.stop(), ut.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t) this._destroyDatasetMeta(t);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.notifyPlugins(\"beforeDestroy\");\n      var t = this.canvas,\n        e = this.ctx;\n      this._stop(), this.config.clearCache(), t && (this.unbindEvents(), cs(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), delete Be[this.id], this.notifyPlugins(\"afterDestroy\");\n    }\n  }, {\n    key: \"toBase64Image\",\n    value: function toBase64Image() {\n      var _this$canvas;\n      return (_this$canvas = this.canvas).toDataURL.apply(_this$canvas, arguments);\n    }\n  }, {\n    key: \"bindEvents\",\n    value: function bindEvents() {\n      this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;\n    }\n  }, {\n    key: \"bindUserEvents\",\n    value: function bindUserEvents() {\n      var _this15 = this;\n      var t = this._listeners,\n        e = this.platform,\n        s = function s(o, r) {\n          e.addEventListener(_this15, o, r), t[o] = r;\n        },\n        n = function n(o, r, a) {\n          o.offsetX = r, o.offsetY = a, _this15._eventHandler(o);\n        };\n      L(this.options.events, function (o) {\n        return s(o, n);\n      });\n    }\n  }, {\n    key: \"bindResponsiveEvents\",\n    value: function bindResponsiveEvents() {\n      var _this16 = this;\n      this._responsiveListeners || (this._responsiveListeners = {});\n      var t = this._responsiveListeners,\n        e = this.platform,\n        s = function s(l, c) {\n          e.addEventListener(_this16, l, c), t[l] = c;\n        },\n        n = function n(l, c) {\n          t[l] && (e.removeEventListener(_this16, l, c), delete t[l]);\n        },\n        o = function o(l, c) {\n          _this16.canvas && _this16.resize(l, c);\n        };\n      var r;\n      var _a2 = function a() {\n        n(\"attach\", _a2), _this16.attached = !0, _this16.resize(), s(\"resize\", o), s(\"detach\", r);\n      };\n      r = function r() {\n        _this16.attached = !1, n(\"resize\", o), _this16._stop(), _this16._resize(0, 0), s(\"attach\", _a2);\n      }, e.isAttached(this.canvas) ? _a2() : r();\n    }\n  }, {\n    key: \"unbindEvents\",\n    value: function unbindEvents() {\n      var _this17 = this;\n      L(this._listeners, function (t, e) {\n        _this17.platform.removeEventListener(_this17, e, t);\n      }), this._listeners = {}, L(this._responsiveListeners, function (t, e) {\n        _this17.platform.removeEventListener(_this17, e, t);\n      }), this._responsiveListeners = void 0;\n    }\n  }, {\n    key: \"updateHoverStyle\",\n    value: function updateHoverStyle(t, e, s) {\n      var n = s ? \"set\" : \"remove\";\n      var o, r, a, l;\n      for (e === \"dataset\" && (o = this.getDatasetMeta(t[0].datasetIndex), o.controller[\"_\" + n + \"DatasetHoverStyle\"]()), a = 0, l = t.length; a < l; ++a) {\n        r = t[a];\n        var c = r && this.getDatasetMeta(r.datasetIndex).controller;\n        c && c[n + \"HoverStyle\"](r.element, r.datasetIndex, r.index);\n      }\n    }\n  }, {\n    key: \"getActiveElements\",\n    value: function getActiveElements() {\n      return this._active || [];\n    }\n  }, {\n    key: \"setActiveElements\",\n    value: function setActiveElements(t) {\n      var _this18 = this;\n      var e = this._active || [],\n        s = t.map(function (_ref5) {\n          var o = _ref5.datasetIndex,\n            r = _ref5.index;\n          var a = _this18.getDatasetMeta(o);\n          if (!a) throw new Error(\"No dataset found at index \" + o);\n          return {\n            datasetIndex: o,\n            element: a.data[r],\n            index: r\n          };\n        });\n      !je(s, e) && (this._active = s, this._lastEvent = null, this._updateHoverStyles(s, e));\n    }\n  }, {\n    key: \"notifyPlugins\",\n    value: function notifyPlugins(t, e, s) {\n      return this._plugins.notify(this, t, e, s);\n    }\n  }, {\n    key: \"isPluginEnabled\",\n    value: function isPluginEnabled(t) {\n      return this._plugins._cache.filter(function (e) {\n        return e.plugin.id === t;\n      }).length === 1;\n    }\n  }, {\n    key: \"_updateHoverStyles\",\n    value: function _updateHoverStyles(t, e, s) {\n      var n = this.options.hover,\n        o = function o(l, c) {\n          return l.filter(function (h) {\n            return !c.some(function (d) {\n              return h.datasetIndex === d.datasetIndex && h.index === d.index;\n            });\n          });\n        },\n        r = o(e, t),\n        a = s ? t : o(t, e);\n      r.length && this.updateHoverStyle(r, n.mode, !1), a.length && n.mode && this.updateHoverStyle(a, n.mode, !0);\n    }\n  }, {\n    key: \"_eventHandler\",\n    value: function _eventHandler(t, e) {\n      var _this19 = this;\n      var s = {\n          event: t,\n          replay: e,\n          cancelable: !0,\n          inChartArea: this.isPointInArea(t)\n        },\n        n = function n(r) {\n          return (r.options.events || _this19.options.events).includes(t[\"native\"].type);\n        };\n      if (this.notifyPlugins(\"beforeEvent\", s, n) === !1) return;\n      var o = this._handleEvent(t, e, s.inChartArea);\n      return s.cancelable = !1, this.notifyPlugins(\"afterEvent\", s, n), (o || s.changed) && this.render(), this;\n    }\n  }, {\n    key: \"_handleEvent\",\n    value: function _handleEvent(t, e, s) {\n      var _this$_active = this._active,\n        n = _this$_active === void 0 ? [] : _this$_active,\n        o = this.options,\n        r = e,\n        a = this._getActiveElements(t, n, s, r),\n        l = Ho(t),\n        c = Ll(t, this._lastEvent, s, l);\n      s && (this._lastEvent = null, I(o.onHover, [t, a, this], this), l && I(o.onClick, [t, a, this], this));\n      var h = !je(a, n);\n      return (h || e) && (this._active = a, this._updateHoverStyles(a, n, e)), this._lastEvent = c, h;\n    }\n  }, {\n    key: \"_getActiveElements\",\n    value: function _getActiveElements(t, e, s, n) {\n      if (t.type === \"mouseout\") return [];\n      if (!s) return e;\n      var o = this.options.hover;\n      return this.getElementsAtEventForMode(t, o.mode, o, n);\n    }\n  }], [{\n    key: \"register\",\n    value: function register() {\n      at.add.apply(at, arguments), $s();\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister() {\n      at.remove.apply(at, arguments), $s();\n    }\n  }]);\n}();\nw(mt, \"defaults\", W), w(mt, \"instances\", Be), w(mt, \"overrides\", zt), w(mt, \"registry\", at), w(mt, \"version\", Ol), w(mt, \"getChart\", js);\nfunction $s() {\n  return L(mt.instances, function (i) {\n    return i._plugins.invalidate();\n  });\n}\nfunction El(i, t, e) {\n  var s = t.startAngle,\n    n = t.x,\n    o = t.y,\n    r = t.outerRadius,\n    a = t.innerRadius,\n    l = t.options,\n    c = l.borderWidth,\n    h = l.borderJoinStyle,\n    d = Math.min(c / r, Z(s - e));\n  if (i.beginPath(), i.arc(n, o, r - c / 2, s + d / 2, e - d / 2), a > 0) {\n    var u = Math.min(c / a, Z(s - e));\n    i.arc(n, o, a + c / 2, e - u / 2, s + u / 2, !0);\n  } else {\n    var _u3 = Math.min(c / 2, r * Z(s - e));\n    if (h === \"round\") i.arc(n, o, _u3, e - E / 2, s + E / 2, !0);else if (h === \"bevel\") {\n      var f = 2 * _u3 * _u3,\n        p = -f * Math.cos(e + E / 2) + n,\n        g = -f * Math.sin(e + E / 2) + o,\n        m = f * Math.cos(s + E / 2) + n,\n        b = f * Math.sin(s + E / 2) + o;\n      i.lineTo(p, g), i.lineTo(m, b);\n    }\n  }\n  i.closePath(), i.moveTo(0, 0), i.rect(0, 0, i.canvas.width, i.canvas.height), i.clip(\"evenodd\");\n}\nfunction Fl(i, t, e) {\n  var s = t.startAngle,\n    n = t.pixelMargin,\n    o = t.x,\n    r = t.y,\n    a = t.outerRadius,\n    l = t.innerRadius;\n  var c = n / a;\n  i.beginPath(), i.arc(o, r, a, s - c, e + c), l > n ? (c = n / l, i.arc(o, r, l, e + c, s - c, !0)) : i.arc(o, r, n, e + V, s - V), i.closePath(), i.clip();\n}\nfunction Il(i) {\n  return Wi(i, [\"outerStart\", \"outerEnd\", \"innerStart\", \"innerEnd\"]);\n}\nfunction zl(i, t, e, s) {\n  var n = Il(i.options.borderRadius),\n    o = (e - t) / 2,\n    r = Math.min(o, s * t / 2),\n    a = function a(l) {\n      var c = (e - Math.min(o, l)) * s / 2;\n      return U(l, 0, Math.min(o, c));\n    };\n  return {\n    outerStart: a(n.outerStart),\n    outerEnd: a(n.outerEnd),\n    innerStart: U(n.innerStart, 0, r),\n    innerEnd: U(n.innerEnd, 0, r)\n  };\n}\nfunction Vt(i, t, e, s) {\n  return {\n    x: e + i * Math.cos(t),\n    y: s + i * Math.sin(t)\n  };\n}\nfunction Ke(i, t, e, s, n, o) {\n  var r = t.x,\n    a = t.y,\n    l = t.startAngle,\n    c = t.pixelMargin,\n    h = t.innerRadius,\n    d = Math.max(t.outerRadius + s + e - c, 0),\n    u = h > 0 ? h + s + e + c : 0;\n  var f = 0;\n  var p = n - l;\n  if (s) {\n    var F = h > 0 ? h - s : 0,\n      z = d > 0 ? d - s : 0,\n      H = (F + z) / 2,\n      it = H !== 0 ? p * H / (H + s) : p;\n    f = (p - it) / 2;\n  }\n  var g = Math.max(1e-3, p * d - e / E) / d,\n    m = (p - g) / 2,\n    b = l + m + f,\n    _ = n - m - f,\n    _zl = zl(t, u, d, _ - b),\n    v = _zl.outerStart,\n    y = _zl.outerEnd,\n    x = _zl.innerStart,\n    M = _zl.innerEnd,\n    S = d - v,\n    k = d - y,\n    P = b + v / S,\n    C = _ - y / k,\n    O = u + x,\n    A = u + M,\n    j = b + x / O,\n    J = _ - M / A;\n  if (i.beginPath(), o) {\n    var _F5 = (P + C) / 2;\n    if (i.arc(r, a, d, P, _F5), i.arc(r, a, d, _F5, C), y > 0) {\n      var $ = Vt(k, C, r, a);\n      i.arc($.x, $.y, y, C, _ + V);\n    }\n    var _z5 = Vt(A, _, r, a);\n    if (i.lineTo(_z5.x, _z5.y), M > 0) {\n      var _$ = Vt(A, J, r, a);\n      i.arc(_$.x, _$.y, M, _ + V, J + Math.PI);\n    }\n    var _H3 = (_ - M / u + (b + x / u)) / 2;\n    if (i.arc(r, a, u, _ - M / u, _H3, !0), i.arc(r, a, u, _H3, b + x / u, !0), x > 0) {\n      var _$2 = Vt(O, j, r, a);\n      i.arc(_$2.x, _$2.y, x, j + Math.PI, b - V);\n    }\n    var _it = Vt(S, b, r, a);\n    if (i.lineTo(_it.x, _it.y), v > 0) {\n      var _$3 = Vt(S, P, r, a);\n      i.arc(_$3.x, _$3.y, v, b - V, P);\n    }\n  } else {\n    i.moveTo(r, a);\n    var _F6 = Math.cos(P) * d + r,\n      _z6 = Math.sin(P) * d + a;\n    i.lineTo(_F6, _z6);\n    var _H4 = Math.cos(C) * d + r,\n      _it2 = Math.sin(C) * d + a;\n    i.lineTo(_H4, _it2);\n  }\n  i.closePath();\n}\nfunction Bl(i, t, e, s, n) {\n  var o = t.fullCircles,\n    r = t.startAngle,\n    a = t.circumference;\n  var l = t.endAngle;\n  if (o) {\n    Ke(i, t, e, s, l, n);\n    for (var c = 0; c < o; ++c) i.fill();\n    isNaN(a) || (l = r + (a % B || B));\n  }\n  return Ke(i, t, e, s, l, n), i.fill(), l;\n}\nfunction Hl(i, t, e, s, n) {\n  var o = t.fullCircles,\n    r = t.startAngle,\n    a = t.circumference,\n    l = t.options,\n    c = l.borderWidth,\n    h = l.borderJoinStyle,\n    d = l.borderDash,\n    u = l.borderDashOffset,\n    f = l.borderRadius,\n    p = l.borderAlign === \"inner\";\n  if (!c) return;\n  i.setLineDash(d || []), i.lineDashOffset = u, p ? (i.lineWidth = c * 2, i.lineJoin = h || \"round\") : (i.lineWidth = c, i.lineJoin = h || \"bevel\");\n  var g = t.endAngle;\n  if (o) {\n    Ke(i, t, e, s, g, n);\n    for (var m = 0; m < o; ++m) i.stroke();\n    isNaN(a) || (g = r + (a % B || B));\n  }\n  p && Fl(i, t, g), l.selfJoin && g - r >= E && f === 0 && h !== \"miter\" && El(i, t, g), o || (Ke(i, t, e, s, g, n), i.stroke());\n}\nvar re = /*#__PURE__*/function (_st2) {\n  function re(e) {\n    var _this20;\n    _classCallCheck(this, re);\n    _this20 = _callSuper(this, re);\n    w(_this20, \"circumference\");\n    w(_this20, \"endAngle\");\n    w(_this20, \"fullCircles\");\n    w(_this20, \"innerRadius\");\n    w(_this20, \"outerRadius\");\n    w(_this20, \"pixelMargin\");\n    w(_this20, \"startAngle\");\n    _this20.options = void 0, _this20.circumference = void 0, _this20.startAngle = void 0, _this20.endAngle = void 0, _this20.innerRadius = void 0, _this20.outerRadius = void 0, _this20.pixelMargin = 0, _this20.fullCircles = 0, e && Object.assign(_this20, e);\n    return _this20;\n  }\n  _inherits(re, _st2);\n  return _createClass(re, [{\n    key: \"inRange\",\n    value: function inRange(e, s, n) {\n      var o = this.getProps([\"x\", \"y\"], n),\n        _yn2 = yn(o, {\n          x: e,\n          y: s\n        }),\n        r = _yn2.angle,\n        a = _yn2.distance,\n        _this$getProps2 = this.getProps([\"startAngle\", \"endAngle\", \"innerRadius\", \"outerRadius\", \"circumference\"], n),\n        l = _this$getProps2.startAngle,\n        c = _this$getProps2.endAngle,\n        h = _this$getProps2.innerRadius,\n        d = _this$getProps2.outerRadius,\n        u = _this$getProps2.circumference,\n        f = (this.options.spacing + this.options.borderWidth) / 2,\n        p = D(u, c - l),\n        g = pe(r, l, c) && l !== c,\n        m = p >= B || g,\n        b = _t(a, h + f, d + f);\n      return m && b;\n    }\n  }, {\n    key: \"getCenterPoint\",\n    value: function getCenterPoint(e) {\n      var _this$getProps3 = this.getProps([\"x\", \"y\", \"startAngle\", \"endAngle\", \"innerRadius\", \"outerRadius\"], e),\n        s = _this$getProps3.x,\n        n = _this$getProps3.y,\n        o = _this$getProps3.startAngle,\n        r = _this$getProps3.endAngle,\n        a = _this$getProps3.innerRadius,\n        l = _this$getProps3.outerRadius,\n        _this$options11 = this.options,\n        c = _this$options11.offset,\n        h = _this$options11.spacing,\n        d = (o + r) / 2,\n        u = (a + l + h + c) / 2;\n      return {\n        x: s + Math.cos(d) * u,\n        y: n + Math.sin(d) * u\n      };\n    }\n  }, {\n    key: \"tooltipPosition\",\n    value: function tooltipPosition(e) {\n      return this.getCenterPoint(e);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(e) {\n      var s = this.options,\n        n = this.circumference,\n        o = (s.offset || 0) / 4,\n        r = (s.spacing || 0) / 2,\n        a = s.circular;\n      if (this.pixelMargin = s.borderAlign === \"inner\" ? 0.33 : 0, this.fullCircles = n > B ? Math.floor(n / B) : 0, n === 0 || this.innerRadius < 0 || this.outerRadius < 0) return;\n      e.save();\n      var l = (this.startAngle + this.endAngle) / 2;\n      e.translate(Math.cos(l) * o, Math.sin(l) * o);\n      var c = 1 - Math.sin(Math.min(E, n || 0)),\n        h = o * c;\n      e.fillStyle = s.backgroundColor, e.strokeStyle = s.borderColor, Bl(e, this, h, r, a), Hl(e, this, h, r, a), e.restore();\n    }\n  }]);\n}(st);\nw(re, \"id\", \"arc\"), w(re, \"defaults\", {\n  borderAlign: \"center\",\n  borderColor: \"#fff\",\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: void 0,\n  borderRadius: 0,\n  borderWidth: 2,\n  offset: 0,\n  spacing: 0,\n  angle: void 0,\n  circular: !0,\n  selfJoin: !1\n}), w(re, \"defaultRoutes\", {\n  backgroundColor: \"backgroundColor\"\n}), w(re, \"descriptors\", {\n  _scriptable: !0,\n  _indexable: function _indexable(e) {\n    return e !== \"borderDash\";\n  }\n});\nfunction Qn(i, t) {\n  var e = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : t;\n  i.lineCap = D(e.borderCapStyle, t.borderCapStyle), i.setLineDash(D(e.borderDash, t.borderDash)), i.lineDashOffset = D(e.borderDashOffset, t.borderDashOffset), i.lineJoin = D(e.borderJoinStyle, t.borderJoinStyle), i.lineWidth = D(e.borderWidth, t.borderWidth), i.strokeStyle = D(e.borderColor, t.borderColor);\n}\nfunction Wl(i, t, e) {\n  i.lineTo(e.x, e.y);\n}\nfunction Nl(i) {\n  return i.stepped ? hr : i.tension || i.cubicInterpolationMode === \"monotone\" ? dr : Wl;\n}\nfunction to(i, t) {\n  var e = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var s = i.length,\n    _e$start = e.start,\n    n = _e$start === void 0 ? 0 : _e$start,\n    _e$end = e.end,\n    o = _e$end === void 0 ? s - 1 : _e$end,\n    r = t.start,\n    a = t.end,\n    l = Math.max(n, r),\n    c = Math.min(o, a),\n    h = n < r && o < r || n > a && o > a;\n  return {\n    count: s,\n    start: l,\n    loop: t.loop,\n    ilen: c < l && !h ? s + c - l : c - l\n  };\n}\nfunction Vl(i, t, e, s) {\n  var n = t.points,\n    o = t.options,\n    _to = to(n, e, s),\n    r = _to.count,\n    a = _to.start,\n    l = _to.loop,\n    c = _to.ilen,\n    h = Nl(o);\n  var _ref6 = s || {},\n    _ref6$move = _ref6.move,\n    d = _ref6$move === void 0 ? !0 : _ref6$move,\n    u = _ref6.reverse,\n    f,\n    p,\n    g;\n  for (f = 0; f <= c; ++f) p = n[(a + (u ? c - f : f)) % r], !p.skip && (d ? (i.moveTo(p.x, p.y), d = !1) : h(i, g, p, u, o.stepped), g = p);\n  return l && (p = n[(a + (u ? c : 0)) % r], h(i, g, p, u, o.stepped)), !!l;\n}\nfunction jl(i, t, e, s) {\n  var n = t.points,\n    _to2 = to(n, e, s),\n    o = _to2.count,\n    r = _to2.start,\n    a = _to2.ilen,\n    _ref7 = s || {},\n    _ref7$move = _ref7.move,\n    l = _ref7$move === void 0 ? !0 : _ref7$move,\n    c = _ref7.reverse;\n  var h = 0,\n    d = 0,\n    u,\n    f,\n    p,\n    g,\n    m,\n    b;\n  var _ = function _(y) {\n      return (r + (c ? a - y : y)) % o;\n    },\n    v = function v() {\n      g !== m && (i.lineTo(h, m), i.lineTo(h, g), i.lineTo(h, b));\n    };\n  for (l && (f = n[_(0)], i.moveTo(f.x, f.y)), u = 0; u <= a; ++u) {\n    if (f = n[_(u)], f.skip) continue;\n    var y = f.x,\n      x = f.y,\n      M = y | 0;\n    M === p ? (x < g ? g = x : x > m && (m = x), h = (d * h + y) / ++d) : (v(), i.lineTo(y, x), p = M, d = 0, g = m = x), b = x;\n  }\n  v();\n}\nfunction Di(i) {\n  var t = i.options,\n    e = t.borderDash && t.borderDash.length;\n  return !i._decimated && !i._loop && !t.tension && t.cubicInterpolationMode !== \"monotone\" && !t.stepped && !e ? jl : Vl;\n}\nfunction $l(i) {\n  return i.stepped ? jr : i.tension || i.cubicInterpolationMode === \"monotone\" ? $r : Rt;\n}\nfunction Yl(i, t, e, s) {\n  var n = t._path;\n  n || (n = t._path = new Path2D(), t.path(n, e, s) && n.closePath()), Qn(i, t.options), i.stroke(n);\n}\nfunction Ul(i, t, e, s) {\n  var n = t.segments,\n    o = t.options,\n    r = Di(t);\n  var _iterator26 = _createForOfIteratorHelper(n),\n    _step26;\n  try {\n    for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n      var a = _step26.value;\n      Qn(i, o, a.style), i.beginPath(), r(i, t, a, {\n        start: e,\n        end: e + s - 1\n      }) && i.closePath(), i.stroke();\n    }\n  } catch (err) {\n    _iterator26.e(err);\n  } finally {\n    _iterator26.f();\n  }\n}\nvar Xl = typeof Path2D == \"function\";\nfunction ql(i, t, e, s) {\n  Xl && !t.options.segment ? Yl(i, t, e, s) : Ul(i, t, e, s);\n}\nvar vt = /*#__PURE__*/function (_st3) {\n  function vt(t) {\n    var _this21;\n    _classCallCheck(this, vt);\n    _this21 = _callSuper(this, vt), _this21.animated = !0, _this21.options = void 0, _this21._chart = void 0, _this21._loop = void 0, _this21._fullLoop = void 0, _this21._path = void 0, _this21._points = void 0, _this21._segments = void 0, _this21._decimated = !1, _this21._pointsUpdated = !1, _this21._datasetIndex = void 0, t && Object.assign(_assertThisInitialized(_this21), t);\n    return _this21;\n  }\n  _inherits(vt, _st3);\n  return _createClass(vt, [{\n    key: \"updateControlPoints\",\n    value: function updateControlPoints(t, e) {\n      var s = this.options;\n      if ((s.tension || s.cubicInterpolationMode === \"monotone\") && !s.stepped && !this._pointsUpdated) {\n        var n = s.spanGaps ? this._loop : this._fullLoop;\n        Fr(this._points, s, t, n, e), this._pointsUpdated = !0;\n      }\n    }\n  }, {\n    key: \"points\",\n    get: function get() {\n      return this._points;\n    },\n    set: function set(t) {\n      this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;\n    }\n  }, {\n    key: \"segments\",\n    get: function get() {\n      return this._segments || (this._segments = Gr(this, this.options.segment));\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      var t = this.segments,\n        e = this.points;\n      return t.length && e[t[0].start];\n    }\n  }, {\n    key: \"last\",\n    value: function last() {\n      var t = this.segments,\n        e = this.points,\n        s = t.length;\n      return s && e[t[s - 1].end];\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(t, e) {\n      var s = this.options,\n        n = t[e],\n        o = this.points,\n        r = Hn(this, {\n          property: e,\n          start: n,\n          end: n\n        });\n      if (!r.length) return;\n      var a = [],\n        l = $l(s);\n      var c, h;\n      for (c = 0, h = r.length; c < h; ++c) {\n        var _r$c = r[c],\n          d = _r$c.start,\n          u = _r$c.end,\n          f = o[d],\n          p = o[u];\n        if (f === p) {\n          a.push(f);\n          continue;\n        }\n        var g = Math.abs((n - f[e]) / (p[e] - f[e])),\n          m = l(f, p, g, s.stepped);\n        m[e] = t[e], a.push(m);\n      }\n      return a.length === 1 ? a[0] : a;\n    }\n  }, {\n    key: \"pathSegment\",\n    value: function pathSegment(t, e, s) {\n      return Di(this)(t, this, e, s);\n    }\n  }, {\n    key: \"path\",\n    value: function path(t, e, s) {\n      var n = this.segments,\n        o = Di(this);\n      var r = this._loop;\n      e = e || 0, s = s || this.points.length - e;\n      var _iterator27 = _createForOfIteratorHelper(n),\n        _step27;\n      try {\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var a = _step27.value;\n          r &= o(t, this, a, {\n            start: e,\n            end: e + s - 1\n          });\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n      return !!r;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(t, e, s, n) {\n      var o = this.options || {};\n      (this.points || []).length && o.borderWidth && (t.save(), ql(t, this, s, n), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);\n    }\n  }]);\n}(st);\nw(vt, \"id\", \"line\"), w(vt, \"defaults\", {\n  borderCapStyle: \"butt\",\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: \"miter\",\n  borderWidth: 3,\n  capBezierPoints: !0,\n  cubicInterpolationMode: \"default\",\n  fill: !1,\n  spanGaps: !1,\n  stepped: !1,\n  tension: 0\n}), w(vt, \"defaultRoutes\", {\n  backgroundColor: \"backgroundColor\",\n  borderColor: \"borderColor\"\n}), w(vt, \"descriptors\", {\n  _scriptable: !0,\n  _indexable: function _indexable(t) {\n    return t !== \"borderDash\" && t !== \"fill\";\n  }\n});\nfunction Ys(i, t, e, s) {\n  var n = i.options,\n    _i$getProps = i.getProps([e], s),\n    o = _i$getProps[e];\n  return Math.abs(t - o) < n.radius + n.hitRadius;\n}\nvar He = /*#__PURE__*/function (_st4) {\n  function He(e) {\n    var _this22;\n    _classCallCheck(this, He);\n    _this22 = _callSuper(this, He);\n    w(_this22, \"parsed\");\n    w(_this22, \"skip\");\n    w(_this22, \"stop\");\n    _this22.options = void 0, _this22.parsed = void 0, _this22.skip = void 0, _this22.stop = void 0, e && Object.assign(_this22, e);\n    return _this22;\n  }\n  _inherits(He, _st4);\n  return _createClass(He, [{\n    key: \"inRange\",\n    value: function inRange(e, s, n) {\n      var o = this.options,\n        _this$getProps4 = this.getProps([\"x\", \"y\"], n),\n        r = _this$getProps4.x,\n        a = _this$getProps4.y;\n      return Math.pow(e - r, 2) + Math.pow(s - a, 2) < Math.pow(o.hitRadius + o.radius, 2);\n    }\n  }, {\n    key: \"inXRange\",\n    value: function inXRange(e, s) {\n      return Ys(this, e, \"x\", s);\n    }\n  }, {\n    key: \"inYRange\",\n    value: function inYRange(e, s) {\n      return Ys(this, e, \"y\", s);\n    }\n  }, {\n    key: \"getCenterPoint\",\n    value: function getCenterPoint(e) {\n      var _this$getProps5 = this.getProps([\"x\", \"y\"], e),\n        s = _this$getProps5.x,\n        n = _this$getProps5.y;\n      return {\n        x: s,\n        y: n\n      };\n    }\n  }, {\n    key: \"size\",\n    value: function size(e) {\n      e = e || this.options || {};\n      var s = e.radius || 0;\n      s = Math.max(s, s && e.hoverRadius || 0);\n      var n = s && e.borderWidth || 0;\n      return (s + n) * 2;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(e, s) {\n      var n = this.options;\n      this.skip || n.radius < 0.1 || !me(this, s, this.size(n) / 2) || (e.strokeStyle = n.borderColor, e.lineWidth = n.borderWidth, e.fillStyle = n.backgroundColor, Si(e, n, this.x, this.y));\n    }\n  }, {\n    key: \"getRange\",\n    value: function getRange() {\n      var e = this.options || {};\n      return e.radius + e.hitRadius;\n    }\n  }]);\n}(st);\nw(He, \"id\", \"point\"),\n/**\n* @type {any}\n*/\nw(He, \"defaults\", {\n  borderWidth: 1,\n  hitRadius: 1,\n  hoverBorderWidth: 1,\n  hoverRadius: 4,\n  pointStyle: \"circle\",\n  radius: 3,\n  rotation: 0\n}),\n/**\n* @type {any}\n*/\nw(He, \"defaultRoutes\", {\n  backgroundColor: \"backgroundColor\",\n  borderColor: \"borderColor\"\n});\nfunction eo(i, t) {\n  var _i$getProps2 = i.getProps([\"x\", \"y\", \"base\", \"width\", \"height\"], t),\n    e = _i$getProps2.x,\n    s = _i$getProps2.y,\n    n = _i$getProps2.base,\n    o = _i$getProps2.width,\n    r = _i$getProps2.height;\n  var a, l, c, h, d;\n  return i.horizontal ? (d = r / 2, a = Math.min(e, n), l = Math.max(e, n), c = s - d, h = s + d) : (d = o / 2, a = e - d, l = e + d, c = Math.min(s, n), h = Math.max(s, n)), {\n    left: a,\n    top: c,\n    right: l,\n    bottom: h\n  };\n}\nfunction Mt(i, t, e, s) {\n  return i ? 0 : U(t, e, s);\n}\nfunction Kl(i, t, e) {\n  var s = i.options.borderWidth,\n    n = i.borderSkipped,\n    o = On(s);\n  return {\n    t: Mt(n.top, o.top, 0, e),\n    r: Mt(n.right, o.right, 0, t),\n    b: Mt(n.bottom, o.bottom, 0, e),\n    l: Mt(n.left, o.left, 0, t)\n  };\n}\nfunction Gl(i, t, e) {\n  var _i$getProps3 = i.getProps([\"enableBorderRadius\"]),\n    s = _i$getProps3.enableBorderRadius,\n    n = i.options.borderRadius,\n    o = Yt(n),\n    r = Math.min(t, e),\n    a = i.borderSkipped,\n    l = s || T(n);\n  return {\n    topLeft: Mt(!l || a.top || a.left, o.topLeft, 0, r),\n    topRight: Mt(!l || a.top || a.right, o.topRight, 0, r),\n    bottomLeft: Mt(!l || a.bottom || a.left, o.bottomLeft, 0, r),\n    bottomRight: Mt(!l || a.bottom || a.right, o.bottomRight, 0, r)\n  };\n}\nfunction Jl(i) {\n  var t = eo(i),\n    e = t.right - t.left,\n    s = t.bottom - t.top,\n    n = Kl(i, e / 2, s / 2),\n    o = Gl(i, e / 2, s / 2);\n  return {\n    outer: {\n      x: t.left,\n      y: t.top,\n      w: e,\n      h: s,\n      radius: o\n    },\n    inner: {\n      x: t.left + n.l,\n      y: t.top + n.t,\n      w: e - n.l - n.r,\n      h: s - n.t - n.b,\n      radius: {\n        topLeft: Math.max(0, o.topLeft - Math.max(n.t, n.l)),\n        topRight: Math.max(0, o.topRight - Math.max(n.t, n.r)),\n        bottomLeft: Math.max(0, o.bottomLeft - Math.max(n.b, n.l)),\n        bottomRight: Math.max(0, o.bottomRight - Math.max(n.b, n.r))\n      }\n    }\n  };\n}\nfunction fi(i, t, e, s) {\n  var n = t === null,\n    o = e === null,\n    a = i && !(n && o) && eo(i, s);\n  return a && (n || _t(t, a.left, a.right)) && (o || _t(e, a.top, a.bottom));\n}\nfunction Zl(i) {\n  return i.topLeft || i.topRight || i.bottomLeft || i.bottomRight;\n}\nfunction Ql(i, t) {\n  i.rect(t.x, t.y, t.w, t.h);\n}\nfunction gi(i, t) {\n  var e = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var s = i.x !== e.x ? -t : 0,\n    n = i.y !== e.y ? -t : 0,\n    o = (i.x + i.w !== e.x + e.w ? t : 0) - s,\n    r = (i.y + i.h !== e.y + e.h ? t : 0) - n;\n  return {\n    x: i.x + s,\n    y: i.y + n,\n    w: i.w + o,\n    h: i.h + r,\n    radius: i.radius\n  };\n}\nvar We = /*#__PURE__*/function (_st5) {\n  function We(t) {\n    var _this23;\n    _classCallCheck(this, We);\n    _this23 = _callSuper(this, We), _this23.options = void 0, _this23.horizontal = void 0, _this23.base = void 0, _this23.width = void 0, _this23.height = void 0, _this23.inflateAmount = void 0, t && Object.assign(_assertThisInitialized(_this23), t);\n    return _this23;\n  }\n  _inherits(We, _st5);\n  return _createClass(We, [{\n    key: \"draw\",\n    value: function draw(t) {\n      var e = this.inflateAmount,\n        _this$options12 = this.options,\n        s = _this$options12.borderColor,\n        n = _this$options12.backgroundColor,\n        _Jl = Jl(this),\n        o = _Jl.inner,\n        r = _Jl.outer,\n        a = Zl(r.radius) ? Ue : Ql;\n      t.save(), (r.w !== o.w || r.h !== o.h) && (t.beginPath(), a(t, gi(r, e, o)), t.clip(), a(t, gi(o, -e, r)), t.fillStyle = s, t.fill(\"evenodd\")), t.beginPath(), a(t, gi(o, e)), t.fillStyle = n, t.fill(), t.restore();\n    }\n  }, {\n    key: \"inRange\",\n    value: function inRange(t, e, s) {\n      return fi(this, t, e, s);\n    }\n  }, {\n    key: \"inXRange\",\n    value: function inXRange(t, e) {\n      return fi(this, t, null, e);\n    }\n  }, {\n    key: \"inYRange\",\n    value: function inYRange(t, e) {\n      return fi(this, null, t, e);\n    }\n  }, {\n    key: \"getCenterPoint\",\n    value: function getCenterPoint(t) {\n      var _this$getProps6 = this.getProps([\"x\", \"y\", \"base\", \"horizontal\"], t),\n        e = _this$getProps6.x,\n        s = _this$getProps6.y,\n        n = _this$getProps6.base,\n        o = _this$getProps6.horizontal;\n      return {\n        x: o ? (e + n) / 2 : e,\n        y: o ? s : (s + n) / 2\n      };\n    }\n  }, {\n    key: \"getRange\",\n    value: function getRange(t) {\n      return t === \"x\" ? this.width / 2 : this.height / 2;\n    }\n  }]);\n}(st);\nw(We, \"id\", \"bar\"), w(We, \"defaults\", {\n  borderSkipped: \"start\",\n  borderWidth: 0,\n  borderRadius: 0,\n  inflateAmount: \"auto\",\n  pointStyle: void 0\n}), w(We, \"defaultRoutes\", {\n  backgroundColor: \"backgroundColor\",\n  borderColor: \"borderColor\"\n});\nfunction tc(i, t, e) {\n  var s = i.segments,\n    n = i.points,\n    o = t.points,\n    r = [];\n  var _iterator28 = _createForOfIteratorHelper(s),\n    _step28;\n  try {\n    for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n      var a = _step28.value;\n      var l = a.start,\n        c = a.end;\n      c = ei(l, c, n);\n      var h = Ci(e, n[l], n[c], a.loop);\n      if (!t.segments) {\n        r.push({\n          source: a,\n          target: h,\n          start: n[l],\n          end: n[c]\n        });\n        continue;\n      }\n      var d = Hn(t, h);\n      var _iterator29 = _createForOfIteratorHelper(d),\n        _step29;\n      try {\n        for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n          var u = _step29.value;\n          var f = Ci(e, o[u.start], o[u.end], u.loop),\n            p = Bn(a, n, f);\n          var _iterator30 = _createForOfIteratorHelper(p),\n            _step30;\n          try {\n            for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n              var g = _step30.value;\n              r.push({\n                source: g,\n                target: u,\n                start: _defineProperty({}, e, Us(h, f, \"start\", Math.max)),\n                end: _defineProperty({}, e, Us(h, f, \"end\", Math.min))\n              });\n            }\n          } catch (err) {\n            _iterator30.e(err);\n          } finally {\n            _iterator30.f();\n          }\n        }\n      } catch (err) {\n        _iterator29.e(err);\n      } finally {\n        _iterator29.f();\n      }\n    }\n  } catch (err) {\n    _iterator28.e(err);\n  } finally {\n    _iterator28.f();\n  }\n  return r;\n}\nfunction Ci(i, t, e, s) {\n  if (s) return;\n  var n = t[i],\n    o = e[i];\n  return i === \"angle\" && (n = Z(n), o = Z(o)), {\n    property: i,\n    start: n,\n    end: o\n  };\n}\nfunction ec(i, t) {\n  var _ref8 = i || {},\n    _ref8$x = _ref8.x,\n    e = _ref8$x === void 0 ? null : _ref8$x,\n    _ref8$y = _ref8.y,\n    s = _ref8$y === void 0 ? null : _ref8$y,\n    n = t.points,\n    o = [];\n  return t.segments.forEach(function (_ref9) {\n    var r = _ref9.start,\n      a = _ref9.end;\n    a = ei(r, a, n);\n    var l = n[r],\n      c = n[a];\n    s !== null ? (o.push({\n      x: l.x,\n      y: s\n    }), o.push({\n      x: c.x,\n      y: s\n    })) : e !== null && (o.push({\n      x: e,\n      y: l.y\n    }), o.push({\n      x: e,\n      y: c.y\n    }));\n  }), o;\n}\nfunction ei(i, t, e) {\n  for (; t > i; t--) {\n    var s = e[t];\n    if (!isNaN(s.x) && !isNaN(s.y)) break;\n  }\n  return t;\n}\nfunction Us(i, t, e, s) {\n  return i && t ? s(i[e], t[e]) : i ? i[e] : t ? t[e] : 0;\n}\nfunction io(i, t) {\n  var e = [],\n    s = !1;\n  return N(i) ? (s = !0, e = i) : e = ec(i, t), e.length ? new vt({\n    points: e,\n    options: {\n      tension: 0\n    },\n    _loop: s,\n    _fullLoop: s\n  }) : null;\n}\nfunction Xs(i) {\n  return i && i.fill !== !1;\n}\nfunction ic(i, t, e) {\n  var n = i[t].fill;\n  var o = [t];\n  var r;\n  if (!e) return n;\n  for (; n !== !1 && o.indexOf(n) === -1;) {\n    if (!q(n)) return n;\n    if (r = i[n], !r) return !1;\n    if (r.visible) return n;\n    o.push(n), n = r.fill;\n  }\n  return !1;\n}\nfunction sc(i, t, e) {\n  var s = ac(i);\n  if (T(s)) return isNaN(s.value) ? !1 : s;\n  var n = parseFloat(s);\n  return q(n) && Math.floor(n) === n ? nc(s[0], t, n, e) : [\"origin\", \"start\", \"end\", \"stack\", \"shape\"].indexOf(s) >= 0 && s;\n}\nfunction nc(i, t, e, s) {\n  return (i === \"-\" || i === \"+\") && (e = t + e), e === t || e < 0 || e >= s ? !1 : e;\n}\nfunction oc(i, t) {\n  var e = null;\n  return i === \"start\" ? e = t.bottom : i === \"end\" ? e = t.top : T(i) ? e = t.getPixelForValue(i.value) : t.getBasePixel && (e = t.getBasePixel()), e;\n}\nfunction rc(i, t, e) {\n  var s;\n  return i === \"start\" ? s = e : i === \"end\" ? s = t.options.reverse ? t.min : t.max : T(i) ? s = i.value : s = t.getBaseValue(), s;\n}\nfunction ac(i) {\n  var t = i.options,\n    e = t.fill;\n  var s = D(e && e.target, e);\n  return s === void 0 && (s = !!t.backgroundColor), s === !1 || s === null ? !1 : s === !0 ? \"origin\" : s;\n}\nfunction lc(i) {\n  var t = i.scale,\n    e = i.index,\n    s = i.line,\n    n = [],\n    o = s.segments,\n    r = s.points,\n    a = cc(t, e);\n  a.push(io({\n    x: null,\n    y: t.bottom\n  }, s));\n  for (var l = 0; l < o.length; l++) {\n    var c = o[l];\n    for (var h = c.start; h <= c.end; h++) hc(n, r[h], a);\n  }\n  return new vt({\n    points: n,\n    options: {}\n  });\n}\nfunction cc(i, t) {\n  var e = [],\n    s = i.getMatchingVisibleMetas(\"line\");\n  for (var n = 0; n < s.length; n++) {\n    var o = s[n];\n    if (o.index === t) break;\n    o.hidden || e.unshift(o.dataset);\n  }\n  return e;\n}\nfunction hc(i, t, e) {\n  var s = [];\n  for (var n = 0; n < e.length; n++) {\n    var o = e[n],\n      _dc = dc(o, t, \"x\"),\n      r = _dc.first,\n      a = _dc.last,\n      l = _dc.point;\n    if (!(!l || r && a)) {\n      if (r) s.unshift(l);else if (i.push(l), !a) break;\n    }\n  }\n  i.push.apply(i, s);\n}\nfunction dc(i, t, e) {\n  var s = i.interpolate(t, e);\n  if (!s) return {};\n  var n = s[e],\n    o = i.segments,\n    r = i.points;\n  var a = !1,\n    l = !1;\n  for (var c = 0; c < o.length; c++) {\n    var h = o[c],\n      d = r[h.start][e],\n      u = r[h.end][e];\n    if (_t(n, d, u)) {\n      a = n === d, l = n === u;\n      break;\n    }\n  }\n  return {\n    first: a,\n    last: l,\n    point: s\n  };\n}\nvar so = /*#__PURE__*/function () {\n  function so(t) {\n    _classCallCheck(this, so);\n    this.x = t.x, this.y = t.y, this.radius = t.radius;\n  }\n  return _createClass(so, [{\n    key: \"pathSegment\",\n    value: function pathSegment(t, e, s) {\n      var n = this.x,\n        o = this.y,\n        r = this.radius;\n      return e = e || {\n        start: 0,\n        end: B\n      }, t.arc(n, o, r, e.end, e.start, !0), !s.bounds;\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(t) {\n      var e = this.x,\n        s = this.y,\n        n = this.radius,\n        o = t.angle;\n      return {\n        x: e + Math.cos(o) * n,\n        y: s + Math.sin(o) * n,\n        angle: o\n      };\n    }\n  }]);\n}();\nfunction uc(i) {\n  var t = i.chart,\n    e = i.fill,\n    s = i.line;\n  if (q(e)) return fc(t, e);\n  if (e === \"stack\") return lc(i);\n  if (e === \"shape\") return !0;\n  var n = gc(i);\n  return n instanceof so ? n : io(n, s);\n}\nfunction fc(i, t) {\n  var e = i.getDatasetMeta(t);\n  return e && i.isDatasetVisible(t) ? e.dataset : null;\n}\nfunction gc(i) {\n  return (i.scale || {}).getPointPositionForValue ? mc(i) : pc(i);\n}\nfunction pc(i) {\n  var _i$scale = i.scale,\n    t = _i$scale === void 0 ? {} : _i$scale,\n    e = i.fill,\n    s = oc(e, t);\n  if (q(s)) {\n    var n = t.isHorizontal();\n    return {\n      x: n ? s : null,\n      y: n ? null : s\n    };\n  }\n  return null;\n}\nfunction mc(i) {\n  var t = i.scale,\n    e = i.fill,\n    s = t.options,\n    n = t.getLabels().length,\n    o = s.reverse ? t.max : t.min,\n    r = rc(e, t, o),\n    a = [];\n  if (s.grid.circular) {\n    var l = t.getPointPositionForValue(0, o);\n    return new so({\n      x: l.x,\n      y: l.y,\n      radius: t.getDistanceFromCenterForValue(r)\n    });\n  }\n  for (var _l2 = 0; _l2 < n; ++_l2) a.push(t.getPointPositionForValue(_l2, r));\n  return a;\n}\nfunction pi(i, t, e) {\n  var s = uc(t),\n    n = t.chart,\n    o = t.index,\n    r = t.line,\n    a = t.scale,\n    l = t.axis,\n    c = r.options,\n    h = c.fill,\n    d = c.backgroundColor,\n    _ref0 = h || {},\n    _ref0$above = _ref0.above,\n    u = _ref0$above === void 0 ? d : _ref0$above,\n    _ref0$below = _ref0.below,\n    f = _ref0$below === void 0 ? d : _ref0$below,\n    p = n.getDatasetMeta(o),\n    g = Wn(n, p);\n  s && r.points.length && (Je(i, e), bc(i, {\n    line: r,\n    target: s,\n    above: u,\n    below: f,\n    area: e,\n    scale: a,\n    axis: l,\n    clip: g\n  }), Ze(i));\n}\nfunction bc(i, t) {\n  var e = t.line,\n    s = t.target,\n    n = t.above,\n    o = t.below,\n    r = t.area,\n    a = t.scale,\n    l = t.clip,\n    c = e._loop ? \"angle\" : t.axis;\n  i.save();\n  var h = o;\n  o !== n && (c === \"x\" ? (qs(i, s, r.top), mi(i, {\n    line: e,\n    target: s,\n    color: n,\n    scale: a,\n    property: c,\n    clip: l\n  }), i.restore(), i.save(), qs(i, s, r.bottom)) : c === \"y\" && (Ks(i, s, r.left), mi(i, {\n    line: e,\n    target: s,\n    color: o,\n    scale: a,\n    property: c,\n    clip: l\n  }), i.restore(), i.save(), Ks(i, s, r.right), h = n)), mi(i, {\n    line: e,\n    target: s,\n    color: h,\n    scale: a,\n    property: c,\n    clip: l\n  }), i.restore();\n}\nfunction qs(i, t, e) {\n  var s = t.segments,\n    n = t.points;\n  var o = !0,\n    r = !1;\n  i.beginPath();\n  var _iterator31 = _createForOfIteratorHelper(s),\n    _step31;\n  try {\n    for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n      var a = _step31.value;\n      var l = a.start,\n        c = a.end,\n        h = n[l],\n        d = n[ei(l, c, n)];\n      o ? (i.moveTo(h.x, h.y), o = !1) : (i.lineTo(h.x, e), i.lineTo(h.x, h.y)), r = !!t.pathSegment(i, a, {\n        move: r\n      }), r ? i.closePath() : i.lineTo(d.x, e);\n    }\n  } catch (err) {\n    _iterator31.e(err);\n  } finally {\n    _iterator31.f();\n  }\n  i.lineTo(t.first().x, e), i.closePath(), i.clip();\n}\nfunction Ks(i, t, e) {\n  var s = t.segments,\n    n = t.points;\n  var o = !0,\n    r = !1;\n  i.beginPath();\n  var _iterator32 = _createForOfIteratorHelper(s),\n    _step32;\n  try {\n    for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n      var a = _step32.value;\n      var l = a.start,\n        c = a.end,\n        h = n[l],\n        d = n[ei(l, c, n)];\n      o ? (i.moveTo(h.x, h.y), o = !1) : (i.lineTo(e, h.y), i.lineTo(h.x, h.y)), r = !!t.pathSegment(i, a, {\n        move: r\n      }), r ? i.closePath() : i.lineTo(e, d.y);\n    }\n  } catch (err) {\n    _iterator32.e(err);\n  } finally {\n    _iterator32.f();\n  }\n  i.lineTo(e, t.first().y), i.closePath(), i.clip();\n}\nfunction mi(i, t) {\n  var e = t.line,\n    s = t.target,\n    n = t.property,\n    o = t.color,\n    r = t.scale,\n    a = t.clip,\n    l = tc(e, s, n);\n  var _iterator33 = _createForOfIteratorHelper(l),\n    _step33;\n  try {\n    for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n      var _step33$value = _step33.value,\n        c = _step33$value.source,\n        h = _step33$value.target,\n        d = _step33$value.start,\n        u = _step33$value.end;\n      var _c$style = c.style,\n        _c$style2 = _c$style === void 0 ? {} : _c$style,\n        _c$style2$backgroundC = _c$style2.backgroundColor,\n        f = _c$style2$backgroundC === void 0 ? o : _c$style2$backgroundC,\n        p = s !== !0;\n      i.save(), i.fillStyle = f, _c(i, r, a, p && Ci(n, d, u)), i.beginPath();\n      var g = !!e.pathSegment(i, c);\n      var m = void 0;\n      if (p) {\n        g ? i.closePath() : Gs(i, s, u, n);\n        var b = !!s.pathSegment(i, h, {\n          move: g,\n          reverse: !0\n        });\n        m = g && b, m || Gs(i, s, d, n);\n      }\n      i.closePath(), i.fill(m ? \"evenodd\" : \"nonzero\"), i.restore();\n    }\n  } catch (err) {\n    _iterator33.e(err);\n  } finally {\n    _iterator33.f();\n  }\n}\nfunction _c(i, t, e, s) {\n  var n = t.chart.chartArea,\n    _ref1 = s || {},\n    o = _ref1.property,\n    r = _ref1.start,\n    a = _ref1.end;\n  if (o === \"x\" || o === \"y\") {\n    var l, c, h, d;\n    o === \"x\" ? (l = r, c = n.top, h = a, d = n.bottom) : (l = n.left, c = r, h = n.right, d = a), i.beginPath(), e && (l = Math.max(l, e.left), h = Math.min(h, e.right), c = Math.max(c, e.top), d = Math.min(d, e.bottom)), i.rect(l, c, h - l, d - c), i.clip();\n  }\n}\nfunction Gs(i, t, e, s) {\n  var n = t.interpolate(e, s);\n  n && i.lineTo(n.x, n.y);\n}\nvar xc = {\n  id: \"filler\",\n  afterDatasetsUpdate: function afterDatasetsUpdate(i, t, e) {\n    var s = (i.data.datasets || []).length,\n      n = [];\n    var o, r, a, l;\n    for (r = 0; r < s; ++r) o = i.getDatasetMeta(r), a = o.dataset, l = null, a && a.options && a instanceof vt && (l = {\n      visible: i.isDatasetVisible(r),\n      index: r,\n      fill: sc(a, r, s),\n      chart: i,\n      axis: o.controller.options.indexAxis,\n      scale: o.vScale,\n      line: a\n    }), o.$filler = l, n.push(l);\n    for (r = 0; r < s; ++r) l = n[r], !(!l || l.fill === !1) && (l.fill = ic(n, r, e.propagate));\n  },\n  beforeDraw: function beforeDraw(i, t, e) {\n    var s = e.drawTime === \"beforeDraw\",\n      n = i.getSortedVisibleDatasetMetas(),\n      o = i.chartArea;\n    for (var r = n.length - 1; r >= 0; --r) {\n      var a = n[r].$filler;\n      a && (a.line.updateControlPoints(o, a.axis), s && a.fill && pi(i.ctx, a, o));\n    }\n  },\n  beforeDatasetsDraw: function beforeDatasetsDraw(i, t, e) {\n    if (e.drawTime !== \"beforeDatasetsDraw\") return;\n    var s = i.getSortedVisibleDatasetMetas();\n    for (var n = s.length - 1; n >= 0; --n) {\n      var o = s[n].$filler;\n      Xs(o) && pi(i.ctx, o, i.chartArea);\n    }\n  },\n  beforeDatasetDraw: function beforeDatasetDraw(i, t, e) {\n    var s = t.meta.$filler;\n    !Xs(s) || e.drawTime !== \"beforeDatasetDraw\" || pi(i.ctx, s, i.chartArea);\n  },\n  defaults: {\n    propagate: !0,\n    drawTime: \"beforeDatasetDraw\"\n  }\n};\nvar Js = function Js(i, t) {\n    var _i$boxHeight = i.boxHeight,\n      e = _i$boxHeight === void 0 ? t : _i$boxHeight,\n      _i$boxWidth = i.boxWidth,\n      s = _i$boxWidth === void 0 ? t : _i$boxWidth;\n    return i.usePointStyle && (e = Math.min(e, t), s = i.pointStyleWidth || Math.min(s, t)), {\n      boxWidth: s,\n      boxHeight: e,\n      itemHeight: Math.max(t, e)\n    };\n  },\n  yc = function yc(i, t) {\n    return i !== null && t !== null && i.datasetIndex === t.datasetIndex && i.index === t.index;\n  };\nvar Zs = /*#__PURE__*/function (_st6) {\n  function Zs(t) {\n    var _this24;\n    _classCallCheck(this, Zs);\n    _this24 = _callSuper(this, Zs), _this24._added = !1, _this24.legendHitBoxes = [], _this24._hoveredItem = null, _this24.doughnutMode = !1, _this24.chart = t.chart, _this24.options = t.options, _this24.ctx = t.ctx, _this24.legendItems = void 0, _this24.columnSizes = void 0, _this24.lineWidths = void 0, _this24.maxHeight = void 0, _this24.maxWidth = void 0, _this24.top = void 0, _this24.bottom = void 0, _this24.left = void 0, _this24.right = void 0, _this24.height = void 0, _this24.width = void 0, _this24._margins = void 0, _this24.position = void 0, _this24.weight = void 0, _this24.fullSize = void 0;\n    return _this24;\n  }\n  _inherits(Zs, _st6);\n  return _createClass(Zs, [{\n    key: \"update\",\n    value: function update(t, e, s) {\n      this.maxWidth = t, this.maxHeight = e, this._margins = s, this.setDimensions(), this.buildLabels(), this.fit();\n    }\n  }, {\n    key: \"setDimensions\",\n    value: function setDimensions() {\n      this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);\n    }\n  }, {\n    key: \"buildLabels\",\n    value: function buildLabels() {\n      var _this25 = this;\n      var t = this.options.labels || {};\n      var e = I(t.generateLabels, [this.chart], this) || [];\n      t.filter && (e = e.filter(function (s) {\n        return t.filter(s, _this25.chart.data);\n      })), t.sort && (e = e.sort(function (s, n) {\n        return t.sort(s, n, _this25.chart.data);\n      })), this.options.reverse && e.reverse(), this.legendItems = e;\n    }\n  }, {\n    key: \"fit\",\n    value: function fit() {\n      var t = this.options,\n        e = this.ctx;\n      if (!t.display) {\n        this.width = this.height = 0;\n        return;\n      }\n      var s = t.labels,\n        n = X(s.font),\n        o = n.size,\n        r = this._computeTitleHeight(),\n        _Js = Js(s, o),\n        a = _Js.boxWidth,\n        l = _Js.itemHeight;\n      var c, h;\n      e.font = n.string, this.isHorizontal() ? (c = this.maxWidth, h = this._fitRows(r, o, a, l) + 10) : (h = this.maxHeight, c = this._fitCols(r, n, a, l) + 10), this.width = Math.min(c, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight);\n    }\n  }, {\n    key: \"_fitRows\",\n    value: function _fitRows(t, e, s, n) {\n      var o = this.ctx,\n        r = this.maxWidth,\n        a = this.options.labels.padding,\n        l = this.legendHitBoxes = [],\n        c = this.lineWidths = [0],\n        h = n + a;\n      var d = t;\n      o.textAlign = \"left\", o.textBaseline = \"middle\";\n      var u = -1,\n        f = -h;\n      return this.legendItems.forEach(function (p, g) {\n        var m = s + e / 2 + o.measureText(p.text).width;\n        (g === 0 || c[c.length - 1] + m + 2 * a > r) && (d += h, c[c.length - (g > 0 ? 0 : 1)] = 0, f += h, u++), l[g] = {\n          left: 0,\n          top: f,\n          row: u,\n          width: m,\n          height: n\n        }, c[c.length - 1] += m + a;\n      }), d;\n    }\n  }, {\n    key: \"_fitCols\",\n    value: function _fitCols(t, e, s, n) {\n      var o = this.ctx,\n        r = this.maxHeight,\n        a = this.options.labels.padding,\n        l = this.legendHitBoxes = [],\n        c = this.columnSizes = [],\n        h = r - t;\n      var d = a,\n        u = 0,\n        f = 0,\n        p = 0,\n        g = 0;\n      return this.legendItems.forEach(function (m, b) {\n        var _vc = vc(s, e, o, m, n),\n          _ = _vc.itemWidth,\n          v = _vc.itemHeight;\n        b > 0 && f + v + 2 * a > h && (d += u + a, c.push({\n          width: u,\n          height: f\n        }), p += u + a, g++, u = f = 0), l[b] = {\n          left: p,\n          top: f,\n          col: g,\n          width: _,\n          height: v\n        }, u = Math.max(u, _), f += v + a;\n      }), d += u, c.push({\n        width: u,\n        height: f\n      }), d;\n    }\n  }, {\n    key: \"adjustHitBoxes\",\n    value: function adjustHitBoxes() {\n      if (!this.options.display) return;\n      var t = this._computeTitleHeight(),\n        e = this.legendHitBoxes,\n        _this$options13 = this.options,\n        s = _this$options13.align,\n        n = _this$options13.labels.padding,\n        o = _this$options13.rtl,\n        r = Ut(o, this.left, this.width);\n      if (this.isHorizontal()) {\n        var a = 0,\n          l = Y(s, this.left + n, this.right - this.lineWidths[a]);\n        var _iterator34 = _createForOfIteratorHelper(e),\n          _step34;\n        try {\n          for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n            var c = _step34.value;\n            a !== c.row && (a = c.row, l = Y(s, this.left + n, this.right - this.lineWidths[a])), c.top += this.top + t + n, c.left = r.leftForLtr(r.x(l), c.width), l += c.width + n;\n          }\n        } catch (err) {\n          _iterator34.e(err);\n        } finally {\n          _iterator34.f();\n        }\n      } else {\n        var _a3 = 0,\n          _l3 = Y(s, this.top + t + n, this.bottom - this.columnSizes[_a3].height);\n        var _iterator35 = _createForOfIteratorHelper(e),\n          _step35;\n        try {\n          for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n            var _c3 = _step35.value;\n            _c3.col !== _a3 && (_a3 = _c3.col, _l3 = Y(s, this.top + t + n, this.bottom - this.columnSizes[_a3].height)), _c3.top = _l3, _c3.left += this.left + n, _c3.left = r.leftForLtr(r.x(_c3.left), _c3.width), _l3 += _c3.height + n;\n          }\n        } catch (err) {\n          _iterator35.e(err);\n        } finally {\n          _iterator35.f();\n        }\n      }\n    }\n  }, {\n    key: \"isHorizontal\",\n    value: function isHorizontal() {\n      return this.options.position === \"top\" || this.options.position === \"bottom\";\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      if (this.options.display) {\n        var t = this.ctx;\n        Je(t, this), this._draw(), Ze(t);\n      }\n    }\n  }, {\n    key: \"_draw\",\n    value: function _draw() {\n      var _this26 = this;\n      var t = this.options,\n        e = this.columnSizes,\n        s = this.lineWidths,\n        n = this.ctx,\n        o = t.align,\n        r = t.labels,\n        a = W.color,\n        l = Ut(t.rtl, this.left, this.width),\n        c = X(r.font),\n        h = r.padding,\n        d = c.size,\n        u = d / 2;\n      var f;\n      this.drawTitle(), n.textAlign = l.textAlign(\"left\"), n.textBaseline = \"middle\", n.lineWidth = 0.5, n.font = c.string;\n      var _Js2 = Js(r, d),\n        p = _Js2.boxWidth,\n        g = _Js2.boxHeight,\n        m = _Js2.itemHeight,\n        b = function b(M, S, k) {\n          if (isNaN(p) || p <= 0 || isNaN(g) || g < 0) return;\n          n.save();\n          var P = D(k.lineWidth, 1);\n          if (n.fillStyle = D(k.fillStyle, a), n.lineCap = D(k.lineCap, \"butt\"), n.lineDashOffset = D(k.lineDashOffset, 0), n.lineJoin = D(k.lineJoin, \"miter\"), n.lineWidth = P, n.strokeStyle = D(k.strokeStyle, a), n.setLineDash(D(k.lineDash, [])), r.usePointStyle) {\n            var C = {\n                radius: g * Math.SQRT2 / 2,\n                pointStyle: k.pointStyle,\n                rotation: k.rotation,\n                borderWidth: P\n              },\n              O = l.xPlus(M, p / 2),\n              A = S + u;\n            Cn(n, C, O, A, r.pointStyleWidth && p);\n          } else {\n            var _C = S + Math.max((d - g) / 2, 0),\n              _O = l.leftForLtr(M, p),\n              _A = Yt(k.borderRadius);\n            n.beginPath(), Object.values(_A).some(function (j) {\n              return j !== 0;\n            }) ? Ue(n, {\n              x: _O,\n              y: _C,\n              w: p,\n              h: g,\n              radius: _A\n            }) : n.rect(_O, _C, p, g), n.fill(), P !== 0 && n.stroke();\n          }\n          n.restore();\n        },\n        _ = function _(M, S, k) {\n          be(n, k.text, M, S + m / 2, c, {\n            strikethrough: k.hidden,\n            textAlign: l.textAlign(k.textAlign)\n          });\n        },\n        v = this.isHorizontal(),\n        y = this._computeTitleHeight();\n      v ? f = {\n        x: Y(o, this.left + h, this.right - s[0]),\n        y: this.top + h + y,\n        line: 0\n      } : f = {\n        x: this.left + h,\n        y: Y(o, this.top + y + h, this.bottom - e[0].height),\n        line: 0\n      }, Fn(this.ctx, t.textDirection);\n      var x = m + h;\n      this.legendItems.forEach(function (M, S) {\n        n.strokeStyle = M.fontColor, n.fillStyle = M.fontColor;\n        var k = n.measureText(M.text).width,\n          P = l.textAlign(M.textAlign || (M.textAlign = r.textAlign)),\n          C = p + u + k;\n        var O = f.x,\n          A = f.y;\n        l.setWidth(_this26.width), v ? S > 0 && O + C + h > _this26.right && (A = f.y += x, f.line++, O = f.x = Y(o, _this26.left + h, _this26.right - s[f.line])) : S > 0 && A + x > _this26.bottom && (O = f.x = O + e[f.line].width + h, f.line++, A = f.y = Y(o, _this26.top + y + h, _this26.bottom - e[f.line].height));\n        var j = l.x(O);\n        if (b(j, A, M), O = Qo(P, O + p + u, v ? O + C : _this26.right, t.rtl), _(l.x(O), A, M), v) f.x += C + h;else if (typeof M.text != \"string\") {\n          var J = c.lineHeight;\n          f.y += no(M, J) + h;\n        } else f.y += x;\n      }), In(this.ctx, t.textDirection);\n    }\n  }, {\n    key: \"drawTitle\",\n    value: function drawTitle() {\n      var t = this.options,\n        e = t.title,\n        s = X(e.font),\n        n = et(e.padding);\n      if (!e.display) return;\n      var o = Ut(t.rtl, this.left, this.width),\n        r = this.ctx,\n        a = e.position,\n        l = s.size / 2,\n        c = n.top + l;\n      var h,\n        d = this.left,\n        u = this.width;\n      if (this.isHorizontal()) u = Math.max.apply(Math, _toConsumableArray(this.lineWidths)), h = this.top + c, d = Y(t.align, d, this.right - u);else {\n        var p = this.columnSizes.reduce(function (g, m) {\n          return Math.max(g, m.height);\n        }, 0);\n        h = c + Y(t.align, this.top, this.bottom - p - t.labels.padding - this._computeTitleHeight());\n      }\n      var f = Y(a, d, d + u);\n      r.textAlign = o.textAlign(zi(a)), r.textBaseline = \"middle\", r.strokeStyle = e.color, r.fillStyle = e.color, r.font = s.string, be(r, e.text, f, h, s);\n    }\n  }, {\n    key: \"_computeTitleHeight\",\n    value: function _computeTitleHeight() {\n      var t = this.options.title,\n        e = X(t.font),\n        s = et(t.padding);\n      return t.display ? e.lineHeight + s.height : 0;\n    }\n  }, {\n    key: \"_getLegendItemAt\",\n    value: function _getLegendItemAt(t, e) {\n      var s, n, o;\n      if (_t(t, this.left, this.right) && _t(e, this.top, this.bottom)) {\n        for (o = this.legendHitBoxes, s = 0; s < o.length; ++s) if (n = o[s], _t(t, n.left, n.left + n.width) && _t(e, n.top, n.top + n.height)) return this.legendItems[s];\n      }\n      return null;\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(t) {\n      var e = this.options;\n      if (!kc(t.type, e)) return;\n      var s = this._getLegendItemAt(t.x, t.y);\n      if (t.type === \"mousemove\" || t.type === \"mouseout\") {\n        var n = this._hoveredItem,\n          o = yc(n, s);\n        n && !o && I(e.onLeave, [t, n, this], this), this._hoveredItem = s, s && !o && I(e.onHover, [t, s, this], this);\n      } else s && I(e.onClick, [t, s, this], this);\n    }\n  }]);\n}(st);\nfunction vc(i, t, e, s, n) {\n  var o = Mc(s, i, t, e),\n    r = Sc(n, s, t.lineHeight);\n  return {\n    itemWidth: o,\n    itemHeight: r\n  };\n}\nfunction Mc(i, t, e, s) {\n  var n = i.text;\n  return n && typeof n != \"string\" && (n = n.reduce(function (o, r) {\n    return o.length > r.length ? o : r;\n  })), t + e.size / 2 + s.measureText(n).width;\n}\nfunction Sc(i, t, e) {\n  var s = i;\n  return typeof t.text != \"string\" && (s = no(t, e)), s;\n}\nfunction no(i, t) {\n  var e = i.text ? i.text.length : 0;\n  return t * e;\n}\nfunction kc(i, t) {\n  return !!((i === \"mousemove\" || i === \"mouseout\") && (t.onHover || t.onLeave) || t.onClick && (i === \"click\" || i === \"mouseup\"));\n}\nvar wc = {\n  id: \"legend\",\n  _element: Zs,\n  start: function start(i, t, e) {\n    var s = i.legend = new Zs({\n      ctx: i.ctx,\n      options: e,\n      chart: i\n    });\n    tt.configure(i, s, e), tt.addBox(i, s);\n  },\n  stop: function stop(i) {\n    tt.removeBox(i, i.legend), delete i.legend;\n  },\n  beforeUpdate: function beforeUpdate(i, t, e) {\n    var s = i.legend;\n    tt.configure(i, s, e), s.options = e;\n  },\n  afterUpdate: function afterUpdate(i) {\n    var t = i.legend;\n    t.buildLabels(), t.adjustHitBoxes();\n  },\n  afterEvent: function afterEvent(i, t) {\n    t.replay || i.legend.handleEvent(t.event);\n  },\n  defaults: {\n    display: !0,\n    position: \"top\",\n    align: \"center\",\n    fullSize: !0,\n    reverse: !1,\n    weight: 1e3,\n    onClick: function onClick(i, t, e) {\n      var s = t.datasetIndex,\n        n = e.chart;\n      n.isDatasetVisible(s) ? (n.hide(s), t.hidden = !0) : (n.show(s), t.hidden = !1);\n    },\n    onHover: null,\n    onLeave: null,\n    labels: {\n      color: function color(i) {\n        return i.chart.options.color;\n      },\n      boxWidth: 40,\n      padding: 10,\n      generateLabels: function generateLabels(i) {\n        var t = i.data.datasets,\n          _i$legend$options$lab = i.legend.options.labels,\n          e = _i$legend$options$lab.usePointStyle,\n          s = _i$legend$options$lab.pointStyle,\n          n = _i$legend$options$lab.textAlign,\n          o = _i$legend$options$lab.color,\n          r = _i$legend$options$lab.useBorderRadius,\n          a = _i$legend$options$lab.borderRadius;\n        return i._getSortedDatasetMetas().map(function (l) {\n          var c = l.controller.getStyle(e ? 0 : void 0),\n            h = et(c.borderWidth);\n          return {\n            text: t[l.index].label,\n            fillStyle: c.backgroundColor,\n            fontColor: o,\n            hidden: !l.visible,\n            lineCap: c.borderCapStyle,\n            lineDash: c.borderDash,\n            lineDashOffset: c.borderDashOffset,\n            lineJoin: c.borderJoinStyle,\n            lineWidth: (h.width + h.height) / 4,\n            strokeStyle: c.borderColor,\n            pointStyle: s || c.pointStyle,\n            rotation: c.rotation,\n            textAlign: n || c.textAlign,\n            borderRadius: r && (a || c.borderRadius),\n            datasetIndex: l.index\n          };\n        }, this);\n      }\n    },\n    title: {\n      color: function color(i) {\n        return i.chart.options.color;\n      },\n      display: !1,\n      position: \"center\",\n      text: \"\"\n    }\n  },\n  descriptors: {\n    _scriptable: function _scriptable(i) {\n      return !i.startsWith(\"on\");\n    },\n    labels: {\n      _scriptable: function _scriptable(i) {\n        return ![\"generateLabels\", \"filter\", \"sort\"].includes(i);\n      }\n    }\n  }\n};\nvar oo = /*#__PURE__*/function (_st7) {\n  function oo(t) {\n    var _this27;\n    _classCallCheck(this, oo);\n    _this27 = _callSuper(this, oo), _this27.chart = t.chart, _this27.options = t.options, _this27.ctx = t.ctx, _this27._padding = void 0, _this27.top = void 0, _this27.bottom = void 0, _this27.left = void 0, _this27.right = void 0, _this27.width = void 0, _this27.height = void 0, _this27.position = void 0, _this27.weight = void 0, _this27.fullSize = void 0;\n    return _this27;\n  }\n  _inherits(oo, _st7);\n  return _createClass(oo, [{\n    key: \"update\",\n    value: function update(t, e) {\n      var s = this.options;\n      if (this.left = 0, this.top = 0, !s.display) {\n        this.width = this.height = this.right = this.bottom = 0;\n        return;\n      }\n      this.width = this.right = t, this.height = this.bottom = e;\n      var n = N(s.text) ? s.text.length : 1;\n      this._padding = et(s.padding);\n      var o = n * X(s.font).lineHeight + this._padding.height;\n      this.isHorizontal() ? this.height = o : this.width = o;\n    }\n  }, {\n    key: \"isHorizontal\",\n    value: function isHorizontal() {\n      var t = this.options.position;\n      return t === \"top\" || t === \"bottom\";\n    }\n  }, {\n    key: \"_drawArgs\",\n    value: function _drawArgs(t) {\n      var e = this.top,\n        s = this.left,\n        n = this.bottom,\n        o = this.right,\n        r = this.options,\n        a = r.align;\n      var l = 0,\n        c,\n        h,\n        d;\n      return this.isHorizontal() ? (h = Y(a, s, o), d = e + t, c = o - s) : (r.position === \"left\" ? (h = s + t, d = Y(a, n, e), l = E * -0.5) : (h = o - t, d = Y(a, e, n), l = E * 0.5), c = n - e), {\n        titleX: h,\n        titleY: d,\n        maxWidth: c,\n        rotation: l\n      };\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var t = this.ctx,\n        e = this.options;\n      if (!e.display) return;\n      var s = X(e.font),\n        o = s.lineHeight / 2 + this._padding.top,\n        _this$_drawArgs = this._drawArgs(o),\n        r = _this$_drawArgs.titleX,\n        a = _this$_drawArgs.titleY,\n        l = _this$_drawArgs.maxWidth,\n        c = _this$_drawArgs.rotation;\n      be(t, e.text, 0, 0, s, {\n        color: e.color,\n        maxWidth: l,\n        rotation: c,\n        textAlign: zi(e.align),\n        textBaseline: \"middle\",\n        translation: [r, a]\n      });\n    }\n  }]);\n}(st);\nfunction Pc(i, t) {\n  var e = new oo({\n    ctx: i.ctx,\n    options: t,\n    chart: i\n  });\n  tt.configure(i, e, t), tt.addBox(i, e), i.titleBlock = e;\n}\nvar Dc = {\n  id: \"title\",\n  _element: oo,\n  start: function start(i, t, e) {\n    Pc(i, e);\n  },\n  stop: function stop(i) {\n    var t = i.titleBlock;\n    tt.removeBox(i, t), delete i.titleBlock;\n  },\n  beforeUpdate: function beforeUpdate(i, t, e) {\n    var s = i.titleBlock;\n    tt.configure(i, s, e), s.options = e;\n  },\n  defaults: {\n    align: \"center\",\n    display: !1,\n    font: {\n      weight: \"bold\"\n    },\n    fullSize: !0,\n    padding: 10,\n    position: \"top\",\n    text: \"\",\n    weight: 2e3\n  },\n  defaultRoutes: {\n    color: \"color\"\n  },\n  descriptors: {\n    _scriptable: !0,\n    _indexable: !1\n  }\n};\nvar ae = {\n  average: function average(i) {\n    if (!i.length) return !1;\n    var t,\n      e,\n      s = /* @__PURE__ */new Set(),\n      n = 0,\n      o = 0;\n    for (t = 0, e = i.length; t < e; ++t) {\n      var a = i[t].element;\n      if (a && a.hasValue()) {\n        var l = a.tooltipPosition();\n        s.add(l.x), n += l.y, ++o;\n      }\n    }\n    return o === 0 || s.size === 0 ? !1 : {\n      x: _toConsumableArray(s).reduce(function (a, l) {\n        return a + l;\n      }) / s.size,\n      y: n / o\n    };\n  },\n  nearest: function nearest(i, t) {\n    if (!i.length) return !1;\n    var e = t.x,\n      s = t.y,\n      n = Number.POSITIVE_INFINITY,\n      o,\n      r,\n      a;\n    for (o = 0, r = i.length; o < r; ++o) {\n      var l = i[o].element;\n      if (l && l.hasValue()) {\n        var c = l.getCenterPoint(),\n          h = vi(t, c);\n        h < n && (n = h, a = l);\n      }\n    }\n    if (a) {\n      var _l4 = a.tooltipPosition();\n      e = _l4.x, s = _l4.y;\n    }\n    return {\n      x: e,\n      y: s\n    };\n  }\n};\nfunction rt(i, t) {\n  return t && (N(t) ? Array.prototype.push.apply(i, t) : i.push(t)), i;\n}\nfunction ft(i) {\n  return (typeof i == \"string\" || i instanceof String) && i.indexOf(\"\\n\") > -1 ? i.split(\"\\n\") : i;\n}\nfunction Cc(i, t) {\n  var e = t.element,\n    s = t.datasetIndex,\n    n = t.index,\n    o = i.getDatasetMeta(s).controller,\n    _o$getLabelAndValue = o.getLabelAndValue(n),\n    r = _o$getLabelAndValue.label,\n    a = _o$getLabelAndValue.value;\n  return {\n    chart: i,\n    label: r,\n    parsed: o.getParsed(n),\n    raw: i.data.datasets[s].data[n],\n    formattedValue: a,\n    dataset: o.getDataset(),\n    dataIndex: n,\n    datasetIndex: s,\n    element: e\n  };\n}\nfunction Qs(i, t) {\n  var e = i.chart.ctx,\n    s = i.body,\n    n = i.footer,\n    o = i.title,\n    r = t.boxWidth,\n    a = t.boxHeight,\n    l = X(t.bodyFont),\n    c = X(t.titleFont),\n    h = X(t.footerFont),\n    d = o.length,\n    u = n.length,\n    f = s.length,\n    p = et(t.padding);\n  var g = p.height,\n    m = 0,\n    b = s.reduce(function (y, x) {\n      return y + x.before.length + x.lines.length + x.after.length;\n    }, 0);\n  if (b += i.beforeBody.length + i.afterBody.length, d && (g += d * c.lineHeight + (d - 1) * t.titleSpacing + t.titleMarginBottom), b) {\n    var y = t.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight;\n    g += f * y + (b - f) * l.lineHeight + (b - 1) * t.bodySpacing;\n  }\n  u && (g += t.footerMarginTop + u * h.lineHeight + (u - 1) * t.footerSpacing);\n  var _ = 0;\n  var v = function v(y) {\n    m = Math.max(m, e.measureText(y).width + _);\n  };\n  return e.save(), e.font = c.string, L(i.title, v), e.font = l.string, L(i.beforeBody.concat(i.afterBody), v), _ = t.displayColors ? r + 2 + t.boxPadding : 0, L(s, function (y) {\n    L(y.before, v), L(y.lines, v), L(y.after, v);\n  }), _ = 0, e.font = h.string, L(i.footer, v), e.restore(), m += p.width, {\n    width: m,\n    height: g\n  };\n}\nfunction Oc(i, t) {\n  var e = t.y,\n    s = t.height;\n  return e < s / 2 ? \"top\" : e > i.height - s / 2 ? \"bottom\" : \"center\";\n}\nfunction Tc(i, t, e, s) {\n  var n = s.x,\n    o = s.width,\n    r = e.caretSize + e.caretPadding;\n  if (i === \"left\" && n + o + r > t.width || i === \"right\" && n - o - r < 0) return !0;\n}\nfunction Ac(i, t, e, s) {\n  var n = e.x,\n    o = e.width,\n    r = i.width,\n    _i$chartArea = i.chartArea,\n    a = _i$chartArea.left,\n    l = _i$chartArea.right;\n  var c = \"center\";\n  return s === \"center\" ? c = n <= (a + l) / 2 ? \"left\" : \"right\" : n <= o / 2 ? c = \"left\" : n >= r - o / 2 && (c = \"right\"), Tc(c, i, t, e) && (c = \"center\"), c;\n}\nfunction tn(i, t, e) {\n  var s = e.yAlign || t.yAlign || Oc(i, e);\n  return {\n    xAlign: e.xAlign || t.xAlign || Ac(i, t, e, s),\n    yAlign: s\n  };\n}\nfunction Rc(i, t) {\n  var e = i.x,\n    s = i.width;\n  return t === \"right\" ? e -= s : t === \"center\" && (e -= s / 2), e;\n}\nfunction Lc(i, t, e) {\n  var s = i.y,\n    n = i.height;\n  return t === \"top\" ? s += e : t === \"bottom\" ? s -= n + e : s -= n / 2, s;\n}\nfunction en(i, t, e, s) {\n  var n = i.caretSize,\n    o = i.caretPadding,\n    r = i.cornerRadius,\n    a = e.xAlign,\n    l = e.yAlign,\n    c = n + o,\n    _Yt = Yt(r),\n    h = _Yt.topLeft,\n    d = _Yt.topRight,\n    u = _Yt.bottomLeft,\n    f = _Yt.bottomRight;\n  var p = Rc(t, a);\n  var g = Lc(t, l, c);\n  return l === \"center\" ? a === \"left\" ? p += c : a === \"right\" && (p -= c) : a === \"left\" ? p -= Math.max(h, u) + n : a === \"right\" && (p += Math.max(d, f) + n), {\n    x: U(p, 0, s.width - t.width),\n    y: U(g, 0, s.height - t.height)\n  };\n}\nfunction Re(i, t, e) {\n  var s = et(e.padding);\n  return t === \"center\" ? i.x + i.width / 2 : t === \"right\" ? i.x + i.width - s.right : i.x + s.left;\n}\nfunction sn(i) {\n  return rt([], ft(i));\n}\nfunction Ec(i, t, e) {\n  return Bt(i, {\n    tooltip: t,\n    tooltipItems: e,\n    type: \"tooltip\"\n  });\n}\nfunction nn(i, t) {\n  var e = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;\n  return e ? i.override(e) : i;\n}\nvar ro = {\n  beforeTitle: dt,\n  title: function title(i) {\n    if (i.length > 0) {\n      var t = i[0],\n        e = t.chart.data.labels,\n        s = e ? e.length : 0;\n      if (this && this.options && this.options.mode === \"dataset\") return t.dataset.label || \"\";\n      if (t.label) return t.label;\n      if (s > 0 && t.dataIndex < s) return e[t.dataIndex];\n    }\n    return \"\";\n  },\n  afterTitle: dt,\n  beforeBody: dt,\n  beforeLabel: dt,\n  label: function label(i) {\n    if (this && this.options && this.options.mode === \"dataset\") return i.label + \": \" + i.formattedValue || i.formattedValue;\n    var t = i.dataset.label || \"\";\n    t && (t += \": \");\n    var e = i.formattedValue;\n    return R(e) || (t += e), t;\n  },\n  labelColor: function labelColor(i) {\n    var e = i.chart.getDatasetMeta(i.datasetIndex).controller.getStyle(i.dataIndex);\n    return {\n      borderColor: e.borderColor,\n      backgroundColor: e.backgroundColor,\n      borderWidth: e.borderWidth,\n      borderDash: e.borderDash,\n      borderDashOffset: e.borderDashOffset,\n      borderRadius: 0\n    };\n  },\n  labelTextColor: function labelTextColor() {\n    return this.options.bodyColor;\n  },\n  labelPointStyle: function labelPointStyle(i) {\n    var e = i.chart.getDatasetMeta(i.datasetIndex).controller.getStyle(i.dataIndex);\n    return {\n      pointStyle: e.pointStyle,\n      rotation: e.rotation\n    };\n  },\n  afterLabel: dt,\n  afterBody: dt,\n  beforeFooter: dt,\n  footer: dt,\n  afterFooter: dt\n};\nfunction K(i, t, e, s) {\n  var n = i[t].call(e, s);\n  return _typeof(n) > \"u\" ? ro[t].call(e, s) : n;\n}\nvar Oi = /*#__PURE__*/function (_st8) {\n  function Oi(t) {\n    var _this28;\n    _classCallCheck(this, Oi);\n    _this28 = _callSuper(this, Oi), _this28.opacity = 0, _this28._active = [], _this28._eventPosition = void 0, _this28._size = void 0, _this28._cachedAnimations = void 0, _this28._tooltipItems = [], _this28.$animations = void 0, _this28.$context = void 0, _this28.chart = t.chart, _this28.options = t.options, _this28.dataPoints = void 0, _this28.title = void 0, _this28.beforeBody = void 0, _this28.body = void 0, _this28.afterBody = void 0, _this28.footer = void 0, _this28.xAlign = void 0, _this28.yAlign = void 0, _this28.x = void 0, _this28.y = void 0, _this28.height = void 0, _this28.width = void 0, _this28.caretX = void 0, _this28.caretY = void 0, _this28.labelColors = void 0, _this28.labelPointStyles = void 0, _this28.labelTextColors = void 0;\n    return _this28;\n  }\n  _inherits(Oi, _st8);\n  return _createClass(Oi, [{\n    key: \"initialize\",\n    value: function initialize(t) {\n      this.options = t, this._cachedAnimations = void 0, this.$context = void 0;\n    }\n  }, {\n    key: \"_resolveAnimations\",\n    value: function _resolveAnimations() {\n      var t = this._cachedAnimations;\n      if (t) return t;\n      var e = this.chart,\n        s = this.options.setContext(this.getContext()),\n        n = s.enabled && e.options.animation && s.animations,\n        o = new Nn(this.chart, n);\n      return n._cacheable && (this._cachedAnimations = Object.freeze(o)), o;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.$context || (this.$context = Ec(this.chart.getContext(), this, this._tooltipItems));\n    }\n  }, {\n    key: \"getTitle\",\n    value: function getTitle(t, e) {\n      var s = e.callbacks,\n        n = K(s, \"beforeTitle\", this, t),\n        o = K(s, \"title\", this, t),\n        r = K(s, \"afterTitle\", this, t);\n      var a = [];\n      return a = rt(a, ft(n)), a = rt(a, ft(o)), a = rt(a, ft(r)), a;\n    }\n  }, {\n    key: \"getBeforeBody\",\n    value: function getBeforeBody(t, e) {\n      return sn(K(e.callbacks, \"beforeBody\", this, t));\n    }\n  }, {\n    key: \"getBody\",\n    value: function getBody(t, e) {\n      var _this29 = this;\n      var s = e.callbacks,\n        n = [];\n      return L(t, function (o) {\n        var r = {\n            before: [],\n            lines: [],\n            after: []\n          },\n          a = nn(s, o);\n        rt(r.before, ft(K(a, \"beforeLabel\", _this29, o))), rt(r.lines, K(a, \"label\", _this29, o)), rt(r.after, ft(K(a, \"afterLabel\", _this29, o))), n.push(r);\n      }), n;\n    }\n  }, {\n    key: \"getAfterBody\",\n    value: function getAfterBody(t, e) {\n      return sn(K(e.callbacks, \"afterBody\", this, t));\n    }\n  }, {\n    key: \"getFooter\",\n    value: function getFooter(t, e) {\n      var s = e.callbacks,\n        n = K(s, \"beforeFooter\", this, t),\n        o = K(s, \"footer\", this, t),\n        r = K(s, \"afterFooter\", this, t);\n      var a = [];\n      return a = rt(a, ft(n)), a = rt(a, ft(o)), a = rt(a, ft(r)), a;\n    }\n  }, {\n    key: \"_createItems\",\n    value: function _createItems(t) {\n      var _this30 = this;\n      var e = this._active,\n        s = this.chart.data,\n        n = [],\n        o = [],\n        r = [];\n      var a = [],\n        l,\n        c;\n      for (l = 0, c = e.length; l < c; ++l) a.push(Cc(this.chart, e[l]));\n      return t.filter && (a = a.filter(function (h, d, u) {\n        return t.filter(h, d, u, s);\n      })), t.itemSort && (a = a.sort(function (h, d) {\n        return t.itemSort(h, d, s);\n      })), L(a, function (h) {\n        var d = nn(t.callbacks, h);\n        n.push(K(d, \"labelColor\", _this30, h)), o.push(K(d, \"labelPointStyle\", _this30, h)), r.push(K(d, \"labelTextColor\", _this30, h));\n      }), this.labelColors = n, this.labelPointStyles = o, this.labelTextColors = r, this.dataPoints = a, a;\n    }\n  }, {\n    key: \"update\",\n    value: function update(t, e) {\n      var s = this.options.setContext(this.getContext()),\n        n = this._active;\n      var o,\n        r = [];\n      if (!n.length) this.opacity !== 0 && (o = {\n        opacity: 0\n      });else {\n        var a = ae[s.position].call(this, n, this._eventPosition);\n        r = this._createItems(s), this.title = this.getTitle(r, s), this.beforeBody = this.getBeforeBody(r, s), this.body = this.getBody(r, s), this.afterBody = this.getAfterBody(r, s), this.footer = this.getFooter(r, s);\n        var l = this._size = Qs(this, s),\n          c = Object.assign({}, a, l),\n          h = tn(this.chart, s, c),\n          d = en(s, c, h, this.chart);\n        this.xAlign = h.xAlign, this.yAlign = h.yAlign, o = {\n          opacity: 1,\n          x: d.x,\n          y: d.y,\n          width: l.width,\n          height: l.height,\n          caretX: a.x,\n          caretY: a.y\n        };\n      }\n      this._tooltipItems = r, this.$context = void 0, o && this._resolveAnimations().update(this, o), t && s.external && s.external.call(this, {\n        chart: this.chart,\n        tooltip: this,\n        replay: e\n      });\n    }\n  }, {\n    key: \"drawCaret\",\n    value: function drawCaret(t, e, s, n) {\n      var o = this.getCaretPosition(t, s, n);\n      e.lineTo(o.x1, o.y1), e.lineTo(o.x2, o.y2), e.lineTo(o.x3, o.y3);\n    }\n  }, {\n    key: \"getCaretPosition\",\n    value: function getCaretPosition(t, e, s) {\n      var n = this.xAlign,\n        o = this.yAlign,\n        r = s.caretSize,\n        a = s.cornerRadius,\n        _Yt2 = Yt(a),\n        l = _Yt2.topLeft,\n        c = _Yt2.topRight,\n        h = _Yt2.bottomLeft,\n        d = _Yt2.bottomRight,\n        u = t.x,\n        f = t.y,\n        p = e.width,\n        g = e.height;\n      var m, b, _, v, y, x;\n      return o === \"center\" ? (y = f + g / 2, n === \"left\" ? (m = u, b = m - r, v = y + r, x = y - r) : (m = u + p, b = m + r, v = y - r, x = y + r), _ = m) : (n === \"left\" ? b = u + Math.max(l, h) + r : n === \"right\" ? b = u + p - Math.max(c, d) - r : b = this.caretX, o === \"top\" ? (v = f, y = v - r, m = b - r, _ = b + r) : (v = f + g, y = v + r, m = b + r, _ = b - r), x = v), {\n        x1: m,\n        x2: b,\n        x3: _,\n        y1: v,\n        y2: y,\n        y3: x\n      };\n    }\n  }, {\n    key: \"drawTitle\",\n    value: function drawTitle(t, e, s) {\n      var n = this.title,\n        o = n.length;\n      var r, a, l;\n      if (o) {\n        var c = Ut(s.rtl, this.x, this.width);\n        for (t.x = Re(this, s.titleAlign, s), e.textAlign = c.textAlign(s.titleAlign), e.textBaseline = \"middle\", r = X(s.titleFont), a = s.titleSpacing, e.fillStyle = s.titleColor, e.font = r.string, l = 0; l < o; ++l) e.fillText(n[l], c.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + a, l + 1 === o && (t.y += s.titleMarginBottom - a);\n      }\n    }\n  }, {\n    key: \"_drawColorBox\",\n    value: function _drawColorBox(t, e, s, n, o) {\n      var r = this.labelColors[s],\n        a = this.labelPointStyles[s],\n        l = o.boxHeight,\n        c = o.boxWidth,\n        h = X(o.bodyFont),\n        d = Re(this, \"left\", o),\n        u = n.x(d),\n        f = l < h.lineHeight ? (h.lineHeight - l) / 2 : 0,\n        p = e.y + f;\n      if (o.usePointStyle) {\n        var g = {\n            radius: Math.min(c, l) / 2,\n            pointStyle: a.pointStyle,\n            rotation: a.rotation,\n            borderWidth: 1\n          },\n          m = n.leftForLtr(u, c) + c / 2,\n          b = p + l / 2;\n        t.strokeStyle = o.multiKeyBackground, t.fillStyle = o.multiKeyBackground, Si(t, g, m, b), t.strokeStyle = r.borderColor, t.fillStyle = r.backgroundColor, Si(t, g, m, b);\n      } else {\n        t.lineWidth = T(r.borderWidth) ? Math.max.apply(Math, _toConsumableArray(Object.values(r.borderWidth))) : r.borderWidth || 1, t.strokeStyle = r.borderColor, t.setLineDash(r.borderDash || []), t.lineDashOffset = r.borderDashOffset || 0;\n        var _g2 = n.leftForLtr(u, c),\n          _m = n.leftForLtr(n.xPlus(u, 1), c - 2),\n          _b3 = Yt(r.borderRadius);\n        Object.values(_b3).some(function (_) {\n          return _ !== 0;\n        }) ? (t.beginPath(), t.fillStyle = o.multiKeyBackground, Ue(t, {\n          x: _g2,\n          y: p,\n          w: c,\n          h: l,\n          radius: _b3\n        }), t.fill(), t.stroke(), t.fillStyle = r.backgroundColor, t.beginPath(), Ue(t, {\n          x: _m,\n          y: p + 1,\n          w: c - 2,\n          h: l - 2,\n          radius: _b3\n        }), t.fill()) : (t.fillStyle = o.multiKeyBackground, t.fillRect(_g2, p, c, l), t.strokeRect(_g2, p, c, l), t.fillStyle = r.backgroundColor, t.fillRect(_m, p + 1, c - 2, l - 2));\n      }\n      t.fillStyle = this.labelTextColors[s];\n    }\n  }, {\n    key: \"drawBody\",\n    value: function drawBody(t, e, s) {\n      var n = this.body,\n        o = s.bodySpacing,\n        r = s.bodyAlign,\n        a = s.displayColors,\n        l = s.boxHeight,\n        c = s.boxWidth,\n        h = s.boxPadding,\n        d = X(s.bodyFont);\n      var u = d.lineHeight,\n        f = 0;\n      var p = Ut(s.rtl, this.x, this.width),\n        g = function g(k) {\n          e.fillText(k, p.x(t.x + f), t.y + u / 2), t.y += u + o;\n        },\n        m = p.textAlign(r);\n      var b, _, v, y, x, M, S;\n      for (e.textAlign = r, e.textBaseline = \"middle\", e.font = d.string, t.x = Re(this, m, s), e.fillStyle = s.bodyColor, L(this.beforeBody, g), f = a && m !== \"right\" ? r === \"center\" ? c / 2 + h : c + 2 + h : 0, y = 0, M = n.length; y < M; ++y) {\n        for (b = n[y], _ = this.labelTextColors[y], e.fillStyle = _, L(b.before, g), v = b.lines, a && v.length && (this._drawColorBox(e, t, y, p, s), u = Math.max(d.lineHeight, l)), x = 0, S = v.length; x < S; ++x) g(v[x]), u = d.lineHeight;\n        L(b.after, g);\n      }\n      f = 0, u = d.lineHeight, L(this.afterBody, g), t.y -= o;\n    }\n  }, {\n    key: \"drawFooter\",\n    value: function drawFooter(t, e, s) {\n      var n = this.footer,\n        o = n.length;\n      var r, a;\n      if (o) {\n        var l = Ut(s.rtl, this.x, this.width);\n        for (t.x = Re(this, s.footerAlign, s), t.y += s.footerMarginTop, e.textAlign = l.textAlign(s.footerAlign), e.textBaseline = \"middle\", r = X(s.footerFont), e.fillStyle = s.footerColor, e.font = r.string, a = 0; a < o; ++a) e.fillText(n[a], l.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + s.footerSpacing;\n      }\n    }\n  }, {\n    key: \"drawBackground\",\n    value: function drawBackground(t, e, s, n) {\n      var o = this.xAlign,\n        r = this.yAlign,\n        a = t.x,\n        l = t.y,\n        c = s.width,\n        h = s.height,\n        _Yt3 = Yt(n.cornerRadius),\n        d = _Yt3.topLeft,\n        u = _Yt3.topRight,\n        f = _Yt3.bottomLeft,\n        p = _Yt3.bottomRight;\n      e.fillStyle = n.backgroundColor, e.strokeStyle = n.borderColor, e.lineWidth = n.borderWidth, e.beginPath(), e.moveTo(a + d, l), r === \"top\" && this.drawCaret(t, e, s, n), e.lineTo(a + c - u, l), e.quadraticCurveTo(a + c, l, a + c, l + u), r === \"center\" && o === \"right\" && this.drawCaret(t, e, s, n), e.lineTo(a + c, l + h - p), e.quadraticCurveTo(a + c, l + h, a + c - p, l + h), r === \"bottom\" && this.drawCaret(t, e, s, n), e.lineTo(a + f, l + h), e.quadraticCurveTo(a, l + h, a, l + h - f), r === \"center\" && o === \"left\" && this.drawCaret(t, e, s, n), e.lineTo(a, l + d), e.quadraticCurveTo(a, l, a + d, l), e.closePath(), e.fill(), n.borderWidth > 0 && e.stroke();\n    }\n  }, {\n    key: \"_updateAnimationTarget\",\n    value: function _updateAnimationTarget(t) {\n      var e = this.chart,\n        s = this.$animations,\n        n = s && s.x,\n        o = s && s.y;\n      if (n || o) {\n        var r = ae[t.position].call(this, this._active, this._eventPosition);\n        if (!r) return;\n        var a = this._size = Qs(this, t),\n          l = Object.assign({}, r, this._size),\n          c = tn(e, t, l),\n          h = en(t, l, c, e);\n        (n._to !== h.x || o._to !== h.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = a.width, this.height = a.height, this.caretX = r.x, this.caretY = r.y, this._resolveAnimations().update(this, h));\n      }\n    }\n  }, {\n    key: \"_willRender\",\n    value: function _willRender() {\n      return !!this.opacity;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(t) {\n      var e = this.options.setContext(this.getContext());\n      var s = this.opacity;\n      if (!s) return;\n      this._updateAnimationTarget(e);\n      var n = {\n          width: this.width,\n          height: this.height\n        },\n        o = {\n          x: this.x,\n          y: this.y\n        };\n      s = Math.abs(s) < 1e-3 ? 0 : s;\n      var r = et(e.padding),\n        a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n      e.enabled && a && (t.save(), t.globalAlpha = s, this.drawBackground(o, t, n, e), Fn(t, e.textDirection), o.y += r.top, this.drawTitle(o, t, e), this.drawBody(o, t, e), this.drawFooter(o, t, e), In(t, e.textDirection), t.restore());\n    }\n  }, {\n    key: \"getActiveElements\",\n    value: function getActiveElements() {\n      return this._active || [];\n    }\n  }, {\n    key: \"setActiveElements\",\n    value: function setActiveElements(t, e) {\n      var _this31 = this;\n      var s = this._active,\n        n = t.map(function (_ref10) {\n          var a = _ref10.datasetIndex,\n            l = _ref10.index;\n          var c = _this31.chart.getDatasetMeta(a);\n          if (!c) throw new Error(\"Cannot find a dataset at index \" + a);\n          return {\n            datasetIndex: a,\n            element: c.data[l],\n            index: l\n          };\n        }),\n        o = !je(s, n),\n        r = this._positionChanged(n, e);\n      (o || r) && (this._active = n, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0));\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(t, e) {\n      var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;\n      if (e && this._ignoreReplayEvents) return !1;\n      this._ignoreReplayEvents = !1;\n      var n = this.options,\n        o = this._active || [],\n        r = this._getActiveElements(t, o, e, s),\n        a = this._positionChanged(r, t),\n        l = e || !je(r, o) || a;\n      return l && (this._active = r, (n.enabled || n.external) && (this._eventPosition = {\n        x: t.x,\n        y: t.y\n      }, this.update(!0, e))), l;\n    }\n  }, {\n    key: \"_getActiveElements\",\n    value: function _getActiveElements(t, e, s, n) {\n      var _this32 = this;\n      var o = this.options;\n      if (t.type === \"mouseout\") return [];\n      if (!n) return e.filter(function (a) {\n        return _this32.chart.data.datasets[a.datasetIndex] && _this32.chart.getDatasetMeta(a.datasetIndex).controller.getParsed(a.index) !== void 0;\n      });\n      var r = this.chart.getElementsAtEventForMode(t, o.mode, o, s);\n      return o.reverse && r.reverse(), r;\n    }\n  }, {\n    key: \"_positionChanged\",\n    value: function _positionChanged(t, e) {\n      var s = this.caretX,\n        n = this.caretY,\n        o = this.options,\n        r = ae[o.position].call(this, t, e);\n      return r !== !1 && (s !== r.x || n !== r.y);\n    }\n  }]);\n}(st);\nw(Oi, \"positioners\", ae);\nvar Fc = {\n  id: \"tooltip\",\n  _element: Oi,\n  positioners: ae,\n  afterInit: function afterInit(i, t, e) {\n    e && (i.tooltip = new Oi({\n      chart: i,\n      options: e\n    }));\n  },\n  beforeUpdate: function beforeUpdate(i, t, e) {\n    i.tooltip && i.tooltip.initialize(e);\n  },\n  reset: function reset(i, t, e) {\n    i.tooltip && i.tooltip.initialize(e);\n  },\n  afterDraw: function afterDraw(i) {\n    var t = i.tooltip;\n    if (t && t._willRender()) {\n      var e = {\n        tooltip: t\n      };\n      if (i.notifyPlugins(\"beforeTooltipDraw\", _objectSpread(_objectSpread({}, e), {}, {\n        cancelable: !0\n      })) === !1) return;\n      t.draw(i.ctx), i.notifyPlugins(\"afterTooltipDraw\", e);\n    }\n  },\n  afterEvent: function afterEvent(i, t) {\n    if (i.tooltip) {\n      var e = t.replay;\n      i.tooltip.handleEvent(t.event, e, t.inChartArea) && (t.changed = !0);\n    }\n  },\n  defaults: {\n    enabled: !0,\n    external: null,\n    position: \"average\",\n    backgroundColor: \"rgba(0,0,0,0.8)\",\n    titleColor: \"#fff\",\n    titleFont: {\n      weight: \"bold\"\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: \"left\",\n    bodyColor: \"#fff\",\n    bodySpacing: 2,\n    bodyFont: {},\n    bodyAlign: \"left\",\n    footerColor: \"#fff\",\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: \"bold\"\n    },\n    footerAlign: \"left\",\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: function boxHeight(i, t) {\n      return t.bodyFont.size;\n    },\n    boxWidth: function boxWidth(i, t) {\n      return t.bodyFont.size;\n    },\n    multiKeyBackground: \"#fff\",\n    displayColors: !0,\n    boxPadding: 0,\n    borderColor: \"rgba(0,0,0,0)\",\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: \"easeOutQuart\"\n    },\n    animations: {\n      numbers: {\n        type: \"number\",\n        properties: [\"x\", \"y\", \"width\", \"height\", \"caretX\", \"caretY\"]\n      },\n      opacity: {\n        easing: \"linear\",\n        duration: 200\n      }\n    },\n    callbacks: ro\n  },\n  defaultRoutes: {\n    bodyFont: \"font\",\n    footerFont: \"font\",\n    titleFont: \"font\"\n  },\n  descriptors: {\n    _scriptable: function _scriptable(i) {\n      return i !== \"filter\" && i !== \"itemSort\" && i !== \"external\";\n    },\n    _indexable: !1,\n    callbacks: {\n      _scriptable: !1,\n      _indexable: !1\n    },\n    animation: {\n      _fallback: !1\n    },\n    animations: {\n      _fallback: \"animation\"\n    }\n  },\n  additionalOptionScopes: [\"interaction\"]\n};\nvar Ic = function Ic(i, t, e, s) {\n  return typeof t == \"string\" ? (e = i.push(t) - 1, s.unshift({\n    index: e,\n    label: t\n  })) : isNaN(t) && (e = null), e;\n};\nfunction zc(i, t, e, s) {\n  var n = i.indexOf(t);\n  if (n === -1) return Ic(i, t, e, s);\n  var o = i.lastIndexOf(t);\n  return n !== o ? e : n;\n}\nvar Bc = function Bc(i, t) {\n  return i === null ? null : U(Math.round(i), 0, t);\n};\nfunction on(i) {\n  var t = this.getLabels();\n  return i >= 0 && i < t.length ? t[i] : i;\n}\nvar Ti = /*#__PURE__*/function (_Gt) {\n  function Ti(t) {\n    var _this33;\n    _classCallCheck(this, Ti);\n    _this33 = _callSuper(this, Ti, [t]), _this33._startValue = void 0, _this33._valueRange = 0, _this33._addedLabels = [];\n    return _this33;\n  }\n  _inherits(Ti, _Gt);\n  return _createClass(Ti, [{\n    key: \"init\",\n    value: function init(t) {\n      var e = this._addedLabels;\n      if (e.length) {\n        var s = this.getLabels();\n        var _iterator36 = _createForOfIteratorHelper(e),\n          _step36;\n        try {\n          for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n            var _step36$value = _step36.value,\n              n = _step36$value.index,\n              o = _step36$value.label;\n            s[n] === o && s.splice(n, 1);\n          }\n        } catch (err) {\n          _iterator36.e(err);\n        } finally {\n          _iterator36.f();\n        }\n        this._addedLabels = [];\n      }\n      _superPropGet(Ti, \"init\", this, 3)([t]);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(t, e) {\n      if (R(t)) return null;\n      var s = this.getLabels();\n      return e = isFinite(e) && s[e] === t ? e : zc(s, t, D(e, t), this._addedLabels), Bc(e, s.length - 1);\n    }\n  }, {\n    key: \"determineDataLimits\",\n    value: function determineDataLimits() {\n      var _this$getUserBounds2 = this.getUserBounds(),\n        t = _this$getUserBounds2.minDefined,\n        e = _this$getUserBounds2.maxDefined;\n      var _this$getMinMax = this.getMinMax(!0),\n        s = _this$getMinMax.min,\n        n = _this$getMinMax.max;\n      this.options.bounds === \"ticks\" && (t || (s = 0), e || (n = this.getLabels().length - 1)), this.min = s, this.max = n;\n    }\n  }, {\n    key: \"buildTicks\",\n    value: function buildTicks() {\n      var t = this.min,\n        e = this.max,\n        s = this.options.offset,\n        n = [];\n      var o = this.getLabels();\n      o = t === 0 && e === o.length - 1 ? o : o.slice(t, e + 1), this._valueRange = Math.max(o.length - (s ? 0 : 1), 1), this._startValue = this.min - (s ? 0.5 : 0);\n      for (var r = t; r <= e; r++) n.push({\n        value: r\n      });\n      return n;\n    }\n  }, {\n    key: \"getLabelForValue\",\n    value: function getLabelForValue(t) {\n      return on.call(this, t);\n    }\n  }, {\n    key: \"configure\",\n    value: function configure() {\n      _superPropGet(Ti, \"configure\", this, 3)([]), this.isHorizontal() || (this._reversePixels = !this._reversePixels);\n    }\n  }, {\n    key: \"getPixelForValue\",\n    value: function getPixelForValue(t) {\n      return typeof t != \"number\" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n    }\n  }, {\n    key: \"getPixelForTick\",\n    value: function getPixelForTick(t) {\n      var e = this.ticks;\n      return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n    }\n  }, {\n    key: \"getValueForPixel\",\n    value: function getValueForPixel(t) {\n      return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);\n    }\n  }, {\n    key: \"getBasePixel\",\n    value: function getBasePixel() {\n      return this.bottom;\n    }\n  }]);\n}(Gt);\nw(Ti, \"id\", \"category\"), w(Ti, \"defaults\", {\n  ticks: {\n    callback: on\n  }\n});\nfunction Hc(i, t) {\n  var e = [],\n    n = i.bounds,\n    o = i.step,\n    r = i.min,\n    a = i.max,\n    l = i.precision,\n    c = i.count,\n    h = i.maxTicks,\n    d = i.maxDigits,\n    u = i.includeBounds,\n    f = o || 1,\n    p = h - 1,\n    g = t.min,\n    m = t.max,\n    b = !R(r),\n    _ = !R(a),\n    v = !R(c),\n    y = (m - g) / (d + 1);\n  var x = es((m - g) / p / f) * f,\n    M,\n    S,\n    k,\n    P;\n  if (x < 1e-14 && !b && !_) return [{\n    value: g\n  }, {\n    value: m\n  }];\n  P = Math.ceil(m / x) - Math.floor(g / x), P > p && (x = es(P * x / p / f) * f), R(l) || (M = Math.pow(10, l), x = Math.ceil(x * M) / M), n === \"ticks\" ? (S = Math.floor(g / x) * x, k = Math.ceil(m / x) * x) : (S = g, k = m), b && _ && o && $o((a - r) / o, x / 1e3) ? (P = Math.round(Math.min((a - r) / x, h)), x = (a - r) / P, S = r, k = a) : v ? (S = b ? r : S, k = _ ? a : k, P = c - 1, x = (k - S) / P) : (P = (k - S) / x, ce(P, Math.round(P), x / 1e3) ? P = Math.round(P) : P = Math.ceil(P));\n  var C = Math.max(is(x), is(S));\n  M = Math.pow(10, R(l) ? C : l), S = Math.round(S * M) / M, k = Math.round(k * M) / M;\n  var O = 0;\n  for (b && (u && S !== r ? (e.push({\n    value: r\n  }), S < r && O++, ce(Math.round((S + O * x) * M) / M, r, rn(r, y, i)) && O++) : S < r && O++); O < P; ++O) {\n    var A = Math.round((S + O * x) * M) / M;\n    if (_ && A > a) break;\n    e.push({\n      value: A\n    });\n  }\n  return _ && u && k !== a ? e.length && ce(e[e.length - 1].value, a, rn(a, y, i)) ? e[e.length - 1].value = a : e.push({\n    value: a\n  }) : (!_ || k === a) && e.push({\n    value: k\n  }), e;\n}\nfunction rn(i, t, _ref11) {\n  var e = _ref11.horizontal,\n    s = _ref11.minRotation;\n  var n = bt(s),\n    o = (e ? Math.sin(n) : Math.cos(n)) || 1e-3,\n    r = 0.75 * t * (\"\" + i).length;\n  return Math.min(t / o, r);\n}\nvar Wc = /*#__PURE__*/function (_Gt2) {\n  function Wc(t) {\n    var _this34;\n    _classCallCheck(this, Wc);\n    _this34 = _callSuper(this, Wc, [t]), _this34.start = void 0, _this34.end = void 0, _this34._startValue = void 0, _this34._endValue = void 0, _this34._valueRange = 0;\n    return _this34;\n  }\n  _inherits(Wc, _Gt2);\n  return _createClass(Wc, [{\n    key: \"parse\",\n    value: function parse(t, e) {\n      return R(t) || (typeof t == \"number\" || t instanceof Number) && !isFinite(+t) ? null : +t;\n    }\n  }, {\n    key: \"handleTickRangeOptions\",\n    value: function handleTickRangeOptions() {\n      var t = this.options.beginAtZero,\n        _this$getUserBounds3 = this.getUserBounds(),\n        e = _this$getUserBounds3.minDefined,\n        s = _this$getUserBounds3.maxDefined;\n      var n = this.min,\n        o = this.max;\n      var r = function r(l) {\n          return n = e ? n : l;\n        },\n        a = function a(l) {\n          return o = s ? o : l;\n        };\n      if (t) {\n        var l = lt(n),\n          c = lt(o);\n        l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && r(0);\n      }\n      if (n === o) {\n        var _l5 = o === 0 ? 1 : Math.abs(o * 0.05);\n        a(o + _l5), t || r(n - _l5);\n      }\n      this.min = n, this.max = o;\n    }\n  }, {\n    key: \"getTickLimit\",\n    value: function getTickLimit() {\n      var t = this.options.ticks;\n      var e = t.maxTicksLimit,\n        s = t.stepSize,\n        n;\n      return s ? (n = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, n > 1e3 && (console.warn(\"scales.\".concat(this.id, \".ticks.stepSize: \").concat(s, \" would result generating up to \").concat(n, \" ticks. Limiting to 1000.\")), n = 1e3)) : (n = this.computeTickLimit(), e = e || 11), e && (n = Math.min(e, n)), n;\n    }\n  }, {\n    key: \"computeTickLimit\",\n    value: function computeTickLimit() {\n      return Number.POSITIVE_INFINITY;\n    }\n  }, {\n    key: \"buildTicks\",\n    value: function buildTicks() {\n      var t = this.options,\n        e = t.ticks;\n      var s = this.getTickLimit();\n      s = Math.max(2, s);\n      var n = {\n          maxTicks: s,\n          bounds: t.bounds,\n          min: t.min,\n          max: t.max,\n          precision: e.precision,\n          step: e.stepSize,\n          count: e.count,\n          maxDigits: this._maxDigits(),\n          horizontal: this.isHorizontal(),\n          minRotation: e.minRotation || 0,\n          includeBounds: e.includeBounds !== !1\n        },\n        o = this._range || this,\n        r = Hc(n, o);\n      return t.bounds === \"ticks\" && Yo(r, this, \"value\"), t.reverse ? (r.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), r;\n    }\n  }, {\n    key: \"configure\",\n    value: function configure() {\n      var t = this.ticks;\n      var e = this.min,\n        s = this.max;\n      if (_superPropGet(Wc, \"configure\", this, 3)([]), this.options.offset && t.length) {\n        var n = (s - e) / Math.max(t.length - 1, 1) / 2;\n        e -= n, s += n;\n      }\n      this._startValue = e, this._endValue = s, this._valueRange = s - e;\n    }\n  }, {\n    key: \"getLabelForValue\",\n    value: function getLabelForValue(t) {\n      return Hi(t, this.chart.options.locale, this.options.ticks.format);\n    }\n  }]);\n}(Gt);\nvar Ai = /*#__PURE__*/function (_Wc) {\n  function Ai() {\n    _classCallCheck(this, Ai);\n    return _callSuper(this, Ai, arguments);\n  }\n  _inherits(Ai, _Wc);\n  return _createClass(Ai, [{\n    key: \"determineDataLimits\",\n    value: function determineDataLimits() {\n      var _this$getMinMax2 = this.getMinMax(!0),\n        t = _this$getMinMax2.min,\n        e = _this$getMinMax2.max;\n      this.min = q(t) ? t : 0, this.max = q(e) ? e : 1, this.handleTickRangeOptions();\n    }\n  }, {\n    key: \"computeTickLimit\",\n    value: function computeTickLimit() {\n      var t = this.isHorizontal(),\n        e = t ? this.width : this.height,\n        s = bt(this.options.ticks.minRotation),\n        n = (t ? Math.sin(s) : Math.cos(s)) || 1e-3,\n        o = this._resolveTickFontOptions(0);\n      return Math.ceil(e / Math.min(40, o.lineHeight / n));\n    }\n  }, {\n    key: \"getPixelForValue\",\n    value: function getPixelForValue(t) {\n      return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n    }\n  }, {\n    key: \"getValueForPixel\",\n    value: function getValueForPixel(t) {\n      return this._startValue + this.getDecimalForPixel(t) * this._valueRange;\n    }\n  }]);\n}(Wc);\nw(Ai, \"id\", \"linear\"), w(Ai, \"defaults\", {\n  ticks: {\n    callback: Dn.formatters.numeric\n  }\n});\nvar ii = {\n    millisecond: {\n      common: !0,\n      size: 1,\n      steps: 1e3\n    },\n    second: {\n      common: !0,\n      size: 1e3,\n      steps: 60\n    },\n    minute: {\n      common: !0,\n      size: 6e4,\n      steps: 60\n    },\n    hour: {\n      common: !0,\n      size: 36e5,\n      steps: 24\n    },\n    day: {\n      common: !0,\n      size: 864e5,\n      steps: 30\n    },\n    week: {\n      common: !1,\n      size: 6048e5,\n      steps: 4\n    },\n    month: {\n      common: !0,\n      size: 2628e6,\n      steps: 12\n    },\n    quarter: {\n      common: !1,\n      size: 7884e6,\n      steps: 4\n    },\n    year: {\n      common: !0,\n      size: 3154e7\n    }\n  },\n  G = /* @__PURE__ */Object.keys(ii);\nfunction an(i, t) {\n  return i - t;\n}\nfunction ln(i, t) {\n  if (R(t)) return null;\n  var e = i._adapter,\n    _i$_parseOpts = i._parseOpts,\n    s = _i$_parseOpts.parser,\n    n = _i$_parseOpts.round,\n    o = _i$_parseOpts.isoWeekday;\n  var r = t;\n  return typeof s == \"function\" && (r = s(r)), q(r) || (r = typeof s == \"string\" ? e.parse(r, s) : e.parse(r)), r === null ? null : (n && (r = n === \"week\" && (Xt(o) || o === !0) ? e.startOf(r, \"isoWeek\", o) : e.startOf(r, n)), +r);\n}\nfunction cn(i, t, e, s) {\n  var n = G.length;\n  for (var o = G.indexOf(i); o < n - 1; ++o) {\n    var r = ii[G[o]],\n      a = r.steps ? r.steps : Number.MAX_SAFE_INTEGER;\n    if (r.common && Math.ceil((e - t) / (a * r.size)) <= s) return G[o];\n  }\n  return G[n - 1];\n}\nfunction Nc(i, t, e, s, n) {\n  for (var o = G.length - 1; o >= G.indexOf(e); o--) {\n    var r = G[o];\n    if (ii[r].common && i._adapter.diff(n, s, r) >= t - 1) return r;\n  }\n  return G[e ? G.indexOf(e) : 0];\n}\nfunction Vc(i) {\n  for (var t = G.indexOf(i) + 1, e = G.length; t < e; ++t) if (ii[G[t]].common) return G[t];\n}\nfunction hn(i, t, e) {\n  if (!e) i[t] = !0;else if (e.length) {\n    var _Ii = Ii(e, t),\n      s = _Ii.lo,\n      n = _Ii.hi,\n      o = e[s] >= t ? e[s] : e[n];\n    i[o] = !0;\n  }\n}\nfunction jc(i, t, e, s) {\n  var n = i._adapter,\n    o = +n.startOf(t[0].value, s),\n    r = t[t.length - 1].value;\n  var a, l;\n  for (a = o; a <= r; a = +n.add(a, 1, s)) l = e[a], l >= 0 && (t[l].major = !0);\n  return t;\n}\nfunction dn(i, t, e) {\n  var s = [],\n    n = {},\n    o = t.length;\n  var r, a;\n  for (r = 0; r < o; ++r) a = t[r], n[a] = r, s.push({\n    value: a,\n    major: !1\n  });\n  return o === 0 || !e ? s : jc(i, s, n, e);\n}\nvar Ge = /*#__PURE__*/function (_Gt3) {\n  function Ge(t) {\n    var _this35;\n    _classCallCheck(this, Ge);\n    _this35 = _callSuper(this, Ge, [t]), _this35._cache = {\n      data: [],\n      labels: [],\n      all: []\n    }, _this35._unit = \"day\", _this35._majorUnit = void 0, _this35._offsets = {}, _this35._normalized = !1, _this35._parseOpts = void 0;\n    return _this35;\n  }\n  _inherits(Ge, _Gt3);\n  return _createClass(Ge, [{\n    key: \"init\",\n    value: function init(t) {\n      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var s = t.time || (t.time = {}),\n        n = this._adapter = new wa._date(t.adapters.date);\n      n.init(e), le(s.displayFormats, n.formats()), this._parseOpts = {\n        parser: s.parser,\n        round: s.round,\n        isoWeekday: s.isoWeekday\n      }, _superPropGet(Ge, \"init\", this, 3)([t]), this._normalized = e.normalized;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(t, e) {\n      return t === void 0 ? null : ln(this, t);\n    }\n  }, {\n    key: \"beforeLayout\",\n    value: function beforeLayout() {\n      _superPropGet(Ge, \"beforeLayout\", this, 3)([]), this._cache = {\n        data: [],\n        labels: [],\n        all: []\n      };\n    }\n  }, {\n    key: \"determineDataLimits\",\n    value: function determineDataLimits() {\n      var t = this.options,\n        e = this._adapter,\n        s = t.time.unit || \"day\";\n      var _this$getUserBounds4 = this.getUserBounds(),\n        n = _this$getUserBounds4.min,\n        o = _this$getUserBounds4.max,\n        r = _this$getUserBounds4.minDefined,\n        a = _this$getUserBounds4.maxDefined;\n      function l(c) {\n        !r && !isNaN(c.min) && (n = Math.min(n, c.min)), !a && !isNaN(c.max) && (o = Math.max(o, c.max));\n      }\n      (!r || !a) && (l(this._getLabelBounds()), (t.bounds !== \"ticks\" || t.ticks.source !== \"labels\") && l(this.getMinMax(!1))), n = q(n) && !isNaN(n) ? n : +e.startOf(Date.now(), s), o = q(o) && !isNaN(o) ? o : +e.endOf(Date.now(), s) + 1, this.min = Math.min(n, o - 1), this.max = Math.max(n + 1, o);\n    }\n  }, {\n    key: \"_getLabelBounds\",\n    value: function _getLabelBounds() {\n      var t = this.getLabelTimestamps();\n      var e = Number.POSITIVE_INFINITY,\n        s = Number.NEGATIVE_INFINITY;\n      return t.length && (e = t[0], s = t[t.length - 1]), {\n        min: e,\n        max: s\n      };\n    }\n  }, {\n    key: \"buildTicks\",\n    value: function buildTicks() {\n      var t = this.options,\n        e = t.time,\n        s = t.ticks,\n        n = s.source === \"labels\" ? this.getLabelTimestamps() : this._generate();\n      t.bounds === \"ticks\" && n.length && (this.min = this._userMin || n[0], this.max = this._userMax || n[n.length - 1]);\n      var o = this.min,\n        r = this.max,\n        a = Go(n, o, r);\n      return this._unit = e.unit || (s.autoSkip ? cn(e.minUnit, this.min, this.max, this._getLabelCapacity(o)) : Nc(this, a.length, e.minUnit, this.min, this.max)), this._majorUnit = !s.major.enabled || this._unit === \"year\" ? void 0 : Vc(this._unit), this.initOffsets(n), t.reverse && a.reverse(), dn(this, a, this._majorUnit);\n    }\n  }, {\n    key: \"afterAutoSkip\",\n    value: function afterAutoSkip() {\n      this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(function (t) {\n        return +t.value;\n      }));\n    }\n  }, {\n    key: \"initOffsets\",\n    value: function initOffsets() {\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var e = 0,\n        s = 0,\n        n,\n        o;\n      this.options.offset && t.length && (n = this.getDecimalForValue(t[0]), t.length === 1 ? e = 1 - n : e = (this.getDecimalForValue(t[1]) - n) / 2, o = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? s = o : s = (o - this.getDecimalForValue(t[t.length - 2])) / 2);\n      var r = t.length < 3 ? 0.5 : 0.25;\n      e = U(e, 0, r), s = U(s, 0, r), this._offsets = {\n        start: e,\n        end: s,\n        factor: 1 / (e + 1 + s)\n      };\n    }\n  }, {\n    key: \"_generate\",\n    value: function _generate() {\n      var t = this._adapter,\n        e = this.min,\n        s = this.max,\n        n = this.options,\n        o = n.time,\n        r = o.unit || cn(o.minUnit, e, s, this._getLabelCapacity(e)),\n        a = D(n.ticks.stepSize, 1),\n        l = r === \"week\" ? o.isoWeekday : !1,\n        c = Xt(l) || l === !0,\n        h = {};\n      var d = e,\n        u,\n        f;\n      if (c && (d = +t.startOf(d, \"isoWeek\", l)), d = +t.startOf(d, c ? \"day\" : r), t.diff(s, e, r) > 1e5 * a) throw new Error(e + \" and \" + s + \" are too far apart with stepSize of \" + a + \" \" + r);\n      var p = n.ticks.source === \"data\" && this.getDataTimestamps();\n      for (u = d, f = 0; u < s; u = +t.add(u, a, r), f++) hn(h, u, p);\n      return (u === s || n.bounds === \"ticks\" || f === 1) && hn(h, u, p), Object.keys(h).sort(an).map(function (g) {\n        return +g;\n      });\n    }\n  }, {\n    key: \"getLabelForValue\",\n    value: function getLabelForValue(t) {\n      var e = this._adapter,\n        s = this.options.time;\n      return s.tooltipFormat ? e.format(t, s.tooltipFormat) : e.format(t, s.displayFormats.datetime);\n    }\n  }, {\n    key: \"format\",\n    value: function format(t, e) {\n      var n = this.options.time.displayFormats,\n        o = this._unit,\n        r = e || n[o];\n      return this._adapter.format(t, r);\n    }\n  }, {\n    key: \"_tickFormatFunction\",\n    value: function _tickFormatFunction(t, e, s, n) {\n      var o = this.options,\n        r = o.ticks.callback;\n      if (r) return I(r, [t, e, s], this);\n      var a = o.time.displayFormats,\n        l = this._unit,\n        c = this._majorUnit,\n        h = l && a[l],\n        d = c && a[c],\n        u = s[e],\n        f = c && d && u && u.major;\n      return this._adapter.format(t, n || (f ? d : h));\n    }\n  }, {\n    key: \"generateTickLabels\",\n    value: function generateTickLabels(t) {\n      var e, s, n;\n      for (e = 0, s = t.length; e < s; ++e) n = t[e], n.label = this._tickFormatFunction(n.value, e, t);\n    }\n  }, {\n    key: \"getDecimalForValue\",\n    value: function getDecimalForValue(t) {\n      return t === null ? NaN : (t - this.min) / (this.max - this.min);\n    }\n  }, {\n    key: \"getPixelForValue\",\n    value: function getPixelForValue(t) {\n      var e = this._offsets,\n        s = this.getDecimalForValue(t);\n      return this.getPixelForDecimal((e.start + s) * e.factor);\n    }\n  }, {\n    key: \"getValueForPixel\",\n    value: function getValueForPixel(t) {\n      var e = this._offsets,\n        s = this.getDecimalForPixel(t) / e.factor - e.end;\n      return this.min + s * (this.max - this.min);\n    }\n  }, {\n    key: \"_getLabelSize\",\n    value: function _getLabelSize(t) {\n      var e = this.options.ticks,\n        s = this.ctx.measureText(t).width,\n        n = bt(this.isHorizontal() ? e.maxRotation : e.minRotation),\n        o = Math.cos(n),\n        r = Math.sin(n),\n        a = this._resolveTickFontOptions(0).size;\n      return {\n        w: s * o + a * r,\n        h: s * r + a * o\n      };\n    }\n  }, {\n    key: \"_getLabelCapacity\",\n    value: function _getLabelCapacity(t) {\n      var e = this.options.time,\n        s = e.displayFormats,\n        n = s[e.unit] || s.millisecond,\n        o = this._tickFormatFunction(t, 0, dn(this, [t], this._majorUnit), n),\n        r = this._getLabelSize(o),\n        a = Math.floor(this.isHorizontal() ? this.width / r.w : this.height / r.h) - 1;\n      return a > 0 ? a : 1;\n    }\n  }, {\n    key: \"getDataTimestamps\",\n    value: function getDataTimestamps() {\n      var t = this._cache.data || [],\n        e,\n        s;\n      if (t.length) return t;\n      var n = this.getMatchingVisibleMetas();\n      if (this._normalized && n.length) return this._cache.data = n[0].controller.getAllParsedValues(this);\n      for (e = 0, s = n.length; e < s; ++e) t = t.concat(n[e].controller.getAllParsedValues(this));\n      return this._cache.data = this.normalize(t);\n    }\n  }, {\n    key: \"getLabelTimestamps\",\n    value: function getLabelTimestamps() {\n      var t = this._cache.labels || [];\n      var e, s;\n      if (t.length) return t;\n      var n = this.getLabels();\n      for (e = 0, s = n.length; e < s; ++e) t.push(ln(this, n[e]));\n      return this._cache.labels = this._normalized ? t : this.normalize(t);\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize(t) {\n      return Mn(t.sort(an));\n    }\n  }]);\n}(Gt);\nw(Ge, \"id\", \"time\"), w(Ge, \"defaults\", {\n  bounds: \"data\",\n  adapters: {},\n  time: {\n    parser: !1,\n    unit: !1,\n    round: !1,\n    isoWeekday: !1,\n    minUnit: \"millisecond\",\n    displayFormats: {}\n  },\n  ticks: {\n    source: \"auto\",\n    callback: !1,\n    major: {\n      enabled: !1\n    }\n  }\n});\nfunction Le(i, t, e) {\n  var _Et, _i$s, _i$n, _Et2, _i$s2, _i$n2;\n  var s = 0,\n    n = i.length - 1,\n    o,\n    r,\n    a,\n    l;\n  e ? (t >= i[s].pos && t <= i[n].pos && (_Et = Et(i, \"pos\", t), s = _Et.lo, n = _Et.hi, _Et), _i$s = i[s], o = _i$s.pos, a = _i$s.time, _i$n = i[n], r = _i$n.pos, l = _i$n.time) : (t >= i[s].time && t <= i[n].time && (_Et2 = Et(i, \"time\", t), s = _Et2.lo, n = _Et2.hi, _Et2), _i$s2 = i[s], o = _i$s2.time, a = _i$s2.pos, _i$n2 = i[n], r = _i$n2.time, l = _i$n2.pos);\n  var c = r - o;\n  return c ? a + (l - a) * (t - o) / c : a;\n}\nvar un = /*#__PURE__*/function (_Ge) {\n  function un(t) {\n    var _this36;\n    _classCallCheck(this, un);\n    _this36 = _callSuper(this, un, [t]), _this36._table = [], _this36._minPos = void 0, _this36._tableRange = void 0;\n    return _this36;\n  }\n  _inherits(un, _Ge);\n  return _createClass(un, [{\n    key: \"initOffsets\",\n    value: function initOffsets() {\n      var t = this._getTimestampsForTable(),\n        e = this._table = this.buildLookupTable(t);\n      this._minPos = Le(e, this.min), this._tableRange = Le(e, this.max) - this._minPos, _superPropGet(un, \"initOffsets\", this, 3)([t]);\n    }\n  }, {\n    key: \"buildLookupTable\",\n    value: function buildLookupTable(t) {\n      var e = this.min,\n        s = this.max,\n        n = [],\n        o = [];\n      var r, a, l, c, h;\n      for (r = 0, a = t.length; r < a; ++r) c = t[r], c >= e && c <= s && n.push(c);\n      if (n.length < 2) return [{\n        time: e,\n        pos: 0\n      }, {\n        time: s,\n        pos: 1\n      }];\n      for (r = 0, a = n.length; r < a; ++r) h = n[r + 1], l = n[r - 1], c = n[r], Math.round((h + l) / 2) !== c && o.push({\n        time: c,\n        pos: r / (a - 1)\n      });\n      return o;\n    }\n  }, {\n    key: \"_generate\",\n    value: function _generate() {\n      var t = this.min,\n        e = this.max;\n      var s = _superPropGet(un, \"getDataTimestamps\", this, 3)([]);\n      return (!s.includes(t) || !s.length) && s.splice(0, 0, t), (!s.includes(e) || s.length === 1) && s.push(e), s.sort(function (n, o) {\n        return n - o;\n      });\n    }\n  }, {\n    key: \"_getTimestampsForTable\",\n    value: function _getTimestampsForTable() {\n      var t = this._cache.all || [];\n      if (t.length) return t;\n      var e = this.getDataTimestamps(),\n        s = this.getLabelTimestamps();\n      return e.length && s.length ? t = this.normalize(e.concat(s)) : t = e.length ? e : s, t = this._cache.all = t, t;\n    }\n  }, {\n    key: \"getDecimalForValue\",\n    value: function getDecimalForValue(t) {\n      return (Le(this._table, t) - this._minPos) / this._tableRange;\n    }\n  }, {\n    key: \"getValueForPixel\",\n    value: function getValueForPixel(t) {\n      var e = this._offsets,\n        s = this.getDecimalForPixel(t) / e.factor - e.end;\n      return Le(this._table, s * this._tableRange + this._minPos, !0);\n    }\n  }]);\n}(Ge);\nw(un, \"id\", \"timeseries\"), w(un, \"defaults\", Ge.defaults);\nmt.register(Ti, Ai, Ee, We, Fe, vt, He, ki, jt, re, Ie, xc, wc, Dc, Fc);\nvar fn = /*#__PURE__*/function () {\n  function fn(t) {\n    _classCallCheck(this, fn);\n    this.chart = null, this.canvas = t;\n  }\n  return _createClass(fn, [{\n    key: \"render\",\n    value: function render(t) {\n      var _ref12, _ref13;\n      var r, a;\n      this.chart && (this.chart.destroy(), this.chart = null);\n      var e = t.chartSpec,\n        s = t.data,\n        n = this.mapChartType(e.type),\n        o = {\n          type: n,\n          data: {\n            labels: s.labels,\n            datasets: s.datasets.map(function (l) {\n              return _objectSpread(_objectSpread({}, l), {}, {\n                fill: e.type === \"area\",\n                tension: e.type === \"line\" || e.type === \"area\" ? 0.3 : 0\n              });\n            })\n          },\n          options: {\n            responsive: !0,\n            maintainAspectRatio: !1,\n            plugins: {\n              title: {\n                display: !!e.title,\n                text: e.title,\n                font: {\n                  size: 16,\n                  weight: \"bold\"\n                }\n              },\n              legend: {\n                display: (_ref12 = (r = e.legend) == null ? void 0 : r.display) !== null && _ref12 !== void 0 ? _ref12 : !0,\n                position: (_ref13 = (a = e.legend) == null ? void 0 : a.position) !== null && _ref13 !== void 0 ? _ref13 : \"top\"\n              },\n              tooltip: {\n                enabled: !0\n              }\n            },\n            scales: this.buildScales(e, n)\n          }\n        };\n      this.chart = new mt(this.canvas, o);\n    }\n  }, {\n    key: \"mapChartType\",\n    value: function mapChartType(t) {\n      switch (t) {\n        case \"area\":\n          return \"line\";\n        case \"bar\":\n        case \"line\":\n        case \"pie\":\n        case \"doughnut\":\n        case \"scatter\":\n          return t;\n        default:\n          return \"bar\";\n      }\n    }\n  }, {\n    key: \"buildScales\",\n    value: function buildScales(t, e) {\n      var s, n, o, r;\n      if (!(e === \"pie\" || e === \"doughnut\")) return {\n        x: {\n          display: !0,\n          title: {\n            display: !!((s = t.xAxis) != null && s.label),\n            text: (n = t.xAxis) == null ? void 0 : n.label\n          }\n        },\n        y: {\n          display: !0,\n          title: {\n            display: !!((o = t.yAxis) != null && o.label),\n            text: (r = t.yAxis) == null ? void 0 : r.label\n          },\n          beginAtZero: !0\n        }\n      };\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.chart && (this.chart.destroy(), this.chart = null);\n    }\n  }]);\n}();\nvar $c = /*#__PURE__*/function () {\n  function $c(t) {\n    _classCallCheck(this, $c);\n    this._chartRenderers = [], this._container = t;\n  }\n  return _createClass($c, [{\n    key: \"renderEmptyState\",\n    value: function renderEmptyState() {\n      this._container.innerHTML = \"\\n      <div class=\\\"empty-state\\\">\\n        <span>Set a prompt to generate a chart</span>\\n      </div>\\n    \";\n    }\n  }, {\n    key: \"showLoading\",\n    value: function showLoading() {\n      this._container.innerHTML = \"\\n      <div class=\\\"loading-overlay\\\">\\n        <div class=\\\"spinner\\\"></div>\\n        <div class=\\\"loading-text\\\">Generating chart...</div>\\n      </div>\\n      <div class=\\\"chart-wrapper\\\">\\n        <canvas></canvas>\\n      </div>\\n    \";\n    }\n  }, {\n    key: \"showError\",\n    value: function showError(t, e) {\n      this._container.innerHTML = \"\\n      <div class=\\\"error-container\\\">\\n        <div class=\\\"error-icon\\\">!</div>\\n        <div class=\\\"error-message\\\">\".concat(this._escapeHtml(t), \"</div>\\n        <button class=\\\"retry-button\\\">Retry</button>\\n      </div>\\n    \");\n      var s = this._container.querySelector(\".retry-button\");\n      s == null || s.addEventListener(\"click\", e);\n    }\n  }, {\n    key: \"renderChart\",\n    value: function renderChart(t) {\n      var _this37 = this;\n      this._destroyRenderers();\n      var e = Array.isArray(t) ? t : [t];\n      if (e.length > 1) {\n        this._container.innerHTML = '<div class=\"charts-grid\"></div>';\n        var n = this._container.querySelector(\".charts-grid\");\n        e.forEach(function (o) {\n          var r = document.createElement(\"div\");\n          r.className = \"chart-wrapper\", r.innerHTML = \"<canvas></canvas>\", n.appendChild(r);\n          var a = r.querySelector(\"canvas\"),\n            l = new fn(a);\n          l.render(o), _this37._chartRenderers.push(l);\n        });\n      } else {\n        this._container.innerHTML = \"\\n        <div class=\\\"chart-wrapper\\\">\\n          <canvas></canvas>\\n        </div>\\n      \";\n        var _n4 = this._container.querySelector(\"canvas\");\n        if (!_n4) return;\n        var o = new fn(_n4);\n        o.render(e[0]), this._chartRenderers.push(o);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._destroyRenderers();\n    }\n  }, {\n    key: \"_destroyRenderers\",\n    value: function _destroyRenderers() {\n      this._chartRenderers.forEach(function (t) {\n        return t.destroy();\n      }), this._chartRenderers = [];\n    }\n  }, {\n    key: \"_escapeHtml\",\n    value: function _escapeHtml(t) {\n      var e = document.createElement(\"div\");\n      return e.textContent = t, e.innerHTML;\n    }\n  }]);\n}();\nvar Yc = \"\\n  :host {\\n    display: block;\\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;\\n  }\\n\\n  .prompt-chart-container {\\n    position: relative;\\n    width: 100%;\\n    height: 100%;\\n    min-height: 300px;\\n  }\\n\\n  .chart-wrapper {\\n    width: 100%;\\n    height: 100%;\\n    min-height: 300px;\\n  }\\n\\n  .charts-grid {\\n    display: grid;\\n    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));\\n    gap: 20px;\\n    width: 100%;\\n    height: 100%;\\n  }\\n\\n  .charts-grid .chart-wrapper {\\n    border: 1px solid #e5e7eb;\\n    border-radius: 8px;\\n    padding: 16px;\\n    background: #fff;\\n  }\\n\\n  .loading-overlay {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    bottom: 0;\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    justify-content: center;\\n    background: rgba(255, 255, 255, 0.9);\\n    z-index: 10;\\n  }\\n\\n  .spinner {\\n    width: 40px;\\n    height: 40px;\\n    border: 3px solid #e5e7eb;\\n    border-top-color: #3b82f6;\\n    border-radius: 50%;\\n    animation: spin 1s linear infinite;\\n  }\\n\\n  @keyframes spin {\\n    to {\\n      transform: rotate(360deg);\\n    }\\n  }\\n\\n  .loading-text {\\n    margin-top: 12px;\\n    color: #6b7280;\\n    font-size: 14px;\\n  }\\n\\n  .error-container {\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    justify-content: center;\\n    height: 100%;\\n    min-height: 200px;\\n    padding: 20px;\\n    text-align: center;\\n    color: #dc2626;\\n  }\\n\\n  .error-icon {\\n    font-size: 48px;\\n    margin-bottom: 16px;\\n  }\\n\\n  .error-message {\\n    font-size: 14px;\\n    max-width: 400px;\\n  }\\n\\n  .retry-button {\\n    margin-top: 16px;\\n    padding: 8px 16px;\\n    background: #3b82f6;\\n    color: white;\\n    border: none;\\n    border-radius: 6px;\\n    cursor: pointer;\\n    font-size: 14px;\\n    transition: background 0.2s;\\n  }\\n\\n  .retry-button:hover {\\n    background: #2563eb;\\n  }\\n\\n  .empty-state {\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    justify-content: center;\\n    height: 100%;\\n    min-height: 200px;\\n    color: #9ca3af;\\n    font-size: 14px;\\n  }\\n\";\nvar Uc = Object.defineProperty,\n  ht = function ht(i, t, e, s) {\n    for (var n = void 0, o = i.length - 1, r; o >= 0; o--) (r = i[o]) && (n = r(t, e, n) || n);\n    return n && Uc(t, e, n), n;\n  };\nvar nt = /*#__PURE__*/function (_i5) {\n  function nt() {\n    var _this38;\n    _classCallCheck(this, nt);\n    _this38 = _callSuper(this, nt), _this38._hasBeenRendered = !1, _this38._abortController = null, _this38._shadow = _this38.attachShadow({\n      mode: \"open\"\n    });\n    var t = document.createElement(\"div\");\n    t.className = \"prompt-chart-container\", _this38._shadow.innerHTML = \"<style>\".concat(Yc, \"</style>\"), _this38._shadow.appendChild(t), _this38._stateRenderer = new $c(t), _this38._demoDataGenerator = new co(), _this38._stateRenderer.renderEmptyState(), setTimeout(function () {\n      _this38._hasBeenRendered || _this38.onRender();\n    }, 20);\n    return _this38;\n  }\n  // prettier-ignore\n  _inherits(nt, _i5);\n  return _createClass(nt, [{\n    key: \"onRender\",\n    value: function onRender() {\n      Ne.attemptAppendStyleSheetToHead(this.style), bi.applyDefaultStyleToComponent(this.style, this.containerStyle), this._hasBeenRendered = !0;\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      var t;\n      this.data ? this._renderData() : this.autoFetch && this.prompt && ((t = this.connect) != null && t.url || this.demo) && this.fetchChart();\n    }\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      this._cleanup();\n    }\n    // override onPropertyChange(property: string, _value: unknown): void {\n    //   if (property === 'data' && this.data) {\n    //     this._renderData();\n    //   } else if (property === 'prompt' && this.autoFetch && this.prompt && (this.connect?.url || this.demo)) {\n    //     this.fetchChart();\n    //   }\n    // }\n  }, {\n    key: \"_renderData\",\n    value: function _renderData() {\n      var t;\n      this.data && (this._stateRenderer.renderChart(this.data), this.dispatchEvent(new CustomEvent(\"chart-loaded\", {\n        detail: this.data,\n        bubbles: !0,\n        composed: !0\n      })), (t = this.onChartLoaded) == null || t.call(this, this.data));\n    }\n    /**\n     * Fetch and render a chart based on the current prompt\n     */\n  }, {\n    key: \"fetchChart\",\n    value: (function () {\n      var _fetchChart = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {\n        var _this39 = this;\n        var t;\n        return _regenerator().w(function (_context) {\n          while (1) switch (_context.n) {\n            case 0:\n              if (this.prompt) {\n                _context.n = 1;\n                break;\n              }\n              this._stateRenderer.showError(\"Missing prompt\", function () {\n                return _this39.fetchChart();\n              });\n              return _context.a(2);\n            case 1:\n              if (!(!this.demo && !((t = this.connect) != null && t.url))) {\n                _context.n = 2;\n                break;\n              }\n              this._stateRenderer.showError(\"Missing connect.url\", function () {\n                return _this39.fetchChart();\n              });\n              return _context.a(2);\n            case 2:\n              if (!this.demo) {\n                _context.n = 4;\n                break;\n              }\n              _context.n = 3;\n              return this._fetchDemoChart();\n            case 3:\n              return _context.a(2);\n            case 4:\n              _context.n = 5;\n              return this._fetchRemoteChart();\n            case 5:\n              return _context.a(2);\n          }\n        }, _callee, this);\n      }));\n      function fetchChart() {\n        return _fetchChart.apply(this, arguments);\n      }\n      return fetchChart;\n    }())\n  }, {\n    key: \"_fetchDemoChart\",\n    value: function () {\n      var _fetchDemoChart2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {\n        var e, t;\n        return _regenerator().w(function (_context2) {\n          while (1) switch (_context2.n) {\n            case 0:\n              this._stateRenderer.showLoading();\n              _context2.n = 1;\n              return new Promise(function (s) {\n                return setTimeout(s, 500);\n              });\n            case 1:\n              t = this._demoDataGenerator.generate(this.prompt);\n              this._stateRenderer.renderChart(t), this.dispatchEvent(new CustomEvent(\"chart-loaded\", {\n                detail: t,\n                bubbles: !0,\n                composed: !0\n              })), (e = this.onChartLoaded) == null || e.call(this, t);\n            case 2:\n              return _context2.a(2);\n          }\n        }, _callee2, this);\n      }));\n      function _fetchDemoChart() {\n        return _fetchDemoChart2.apply(this, arguments);\n      }\n      return _fetchDemoChart;\n    }()\n  }, {\n    key: \"_fetchRemoteChart\",\n    value: function () {\n      var _fetchRemoteChart2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {\n        var _this40 = this;\n        var t, e, s, _this$connect$method, n, o, l, r, a, _o4, _t4, _t5, _t6;\n        return _regenerator().w(function (_context3) {\n          while (1) switch (_context3.p = _context3.n) {\n            case 0:\n              (t = this._abortController) == null || t.abort(), this._abortController = new AbortController(), this._stateRenderer.showLoading();\n              _context3.p = 1;\n              n = {\n                endpoint: this.connect.url,\n                method: (_this$connect$method = this.connect.method) !== null && _this$connect$method !== void 0 ? _this$connect$method : \"POST\",\n                headers: _objectSpread({\n                  \"Content-Type\": \"application/json\"\n                }, this.connect.headers),\n                body: {\n                  prompt: this.prompt\n                }\n              };\n              _t4 = this.requestInterceptor;\n              if (!_t4) {\n                _context3.n = 3;\n                break;\n              }\n              _context3.n = 2;\n              return this.requestInterceptor(n);\n            case 2:\n              n = _context3.v;\n            case 3:\n              _context3.n = 4;\n              return fetch(n.endpoint, {\n                method: n.method,\n                headers: n.headers,\n                body: JSON.stringify(n.body),\n                signal: this._abortController.signal\n              });\n            case 4:\n              o = _context3.v;\n              if (o.ok) {\n                _context3.n = 6;\n                break;\n              }\n              _context3.n = 5;\n              return o.json()[\"catch\"](function () {\n                return {\n                  error: \"Request failed\"\n                };\n              });\n            case 5:\n              l = _context3.v;\n              throw new Error(l.error || \"HTTP \".concat(o.status));\n            case 6:\n              _context3.n = 7;\n              return o.json();\n            case 7:\n              r = _context3.v;\n              if (!this.responseInterceptor) {\n                _context3.n = 9;\n                break;\n              }\n              _context3.n = 8;\n              return this.responseInterceptor(r);\n            case 8:\n              _t5 = _context3.v;\n              _context3.n = 10;\n              break;\n            case 9:\n              _t5 = r;\n            case 10:\n              a = _t5;\n              this._stateRenderer.renderChart(a), this.dispatchEvent(new CustomEvent(\"chart-loaded\", {\n                detail: a,\n                bubbles: !0,\n                composed: !0\n              })), (e = this.onChartLoaded) == null || e.call(this, a);\n              _context3.n = 13;\n              break;\n            case 11:\n              _context3.p = 11;\n              _t6 = _context3.v;\n              if (!(_t6 instanceof Error && _t6.name === \"AbortError\")) {\n                _context3.n = 12;\n                break;\n              }\n              return _context3.a(2);\n            case 12:\n              _o4 = _t6 instanceof Error ? _t6.message : \"Unknown error\";\n              this._stateRenderer.showError(_o4, function () {\n                return _this40.fetchChart();\n              }), this.dispatchEvent(new CustomEvent(\"chart-error\", {\n                detail: {\n                  error: _o4\n                },\n                bubbles: !0,\n                composed: !0\n              })), (s = this.onChartError) == null || s.call(this);\n            case 13:\n              return _context3.a(2);\n          }\n        }, _callee3, this, [[1, 11]]);\n      }));\n      function _fetchRemoteChart() {\n        return _fetchRemoteChart2.apply(this, arguments);\n      }\n      return _fetchRemoteChart;\n    }()\n  }, {\n    key: \"_cleanup\",\n    value: function _cleanup() {\n      var t;\n      (t = this._abortController) == null || t.abort(), this._stateRenderer.destroy();\n    }\n  }]);\n}(_i);\nht([ct(\"object\")], nt.prototype, \"connect\");\nht([ct(\"string\")], nt.prototype, \"prompt\");\nht([ct(\"boolean\")], nt.prototype, \"autoFetch\");\nht([ct(\"object\")], nt.prototype, \"containerStyle\");\nht([ct(\"function\")], nt.prototype, \"onChartLoaded\");\nht([ct(\"function\")], nt.prototype, \"onChartError\");\nht([ct(\"function\")], nt.prototype, \"requestInterceptor\");\nht([ct(\"function\")], nt.prototype, \"responseInterceptor\");\nht([ct(\"boolean\")], nt.prototype, \"demo\");\nht([ct(\"object\")], nt.prototype, \"data\");\ncustomElements.get(\"prompt-chart\") || customElements.define(\"prompt-chart\", nt);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvbXB0LWNoYXJ0L2Rpc3QvcHJvbXB0Q2hhcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwwQkFBMEIsME5BQTBOLHdFQUF3RSx5QkFBeUIsK0ZBQStGLDhEQUE4RCwrQ0FBK0MsK0RBQStELDZDQUE2QyxtQkFBbUIsMEJBQTBCLCtCQUErQixPQUFPLG9DQUFvQyw4T0FBOE8sMEJBQTBCLG1CQUFtQiw0QkFBNEIsNERBQTRELDRDQUE0QywwQkFBMEIsSUFBSSx1RUFBdUUsTUFBTSxnQkFBZ0IsbUNBQW1DLDhFQUE4RSx1QkFBdUIsaUNBQWlDLHVJQUF1SSxTQUFTLGdFQUFnRSxZQUFZLHVCQUF1QixVQUFVLFdBQVcsU0FBUyx5QkFBeUIscUJBQXFCLFlBQVksd0JBQXdCLGdDQUFnQyx5Q0FBeUMsMkJBQTJCLDJEQUEyRCxtQkFBbUIsY0FBYywwRkFBMEYsZ0JBQWdCLHVOQUF1Tiw2YkFBNmIsY0FBYyxvREFBb0QsOEJBQThCLDZDQUE2QyxTQUFTLGVBQWU7QUFDNzRGLDJDQUEyQywrQkFBK0IsTUFBTSxJQUFJLFFBQVEsS0FBSyxZQUFZLFNBQVMsZ0VBQWdFLG1CQUFtQix5Q0FBeUMsK0JBQStCLEtBQUssa0JBQWtCLDBEQUEwRCwrREFBK0Q7QUFDamEsbURBQW1ELE1BQU0sZ0NBQWdDLFlBQVksb0JBQW9CO0FBQ3pILGdDQUFnQyxxQkFBcUIsNkJBQTZCLHFDQUFxQyx1QkFBdUIsb0JBQW9CLHlEQUF5RCxxQkFBcUIsMERBQTBELGdCQUFnQjtBQUMxVCx5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWEscUNBQXFDLDhEQUE4RCx3REFBd0Qsd0JBQXdCO0FBQ25MLGtCQUFrQix1R0FBdUcsOEJBQThCLFNBQVMsK0NBQStDLHNFQUFzRTtBQUNyUixnQ0FBZ0MsT0FBTyxHQUFHLGdFQUFnRSxHQUFHO0FBQzdHLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsdUNBQXVDLGtHQUFrRyxpQkFBaUIsd0NBQXdDLE1BQU0seUNBQXlDLDZCQUE2QixVQUFVLFlBQVksa0VBQWtFLFdBQVcsWUFBWSxpQkFBaUIsVUFBVSxNQUFNLGlGQUFpRixVQUFVLG9CQUFvQjtBQUM3Z0IsOEJBQThCO0FBQzlCLG9DQUFvQyxvRUFBb0UsMERBQTBEO0FBQ2xLLDRDQUE0QywrRUFBK0UsVUFBVSx5R0FBeUcsY0FBYyxrQ0FBa0MsU0FBUyx3QkFBd0IsMkJBQTJCLFdBQVcsSUFBSSw4QkFBOEIscUJBQXFCLFVBQVUsWUFBWSxnS0FBZ0ssdUJBQXVCLFNBQVMsa0JBQWtCLGdCQUFnQixvQkFBb0Isa0JBQWtCLHVCQUF1QixxQkFBcUIsZ0JBQWdCLG9CQUFvQixNQUFNLDZDQUE2QyxVQUFVO0FBQ3YwQixpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLDZDQUE2QyxTQUFTLDBEQUEwRCxVQUFVLGdDQUFnQztBQUMxSiwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLG1DQUFtQywrQ0FBK0MsOEJBQThCLE9BQU8sa0JBQWtCO0FBQ3pJLCtCQUErQjtBQUMvQiw0Q0FBNEMsdUVBQXVFLG1HQUFtRztBQUN0TixxQ0FBcUMseUdBQXlHO0FBQzlJLDJCQUEyQixxSEFBcUgsZ0RBQWdELGVBQWUsNENBQTRDLDJDQUEyQyxjQUFjO0FBQ3BULCtCQUErQix1REFBdUQseURBQXlELG1EQUFtRCx1R0FBdUcsb0JBQW9CLCtCQUErQixxQkFBcUIscUJBQXFCLHNFQUFzRSx3REFBd0QsZUFBZSxrRUFBa0UsaUNBQWlDO0FBQ3RuQiwrQkFBK0Isa0ZBQWtGLGdCQUFnQixvQkFBb0Isb0NBQW9DO0FBQ3pMLHVDQUF1QyxNQUFNLHFGQUFxRixNQUFNLGFBQWEsMkVBQTJFLGFBQWE7QUFDN08sZ0NBQWdDLE1BQU0sb0VBQW9FLFlBQVk7QUFDdEgsaUNBQWlDLGtHQUFrRyw0QkFBNEI7QUFDL0osOEJBQThCLCtGQUErRixpREFBaUQ7QUFDOUssaUNBQWlDO0FBQ2pDLG1DQUFtQyxnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDdEYsaUNBQWlDLHFIQUFxSCxjQUFjO0FBQ3BLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxPQUFPO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTyx3QkFBd0IsNkRBQTZELE9BQU87QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4QkFBOEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0NBQWdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNEJBQTRCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0JBQWtCO0FBQzNCLFNBQVMsc0JBQXNCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGFBQWE7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxlQUFlO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsZUFBZTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSkFBb0o7QUFDcEo7QUFDQSxLQUFLLG9CQUFvQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxpQkFBaUI7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSywrR0FBK0csNkRBQTZEO0FBQ2pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SDtBQUM1SDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsU0FBUyxFQUFFO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxzREFBc0Q7QUFDekQ7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDLFNBQVMsbUJBQW1CO0FBQzVCLDhCQUE4Qix1QkFBdUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQyxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxnQkFBZ0I7QUFDdkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU8sd0RBQXdEO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQ0FBa0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbUNBQW1DO0FBQ25DLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8seURBQXlEO0FBQ3pGO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlFQUFpRTtBQUNuRjtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsV0FBVztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkMsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8scUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPLHFCQUFxQjtBQUN6RDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQ0FBcUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdCQUF3QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQ0FBa0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQ0FBa0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsT0FBTztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE1BQU07QUFDbkYsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG1kQUFtZCw0UUFBNFE7QUFDcHVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLFNBQVMsb0ZBQW9GLHlDQUF5QyxPQUFPO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxzR0FBc0csd0dBQXdHLHVHQUF1RztBQUMvWixnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsOEVBQThFO0FBQzdKO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUiwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGVBQWU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwRUFBMEUsZUFBZTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMEVBQTBFLGVBQWU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwRUFBMEUsZUFBZTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMEVBQTBFLGVBQWU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2RUFBNkUsaUJBQWlCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2RUFBNkUsaUJBQWlCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQixrQ0FBa0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsaUJBQWlCO0FBQy9HO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULGtDQUFrQztBQUNsQyxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtXQUFrVyxpRkFBaUYsOENBQThDLDBCQUEwQjtBQUMzZjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLE9BQU87QUFDM0U7QUFDQTtBQUNBO0FBQ0EsdVVBQXVVO0FBQ3ZVO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsdURBQXVELE9BQU87QUFDOUQsMkRBQTJELFdBQVc7QUFDdEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0MsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxPQUFPO0FBQ3RGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sdUJBQXVCO0FBQzlCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0pBQWdKLE9BQU87QUFDdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQ0FBa0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQ0FBa0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQ0FBa0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsdUNBQXVDO0FBQ3ZDLGVBQWU7QUFDZjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQ0FBZ0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQkFBa0IsY0FBYztBQUNoQztBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0JBQWdCLE9BQU87QUFDdkIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUg7QUFDakg7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKO0FBQ2xKO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnTkFBZ04sT0FBTztBQUN2TjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNE9BQTRPLE9BQU87QUFDblAsNE1BQTRNLE9BQU87QUFDbk47QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwTkFBME4sT0FBTztBQUNqTztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFFBQVE7QUFDckY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOEZBQThGLE9BQU87QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywyRUFBMkU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELHFCQUFxQixxQkFBcUIscUdBQXFHLEtBQUssK0JBQStCLHlCQUF5QixrQkFBa0IsbUJBQW1CLHdCQUF3QixLQUFLLHNCQUFzQixrQkFBa0IsbUJBQW1CLHdCQUF3QixLQUFLLG9CQUFvQixvQkFBb0Isa0VBQWtFLGdCQUFnQixrQkFBa0IsbUJBQW1CLEtBQUssbUNBQW1DLGdDQUFnQyx5QkFBeUIsb0JBQW9CLHVCQUF1QixLQUFLLHdCQUF3Qix5QkFBeUIsYUFBYSxjQUFjLGVBQWUsZ0JBQWdCLG9CQUFvQiw2QkFBNkIsMEJBQTBCLDhCQUE4QiwyQ0FBMkMsa0JBQWtCLEtBQUssZ0JBQWdCLGtCQUFrQixtQkFBbUIsZ0NBQWdDLGdDQUFnQyx5QkFBeUIseUNBQXlDLEtBQUssdUJBQXVCLFVBQVUsa0NBQWtDLE9BQU8sS0FBSyxxQkFBcUIsdUJBQXVCLHFCQUFxQixzQkFBc0IsS0FBSyx3QkFBd0Isb0JBQW9CLDZCQUE2QiwwQkFBMEIsOEJBQThCLG1CQUFtQix3QkFBd0Isb0JBQW9CLHlCQUF5QixxQkFBcUIsS0FBSyxtQkFBbUIsc0JBQXNCLDBCQUEwQixLQUFLLHNCQUFzQixzQkFBc0IsdUJBQXVCLEtBQUsscUJBQXFCLHVCQUF1Qix3QkFBd0IsMEJBQTBCLG1CQUFtQixtQkFBbUIseUJBQXlCLHNCQUFzQixzQkFBc0Isa0NBQWtDLEtBQUssMkJBQTJCLDBCQUEwQixLQUFLLG9CQUFvQixvQkFBb0IsNkJBQTZCLDBCQUEwQiw4QkFBOEIsbUJBQW1CLHdCQUF3QixxQkFBcUIsc0JBQXNCLEtBQUs7QUFDeHBFO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb21wdC1jaGFydC9kaXN0L3Byb21wdENoYXJ0LmpzPzE0OGYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3JlZ2VuZXJhdG9yKCkgeyAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL2Jsb2IvbWFpbi9wYWNrYWdlcy9iYWJlbC1oZWxwZXJzL0xJQ0VOU0UgKi8gdmFyIGUsIHQsIHIgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LCBuID0gci5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIiwgbyA9IHIudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7IGZ1bmN0aW9uIGkociwgbiwgbywgaSkgeyB2YXIgYyA9IG4gJiYgbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBuIDogR2VuZXJhdG9yLCB1ID0gT2JqZWN0LmNyZWF0ZShjLnByb3RvdHlwZSk7IHJldHVybiBfcmVnZW5lcmF0b3JEZWZpbmUyKHUsIFwiX2ludm9rZVwiLCBmdW5jdGlvbiAociwgbiwgbykgeyB2YXIgaSwgYywgdSwgZiA9IDAsIHAgPSBvIHx8IFtdLCB5ID0gITEsIEcgPSB7IHA6IDAsIG46IDAsIHY6IGUsIGE6IGQsIGY6IGQuYmluZChlLCA0KSwgZDogZnVuY3Rpb24gZCh0LCByKSB7IHJldHVybiBpID0gdCwgYyA9IDAsIHUgPSBlLCBHLm4gPSByLCBhOyB9IH07IGZ1bmN0aW9uIGQociwgbikgeyBmb3IgKGMgPSByLCB1ID0gbiwgdCA9IDA7ICF5ICYmIGYgJiYgIW8gJiYgdCA8IHAubGVuZ3RoOyB0KyspIHsgdmFyIG8sIGkgPSBwW3RdLCBkID0gRy5wLCBsID0gaVsyXTsgciA+IDMgPyAobyA9IGwgPT09IG4pICYmICh1ID0gaVsoYyA9IGlbNF0pID8gNSA6IChjID0gMywgMyldLCBpWzRdID0gaVs1XSA9IGUpIDogaVswXSA8PSBkICYmICgobyA9IHIgPCAyICYmIGQgPCBpWzFdKSA/IChjID0gMCwgRy52ID0gbiwgRy5uID0gaVsxXSkgOiBkIDwgbCAmJiAobyA9IHIgPCAzIHx8IGlbMF0gPiBuIHx8IG4gPiBsKSAmJiAoaVs0XSA9IHIsIGlbNV0gPSBuLCBHLm4gPSBsLCBjID0gMCkpOyB9IGlmIChvIHx8IHIgPiAxKSByZXR1cm4gYTsgdGhyb3cgeSA9ICEwLCBuOyB9IHJldHVybiBmdW5jdGlvbiAobywgcCwgbCkgeyBpZiAoZiA+IDEpIHRocm93IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7IGZvciAoeSAmJiAxID09PSBwICYmIGQocCwgbCksIGMgPSBwLCB1ID0gbDsgKHQgPSBjIDwgMiA/IGUgOiB1KSB8fCAheTspIHsgaSB8fCAoYyA/IGMgPCAzID8gKGMgPiAxICYmIChHLm4gPSAtMSksIGQoYywgdSkpIDogRy5uID0gdSA6IEcudiA9IHUpOyB0cnkgeyBpZiAoZiA9IDIsIGkpIHsgaWYgKGMgfHwgKG8gPSBcIm5leHRcIiksIHQgPSBpW29dKSB7IGlmICghKHQgPSB0LmNhbGwoaSwgdSkpKSB0aHJvdyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTsgaWYgKCF0LmRvbmUpIHJldHVybiB0OyB1ID0gdC52YWx1ZSwgYyA8IDIgJiYgKGMgPSAwKTsgfSBlbHNlIDEgPT09IGMgJiYgKHQgPSBpW1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoaSksIGMgPCAyICYmICh1ID0gVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBvICsgXCInIG1ldGhvZFwiKSwgYyA9IDEpOyBpID0gZTsgfSBlbHNlIGlmICgodCA9ICh5ID0gRy5uIDwgMCkgPyB1IDogci5jYWxsKG4sIEcpKSAhPT0gYSkgYnJlYWs7IH0gY2F0Y2ggKHQpIHsgaSA9IGUsIGMgPSAxLCB1ID0gdDsgfSBmaW5hbGx5IHsgZiA9IDE7IH0gfSByZXR1cm4geyB2YWx1ZTogdCwgZG9uZTogeSB9OyB9OyB9KHIsIG8sIGkpLCAhMCksIHU7IH0gdmFyIGEgPSB7fTsgZnVuY3Rpb24gR2VuZXJhdG9yKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9IHQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IHZhciBjID0gW11bbl0gPyB0KHQoW11bbl0oKSkpIDogKF9yZWdlbmVyYXRvckRlZmluZTIodCA9IHt9LCBuLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgdCksIHUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjKTsgZnVuY3Rpb24gZihlKSB7IHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZSwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKGUuX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIF9yZWdlbmVyYXRvckRlZmluZTIoZSwgbywgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1KSwgZTsgfSByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIF9yZWdlbmVyYXRvckRlZmluZTIodSwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSksIF9yZWdlbmVyYXRvckRlZmluZTIoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiwgX3JlZ2VuZXJhdG9yRGVmaW5lMihHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgbywgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgX3JlZ2VuZXJhdG9yRGVmaW5lMih1KSwgX3JlZ2VuZXJhdG9yRGVmaW5lMih1LCBvLCBcIkdlbmVyYXRvclwiKSwgX3JlZ2VuZXJhdG9yRGVmaW5lMih1LCBuLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgX3JlZ2VuZXJhdG9yRGVmaW5lMih1LCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7IH0pLCAoX3JlZ2VuZXJhdG9yID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yKCkgeyByZXR1cm4geyB3OiBpLCBtOiBmIH07IH0pKCk7IH1cbmZ1bmN0aW9uIF9yZWdlbmVyYXRvckRlZmluZTIoZSwgciwgbiwgdCkgeyB2YXIgaSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTsgdHJ5IHsgaSh7fSwgXCJcIiwge30pOyB9IGNhdGNoIChlKSB7IGkgPSAwOyB9IF9yZWdlbmVyYXRvckRlZmluZTIgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3JEZWZpbmUoZSwgciwgbiwgdCkgeyBmdW5jdGlvbiBvKHIsIG4pIHsgX3JlZ2VuZXJhdG9yRGVmaW5lMihlLCByLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gdGhpcy5faW52b2tlKHIsIG4sIGUpOyB9KTsgfSByID8gaSA/IGkoZSwgciwgeyB2YWx1ZTogbiwgZW51bWVyYWJsZTogIXQsIGNvbmZpZ3VyYWJsZTogIXQsIHdyaXRhYmxlOiAhdCB9KSA6IGVbcl0gPSBuIDogKG8oXCJuZXh0XCIsIDApLCBvKFwidGhyb3dcIiwgMSksIG8oXCJyZXR1cm5cIiwgMikpOyB9LCBfcmVnZW5lcmF0b3JEZWZpbmUyKGUsIHIsIG4sIHQpOyB9XG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAobiwgdCwgZSwgciwgbywgYSwgYykgeyB0cnkgeyB2YXIgaSA9IG5bYV0oYyksIHUgPSBpLnZhbHVlOyB9IGNhdGNoIChuKSB7IHJldHVybiB2b2lkIGUobik7IH0gaS5kb25lID8gdCh1KSA6IFByb21pc2UucmVzb2x2ZSh1KS50aGVuKHIsIG8pOyB9XG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciB0ID0gdGhpcywgZSA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyLCBvKSB7IHZhciBhID0gbi5hcHBseSh0LCBlKTsgZnVuY3Rpb24gX25leHQobikgeyBhc3luY0dlbmVyYXRvclN0ZXAoYSwgciwgbywgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIG4pOyB9IGZ1bmN0aW9uIF90aHJvdyhuKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChhLCByLCBvLCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIG4pOyB9IF9uZXh0KHZvaWQgMCk7IH0pOyB9OyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9zdXBlclByb3BHZXQodCwgbywgZSwgcikgeyB2YXIgcCA9IF9nZXQoX2dldFByb3RvdHlwZU9mKDEgJiByID8gdC5wcm90b3R5cGUgOiB0KSwgbywgZSk7IHJldHVybiAyICYgciAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHAgPyBmdW5jdGlvbiAodCkgeyByZXR1cm4gcC5hcHBseShlLCB0KTsgfSA6IHA7IH1cbmZ1bmN0aW9uIF9nZXQoKSB7IHJldHVybiBfZ2V0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmdldCA/IFJlZmxlY3QuZ2V0LmJpbmQoKSA6IGZ1bmN0aW9uIChlLCB0LCByKSB7IHZhciBwID0gX3N1cGVyUHJvcEJhc2UoZSwgdCk7IGlmIChwKSB7IHZhciBuID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwLCB0KTsgcmV0dXJuIG4uZ2V0ID8gbi5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IGUgOiByKSA6IG4udmFsdWU7IH0gfSwgX2dldC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZSh0LCBvKSB7IGZvciAoOyAhe30uaGFzT3duUHJvcGVydHkuY2FsbCh0LCBvKSAmJiBudWxsICE9PSAodCA9IF9nZXRQcm90b3R5cGVPZih0KSk7KTsgcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIociwgZSkgeyB2YXIgdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmICghdCkgeyBpZiAoQXJyYXkuaXNBcnJheShyKSB8fCAodCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSkgfHwgZSAmJiByICYmIFwibnVtYmVyXCIgPT0gdHlwZW9mIHIubGVuZ3RoKSB7IHQgJiYgKHIgPSB0KTsgdmFyIF9uNSA9IDAsIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IHJldHVybiBfbjUgPj0gci5sZW5ndGggPyB7IGRvbmU6ICEwIH0gOiB7IGRvbmU6ICExLCB2YWx1ZTogcltfbjUrK10gfTsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHRocm93IHI7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG8sIGEgPSAhMCwgdSA9ICExOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyB0ID0gdC5jYWxsKHIpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgciA9IHQubmV4dCgpOyByZXR1cm4gYSA9IHIuZG9uZSwgcjsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHUgPSAhMCwgbyA9IHI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGEgfHwgbnVsbCA9PSB0W1wicmV0dXJuXCJdIHx8IHRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKHUpIHRocm93IG87IH0gfSB9OyB9XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkocikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXkocikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDsgfSB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KHIpIHsgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBudWxsICE9IHJbU3ltYm9sLml0ZXJhdG9yXSB8fCBudWxsICE9IHJbXCJAQGl0ZXJhdG9yXCJdKSByZXR1cm4gQXJyYXkuZnJvbShyKTsgfVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGUpIHsgaWYgKGUgJiYgKFwib2JqZWN0XCIgPT0gX3R5cGVvZihlKSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTsgaWYgKHZvaWQgMCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZCh0KTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChlKSB7IGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyh0LCBlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogdCwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZSAmJiBfc2V0UHJvdG90eXBlT2YodCwgZSk7IH1cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIodCkgeyB2YXIgciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgTWFwID8gbmV3IE1hcCgpIDogdm9pZCAwOyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIodCkgeyBpZiAobnVsbCA9PT0gdCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24odCkpIHJldHVybiB0OyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IGlmICh2b2lkIDAgIT09IHIpIHsgaWYgKHIuaGFzKHQpKSByZXR1cm4gci5nZXQodCk7IHIuc2V0KHQsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KHQsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSByZXR1cm4gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiAhMSwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gfSksIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCB0KTsgfSwgX3dyYXBOYXRpdmVTdXBlcih0KTsgfVxuZnVuY3Rpb24gX2NvbnN0cnVjdCh0LCBlLCByKSB7IGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB2YXIgbyA9IFtudWxsXTsgby5wdXNoLmFwcGx5KG8sIGUpOyB2YXIgcCA9IG5ldyAodC5iaW5kLmFwcGx5KHQsIG8pKSgpOyByZXR1cm4gciAmJiBfc2V0UHJvdG90eXBlT2YocCwgci5wcm90b3R5cGUpLCBwOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKHQpIHsgdHJ5IHsgcmV0dXJuIC0xICE9PSBGdW5jdGlvbi50b1N0cmluZy5jYWxsKHQpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpOyB9IGNhdGNoIChuKSB7IHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQ7IH0gfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKHQsIGUpIHsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCwgZSkgeyByZXR1cm4gdC5fX3Byb3RvX18gPSBlLCB0OyB9LCBfc2V0UHJvdG90eXBlT2YodCwgZSk7IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZih0KSB7IHJldHVybiBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTsgfSwgX2dldFByb3RvdHlwZU9mKHQpOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG52YXIgYW8gPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgbG8gPSBmdW5jdGlvbiBsbyhpLCB0LCBlKSB7XG4gIHJldHVybiB0IGluIGkgPyBhbyhpLCB0LCB7XG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICB3cml0YWJsZTogITAsXG4gICAgdmFsdWU6IGVcbiAgfSkgOiBpW3RdID0gZTtcbn07XG52YXIgdyA9IGZ1bmN0aW9uIHcoaSwgdCwgZSkge1xuICByZXR1cm4gbG8oaSwgX3R5cGVvZih0KSAhPSBcInN5bWJvbFwiID8gdCArIFwiXCIgOiB0LCBlKTtcbn07XG52YXIgTHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTHQpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoTHQsIG51bGwsIFt7XG4gICAga2V5OiBcImF0dGVtcHRBcHBlbmRTdHlsZVNoZWV0VG9IZWFkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGVtcHRBcHBlbmRTdHlsZVNoZWV0VG9IZWFkKHQpIHtcbiAgICAgIGlmICh0LmZvbnRGYW1pbHkgJiYgdC5mb250RmFtaWx5ICE9PSBMdC5ERUZBVUxUX0ZPTlRfRkFNSUxZKSByZXR1cm47XG4gICAgICB2YXIgZSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcbiAgICAgIGlmICghQXJyYXkuZnJvbShlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGlua1wiKSkuc29tZShmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gbi5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBMdC5GT05UX1VSTDtcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgICAgIG4ucmVsID0gXCJzdHlsZXNoZWV0XCIsIG4uaHJlZiA9IEx0LkZPTlRfVVJMLCBlLmFwcGVuZENoaWxkKG4pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xufSgpO1xuTHQuRk9OVF9VUkwgPSBcImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzMj9mYW1pbHk9SW50ZXI6d2dodEA0MDA7NjAwJmRpc3BsYXk9c3dhcFwiLCBMdC5ERUZBVUxUX0ZPTlRfRkFNSUxZID0gXCInSW50ZXInLCBzYW5zLXNlcmlmLCBBdmVuaXIsIEhlbHZldGljYSwgQXJpYWxcIjtcbnZhciBOZSA9IEx0O1xudmFyICR0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gJHQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsICR0KTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKCR0LCBudWxsLCBbe1xuICAgIGtleTogXCJhcHBseVRvU3R5bGVJZk5vdERlZmluZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlUb1N0eWxlSWZOb3REZWZpbmVkKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHMgaW4gZSkge1xuICAgICAgICB2YXIgbiA9IHMsXG4gICAgICAgICAgbyA9IGVbbl07XG4gICAgICAgIHRbbl0gPT09IFwiXCIgJiYgbyAmJiAodFtuXSA9IG8pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseURlZmF1bHRTdHlsZVRvQ29tcG9uZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdFN0eWxlVG9Db21wb25lbnQodCwgZSkge1xuICAgICAgZSAmJiAkdC5hcHBseVRvU3R5bGVJZk5vdERlZmluZWQodCwgZSksICR0LmFwcGx5VG9TdHlsZUlmTm90RGVmaW5lZCh0LCAkdC5ERUZBVUxUX0NPTVBPTkVOVF9TVFlMRSk7XG4gICAgfVxuICB9XSk7XG59KCk7XG4kdC5ERUZBVUxUX0NPTVBPTkVOVF9TVFlMRSA9IHtcbiAgaGVpZ2h0OiBcIjM1MHB4XCIsXG4gIHdpZHRoOiBcIjEwMCVcIixcbiAgZm9udEZhbWlseTogTmUuREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgZm9udFNpemU6IFwiMC45cmVtXCIsXG4gIGJhY2tncm91bmRDb2xvcjogXCJ3aGl0ZVwiLFxuICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICBvdmVyZmxvdzogXCJoaWRkZW5cIlxufTtcbnZhciBiaSA9ICR0O1xudmFyIFZlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZlKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFZlLCBudWxsLCBbe1xuICAgIGtleTogXCJ3YWl0Rm9yUHJvcGVydGllc1RvQmVVcGRhdGVkQmVmb3JlUmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdhaXRGb3JQcm9wZXJ0aWVzVG9CZVVwZGF0ZWRCZWZvcmVSZW5kZXIodCkge1xuICAgICAgdC5fcHJvcFVwZGF0ZWRfID0gITEsIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0Ll9wcm9wVXBkYXRlZF8gPyBWZS53YWl0Rm9yUHJvcGVydGllc1RvQmVVcGRhdGVkQmVmb3JlUmVuZGVyKHQpIDogKHQuX3dhaXRpbmdUb1JlbmRlcl8gPSAhMSwgdC5vblJlbmRlcigpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhdHRlbXB0UmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGVtcHRSZW5kZXIodCkge1xuICAgICAgdC5fcHJvcFVwZGF0ZWRfID0gITAsIHQuX3dhaXRpbmdUb1JlbmRlcl8gfHwgKHQuX3dhaXRpbmdUb1JlbmRlcl8gPSAhMCwgVmUud2FpdEZvclByb3BlcnRpZXNUb0JlVXBkYXRlZEJlZm9yZVJlbmRlcih0KSk7XG4gICAgfVxuICB9XSk7XG59KCk7XG52YXIgZ3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9IVE1MRWxlbWVudCkge1xuICAvLyBJZiB0aGlzIGlzIG5vdCB3b3JraW5nLCB0cnkgdXNpbmcgcHJvcGVydHlOYW1lIGRpcmVjdGx5XG4gIGZ1bmN0aW9uIGd0KCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgZ3QpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBndCksIF90aGlzLl93YWl0aW5nVG9SZW5kZXJfID0gITEsIF90aGlzLl9wcm9wVXBkYXRlZF8gPSAhMSwgT2JqZWN0LmtleXMoZ3QuX2F0dHJpYnV0ZVRvUHJvcGVydHlfKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IGd0Ll9hdHRyaWJ1dGVUb1Byb3BlcnR5X1t0XTtcbiAgICAgIF90aGlzLmNvbnN0cnVjdFByb3BlcnR5QWNjZXNzb3JzKGUpLCBfdGhpcy5oYXNPd25Qcm9wZXJ0eSh0KSB8fCBfdGhpcy5jb25zdHJ1Y3RQcm9wZXJ0eUFjY2Vzc29ycyhlLCB0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKGd0LCBfSFRNTEVsZW1lbnQpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKGd0LCBbe1xuICAgIGtleTogXCJjb25zdHJ1Y3RQcm9wZXJ0eUFjY2Vzc29yc1wiLFxuICAgIHZhbHVlOlxuICAgIC8vIG5lZWQgdG8gYmUgY2FsbGVkIGhlcmUgYXMgYWNjZXNzb3JzIG5lZWQgdG8gYmUgc2V0IGZvciB0aGUgY2xhc3MgaW5zdGFuY2VcbiAgICBmdW5jdGlvbiBjb25zdHJ1Y3RQcm9wZXJ0eUFjY2Vzc29ycyh0LCBlKSB7XG4gICAgICB2YXIgcztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBlIHx8IHQsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHIpIHtcbiAgICAgICAgICBzID0gciwgZSA/IHRoaXNbdF0gPSByIDogVmUuYXR0ZW1wdFJlbmRlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sodCwgZSwgcykge1xuICAgICAgaWYgKGUgPT09IHMpIHJldHVybjtcbiAgICAgIHZhciBuID0gZ3QuX2F0dHJpYnV0ZXNfW3RdKHMpLFxuICAgICAgICBvID0gZ3QuX2F0dHJpYnV0ZVRvUHJvcGVydHlfW3RdO1xuICAgICAgdGhpc1tvXSA9IG47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uUmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVuZGVyKCkge31cbiAgfV0sIFt7XG4gICAga2V5OiBcIm9ic2VydmVkQXR0cmlidXRlc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGd0Ll9hdHRyaWJ1dGVzXykgfHwgW107XG4gICAgfVxuICB9XSk7XG59KC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEhUTUxFbGVtZW50KSk7XG5ndC5fYXR0cmlidXRlc18gPSB7fSwgZ3QuX2F0dHJpYnV0ZVRvUHJvcGVydHlfID0ge307XG52YXIgX2kgPSBndDtcbnZhciBjbyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGNvKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBjbyk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhjbywgW3tcbiAgICBrZXk6IFwiZ2VuZXJhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGUodCkge1xuICAgICAgdmFyIGUgPSB0LnRvTG93ZXJDYXNlKCksXG4gICAgICAgIHMgPSB0aGlzLmRldGVjdENoYXJ0VHlwZShlKSxcbiAgICAgICAgbiA9IHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0LnNsaWNlKDEpLFxuICAgICAgICBfdGhpcyRnZW5lcmF0ZURhdGFzZXQgPSB0aGlzLmdlbmVyYXRlRGF0YXNldChlKSxcbiAgICAgICAgbyA9IF90aGlzJGdlbmVyYXRlRGF0YXNldC5sYWJlbHMsXG4gICAgICAgIHIgPSBfdGhpcyRnZW5lcmF0ZURhdGFzZXQuZGF0YXNldHMsXG4gICAgICAgIGEgPSBfdGhpcyRnZW5lcmF0ZURhdGFzZXQuZGF0YXNldDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNoYXJ0U3BlYzoge1xuICAgICAgICAgIHR5cGU6IHMsXG4gICAgICAgICAgdGl0bGU6IG4sXG4gICAgICAgICAgeEF4aXM6IHtcbiAgICAgICAgICAgIGxhYmVsOiBcIkNhdGVnb3J5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHlBeGlzOiB7XG4gICAgICAgICAgICBsYWJlbDogXCJWYWx1ZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHIubGVuZ3RoID4gMSB8fCBzID09PSBcInBpZVwiIHx8IHMgPT09IFwiZG91Z2hudXRcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcInRvcFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgbGFiZWxzOiBvLFxuICAgICAgICAgIGRhdGFzZXRzOiByXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgZ2VuZXJhdGVkQXQ6ICgvKiBAX19QVVJFX18gKi9uZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIGRhdGFzZXQ6IGEsXG4gICAgICAgICAgcmVjb3JkQ291bnQ6IG8ubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRldGVjdENoYXJ0VHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRlY3RDaGFydFR5cGUodCkge1xuICAgICAgcmV0dXJuIHQuaW5jbHVkZXMoXCJwaWVcIikgPyBcInBpZVwiIDogdC5pbmNsdWRlcyhcImRvdWdobnV0XCIpIHx8IHQuaW5jbHVkZXMoXCJkb251dFwiKSA/IFwiZG91Z2hudXRcIiA6IHQuaW5jbHVkZXMoXCJsaW5lXCIpIHx8IHQuaW5jbHVkZXMoXCJ0cmVuZFwiKSA/IFwibGluZVwiIDogdC5pbmNsdWRlcyhcImFyZWFcIikgPyBcImFyZWFcIiA6IHQuaW5jbHVkZXMoXCJzY2F0dGVyXCIpID8gXCJzY2F0dGVyXCIgOiBcImJhclwiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZURhdGFzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVEYXRhc2V0KHQpIHtcbiAgICAgIHJldHVybiB0LmluY2x1ZGVzKFwibW9udGhcIikgfHwgdC5pbmNsdWRlcyhcInllYXJcIikgPyB0aGlzLmdlbmVyYXRlTW9udGhseURhdGEodCkgOiB0LmluY2x1ZGVzKFwicHJvZHVjdFwiKSB8fCB0LmluY2x1ZGVzKFwicmV2ZW51ZVwiKSA/IHRoaXMuZ2VuZXJhdGVQcm9kdWN0UmV2ZW51ZURhdGEoKSA6IHQuaW5jbHVkZXMoXCJzdGF0dXNcIikgfHwgdC5pbmNsdWRlcyhcIm9yZGVyXCIpID8gdGhpcy5nZW5lcmF0ZU9yZGVyU3RhdHVzRGF0YSgpIDogdC5pbmNsdWRlcyhcInNpZ251cFwiKSB8fCB0LmluY2x1ZGVzKFwidXNlclwiKSA/IHRoaXMuZ2VuZXJhdGVVc2VyU2lnbnVwRGF0YSgpIDogdC5pbmNsdWRlcyhcInByb2ZpdFwiKSB8fCB0LmluY2x1ZGVzKFwidG9wXCIpID8gdGhpcy5nZW5lcmF0ZVByb2ZpdERhdGEoKSA6IHRoaXMuZ2VuZXJhdGVEZWZhdWx0RGF0YSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZU1vbnRobHlEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlTW9udGhseURhdGEodCkge1xuICAgICAgdmFyIGUgPSBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl07XG4gICAgICByZXR1cm4gdC5pbmNsdWRlcyhcInJlZ2lvblwiKSA/IHtcbiAgICAgICAgbGFiZWxzOiBlLFxuICAgICAgICBkYXRhc2V0czogW3tcbiAgICAgICAgICBsYWJlbDogXCJOb3J0aFwiLFxuICAgICAgICAgIGRhdGE6IFs2NSwgNzgsIDkwLCA4MSwgOTYsIDEwNSwgMTEwLCAxMDIsIDk1LCA4OCwgOTIsIDEwOF0sXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzYjgyZjZcIixcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCIjM2I4MmY2XCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGxhYmVsOiBcIlNvdXRoXCIsXG4gICAgICAgICAgZGF0YTogWzQ1LCA1MiwgNjAsIDU1LCA3MCwgODIsIDg4LCA4MCwgNzIsIDY1LCA3MCwgODVdLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMTBiOTgxXCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzEwYjk4MVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBsYWJlbDogXCJFYXN0XCIsXG4gICAgICAgICAgZGF0YTogWzM1LCA0MCwgNDgsIDQ1LCA1NSwgNjIsIDY4LCA2MCwgNTUsIDUwLCA1MiwgNjVdLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjU5ZTBiXCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwiI2Y1OWUwYlwiXG4gICAgICAgIH1dLFxuICAgICAgICBkYXRhc2V0OiBcInNhbGVzX2J5X3JlZ2lvblwiXG4gICAgICB9IDoge1xuICAgICAgICBsYWJlbHM6IGUsXG4gICAgICAgIGRhdGFzZXRzOiBbe1xuICAgICAgICAgIGxhYmVsOiBcIlZhbHVlXCIsXG4gICAgICAgICAgZGF0YTogWzY1LCA3OCwgOTAsIDgxLCA5NiwgMTA1LCAxMTAsIDEwMiwgOTUsIDg4LCA5MiwgMTA4XSxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzNiODJmNlwiLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiMzYjgyZjZcIlxuICAgICAgICB9XSxcbiAgICAgICAgZGF0YXNldDogXCJtb250aGx5X2RhdGFcIlxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VuZXJhdGVQcm9kdWN0UmV2ZW51ZURhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVQcm9kdWN0UmV2ZW51ZURhdGEoKSB7XG4gICAgICB2YXIgdCA9IFtcIlByb2R1Y3QgQVwiLCBcIlByb2R1Y3QgQlwiLCBcIlByb2R1Y3QgQ1wiLCBcIlByb2R1Y3QgRFwiLCBcIlByb2R1Y3QgRVwiXSxcbiAgICAgICAgZSA9IFtcIiMzYjgyZjZcIiwgXCIjMTBiOTgxXCIsIFwiI2Y1OWUwYlwiLCBcIiNlZjQ0NDRcIiwgXCIjOGI1Y2Y2XCJdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFiZWxzOiB0LFxuICAgICAgICBkYXRhc2V0czogW3tcbiAgICAgICAgICBsYWJlbDogXCJSZXZlbnVlXCIsXG4gICAgICAgICAgZGF0YTogWzQyZTMsIDM1ZTMsIDI4ZTMsIDIxZTMsIDE1ZTNdLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZSxcbiAgICAgICAgICBib3JkZXJDb2xvcjogZVxuICAgICAgICB9XSxcbiAgICAgICAgZGF0YXNldDogXCJwcm9kdWN0X3JldmVudWVcIlxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VuZXJhdGVPcmRlclN0YXR1c0RhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVPcmRlclN0YXR1c0RhdGEoKSB7XG4gICAgICB2YXIgdCA9IFtcIkNvbXBsZXRlZFwiLCBcIlBlbmRpbmdcIiwgXCJQcm9jZXNzaW5nXCIsIFwiQ2FuY2VsbGVkXCJdLFxuICAgICAgICBlID0gW1wiIzEwYjk4MVwiLCBcIiNmNTllMGJcIiwgXCIjM2I4MmY2XCIsIFwiI2VmNDQ0NFwiXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhYmVsczogdCxcbiAgICAgICAgZGF0YXNldHM6IFt7XG4gICAgICAgICAgbGFiZWw6IFwiT3JkZXJzXCIsXG4gICAgICAgICAgZGF0YTogWzI0NSwgODksIDU2LCAyM10sXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiBlXG4gICAgICAgIH1dLFxuICAgICAgICBkYXRhc2V0OiBcIm9yZGVyX3N0YXR1c1wiXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZVVzZXJTaWdudXBEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlVXNlclNpZ251cERhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYWJlbHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXSxcbiAgICAgICAgZGF0YXNldHM6IFt7XG4gICAgICAgICAgbGFiZWw6IFwiU2lnbnVwc1wiLFxuICAgICAgICAgIGRhdGE6IFsxMjAsIDE0NSwgMTgwLCAyMjAsIDI5MCwgMzUwLCA0MjAsIDQ4MCwgNTIwLCA1ODAsIDY1MCwgNzIwXSxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzhiNWNmNlwiLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiM4YjVjZjZcIlxuICAgICAgICB9XSxcbiAgICAgICAgZGF0YXNldDogXCJ1c2VyX3NpZ251cHNcIlxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VuZXJhdGVQcm9maXREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlUHJvZml0RGF0YSgpIHtcbiAgICAgIHZhciB0ID0gW1wiV2lkZ2V0IFByb1wiLCBcIkdhZGdldCBYXCIsIFwiVG9vbCBNYXN0ZXJcIiwgXCJEZXZpY2UgUGx1c1wiLCBcIlNtYXJ0IEtpdFwiXSxcbiAgICAgICAgZSA9IFtcIiMzYjgyZjZcIiwgXCIjMTBiOTgxXCIsIFwiI2Y1OWUwYlwiLCBcIiNlZjQ0NDRcIiwgXCIjOGI1Y2Y2XCJdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFiZWxzOiB0LFxuICAgICAgICBkYXRhc2V0czogW3tcbiAgICAgICAgICBsYWJlbDogXCJQcm9maXRcIixcbiAgICAgICAgICBkYXRhOiBbMTg1MDAsIDE1MjAwLCAxMjgwMCwgOTUwMCwgNzIwMF0sXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiBlXG4gICAgICAgIH1dLFxuICAgICAgICBkYXRhc2V0OiBcInByb2R1Y3RfcHJvZml0XCJcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlRGVmYXVsdERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVEZWZhdWx0RGF0YSgpIHtcbiAgICAgIHZhciB0ID0gW1wiQ2F0ZWdvcnkgQVwiLCBcIkNhdGVnb3J5IEJcIiwgXCJDYXRlZ29yeSBDXCIsIFwiQ2F0ZWdvcnkgRFwiLCBcIkNhdGVnb3J5IEVcIl0sXG4gICAgICAgIGUgPSBbXCIjM2I4MmY2XCIsIFwiIzEwYjk4MVwiLCBcIiNmNTllMGJcIiwgXCIjZWY0NDQ0XCIsIFwiIzhiNWNmNlwiXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhYmVsczogdCxcbiAgICAgICAgZGF0YXNldHM6IFt7XG4gICAgICAgICAgbGFiZWw6IFwiVmFsdWVcIixcbiAgICAgICAgICBkYXRhOiBbNDIsIDM1LCAyOCwgMjEsIDE1XSxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGUsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IGVcbiAgICAgICAgfV0sXG4gICAgICAgIGRhdGFzZXQ6IFwiZGVtb19kYXRhXCJcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG59KCk7XG52YXIgWGkgPSAvKiNfX1BVUkVfXyovX2NyZWF0ZUNsYXNzKGZ1bmN0aW9uIFhpKCkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWGkpO1xufSk7XG5YaS5hdHRpYnV0ZXMgPSB7XG4gIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nKHQpIHtcbiAgICByZXR1cm4gdDtcbiAgfSxcbiAgbnVtYmVyOiBmdW5jdGlvbiBudW1iZXIodCkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHQpO1xuICB9LFxuICBcImJvb2xlYW5cIjogZnVuY3Rpb24gYm9vbGVhbih0KSB7XG4gICAgcmV0dXJuIHQgPT09IFwidHJ1ZVwiO1xuICB9LFxuICBvYmplY3Q6IGZ1bmN0aW9uIG9iamVjdCh0KSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodCk7XG4gIH0sXG4gIGFycmF5OiBmdW5jdGlvbiBhcnJheSh0KSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodCk7XG4gIH0sXG4gIFwiZnVuY3Rpb25cIjogZnVuY3Rpb24gX2Z1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwicmV0dXJuIFwiLmNvbmNhdCh0KSkoKTtcbiAgfVxufTtcbnZhciB4aSA9IFhpO1xuZnVuY3Rpb24gY3QoaSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgZSwge30pO1xuICAgIHZhciBzID0gdC5jb25zdHJ1Y3RvcixcbiAgICAgIG4gPSBlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgcy5fYXR0cmlidXRlc19bbl0gPSB4aS5hdHRpYnV0ZXNbaV0sIHMuX2F0dHJpYnV0ZVRvUHJvcGVydHlfW25dID0gZTtcbiAgfTtcbn1cbi8qIVxuICogQGt1cmtsZS9jb2xvciB2MC4zLjRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rdXJrbGUvY29sb3IjcmVhZG1lXG4gKiAoYykgMjAyNCBKdWtrYSBLdXJrZWxhXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuZnVuY3Rpb24geGUoaSkge1xuICByZXR1cm4gaSArIDAuNSB8IDA7XG59XG52YXIgeHQgPSBmdW5jdGlvbiB4dChpLCB0LCBlKSB7XG4gIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihpLCBlKSwgdCk7XG59O1xuZnVuY3Rpb24gbmUoaSkge1xuICByZXR1cm4geHQoeGUoaSAqIDIuNTUpLCAwLCAyNTUpO1xufVxuZnVuY3Rpb24gU3QoaSkge1xuICByZXR1cm4geHQoeGUoaSAqIDI1NSksIDAsIDI1NSk7XG59XG5mdW5jdGlvbiBwdChpKSB7XG4gIHJldHVybiB4dCh4ZShpIC8gMi41NSkgLyAxMDAsIDAsIDEpO1xufVxuZnVuY3Rpb24gcWkoaSkge1xuICByZXR1cm4geHQoeGUoaSAqIDEwMCksIDAsIDEwMCk7XG59XG52YXIgUSA9IHtcbiAgICAwOiAwLFxuICAgIDE6IDEsXG4gICAgMjogMixcbiAgICAzOiAzLFxuICAgIDQ6IDQsXG4gICAgNTogNSxcbiAgICA2OiA2LFxuICAgIDc6IDcsXG4gICAgODogOCxcbiAgICA5OiA5LFxuICAgIEE6IDEwLFxuICAgIEI6IDExLFxuICAgIEM6IDEyLFxuICAgIEQ6IDEzLFxuICAgIEU6IDE0LFxuICAgIEY6IDE1LFxuICAgIGE6IDEwLFxuICAgIGI6IDExLFxuICAgIGM6IDEyLFxuICAgIGQ6IDEzLFxuICAgIGU6IDE0LFxuICAgIGY6IDE1XG4gIH0sXG4gIHlpID0gX3RvQ29uc3VtYWJsZUFycmF5KFwiMDEyMzQ1Njc4OUFCQ0RFRlwiKSxcbiAgaG8gPSBmdW5jdGlvbiBobyhpKSB7XG4gICAgcmV0dXJuIHlpW2kgJiAxNV07XG4gIH0sXG4gIHVvID0gZnVuY3Rpb24gdW8oaSkge1xuICAgIHJldHVybiB5aVsoaSAmIDI0MCkgPj4gNF0gKyB5aVtpICYgMTVdO1xuICB9LFxuICB2ZSA9IGZ1bmN0aW9uIHZlKGkpIHtcbiAgICByZXR1cm4gKGkgJiAyNDApID4+IDQgPT09IChpICYgMTUpO1xuICB9LFxuICBmbyA9IGZ1bmN0aW9uIGZvKGkpIHtcbiAgICByZXR1cm4gdmUoaS5yKSAmJiB2ZShpLmcpICYmIHZlKGkuYikgJiYgdmUoaS5hKTtcbiAgfTtcbmZ1bmN0aW9uIGdvKGkpIHtcbiAgdmFyIHQgPSBpLmxlbmd0aCxcbiAgICBlO1xuICByZXR1cm4gaVswXSA9PT0gXCIjXCIgJiYgKHQgPT09IDQgfHwgdCA9PT0gNSA/IGUgPSB7XG4gICAgcjogMjU1ICYgUVtpWzFdXSAqIDE3LFxuICAgIGc6IDI1NSAmIFFbaVsyXV0gKiAxNyxcbiAgICBiOiAyNTUgJiBRW2lbM11dICogMTcsXG4gICAgYTogdCA9PT0gNSA/IFFbaVs0XV0gKiAxNyA6IDI1NVxuICB9IDogKHQgPT09IDcgfHwgdCA9PT0gOSkgJiYgKGUgPSB7XG4gICAgcjogUVtpWzFdXSA8PCA0IHwgUVtpWzJdXSxcbiAgICBnOiBRW2lbM11dIDw8IDQgfCBRW2lbNF1dLFxuICAgIGI6IFFbaVs1XV0gPDwgNCB8IFFbaVs2XV0sXG4gICAgYTogdCA9PT0gOSA/IFFbaVs3XV0gPDwgNCB8IFFbaVs4XV0gOiAyNTVcbiAgfSkpLCBlO1xufVxudmFyIHBvID0gZnVuY3Rpb24gcG8oaSwgdCkge1xuICByZXR1cm4gaSA8IDI1NSA/IHQoaSkgOiBcIlwiO1xufTtcbmZ1bmN0aW9uIG1vKGkpIHtcbiAgdmFyIHQgPSBmbyhpKSA/IGhvIDogdW87XG4gIHJldHVybiBpID8gXCIjXCIgKyB0KGkucikgKyB0KGkuZykgKyB0KGkuYikgKyBwbyhpLmEsIHQpIDogdm9pZCAwO1xufVxudmFyIGJvID0gL14oaHNsYT98aHdifGhzdilcXChcXHMqKFstKy5lXFxkXSspKD86ZGVnKT9bXFxzLF0rKFstKy5lXFxkXSspJVtcXHMsXSsoWy0rLmVcXGRdKyklKD86W1xccyxdKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcbmZ1bmN0aW9uIGduKGksIHQsIGUpIHtcbiAgdmFyIHMgPSB0ICogTWF0aC5taW4oZSwgMSAtIGUpLFxuICAgIG4gPSBmdW5jdGlvbiBuKG8pIHtcbiAgICAgIHZhciByID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAobyArIGkgLyAzMCkgJSAxMjtcbiAgICAgIHJldHVybiBlIC0gcyAqIE1hdGgubWF4KE1hdGgubWluKHIgLSAzLCA5IC0gciwgMSksIC0xKTtcbiAgICB9O1xuICByZXR1cm4gW24oMCksIG4oOCksIG4oNCldO1xufVxuZnVuY3Rpb24gX28oaSwgdCwgZSkge1xuICB2YXIgcyA9IGZ1bmN0aW9uIHMobikge1xuICAgIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAobiArIGkgLyA2MCkgJSA2O1xuICAgIHJldHVybiBlIC0gZSAqIHQgKiBNYXRoLm1heChNYXRoLm1pbihvLCA0IC0gbywgMSksIDApO1xuICB9O1xuICByZXR1cm4gW3MoNSksIHMoMyksIHMoMSldO1xufVxuZnVuY3Rpb24geG8oaSwgdCwgZSkge1xuICB2YXIgcyA9IGduKGksIDEsIDAuNSk7XG4gIHZhciBuO1xuICBmb3IgKHQgKyBlID4gMSAmJiAobiA9IDEgLyAodCArIGUpLCB0ICo9IG4sIGUgKj0gbiksIG4gPSAwOyBuIDwgMzsgbisrKSBzW25dICo9IDEgLSB0IC0gZSwgc1tuXSArPSB0O1xuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIHlvKGksIHQsIGUsIHMsIG4pIHtcbiAgcmV0dXJuIGkgPT09IG4gPyAodCAtIGUpIC8gcyArICh0IDwgZSA/IDYgOiAwKSA6IHQgPT09IG4gPyAoZSAtIGkpIC8gcyArIDIgOiAoaSAtIHQpIC8gcyArIDQ7XG59XG5mdW5jdGlvbiBSaShpKSB7XG4gIHZhciBlID0gaS5yIC8gMjU1LFxuICAgIHMgPSBpLmcgLyAyNTUsXG4gICAgbiA9IGkuYiAvIDI1NSxcbiAgICBvID0gTWF0aC5tYXgoZSwgcywgbiksXG4gICAgciA9IE1hdGgubWluKGUsIHMsIG4pLFxuICAgIGEgPSAobyArIHIpIC8gMjtcbiAgdmFyIGwsIGMsIGg7XG4gIHJldHVybiBvICE9PSByICYmIChoID0gbyAtIHIsIGMgPSBhID4gMC41ID8gaCAvICgyIC0gbyAtIHIpIDogaCAvIChvICsgciksIGwgPSB5byhlLCBzLCBuLCBoLCBvKSwgbCA9IGwgKiA2MCArIDAuNSksIFtsIHwgMCwgYyB8fCAwLCBhXTtcbn1cbmZ1bmN0aW9uIExpKGksIHQsIGUsIHMpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5KHQpID8gaSh0WzBdLCB0WzFdLCB0WzJdKSA6IGkodCwgZSwgcykpLm1hcChTdCk7XG59XG5mdW5jdGlvbiBFaShpLCB0LCBlKSB7XG4gIHJldHVybiBMaShnbiwgaSwgdCwgZSk7XG59XG5mdW5jdGlvbiB2byhpLCB0LCBlKSB7XG4gIHJldHVybiBMaSh4bywgaSwgdCwgZSk7XG59XG5mdW5jdGlvbiBNbyhpLCB0LCBlKSB7XG4gIHJldHVybiBMaShfbywgaSwgdCwgZSk7XG59XG5mdW5jdGlvbiBwbihpKSB7XG4gIHJldHVybiAoaSAlIDM2MCArIDM2MCkgJSAzNjA7XG59XG5mdW5jdGlvbiBTbyhpKSB7XG4gIHZhciB0ID0gYm8uZXhlYyhpKTtcbiAgdmFyIGUgPSAyNTUsXG4gICAgcztcbiAgaWYgKCF0KSByZXR1cm47XG4gIHRbNV0gIT09IHMgJiYgKGUgPSB0WzZdID8gbmUoK3RbNV0pIDogU3QoK3RbNV0pKTtcbiAgdmFyIG4gPSBwbigrdFsyXSksXG4gICAgbyA9ICt0WzNdIC8gMTAwLFxuICAgIHIgPSArdFs0XSAvIDEwMDtcbiAgcmV0dXJuIHRbMV0gPT09IFwiaHdiXCIgPyBzID0gdm8obiwgbywgcikgOiB0WzFdID09PSBcImhzdlwiID8gcyA9IE1vKG4sIG8sIHIpIDogcyA9IEVpKG4sIG8sIHIpLCB7XG4gICAgcjogc1swXSxcbiAgICBnOiBzWzFdLFxuICAgIGI6IHNbMl0sXG4gICAgYTogZVxuICB9O1xufVxuZnVuY3Rpb24ga28oaSwgdCkge1xuICB2YXIgZSA9IFJpKGkpO1xuICBlWzBdID0gcG4oZVswXSArIHQpLCBlID0gRWkoZSksIGkuciA9IGVbMF0sIGkuZyA9IGVbMV0sIGkuYiA9IGVbMl07XG59XG5mdW5jdGlvbiB3byhpKSB7XG4gIGlmICghaSkgcmV0dXJuO1xuICB2YXIgdCA9IFJpKGkpLFxuICAgIGUgPSB0WzBdLFxuICAgIHMgPSBxaSh0WzFdKSxcbiAgICBuID0gcWkodFsyXSk7XG4gIHJldHVybiBpLmEgPCAyNTUgPyBcImhzbGEoXCIuY29uY2F0KGUsIFwiLCBcIikuY29uY2F0KHMsIFwiJSwgXCIpLmNvbmNhdChuLCBcIiUsIFwiKS5jb25jYXQocHQoaS5hKSwgXCIpXCIpIDogXCJoc2woXCIuY29uY2F0KGUsIFwiLCBcIikuY29uY2F0KHMsIFwiJSwgXCIpLmNvbmNhdChuLCBcIiUpXCIpO1xufVxudmFyIEtpID0ge1xuICAgIHg6IFwiZGFya1wiLFxuICAgIFo6IFwibGlnaHRcIixcbiAgICBZOiBcInJlXCIsXG4gICAgWDogXCJibHVcIixcbiAgICBXOiBcImdyXCIsXG4gICAgVjogXCJtZWRpdW1cIixcbiAgICBVOiBcInNsYXRlXCIsXG4gICAgQTogXCJlZVwiLFxuICAgIFQ6IFwib2xcIixcbiAgICBTOiBcIm9yXCIsXG4gICAgQjogXCJyYVwiLFxuICAgIEM6IFwibGF0ZWdcIixcbiAgICBEOiBcImlnaHRzXCIsXG4gICAgUjogXCJpblwiLFxuICAgIFE6IFwidHVycXVvaXNcIixcbiAgICBFOiBcImhpXCIsXG4gICAgUDogXCJyb1wiLFxuICAgIE86IFwiYWxcIixcbiAgICBOOiBcImxlXCIsXG4gICAgTTogXCJkZVwiLFxuICAgIEw6IFwieWVsbG9cIixcbiAgICBGOiBcImVuXCIsXG4gICAgSzogXCJjaFwiLFxuICAgIEc6IFwiYXJrc1wiLFxuICAgIEg6IFwiZWFcIixcbiAgICBJOiBcImlnaHRnXCIsXG4gICAgSjogXCJ3aFwiXG4gIH0sXG4gIEdpID0ge1xuICAgIE9pY2VYZTogXCJmMGY4ZmZcIixcbiAgICBhbnRpcXVld0V0ZTogXCJmYWViZDdcIixcbiAgICBhcXVhOiBcImZmZmZcIixcbiAgICBhcXVhbWFyUmU6IFwiN2ZmZmQ0XCIsXG4gICAgYXp1WTogXCJmMGZmZmZcIixcbiAgICBiZWlnZTogXCJmNWY1ZGNcIixcbiAgICBiaXNxdWU6IFwiZmZlNGM0XCIsXG4gICAgYmxhY2s6IFwiMFwiLFxuICAgIGJsYW5LZWRPbW9uZDogXCJmZmViY2RcIixcbiAgICBYZTogXCJmZlwiLFxuICAgIFhldmlUZXQ6IFwiOGEyYmUyXCIsXG4gICAgYlB3bjogXCJhNTJhMmFcIixcbiAgICBidXJseXdvb2Q6IFwiZGViODg3XCIsXG4gICAgY2FNdFhlOiBcIjVmOWVhMFwiLFxuICAgIEthcnRZdXNlOiBcIjdmZmYwMFwiLFxuICAgIEtvY1RhdGU6IFwiZDI2OTFlXCIsXG4gICAgY1NPOiBcImZmN2Y1MFwiLFxuICAgIGNTbmZsb3dlclhlOiBcIjY0OTVlZFwiLFxuICAgIGNTbnNpbGs6IFwiZmZmOGRjXCIsXG4gICAgY3JpbXNvbjogXCJkYzE0M2NcIixcbiAgICBjeWFuOiBcImZmZmZcIixcbiAgICB4WGU6IFwiOGJcIixcbiAgICB4Y3lhbjogXCI4YjhiXCIsXG4gICAgeGdUTW5QZDogXCJiODg2MGJcIixcbiAgICB4V2F5OiBcImE5YTlhOVwiLFxuICAgIHhnWUY6IFwiNjQwMFwiLFxuICAgIHhnWXk6IFwiYTlhOWE5XCIsXG4gICAgeGtoYWtpOiBcImJkYjc2YlwiLFxuICAgIHhtYWdGdGE6IFwiOGIwMDhiXCIsXG4gICAgeFRpdmVnWUY6IFwiNTU2YjJmXCIsXG4gICAgeFNhbmdlOiBcImZmOGMwMFwiLFxuICAgIHhTY0VkOiBcIjk5MzJjY1wiLFxuICAgIHhZZDogXCI4YjAwMDBcIixcbiAgICB4c09tb246IFwiZTk5NjdhXCIsXG4gICAgeHNIZ1lGOiBcIjhmYmM4ZlwiLFxuICAgIHhVWGU6IFwiNDgzZDhiXCIsXG4gICAgeFVXYXk6IFwiMmY0ZjRmXCIsXG4gICAgeFVnWXk6IFwiMmY0ZjRmXCIsXG4gICAgeFFlOiBcImNlZDFcIixcbiAgICB4dmlUZXQ6IFwiOTQwMGQzXCIsXG4gICAgZEFwcFJrOiBcImZmMTQ5M1wiLFxuICAgIGRBcHNreVhlOiBcImJmZmZcIixcbiAgICBkaW1XYXk6IFwiNjk2OTY5XCIsXG4gICAgZGltZ1l5OiBcIjY5Njk2OVwiLFxuICAgIGRvZGdlclhlOiBcIjFlOTBmZlwiLFxuICAgIGZpWWJyaWNrOiBcImIyMjIyMlwiLFxuICAgIGZsU093RXRlOiBcImZmZmFmMFwiLFxuICAgIGZvWXN0V0FuOiBcIjIyOGIyMlwiLFxuICAgIGZ1S3NpYTogXCJmZjAwZmZcIixcbiAgICBnYVJzYlNvOiBcImRjZGNkY1wiLFxuICAgIGdob3N0d0V0ZTogXCJmOGY4ZmZcIixcbiAgICBnVGQ6IFwiZmZkNzAwXCIsXG4gICAgZ1RNblBkOiBcImRhYTUyMFwiLFxuICAgIFdheTogXCI4MDgwODBcIixcbiAgICBnWUY6IFwiODAwMFwiLFxuICAgIGdZRkx3OiBcImFkZmYyZlwiLFxuICAgIGdZeTogXCI4MDgwODBcIixcbiAgICBob25leU13OiBcImYwZmZmMFwiLFxuICAgIGhvdHBSazogXCJmZjY5YjRcIixcbiAgICBSZGlhbllkOiBcImNkNWM1Y1wiLFxuICAgIFJkaWdvOiBcIjRiMDA4MlwiLFxuICAgIGl2U3k6IFwiZmZmZmYwXCIsXG4gICAga2hha2k6IFwiZjBlNjhjXCIsXG4gICAgbGF2Rk1yOiBcImU2ZTZmYVwiLFxuICAgIGxhdkZNclhzaDogXCJmZmYwZjVcIixcbiAgICBsYXduZ1lGOiBcIjdjZmMwMFwiLFxuICAgIE5tb25jRWZmb246IFwiZmZmYWNkXCIsXG4gICAgWlhlOiBcImFkZDhlNlwiLFxuICAgIFpjU086IFwiZjA4MDgwXCIsXG4gICAgWmN5YW46IFwiZTBmZmZmXCIsXG4gICAgWmdUTW5QZEx3OiBcImZhZmFkMlwiLFxuICAgIFpXYXk6IFwiZDNkM2QzXCIsXG4gICAgWmdZRjogXCI5MGVlOTBcIixcbiAgICBaZ1l5OiBcImQzZDNkM1wiLFxuICAgIFpwUms6IFwiZmZiNmMxXCIsXG4gICAgWnNPbW9uOiBcImZmYTA3YVwiLFxuICAgIFpzSGdZRjogXCIyMGIyYWFcIixcbiAgICBac2t5WGU6IFwiODdjZWZhXCIsXG4gICAgWlVXYXk6IFwiNzc4ODk5XCIsXG4gICAgWlVnWXk6IFwiNzc4ODk5XCIsXG4gICAgWnN0QWxYZTogXCJiMGM0ZGVcIixcbiAgICBaTHc6IFwiZmZmZmUwXCIsXG4gICAgbGltZTogXCJmZjAwXCIsXG4gICAgbGltZWdZRjogXCIzMmNkMzJcIixcbiAgICBsUkY6IFwiZmFmMGU2XCIsXG4gICAgbWFnRnRhOiBcImZmMDBmZlwiLFxuICAgIG1hUG9uOiBcIjgwMDAwMFwiLFxuICAgIFZhcXVhbWFyUmU6IFwiNjZjZGFhXCIsXG4gICAgVlhlOiBcImNkXCIsXG4gICAgVlNjRWQ6IFwiYmE1NWQzXCIsXG4gICAgVnB1cnBOOiBcIjkzNzBkYlwiLFxuICAgIFZzSGdZRjogXCIzY2IzNzFcIixcbiAgICBWVVhlOiBcIjdiNjhlZVwiLFxuICAgIFZzcHJSZ2dZRjogXCJmYTlhXCIsXG4gICAgVlFlOiBcIjQ4ZDFjY1wiLFxuICAgIFZ2aVRldFlkOiBcImM3MTU4NVwiLFxuICAgIG1pZG5pZ2h0WGU6IFwiMTkxOTcwXCIsXG4gICAgbVJ0Y1lhbTogXCJmNWZmZmFcIixcbiAgICBtaXN0eVBzZTogXCJmZmU0ZTFcIixcbiAgICBtb2NjYXNSOiBcImZmZTRiNVwiLFxuICAgIG5hdmFqb3dFdGU6IFwiZmZkZWFkXCIsXG4gICAgbmF2eTogXCI4MFwiLFxuICAgIFRkbGFjZTogXCJmZGY1ZTZcIixcbiAgICBUaXZlOiBcIjgwODAwMFwiLFxuICAgIFRpdmVkQmI6IFwiNmI4ZTIzXCIsXG4gICAgU2FuZ2U6IFwiZmZhNTAwXCIsXG4gICAgU2FuZ2VZZDogXCJmZjQ1MDBcIixcbiAgICBTY0VkOiBcImRhNzBkNlwiLFxuICAgIHBPZWdUTW5QZDogXCJlZWU4YWFcIixcbiAgICBwT2VnWUY6IFwiOThmYjk4XCIsXG4gICAgcE9lUWU6IFwiYWZlZWVlXCIsXG4gICAgcE9ldmlUZXRZZDogXCJkYjcwOTNcIixcbiAgICBwYXBheWF3RXA6IFwiZmZlZmQ1XCIsXG4gICAgcEhLcHVmZjogXCJmZmRhYjlcIixcbiAgICBwZXJ1OiBcImNkODUzZlwiLFxuICAgIHBSazogXCJmZmMwY2JcIixcbiAgICBwbHVtOiBcImRkYTBkZFwiLFxuICAgIHBvd01yWGU6IFwiYjBlMGU2XCIsXG4gICAgcHVycE46IFwiODAwMDgwXCIsXG4gICAgWWJlY2NhcHVycE46IFwiNjYzMzk5XCIsXG4gICAgWWQ6IFwiZmYwMDAwXCIsXG4gICAgUHN5YnJvd246IFwiYmM4ZjhmXCIsXG4gICAgUHlPWGU6IFwiNDE2OWUxXCIsXG4gICAgc2FkZE5iUHduOiBcIjhiNDUxM1wiLFxuICAgIHNPbW9uOiBcImZhODA3MlwiLFxuICAgIHNhbmR5YlB3bjogXCJmNGE0NjBcIixcbiAgICBzSGdZRjogXCIyZThiNTdcIixcbiAgICBzSHNoZWxsOiBcImZmZjVlZVwiLFxuICAgIHNpRm5hOiBcImEwNTIyZFwiLFxuICAgIHNpbHZlcjogXCJjMGMwYzBcIixcbiAgICBza3lYZTogXCI4N2NlZWJcIixcbiAgICBVWGU6IFwiNmE1YWNkXCIsXG4gICAgVVdheTogXCI3MDgwOTBcIixcbiAgICBVZ1l5OiBcIjcwODA5MFwiLFxuICAgIHNub3c6IFwiZmZmYWZhXCIsXG4gICAgc3ByUmdnWUY6IFwiZmY3ZlwiLFxuICAgIHN0QWxYZTogXCI0NjgyYjRcIixcbiAgICB0YW46IFwiZDJiNDhjXCIsXG4gICAgdGVPOiBcIjgwODBcIixcbiAgICB0RXN0TjogXCJkOGJmZDhcIixcbiAgICB0b21hdG86IFwiZmY2MzQ3XCIsXG4gICAgUWU6IFwiNDBlMGQwXCIsXG4gICAgdmlUZXQ6IFwiZWU4MmVlXCIsXG4gICAgSkh0OiBcImY1ZGViM1wiLFxuICAgIHdFdGU6IFwiZmZmZmZmXCIsXG4gICAgd0V0ZXNtb2tlOiBcImY1ZjVmNVwiLFxuICAgIEx3OiBcImZmZmYwMFwiLFxuICAgIEx3Z1lGOiBcIjlhY2QzMlwiXG4gIH07XG5mdW5jdGlvbiBQbygpIHtcbiAgdmFyIGkgPSB7fSxcbiAgICB0ID0gT2JqZWN0LmtleXMoR2kpLFxuICAgIGUgPSBPYmplY3Qua2V5cyhLaSk7XG4gIHZhciBzLCBuLCBvLCByLCBhO1xuICBmb3IgKHMgPSAwOyBzIDwgdC5sZW5ndGg7IHMrKykge1xuICAgIGZvciAociA9IGEgPSB0W3NdLCBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIG8gPSBlW25dLCBhID0gYS5yZXBsYWNlKG8sIEtpW29dKTtcbiAgICBvID0gcGFyc2VJbnQoR2lbcl0sIDE2KSwgaVthXSA9IFtvID4+IDE2ICYgMjU1LCBvID4+IDggJiAyNTUsIG8gJiAyNTVdO1xuICB9XG4gIHJldHVybiBpO1xufVxudmFyIE1lO1xuZnVuY3Rpb24gRG8oaSkge1xuICBNZSB8fCAoTWUgPSBQbygpLCBNZS50cmFuc3BhcmVudCA9IFswLCAwLCAwLCAwXSk7XG4gIHZhciB0ID0gTWVbaS50b0xvd2VyQ2FzZSgpXTtcbiAgcmV0dXJuIHQgJiYge1xuICAgIHI6IHRbMF0sXG4gICAgZzogdFsxXSxcbiAgICBiOiB0WzJdLFxuICAgIGE6IHQubGVuZ3RoID09PSA0ID8gdFszXSA6IDI1NVxuICB9O1xufVxudmFyIENvID0gL15yZ2JhP1xcKFxccyooWy0rLlxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/KD86W1xccywvXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiBPbyhpKSB7XG4gIHZhciB0ID0gQ28uZXhlYyhpKTtcbiAgdmFyIGUgPSAyNTUsXG4gICAgcyxcbiAgICBuLFxuICAgIG87XG4gIGlmICh0KSB7XG4gICAgaWYgKHRbN10gIT09IHMpIHtcbiAgICAgIHZhciByID0gK3RbN107XG4gICAgICBlID0gdFs4XSA/IG5lKHIpIDogeHQociAqIDI1NSwgMCwgMjU1KTtcbiAgICB9XG4gICAgcmV0dXJuIHMgPSArdFsxXSwgbiA9ICt0WzNdLCBvID0gK3RbNV0sIHMgPSAyNTUgJiAodFsyXSA/IG5lKHMpIDogeHQocywgMCwgMjU1KSksIG4gPSAyNTUgJiAodFs0XSA/IG5lKG4pIDogeHQobiwgMCwgMjU1KSksIG8gPSAyNTUgJiAodFs2XSA/IG5lKG8pIDogeHQobywgMCwgMjU1KSksIHtcbiAgICAgIHI6IHMsXG4gICAgICBnOiBuLFxuICAgICAgYjogbyxcbiAgICAgIGE6IGVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBUbyhpKSB7XG4gIHJldHVybiBpICYmIChpLmEgPCAyNTUgPyBcInJnYmEoXCIuY29uY2F0KGkuciwgXCIsIFwiKS5jb25jYXQoaS5nLCBcIiwgXCIpLmNvbmNhdChpLmIsIFwiLCBcIikuY29uY2F0KHB0KGkuYSksIFwiKVwiKSA6IFwicmdiKFwiLmNvbmNhdChpLnIsIFwiLCBcIikuY29uY2F0KGkuZywgXCIsIFwiKS5jb25jYXQoaS5iLCBcIilcIikpO1xufVxudmFyIHNpID0gZnVuY3Rpb24gc2koaSkge1xuICAgIHJldHVybiBpIDw9IDMxMzA4ZS03ID8gaSAqIDEyLjkyIDogTWF0aC5wb3coaSwgMSAvIDIuNCkgKiAxLjA1NSAtIDAuMDU1O1xuICB9LFxuICBOdCA9IGZ1bmN0aW9uIE50KGkpIHtcbiAgICByZXR1cm4gaSA8PSAwLjA0MDQ1ID8gaSAvIDEyLjkyIDogTWF0aC5wb3coKGkgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgfTtcbmZ1bmN0aW9uIEFvKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBOdChwdChpLnIpKSxcbiAgICBuID0gTnQocHQoaS5nKSksXG4gICAgbyA9IE50KHB0KGkuYikpO1xuICByZXR1cm4ge1xuICAgIHI6IFN0KHNpKHMgKyBlICogKE50KHB0KHQucikpIC0gcykpKSxcbiAgICBnOiBTdChzaShuICsgZSAqIChOdChwdCh0LmcpKSAtIG4pKSksXG4gICAgYjogU3Qoc2kobyArIGUgKiAoTnQocHQodC5iKSkgLSBvKSkpLFxuICAgIGE6IGkuYSArIGUgKiAodC5hIC0gaS5hKVxuICB9O1xufVxuZnVuY3Rpb24gU2UoaSwgdCwgZSkge1xuICBpZiAoaSkge1xuICAgIHZhciBzID0gUmkoaSk7XG4gICAgc1t0XSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNbdF0gKyBzW3RdICogZSwgdCA9PT0gMCA/IDM2MCA6IDEpKSwgcyA9IEVpKHMpLCBpLnIgPSBzWzBdLCBpLmcgPSBzWzFdLCBpLmIgPSBzWzJdO1xuICB9XG59XG5mdW5jdGlvbiBtbihpLCB0KSB7XG4gIHJldHVybiBpICYmIE9iamVjdC5hc3NpZ24odCB8fCB7fSwgaSk7XG59XG5mdW5jdGlvbiBKaShpKSB7XG4gIHZhciB0ID0ge1xuICAgIHI6IDAsXG4gICAgZzogMCxcbiAgICBiOiAwLFxuICAgIGE6IDI1NVxuICB9O1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShpKSA/IGkubGVuZ3RoID49IDMgJiYgKHQgPSB7XG4gICAgcjogaVswXSxcbiAgICBnOiBpWzFdLFxuICAgIGI6IGlbMl0sXG4gICAgYTogMjU1XG4gIH0sIGkubGVuZ3RoID4gMyAmJiAodC5hID0gU3QoaVszXSkpKSA6ICh0ID0gbW4oaSwge1xuICAgIHI6IDAsXG4gICAgZzogMCxcbiAgICBiOiAwLFxuICAgIGE6IDFcbiAgfSksIHQuYSA9IFN0KHQuYSkpLCB0O1xufVxuZnVuY3Rpb24gUm8oaSkge1xuICByZXR1cm4gaS5jaGFyQXQoMCkgPT09IFwiclwiID8gT28oaSkgOiBTbyhpKTtcbn1cbnZhciB1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHVlKHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgdWUpO1xuICAgIGlmICh0IGluc3RhbmNlb2YgdWUpIHJldHVybiB0O1xuICAgIHZhciBlID0gX3R5cGVvZih0KTtcbiAgICB2YXIgcztcbiAgICBlID09PSBcIm9iamVjdFwiID8gcyA9IEppKHQpIDogZSA9PT0gXCJzdHJpbmdcIiAmJiAocyA9IGdvKHQpIHx8IERvKHQpIHx8IFJvKHQpKSwgdGhpcy5fcmdiID0gcywgdGhpcy5fdmFsaWQgPSAhIXM7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyh1ZSwgW3tcbiAgICBrZXk6IFwidmFsaWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWxpZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmdiXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgdCA9IG1uKHRoaXMuX3JnYik7XG4gICAgICByZXR1cm4gdCAmJiAodC5hID0gcHQodC5hKSksIHQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0KSB7XG4gICAgICB0aGlzLl9yZ2IgPSBKaSh0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmdiU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJnYlN0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWxpZCA/IFRvKHRoaXMuX3JnYikgOiB2b2lkIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhleFN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZXhTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyBtbyh0aGlzLl9yZ2IpIDogdm9pZCAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoc2xTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaHNsU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gd28odGhpcy5fcmdiKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWl4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1peCh0LCBlKSB7XG4gICAgICBpZiAodCkge1xuICAgICAgICB2YXIgcyA9IHRoaXMucmdiLFxuICAgICAgICAgIG4gPSB0LnJnYjtcbiAgICAgICAgdmFyIG87XG4gICAgICAgIHZhciByID0gZSA9PT0gbyA/IDAuNSA6IGUsXG4gICAgICAgICAgYSA9IDIgKiByIC0gMSxcbiAgICAgICAgICBsID0gcy5hIC0gbi5hLFxuICAgICAgICAgIGMgPSAoKGEgKiBsID09PSAtMSA/IGEgOiAoYSArIGwpIC8gKDEgKyBhICogbCkpICsgMSkgLyAyO1xuICAgICAgICBvID0gMSAtIGMsIHMuciA9IDI1NSAmIGMgKiBzLnIgKyBvICogbi5yICsgMC41LCBzLmcgPSAyNTUgJiBjICogcy5nICsgbyAqIG4uZyArIDAuNSwgcy5iID0gMjU1ICYgYyAqIHMuYiArIG8gKiBuLmIgKyAwLjUsIHMuYSA9IHIgKiBzLmEgKyAoMSAtIHIpICogbi5hLCB0aGlzLnJnYiA9IHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJwb2xhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGUodCwgZSkge1xuICAgICAgcmV0dXJuIHQgJiYgKHRoaXMuX3JnYiA9IEFvKHRoaXMuX3JnYiwgdC5fcmdiLCBlKSksIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB1ZSh0aGlzLnJnYik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFscGhhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFscGhhKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZ2IuYSA9IFN0KHQpLCB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhcmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyZXIodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9yZ2I7XG4gICAgICByZXR1cm4gZS5hICo9IDEgLSB0LCB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJncmV5c2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3JleXNjYWxlKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9yZ2IsXG4gICAgICAgIGUgPSB4ZSh0LnIgKiAwLjMgKyB0LmcgKiAwLjU5ICsgdC5iICogMC4xMSk7XG4gICAgICByZXR1cm4gdC5yID0gdC5nID0gdC5iID0gZSwgdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3BhcXVlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGFxdWVyKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fcmdiO1xuICAgICAgcmV0dXJuIGUuYSAqPSAxICsgdCwgdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmVnYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fcmdiO1xuICAgICAgcmV0dXJuIHQuciA9IDI1NSAtIHQuciwgdC5nID0gMjU1IC0gdC5nLCB0LmIgPSAyNTUgLSB0LmIsIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpZ2h0ZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlnaHRlbih0KSB7XG4gICAgICByZXR1cm4gU2UodGhpcy5fcmdiLCAyLCB0KSwgdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGFya2VuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRhcmtlbih0KSB7XG4gICAgICByZXR1cm4gU2UodGhpcy5fcmdiLCAyLCAtdCksIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNhdHVyYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhdHVyYXRlKHQpIHtcbiAgICAgIHJldHVybiBTZSh0aGlzLl9yZ2IsIDEsIHQpLCB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXNhdHVyYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc2F0dXJhdGUodCkge1xuICAgICAgcmV0dXJuIFNlKHRoaXMuX3JnYiwgMSwgLXQpLCB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm90YXRlKHQpIHtcbiAgICAgIHJldHVybiBrbyh0aGlzLl9yZ2IsIHQpLCB0aGlzO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuLyohXG4gKiBDaGFydC5qcyB2NC41LjFcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAyNSBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5mdW5jdGlvbiBkdCgpIHt9XG52YXIgTG8gPSAvKiBAX19QVVJFX18gKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBpID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaSsrO1xuICB9O1xufSgpO1xuZnVuY3Rpb24gUihpKSB7XG4gIHJldHVybiBpID09IG51bGw7XG59XG5mdW5jdGlvbiBOKGkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheShpKSkgcmV0dXJuICEwO1xuICB2YXIgdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpKTtcbiAgcmV0dXJuIHQuc2xpY2UoMCwgNykgPT09IFwiW29iamVjdFwiICYmIHQuc2xpY2UoLTYpID09PSBcIkFycmF5XVwiO1xufVxuZnVuY3Rpb24gVChpKSB7XG4gIHJldHVybiBpICE9PSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbn1cbmZ1bmN0aW9uIHEoaSkge1xuICByZXR1cm4gKHR5cGVvZiBpID09IFwibnVtYmVyXCIgfHwgaSBpbnN0YW5jZW9mIE51bWJlcikgJiYgaXNGaW5pdGUoK2kpO1xufVxuZnVuY3Rpb24gb3QoaSwgdCkge1xuICByZXR1cm4gcShpKSA/IGkgOiB0O1xufVxuZnVuY3Rpb24gRChpLCB0KSB7XG4gIHJldHVybiBfdHlwZW9mKGkpID4gXCJ1XCIgPyB0IDogaTtcbn1cbnZhciBFbyA9IGZ1bmN0aW9uIEVvKGksIHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiAmJiBpLmVuZHNXaXRoKFwiJVwiKSA/IHBhcnNlRmxvYXQoaSkgLyAxMDAgOiAraSAvIHQ7XG4gIH0sXG4gIGJuID0gZnVuY3Rpb24gYm4oaSwgdCkge1xuICAgIHJldHVybiB0eXBlb2YgaSA9PSBcInN0cmluZ1wiICYmIGkuZW5kc1dpdGgoXCIlXCIpID8gcGFyc2VGbG9hdChpKSAvIDEwMCAqIHQgOiAraTtcbiAgfTtcbmZ1bmN0aW9uIEkoaSwgdCwgZSkge1xuICBpZiAoaSAmJiB0eXBlb2YgaS5jYWxsID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGkuYXBwbHkoZSwgdCk7XG59XG5mdW5jdGlvbiBMKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4sIG8sIHI7XG4gIGlmIChOKGkpKSBmb3IgKG8gPSBpLmxlbmd0aCwgbiA9IDA7IG4gPCBvOyBuKyspIHQuY2FsbChlLCBpW25dLCBuKTtlbHNlIGlmIChUKGkpKSBmb3IgKHIgPSBPYmplY3Qua2V5cyhpKSwgbyA9IHIubGVuZ3RoLCBuID0gMDsgbiA8IG87IG4rKykgdC5jYWxsKGUsIGlbcltuXV0sIHJbbl0pO1xufVxuZnVuY3Rpb24gamUoaSwgdCkge1xuICB2YXIgZSwgcywgbiwgbztcbiAgaWYgKCFpIHx8ICF0IHx8IGkubGVuZ3RoICE9PSB0Lmxlbmd0aCkgcmV0dXJuICExO1xuICBmb3IgKGUgPSAwLCBzID0gaS5sZW5ndGg7IGUgPCBzOyArK2UpIGlmIChuID0gaVtlXSwgbyA9IHRbZV0sIG4uZGF0YXNldEluZGV4ICE9PSBvLmRhdGFzZXRJbmRleCB8fCBuLmluZGV4ICE9PSBvLmluZGV4KSByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uICRlKGkpIHtcbiAgaWYgKE4oaSkpIHJldHVybiBpLm1hcCgkZSk7XG4gIGlmIChUKGkpKSB7XG4gICAgdmFyIHQgPSAvKiBAX19QVVJFX18gKi9PYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgZSA9IE9iamVjdC5rZXlzKGkpLFxuICAgICAgcyA9IGUubGVuZ3RoO1xuICAgIHZhciBuID0gMDtcbiAgICBmb3IgKDsgbiA8IHM7ICsrbikgdFtlW25dXSA9ICRlKGlbZVtuXV0pO1xuICAgIHJldHVybiB0O1xuICB9XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gX24oaSkge1xuICByZXR1cm4gW1wiX19wcm90b19fXCIsIFwicHJvdG90eXBlXCIsIFwiY29uc3RydWN0b3JcIl0uaW5kZXhPZihpKSA9PT0gLTE7XG59XG5mdW5jdGlvbiBGbyhpLCB0LCBlLCBzKSB7XG4gIGlmICghX24oaSkpIHJldHVybjtcbiAgdmFyIG4gPSB0W2ldLFxuICAgIG8gPSBlW2ldO1xuICBUKG4pICYmIFQobykgPyBmZShuLCBvLCBzKSA6IHRbaV0gPSAkZShvKTtcbn1cbmZ1bmN0aW9uIGZlKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBOKHQpID8gdCA6IFt0XSxcbiAgICBuID0gcy5sZW5ndGg7XG4gIGlmICghVChpKSkgcmV0dXJuIGk7XG4gIGUgPSBlIHx8IHt9O1xuICB2YXIgbyA9IGUubWVyZ2VyIHx8IEZvO1xuICB2YXIgcjtcbiAgZm9yICh2YXIgYSA9IDA7IGEgPCBuOyArK2EpIHtcbiAgICBpZiAociA9IHNbYV0sICFUKHIpKSBjb250aW51ZTtcbiAgICB2YXIgbCA9IE9iamVjdC5rZXlzKHIpO1xuICAgIGZvciAodmFyIGMgPSAwLCBoID0gbC5sZW5ndGg7IGMgPCBoOyArK2MpIG8obFtjXSwgaSwgciwgZSk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBsZShpLCB0KSB7XG4gIHJldHVybiBmZShpLCB0LCB7XG4gICAgbWVyZ2VyOiBJb1xuICB9KTtcbn1cbmZ1bmN0aW9uIElvKGksIHQsIGUpIHtcbiAgaWYgKCFfbihpKSkgcmV0dXJuO1xuICB2YXIgcyA9IHRbaV0sXG4gICAgbiA9IGVbaV07XG4gIFQocykgJiYgVChuKSA/IGxlKHMsIG4pIDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIGkpIHx8ICh0W2ldID0gJGUobikpO1xufVxudmFyIFppID0ge1xuICAvLyBDaGFydC5oZWxwZXJzLmNvcmUgcmVzb2x2ZU9iamVjdEtleSBzaG91bGQgcmVzb2x2ZSBlbXB0eSBrZXkgdG8gcm9vdCBvYmplY3RcbiAgXCJcIjogZnVuY3Rpb24gXyhpKSB7XG4gICAgcmV0dXJuIGk7XG4gIH0sXG4gIC8vIGRlZmF1bHQgcmVzb2x2ZXJzXG4gIHg6IGZ1bmN0aW9uIHgoaSkge1xuICAgIHJldHVybiBpLng7XG4gIH0sXG4gIHk6IGZ1bmN0aW9uIHkoaSkge1xuICAgIHJldHVybiBpLnk7XG4gIH1cbn07XG5mdW5jdGlvbiB6byhpKSB7XG4gIHZhciB0ID0gaS5zcGxpdChcIi5cIiksXG4gICAgZSA9IFtdO1xuICB2YXIgcyA9IFwiXCI7XG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0KSxcbiAgICBfc3RlcDtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIG4gPSBfc3RlcC52YWx1ZTtcbiAgICAgIHMgKz0gbiwgcy5lbmRzV2l0aChcIlxcXFxcIikgPyBzID0gcy5zbGljZSgwLCAtMSkgKyBcIi5cIiA6IChlLnB1c2gocyksIHMgPSBcIlwiKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIEJvKGkpIHtcbiAgdmFyIHQgPSB6byhpKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0KSxcbiAgICAgIF9zdGVwMjtcbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIHMgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgIGlmIChzID09PSBcIlwiKSBicmVhaztcbiAgICAgICAgZSA9IGUgJiYgZVtzXTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH07XG59XG5mdW5jdGlvbiBJdChpLCB0KSB7XG4gIHJldHVybiAoWmlbdF0gfHwgKFppW3RdID0gQm8odCkpKShpKTtcbn1cbmZ1bmN0aW9uIEZpKGkpIHtcbiAgcmV0dXJuIGkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBpLnNsaWNlKDEpO1xufVxudmFyIGdlID0gZnVuY3Rpb24gZ2UoaSkge1xuICAgIHJldHVybiBfdHlwZW9mKGkpIDwgXCJ1XCI7XG4gIH0sXG4gIHd0ID0gZnVuY3Rpb24gd3QoaSkge1xuICAgIHJldHVybiB0eXBlb2YgaSA9PSBcImZ1bmN0aW9uXCI7XG4gIH0sXG4gIFFpID0gZnVuY3Rpb24gUWkoaSwgdCkge1xuICAgIGlmIChpLnNpemUgIT09IHQuc2l6ZSkgcmV0dXJuICExO1xuICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaSksXG4gICAgICBfc3RlcDM7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBlID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICBpZiAoIXQuaGFzKGUpKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgfVxuICAgIHJldHVybiAhMDtcbiAgfTtcbmZ1bmN0aW9uIEhvKGkpIHtcbiAgcmV0dXJuIGkudHlwZSA9PT0gXCJtb3VzZXVwXCIgfHwgaS50eXBlID09PSBcImNsaWNrXCIgfHwgaS50eXBlID09PSBcImNvbnRleHRtZW51XCI7XG59XG52YXIgRSA9IE1hdGguUEksXG4gIEIgPSAyICogRSxcbiAgV28gPSBCICsgRSxcbiAgWWUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gIE5vID0gRSAvIDE4MCxcbiAgViA9IEUgLyAyLFxuICBDdCA9IEUgLyA0LFxuICB0cyA9IEUgKiAyIC8gMyxcbiAgeG4gPSBNYXRoLmxvZzEwLFxuICBsdCA9IE1hdGguc2lnbjtcbmZ1bmN0aW9uIGNlKGksIHQsIGUpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGkgLSB0KSA8IGU7XG59XG5mdW5jdGlvbiBlcyhpKSB7XG4gIHZhciB0ID0gTWF0aC5yb3VuZChpKTtcbiAgaSA9IGNlKGksIHQsIGkgLyAxZTMpID8gdCA6IGk7XG4gIHZhciBlID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoeG4oaSkpKSxcbiAgICBzID0gaSAvIGU7XG4gIHJldHVybiAocyA8PSAxID8gMSA6IHMgPD0gMiA/IDIgOiBzIDw9IDUgPyA1IDogMTApICogZTtcbn1cbmZ1bmN0aW9uIFZvKGkpIHtcbiAgdmFyIHQgPSBbXSxcbiAgICBlID0gTWF0aC5zcXJ0KGkpO1xuICB2YXIgcztcbiAgZm9yIChzID0gMTsgcyA8IGU7IHMrKykgaSAlIHMgPT09IDAgJiYgKHQucHVzaChzKSwgdC5wdXNoKGkgLyBzKSk7XG4gIHJldHVybiBlID09PSAoZSB8IDApICYmIHQucHVzaChlKSwgdC5zb3J0KGZ1bmN0aW9uIChuLCBvKSB7XG4gICAgcmV0dXJuIG4gLSBvO1xuICB9KS5wb3AoKSwgdDtcbn1cbmZ1bmN0aW9uIGpvKGkpIHtcbiAgcmV0dXJuIF90eXBlb2YoaSkgPT0gXCJzeW1ib2xcIiB8fCBfdHlwZW9mKGkpID09IFwib2JqZWN0XCIgJiYgaSAhPT0gbnVsbCAmJiAhKFN5bWJvbC50b1ByaW1pdGl2ZSBpbiBpIHx8IFwidG9TdHJpbmdcIiBpbiBpIHx8IFwidmFsdWVPZlwiIGluIGkpO1xufVxuZnVuY3Rpb24gWHQoaSkge1xuICByZXR1cm4gIWpvKGkpICYmICFpc05hTihwYXJzZUZsb2F0KGkpKSAmJiBpc0Zpbml0ZShpKTtcbn1cbmZ1bmN0aW9uICRvKGksIHQpIHtcbiAgdmFyIGUgPSBNYXRoLnJvdW5kKGkpO1xuICByZXR1cm4gZSAtIHQgPD0gaSAmJiBlICsgdCA+PSBpO1xufVxuZnVuY3Rpb24gWW8oaSwgdCwgZSkge1xuICB2YXIgcywgbiwgbztcbiAgZm9yIChzID0gMCwgbiA9IGkubGVuZ3RoOyBzIDwgbjsgcysrKSBvID0gaVtzXVtlXSwgaXNOYU4obykgfHwgKHQubWluID0gTWF0aC5taW4odC5taW4sIG8pLCB0Lm1heCA9IE1hdGgubWF4KHQubWF4LCBvKSk7XG59XG5mdW5jdGlvbiBidChpKSB7XG4gIHJldHVybiBpICogKEUgLyAxODApO1xufVxuZnVuY3Rpb24gVW8oaSkge1xuICByZXR1cm4gaSAqICgxODAgLyBFKTtcbn1cbmZ1bmN0aW9uIGlzKGkpIHtcbiAgaWYgKCFxKGkpKSByZXR1cm47XG4gIHZhciB0ID0gMSxcbiAgICBlID0gMDtcbiAgZm9yICg7IE1hdGgucm91bmQoaSAqIHQpIC8gdCAhPT0gaTspIHQgKj0gMTAsIGUrKztcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiB5bihpLCB0KSB7XG4gIHZhciBlID0gdC54IC0gaS54LFxuICAgIHMgPSB0LnkgLSBpLnksXG4gICAgbiA9IE1hdGguc3FydChlICogZSArIHMgKiBzKTtcbiAgdmFyIG8gPSBNYXRoLmF0YW4yKHMsIGUpO1xuICByZXR1cm4gbyA8IC0wLjUgKiBFICYmIChvICs9IEIpLCB7XG4gICAgYW5nbGU6IG8sXG4gICAgZGlzdGFuY2U6IG5cbiAgfTtcbn1cbmZ1bmN0aW9uIHZpKGksIHQpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0LnggLSBpLngsIDIpICsgTWF0aC5wb3codC55IC0gaS55LCAyKSk7XG59XG5mdW5jdGlvbiBYbyhpLCB0KSB7XG4gIHJldHVybiAoaSAtIHQgKyBXbykgJSBCIC0gRTtcbn1cbmZ1bmN0aW9uIFooaSkge1xuICByZXR1cm4gKGkgJSBCICsgQikgJSBCO1xufVxuZnVuY3Rpb24gcGUoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IFooaSksXG4gICAgbyA9IFoodCksXG4gICAgciA9IFooZSksXG4gICAgYSA9IFoobyAtIG4pLFxuICAgIGwgPSBaKHIgLSBuKSxcbiAgICBjID0gWihuIC0gbyksXG4gICAgaCA9IFoobiAtIHIpO1xuICByZXR1cm4gbiA9PT0gbyB8fCBuID09PSByIHx8IHMgJiYgbyA9PT0gciB8fCBhID4gbCAmJiBjIDwgaDtcbn1cbmZ1bmN0aW9uIFUoaSwgdCwgZSkge1xuICByZXR1cm4gTWF0aC5tYXgodCwgTWF0aC5taW4oZSwgaSkpO1xufVxuZnVuY3Rpb24gcW8oaSkge1xuICByZXR1cm4gVShpLCAtMzI3NjgsIDMyNzY3KTtcbn1cbmZ1bmN0aW9uIF90KGksIHQsIGUpIHtcbiAgdmFyIHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDFlLTY7XG4gIHJldHVybiBpID49IE1hdGgubWluKHQsIGUpIC0gcyAmJiBpIDw9IE1hdGgubWF4KHQsIGUpICsgcztcbn1cbmZ1bmN0aW9uIElpKGksIHQsIGUpIHtcbiAgZSA9IGUgfHwgZnVuY3Rpb24gKHIpIHtcbiAgICByZXR1cm4gaVtyXSA8IHQ7XG4gIH07XG4gIHZhciBzID0gaS5sZW5ndGggLSAxLFxuICAgIG4gPSAwLFxuICAgIG87XG4gIGZvciAoOyBzIC0gbiA+IDE7KSBvID0gbiArIHMgPj4gMSwgZShvKSA/IG4gPSBvIDogcyA9IG87XG4gIHJldHVybiB7XG4gICAgbG86IG4sXG4gICAgaGk6IHNcbiAgfTtcbn1cbnZhciBFdCA9IGZ1bmN0aW9uIEV0KGksIHQsIGUsIHMpIHtcbiAgICByZXR1cm4gSWkoaSwgZSwgcyA/IGZ1bmN0aW9uIChuKSB7XG4gICAgICB2YXIgbyA9IGlbbl1bdF07XG4gICAgICByZXR1cm4gbyA8IGUgfHwgbyA9PT0gZSAmJiBpW24gKyAxXVt0XSA9PT0gZTtcbiAgICB9IDogZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBpW25dW3RdIDwgZTtcbiAgICB9KTtcbiAgfSxcbiAgS28gPSBmdW5jdGlvbiBLbyhpLCB0LCBlKSB7XG4gICAgcmV0dXJuIElpKGksIGUsIGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gaVtzXVt0XSA+PSBlO1xuICAgIH0pO1xuICB9O1xuZnVuY3Rpb24gR28oaSwgdCwgZSkge1xuICB2YXIgcyA9IDAsXG4gICAgbiA9IGkubGVuZ3RoO1xuICBmb3IgKDsgcyA8IG4gJiYgaVtzXSA8IHQ7KSBzKys7XG4gIGZvciAoOyBuID4gcyAmJiBpW24gLSAxXSA+IGU7KSBuLS07XG4gIHJldHVybiBzID4gMCB8fCBuIDwgaS5sZW5ndGggPyBpLnNsaWNlKHMsIG4pIDogaTtcbn1cbnZhciB2biA9IFtcInB1c2hcIiwgXCJwb3BcIiwgXCJzaGlmdFwiLCBcInNwbGljZVwiLCBcInVuc2hpZnRcIl07XG5mdW5jdGlvbiBKbyhpLCB0KSB7XG4gIGlmIChpLl9jaGFydGpzKSB7XG4gICAgaS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaCh0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIFwiX2NoYXJ0anNcIiwge1xuICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgZW51bWVyYWJsZTogITEsXG4gICAgdmFsdWU6IHtcbiAgICAgIGxpc3RlbmVyczogW3RdXG4gICAgfVxuICB9KSwgdm4uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzID0gXCJfb25EYXRhXCIgKyBGaShlKSxcbiAgICAgIG4gPSBpW2VdO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBlLCB7XG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBvID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIG9bX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSBuLmFwcGx5KHRoaXMsIG8pO1xuICAgICAgICByZXR1cm4gaS5fY2hhcnRqcy5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHR5cGVvZiBhW3NdID09IFwiZnVuY3Rpb25cIiAmJiBhW3NdLmFwcGx5KGEsIG8pO1xuICAgICAgICB9KSwgcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzcyhpLCB0KSB7XG4gIHZhciBlID0gaS5fY2hhcnRqcztcbiAgaWYgKCFlKSByZXR1cm47XG4gIHZhciBzID0gZS5saXN0ZW5lcnMsXG4gICAgbiA9IHMuaW5kZXhPZih0KTtcbiAgbiAhPT0gLTEgJiYgcy5zcGxpY2UobiwgMSksICEocy5sZW5ndGggPiAwKSAmJiAodm4uZm9yRWFjaChmdW5jdGlvbiAobykge1xuICAgIGRlbGV0ZSBpW29dO1xuICB9KSwgZGVsZXRlIGkuX2NoYXJ0anMpO1xufVxuZnVuY3Rpb24gTW4oaSkge1xuICB2YXIgdCA9IG5ldyBTZXQoaSk7XG4gIHJldHVybiB0LnNpemUgPT09IGkubGVuZ3RoID8gaSA6IEFycmF5LmZyb20odCk7XG59XG52YXIgU24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHdpbmRvdykpID4gXCJ1XCIgPyBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBpKCk7XG4gIH0gOiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xufSgpO1xuZnVuY3Rpb24ga24oaSwgdCkge1xuICB2YXIgZSA9IFtdLFxuICAgIHMgPSAhMTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIG4gPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIG5bX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgZSA9IG4sIHMgfHwgKHMgPSAhMCwgU24uY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHMgPSAhMSwgaS5hcHBseSh0LCBlKTtcbiAgICB9KSk7XG4gIH07XG59XG5mdW5jdGlvbiBabyhpLCB0KSB7XG4gIHZhciBlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgcyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cbiAgICByZXR1cm4gdCA/IChjbGVhclRpbWVvdXQoZSksIGUgPSBzZXRUaW1lb3V0KGksIHQsIHMpKSA6IGkuYXBwbHkodGhpcywgcyksIHQ7XG4gIH07XG59XG52YXIgemkgPSBmdW5jdGlvbiB6aShpKSB7XG4gICAgcmV0dXJuIGkgPT09IFwic3RhcnRcIiA/IFwibGVmdFwiIDogaSA9PT0gXCJlbmRcIiA/IFwicmlnaHRcIiA6IFwiY2VudGVyXCI7XG4gIH0sXG4gIFkgPSBmdW5jdGlvbiBZKGksIHQsIGUpIHtcbiAgICByZXR1cm4gaSA9PT0gXCJzdGFydFwiID8gdCA6IGkgPT09IFwiZW5kXCIgPyBlIDogKHQgKyBlKSAvIDI7XG4gIH0sXG4gIFFvID0gZnVuY3Rpb24gUW8oaSwgdCwgZSwgcykge1xuICAgIHJldHVybiBpID09PSAocyA/IFwibGVmdFwiIDogXCJyaWdodFwiKSA/IGUgOiBpID09PSBcImNlbnRlclwiID8gKHQgKyBlKSAvIDIgOiB0O1xuICB9O1xuZnVuY3Rpb24gd24oaSwgdCwgZSkge1xuICB2YXIgcyA9IHQubGVuZ3RoO1xuICB2YXIgbiA9IDAsXG4gICAgbyA9IHM7XG4gIGlmIChpLl9zb3J0ZWQpIHtcbiAgICB2YXIgciA9IGkuaVNjYWxlLFxuICAgICAgYSA9IGkudlNjYWxlLFxuICAgICAgbCA9IGkuX3BhcnNlZCxcbiAgICAgIGMgPSBpLmRhdGFzZXQgJiYgaS5kYXRhc2V0Lm9wdGlvbnMgPyBpLmRhdGFzZXQub3B0aW9ucy5zcGFuR2FwcyA6IG51bGwsXG4gICAgICBoID0gci5heGlzLFxuICAgICAgX3IkZ2V0VXNlckJvdW5kcyA9IHIuZ2V0VXNlckJvdW5kcygpLFxuICAgICAgZCA9IF9yJGdldFVzZXJCb3VuZHMubWluLFxuICAgICAgdSA9IF9yJGdldFVzZXJCb3VuZHMubWF4LFxuICAgICAgZiA9IF9yJGdldFVzZXJCb3VuZHMubWluRGVmaW5lZCxcbiAgICAgIHAgPSBfciRnZXRVc2VyQm91bmRzLm1heERlZmluZWQ7XG4gICAgaWYgKGYpIHtcbiAgICAgIGlmIChuID0gTWF0aC5taW4oXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gdHlwZSBfcGFyc2VkXG4gICAgICBFdChsLCBoLCBkKS5sbyxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byBmaXggdHlwZXMgb24gX2xvb2t1cEJ5S2V5XG4gICAgICBlID8gcyA6IEV0KHQsIGgsIHIuZ2V0UGl4ZWxGb3JWYWx1ZShkKSkubG8pLCBjKSB7XG4gICAgICAgIHZhciBnID0gbC5zbGljZSgwLCBuICsgMSkucmV2ZXJzZSgpLmZpbmRJbmRleChmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiAhUihtW2EuYXhpc10pO1xuICAgICAgICB9KTtcbiAgICAgICAgbiAtPSBNYXRoLm1heCgwLCBnKTtcbiAgICAgIH1cbiAgICAgIG4gPSBVKG4sIDAsIHMgLSAxKTtcbiAgICB9XG4gICAgaWYgKHApIHtcbiAgICAgIHZhciBfZyA9IE1hdGgubWF4KFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOZWVkIHRvIHR5cGUgX3BhcnNlZFxuICAgICAgRXQobCwgci5heGlzLCB1LCAhMCkuaGkgKyAxLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOZWVkIHRvIGZpeCB0eXBlcyBvbiBfbG9va3VwQnlLZXlcbiAgICAgIGUgPyAwIDogRXQodCwgaCwgci5nZXRQaXhlbEZvclZhbHVlKHUpLCAhMCkuaGkgKyAxKTtcbiAgICAgIGlmIChjKSB7XG4gICAgICAgIHZhciBtID0gbC5zbGljZShfZyAtIDEpLmZpbmRJbmRleChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHJldHVybiAhUihiW2EuYXhpc10pO1xuICAgICAgICB9KTtcbiAgICAgICAgX2cgKz0gTWF0aC5tYXgoMCwgbSk7XG4gICAgICB9XG4gICAgICBvID0gVShfZywgbiwgcykgLSBuO1xuICAgIH0gZWxzZSBvID0gcyAtIG47XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogbixcbiAgICBjb3VudDogb1xuICB9O1xufVxuZnVuY3Rpb24gUG4oaSkge1xuICB2YXIgdCA9IGkueFNjYWxlLFxuICAgIGUgPSBpLnlTY2FsZSxcbiAgICBzID0gaS5fc2NhbGVSYW5nZXMsXG4gICAgbiA9IHtcbiAgICAgIHhtaW46IHQubWluLFxuICAgICAgeG1heDogdC5tYXgsXG4gICAgICB5bWluOiBlLm1pbixcbiAgICAgIHltYXg6IGUubWF4XG4gICAgfTtcbiAgaWYgKCFzKSByZXR1cm4gaS5fc2NhbGVSYW5nZXMgPSBuLCAhMDtcbiAgdmFyIG8gPSBzLnhtaW4gIT09IHQubWluIHx8IHMueG1heCAhPT0gdC5tYXggfHwgcy55bWluICE9PSBlLm1pbiB8fCBzLnltYXggIT09IGUubWF4O1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihzLCBuKSwgbztcbn1cbnZhciBrZSA9IGZ1bmN0aW9uIGtlKGkpIHtcbiAgICByZXR1cm4gaSA9PT0gMCB8fCBpID09PSAxO1xuICB9LFxuICBucyA9IGZ1bmN0aW9uIG5zKGksIHQsIGUpIHtcbiAgICByZXR1cm4gLShNYXRoLnBvdygyLCAxMCAqIChpIC09IDEpKSAqIE1hdGguc2luKChpIC0gdCkgKiBCIC8gZSkpO1xuICB9LFxuICBvcyA9IGZ1bmN0aW9uIG9zKGksIHQsIGUpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwICogaSkgKiBNYXRoLnNpbigoaSAtIHQpICogQiAvIGUpICsgMTtcbiAgfSxcbiAgaGUgPSB7XG4gICAgbGluZWFyOiBmdW5jdGlvbiBsaW5lYXIoaSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfSxcbiAgICBlYXNlSW5RdWFkOiBmdW5jdGlvbiBlYXNlSW5RdWFkKGkpIHtcbiAgICAgIHJldHVybiBpICogaTtcbiAgICB9LFxuICAgIGVhc2VPdXRRdWFkOiBmdW5jdGlvbiBlYXNlT3V0UXVhZChpKSB7XG4gICAgICByZXR1cm4gLWkgKiAoaSAtIDIpO1xuICAgIH0sXG4gICAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24gZWFzZUluT3V0UXVhZChpKSB7XG4gICAgICByZXR1cm4gKGkgLz0gMC41KSA8IDEgPyAwLjUgKiBpICogaSA6IC0wLjUgKiAoLS1pICogKGkgLSAyKSAtIDEpO1xuICAgIH0sXG4gICAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uIGVhc2VJbkN1YmljKGkpIHtcbiAgICAgIHJldHVybiBpICogaSAqIGk7XG4gICAgfSxcbiAgICBlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uIGVhc2VPdXRDdWJpYyhpKSB7XG4gICAgICByZXR1cm4gKGkgLT0gMSkgKiBpICogaSArIDE7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24gZWFzZUluT3V0Q3ViaWMoaSkge1xuICAgICAgcmV0dXJuIChpIC89IDAuNSkgPCAxID8gMC41ICogaSAqIGkgKiBpIDogMC41ICogKChpIC09IDIpICogaSAqIGkgKyAyKTtcbiAgICB9LFxuICAgIGVhc2VJblF1YXJ0OiBmdW5jdGlvbiBlYXNlSW5RdWFydChpKSB7XG4gICAgICByZXR1cm4gaSAqIGkgKiBpICogaTtcbiAgICB9LFxuICAgIGVhc2VPdXRRdWFydDogZnVuY3Rpb24gZWFzZU91dFF1YXJ0KGkpIHtcbiAgICAgIHJldHVybiAtKChpIC09IDEpICogaSAqIGkgKiBpIC0gMSk7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24gZWFzZUluT3V0UXVhcnQoaSkge1xuICAgICAgcmV0dXJuIChpIC89IDAuNSkgPCAxID8gMC41ICogaSAqIGkgKiBpICogaSA6IC0wLjUgKiAoKGkgLT0gMikgKiBpICogaSAqIGkgLSAyKTtcbiAgICB9LFxuICAgIGVhc2VJblF1aW50OiBmdW5jdGlvbiBlYXNlSW5RdWludChpKSB7XG4gICAgICByZXR1cm4gaSAqIGkgKiBpICogaSAqIGk7XG4gICAgfSxcbiAgICBlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uIGVhc2VPdXRRdWludChpKSB7XG4gICAgICByZXR1cm4gKGkgLT0gMSkgKiBpICogaSAqIGkgKiBpICsgMTtcbiAgICB9LFxuICAgIGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbiBlYXNlSW5PdXRRdWludChpKSB7XG4gICAgICByZXR1cm4gKGkgLz0gMC41KSA8IDEgPyAwLjUgKiBpICogaSAqIGkgKiBpICogaSA6IDAuNSAqICgoaSAtPSAyKSAqIGkgKiBpICogaSAqIGkgKyAyKTtcbiAgICB9LFxuICAgIGVhc2VJblNpbmU6IGZ1bmN0aW9uIGVhc2VJblNpbmUoaSkge1xuICAgICAgcmV0dXJuIC1NYXRoLmNvcyhpICogVikgKyAxO1xuICAgIH0sXG4gICAgZWFzZU91dFNpbmU6IGZ1bmN0aW9uIGVhc2VPdXRTaW5lKGkpIHtcbiAgICAgIHJldHVybiBNYXRoLnNpbihpICogVik7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRTaW5lOiBmdW5jdGlvbiBlYXNlSW5PdXRTaW5lKGkpIHtcbiAgICAgIHJldHVybiAtMC41ICogKE1hdGguY29zKEUgKiBpKSAtIDEpO1xuICAgIH0sXG4gICAgZWFzZUluRXhwbzogZnVuY3Rpb24gZWFzZUluRXhwbyhpKSB7XG4gICAgICByZXR1cm4gaSA9PT0gMCA/IDAgOiBNYXRoLnBvdygyLCAxMCAqIChpIC0gMSkpO1xuICAgIH0sXG4gICAgZWFzZU91dEV4cG86IGZ1bmN0aW9uIGVhc2VPdXRFeHBvKGkpIHtcbiAgICAgIHJldHVybiBpID09PSAxID8gMSA6IC1NYXRoLnBvdygyLCAtMTAgKiBpKSArIDE7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRFeHBvOiBmdW5jdGlvbiBlYXNlSW5PdXRFeHBvKGkpIHtcbiAgICAgIHJldHVybiBrZShpKSA/IGkgOiBpIDwgMC41ID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAoaSAqIDIgLSAxKSkgOiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChpICogMiAtIDEpKSArIDIpO1xuICAgIH0sXG4gICAgZWFzZUluQ2lyYzogZnVuY3Rpb24gZWFzZUluQ2lyYyhpKSB7XG4gICAgICByZXR1cm4gaSA+PSAxID8gaSA6IC0oTWF0aC5zcXJ0KDEgLSBpICogaSkgLSAxKTtcbiAgICB9LFxuICAgIGVhc2VPdXRDaXJjOiBmdW5jdGlvbiBlYXNlT3V0Q2lyYyhpKSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAoaSAtPSAxKSAqIGkpO1xuICAgIH0sXG4gICAgZWFzZUluT3V0Q2lyYzogZnVuY3Rpb24gZWFzZUluT3V0Q2lyYyhpKSB7XG4gICAgICByZXR1cm4gKGkgLz0gMC41KSA8IDEgPyAtMC41ICogKE1hdGguc3FydCgxIC0gaSAqIGkpIC0gMSkgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoaSAtPSAyKSAqIGkpICsgMSk7XG4gICAgfSxcbiAgICBlYXNlSW5FbGFzdGljOiBmdW5jdGlvbiBlYXNlSW5FbGFzdGljKGkpIHtcbiAgICAgIHJldHVybiBrZShpKSA/IGkgOiBucyhpLCAwLjA3NSwgMC4zKTtcbiAgICB9LFxuICAgIGVhc2VPdXRFbGFzdGljOiBmdW5jdGlvbiBlYXNlT3V0RWxhc3RpYyhpKSB7XG4gICAgICByZXR1cm4ga2UoaSkgPyBpIDogb3MoaSwgMC4wNzUsIDAuMyk7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRFbGFzdGljOiBmdW5jdGlvbiBlYXNlSW5PdXRFbGFzdGljKGkpIHtcbiAgICAgIHJldHVybiBrZShpKSA/IGkgOiBpIDwgMC41ID8gMC41ICogbnMoaSAqIDIsIDAuMTEyNSwgMC40NSkgOiAwLjUgKyAwLjUgKiBvcyhpICogMiAtIDEsIDAuMTEyNSwgMC40NSk7XG4gICAgfSxcbiAgICBlYXNlSW5CYWNrOiBmdW5jdGlvbiBlYXNlSW5CYWNrKGkpIHtcbiAgICAgIHJldHVybiBpICogaSAqICgoMS43MDE1OCArIDEpICogaSAtIDEuNzAxNTgpO1xuICAgIH0sXG4gICAgZWFzZU91dEJhY2s6IGZ1bmN0aW9uIGVhc2VPdXRCYWNrKGkpIHtcbiAgICAgIHJldHVybiAoaSAtPSAxKSAqIGkgKiAoKDEuNzAxNTggKyAxKSAqIGkgKyAxLjcwMTU4KSArIDE7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRCYWNrOiBmdW5jdGlvbiBlYXNlSW5PdXRCYWNrKGkpIHtcbiAgICAgIHZhciB0ID0gMS43MDE1ODtcbiAgICAgIHJldHVybiAoaSAvPSAwLjUpIDwgMSA/IDAuNSAqIChpICogaSAqICgoKHQgKj0gMS41MjUpICsgMSkgKiBpIC0gdCkpIDogMC41ICogKChpIC09IDIpICogaSAqICgoKHQgKj0gMS41MjUpICsgMSkgKiBpICsgdCkgKyAyKTtcbiAgICB9LFxuICAgIGVhc2VJbkJvdW5jZTogZnVuY3Rpb24gZWFzZUluQm91bmNlKGkpIHtcbiAgICAgIHJldHVybiAxIC0gaGUuZWFzZU91dEJvdW5jZSgxIC0gaSk7XG4gICAgfSxcbiAgICBlYXNlT3V0Qm91bmNlOiBmdW5jdGlvbiBlYXNlT3V0Qm91bmNlKGkpIHtcbiAgICAgIHJldHVybiBpIDwgMSAvIDIuNzUgPyA3LjU2MjUgKiBpICogaSA6IGkgPCAyIC8gMi43NSA/IDcuNTYyNSAqIChpIC09IDEuNSAvIDIuNzUpICogaSArIDAuNzUgOiBpIDwgMi41IC8gMi43NSA/IDcuNTYyNSAqIChpIC09IDIuMjUgLyAyLjc1KSAqIGkgKyAwLjkzNzUgOiA3LjU2MjUgKiAoaSAtPSAyLjYyNSAvIDIuNzUpICogaSArIDAuOTg0Mzc1O1xuICAgIH0sXG4gICAgZWFzZUluT3V0Qm91bmNlOiBmdW5jdGlvbiBlYXNlSW5PdXRCb3VuY2UoaSkge1xuICAgICAgcmV0dXJuIGkgPCAwLjUgPyBoZS5lYXNlSW5Cb3VuY2UoaSAqIDIpICogMC41IDogaGUuZWFzZU91dEJvdW5jZShpICogMiAtIDEpICogMC41ICsgMC41O1xuICAgIH1cbiAgfTtcbmZ1bmN0aW9uIEJpKGkpIHtcbiAgaWYgKGkgJiYgX3R5cGVvZihpKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgdmFyIHQgPSBpLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHQgPT09IFwiW29iamVjdCBDYW52YXNQYXR0ZXJuXVwiIHx8IHQgPT09IFwiW29iamVjdCBDYW52YXNHcmFkaWVudF1cIjtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBycyhpKSB7XG4gIHJldHVybiBCaShpKSA/IGkgOiBuZXcgdWUoaSk7XG59XG5mdW5jdGlvbiBuaShpKSB7XG4gIHJldHVybiBCaShpKSA/IGkgOiBuZXcgdWUoaSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5oZXhTdHJpbmcoKTtcbn1cbnZhciB0ciA9IFtcInhcIiwgXCJ5XCIsIFwiYm9yZGVyV2lkdGhcIiwgXCJyYWRpdXNcIiwgXCJ0ZW5zaW9uXCJdLFxuICBlciA9IFtcImNvbG9yXCIsIFwiYm9yZGVyQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIl07XG5mdW5jdGlvbiBpcihpKSB7XG4gIGkuc2V0KFwiYW5pbWF0aW9uXCIsIHtcbiAgICBkZWxheTogdm9pZCAwLFxuICAgIGR1cmF0aW9uOiAxZTMsXG4gICAgZWFzaW5nOiBcImVhc2VPdXRRdWFydFwiLFxuICAgIGZuOiB2b2lkIDAsXG4gICAgZnJvbTogdm9pZCAwLFxuICAgIGxvb3A6IHZvaWQgMCxcbiAgICB0bzogdm9pZCAwLFxuICAgIHR5cGU6IHZvaWQgMFxuICB9KSwgaS5kZXNjcmliZShcImFuaW1hdGlvblwiLCB7XG4gICAgX2ZhbGxiYWNrOiAhMSxcbiAgICBfaW5kZXhhYmxlOiAhMSxcbiAgICBfc2NyaXB0YWJsZTogZnVuY3Rpb24gX3NjcmlwdGFibGUodCkge1xuICAgICAgcmV0dXJuIHQgIT09IFwib25Qcm9ncmVzc1wiICYmIHQgIT09IFwib25Db21wbGV0ZVwiICYmIHQgIT09IFwiZm5cIjtcbiAgICB9XG4gIH0pLCBpLnNldChcImFuaW1hdGlvbnNcIiwge1xuICAgIGNvbG9yczoge1xuICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgcHJvcGVydGllczogZXJcbiAgICB9LFxuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBwcm9wZXJ0aWVzOiB0clxuICAgIH1cbiAgfSksIGkuZGVzY3JpYmUoXCJhbmltYXRpb25zXCIsIHtcbiAgICBfZmFsbGJhY2s6IFwiYW5pbWF0aW9uXCJcbiAgfSksIGkuc2V0KFwidHJhbnNpdGlvbnNcIiwge1xuICAgIGFjdGl2ZToge1xuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIGR1cmF0aW9uOiA0MDBcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlc2l6ZToge1xuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICB9XG4gICAgfSxcbiAgICBzaG93OiB7XG4gICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgIGNvbG9yczoge1xuICAgICAgICAgIGZyb206IFwidHJhbnNwYXJlbnRcIlxuICAgICAgICB9LFxuICAgICAgICB2aXNpYmxlOiB7XG4gICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaGlkZToge1xuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICBjb2xvcnM6IHtcbiAgICAgICAgICB0bzogXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgIH0sXG4gICAgICAgIHZpc2libGU6IHtcbiAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBlYXNpbmc6IFwibGluZWFyXCIsXG4gICAgICAgICAgZm46IGZ1bmN0aW9uIGZuKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0IHwgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gc3IoaSkge1xuICBpLnNldChcImxheW91dFwiLCB7XG4gICAgYXV0b1BhZGRpbmc6ICEwLFxuICAgIHBhZGRpbmc6IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMFxuICAgIH1cbiAgfSk7XG59XG52YXIgYXMgPSAvKiBAX19QVVJFX18gKi9uZXcgTWFwKCk7XG5mdW5jdGlvbiBucihpLCB0KSB7XG4gIHQgPSB0IHx8IHt9O1xuICB2YXIgZSA9IGkgKyBKU09OLnN0cmluZ2lmeSh0KTtcbiAgdmFyIHMgPSBhcy5nZXQoZSk7XG4gIHJldHVybiBzIHx8IChzID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGksIHQpLCBhcy5zZXQoZSwgcykpLCBzO1xufVxuZnVuY3Rpb24gSGkoaSwgdCwgZSkge1xuICByZXR1cm4gbnIodCwgZSkuZm9ybWF0KGkpO1xufVxudmFyIG9yID0ge1xuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcyhpKSB7XG4gICAgcmV0dXJuIE4oaSkgPyBpIDogXCJcIiArIGk7XG4gIH0sXG4gIG51bWVyaWM6IGZ1bmN0aW9uIG51bWVyaWMoaSwgdCwgZSkge1xuICAgIGlmIChpID09PSAwKSByZXR1cm4gXCIwXCI7XG4gICAgdmFyIHMgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlO1xuICAgIHZhciBuLFxuICAgICAgbyA9IGk7XG4gICAgaWYgKGUubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGMgPSBNYXRoLm1heChNYXRoLmFicyhlWzBdLnZhbHVlKSwgTWF0aC5hYnMoZVtlLmxlbmd0aCAtIDFdLnZhbHVlKSk7XG4gICAgICAoYyA8IDFlLTQgfHwgYyA+IDFlMTUpICYmIChuID0gXCJzY2llbnRpZmljXCIpLCBvID0gcnIoaSwgZSk7XG4gICAgfVxuICAgIHZhciByID0geG4oTWF0aC5hYnMobykpLFxuICAgICAgYSA9IGlzTmFOKHIpID8gMSA6IE1hdGgubWF4KE1hdGgubWluKC0xICogTWF0aC5mbG9vcihyKSwgMjApLCAwKSxcbiAgICAgIGwgPSB7XG4gICAgICAgIG5vdGF0aW9uOiBuLFxuICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IGEsXG4gICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogYVxuICAgICAgfTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihsLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KSwgSGkoaSwgcywgbCk7XG4gIH1cbn07XG5mdW5jdGlvbiBycihpLCB0KSB7XG4gIHZhciBlID0gdC5sZW5ndGggPiAzID8gdFsyXS52YWx1ZSAtIHRbMV0udmFsdWUgOiB0WzFdLnZhbHVlIC0gdFswXS52YWx1ZTtcbiAgcmV0dXJuIE1hdGguYWJzKGUpID49IDEgJiYgaSAhPT0gTWF0aC5mbG9vcihpKSAmJiAoZSA9IGkgLSBNYXRoLmZsb29yKGkpKSwgZTtcbn1cbnZhciBEbiA9IHtcbiAgZm9ybWF0dGVyczogb3Jcbn07XG5mdW5jdGlvbiBhcihpKSB7XG4gIGkuc2V0KFwic2NhbGVcIiwge1xuICAgIGRpc3BsYXk6ICEwLFxuICAgIG9mZnNldDogITEsXG4gICAgcmV2ZXJzZTogITEsXG4gICAgYmVnaW5BdFplcm86ICExLFxuICAgIGJvdW5kczogXCJ0aWNrc1wiLFxuICAgIGNsaXA6ICEwLFxuICAgIGdyYWNlOiAwLFxuICAgIGdyaWQ6IHtcbiAgICAgIGRpc3BsYXk6ICEwLFxuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgZHJhd09uQ2hhcnRBcmVhOiAhMCxcbiAgICAgIGRyYXdUaWNrczogITAsXG4gICAgICB0aWNrTGVuZ3RoOiA4LFxuICAgICAgdGlja1dpZHRoOiBmdW5jdGlvbiB0aWNrV2lkdGgodCwgZSkge1xuICAgICAgICByZXR1cm4gZS5saW5lV2lkdGg7XG4gICAgICB9LFxuICAgICAgdGlja0NvbG9yOiBmdW5jdGlvbiB0aWNrQ29sb3IodCwgZSkge1xuICAgICAgICByZXR1cm4gZS5jb2xvcjtcbiAgICAgIH0sXG4gICAgICBvZmZzZXQ6ICExXG4gICAgfSxcbiAgICBib3JkZXI6IHtcbiAgICAgIGRpc3BsYXk6ICEwLFxuICAgICAgZGFzaDogW10sXG4gICAgICBkYXNoT2Zmc2V0OiAwLFxuICAgICAgd2lkdGg6IDFcbiAgICB9LFxuICAgIHRpdGxlOiB7XG4gICAgICBkaXNwbGF5OiAhMSxcbiAgICAgIHRleHQ6IFwiXCIsXG4gICAgICBwYWRkaW5nOiB7XG4gICAgICAgIHRvcDogNCxcbiAgICAgICAgYm90dG9tOiA0XG4gICAgICB9XG4gICAgfSxcbiAgICB0aWNrczoge1xuICAgICAgbWluUm90YXRpb246IDAsXG4gICAgICBtYXhSb3RhdGlvbjogNTAsXG4gICAgICBtaXJyb3I6ICExLFxuICAgICAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuICAgICAgdGV4dFN0cm9rZUNvbG9yOiBcIlwiLFxuICAgICAgcGFkZGluZzogMyxcbiAgICAgIGRpc3BsYXk6ICEwLFxuICAgICAgYXV0b1NraXA6ICEwLFxuICAgICAgYXV0b1NraXBQYWRkaW5nOiAzLFxuICAgICAgbGFiZWxPZmZzZXQ6IDAsXG4gICAgICBjYWxsYmFjazogRG4uZm9ybWF0dGVycy52YWx1ZXMsXG4gICAgICBtaW5vcjoge30sXG4gICAgICBtYWpvcjoge30sXG4gICAgICBhbGlnbjogXCJjZW50ZXJcIixcbiAgICAgIGNyb3NzQWxpZ246IFwibmVhclwiLFxuICAgICAgc2hvd0xhYmVsQmFja2Ryb3A6ICExLFxuICAgICAgYmFja2Ryb3BDb2xvcjogXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpXCIsXG4gICAgICBiYWNrZHJvcFBhZGRpbmc6IDJcbiAgICB9XG4gIH0pLCBpLnJvdXRlKFwic2NhbGUudGlja3NcIiwgXCJjb2xvclwiLCBcIlwiLCBcImNvbG9yXCIpLCBpLnJvdXRlKFwic2NhbGUuZ3JpZFwiLCBcImNvbG9yXCIsIFwiXCIsIFwiYm9yZGVyQ29sb3JcIiksIGkucm91dGUoXCJzY2FsZS5ib3JkZXJcIiwgXCJjb2xvclwiLCBcIlwiLCBcImJvcmRlckNvbG9yXCIpLCBpLnJvdXRlKFwic2NhbGUudGl0bGVcIiwgXCJjb2xvclwiLCBcIlwiLCBcImNvbG9yXCIpLCBpLmRlc2NyaWJlKFwic2NhbGVcIiwge1xuICAgIF9mYWxsYmFjazogITEsXG4gICAgX3NjcmlwdGFibGU6IGZ1bmN0aW9uIF9zY3JpcHRhYmxlKHQpIHtcbiAgICAgIHJldHVybiAhdC5zdGFydHNXaXRoKFwiYmVmb3JlXCIpICYmICF0LnN0YXJ0c1dpdGgoXCJhZnRlclwiKSAmJiB0ICE9PSBcImNhbGxiYWNrXCIgJiYgdCAhPT0gXCJwYXJzZXJcIjtcbiAgICB9LFxuICAgIF9pbmRleGFibGU6IGZ1bmN0aW9uIF9pbmRleGFibGUodCkge1xuICAgICAgcmV0dXJuIHQgIT09IFwiYm9yZGVyRGFzaFwiICYmIHQgIT09IFwidGlja0JvcmRlckRhc2hcIiAmJiB0ICE9PSBcImRhc2hcIjtcbiAgICB9XG4gIH0pLCBpLmRlc2NyaWJlKFwic2NhbGVzXCIsIHtcbiAgICBfZmFsbGJhY2s6IFwic2NhbGVcIlxuICB9KSwgaS5kZXNjcmliZShcInNjYWxlLnRpY2tzXCIsIHtcbiAgICBfc2NyaXB0YWJsZTogZnVuY3Rpb24gX3NjcmlwdGFibGUodCkge1xuICAgICAgcmV0dXJuIHQgIT09IFwiYmFja2Ryb3BQYWRkaW5nXCIgJiYgdCAhPT0gXCJjYWxsYmFja1wiO1xuICAgIH0sXG4gICAgX2luZGV4YWJsZTogZnVuY3Rpb24gX2luZGV4YWJsZSh0KSB7XG4gICAgICByZXR1cm4gdCAhPT0gXCJiYWNrZHJvcFBhZGRpbmdcIjtcbiAgICB9XG4gIH0pO1xufVxudmFyIHp0ID0gLyogQF9fUFVSRV9fICovT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgTWkgPSAvKiBAX19QVVJFX18gKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gZGUoaSwgdCkge1xuICBpZiAoIXQpIHJldHVybiBpO1xuICB2YXIgZSA9IHQuc3BsaXQoXCIuXCIpO1xuICBmb3IgKHZhciBzID0gMCwgbiA9IGUubGVuZ3RoOyBzIDwgbjsgKytzKSB7XG4gICAgdmFyIG8gPSBlW3NdO1xuICAgIGkgPSBpW29dIHx8IChpW29dID0gLyogQF9fUFVSRV9fICovT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBvaShpLCB0LCBlKSB7XG4gIHJldHVybiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gZmUoZGUoaSwgdCksIGUpIDogZmUoZGUoaSwgXCJcIiksIHQpO1xufVxudmFyIGxyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gbHIodCwgZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBscik7XG4gICAgdGhpcy5hbmltYXRpb24gPSB2b2lkIDAsIHRoaXMuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKDAsMCwwLDAuMSlcIiwgdGhpcy5ib3JkZXJDb2xvciA9IFwicmdiYSgwLDAsMCwwLjEpXCIsIHRoaXMuY29sb3IgPSBcIiM2NjZcIiwgdGhpcy5kYXRhc2V0cyA9IHt9LCB0aGlzLmRldmljZVBpeGVsUmF0aW8gPSBmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMuY2hhcnQucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIH0sIHRoaXMuZWxlbWVudHMgPSB7fSwgdGhpcy5ldmVudHMgPSBbXCJtb3VzZW1vdmVcIiwgXCJtb3VzZW91dFwiLCBcImNsaWNrXCIsIFwidG91Y2hzdGFydFwiLCBcInRvdWNobW92ZVwiXSwgdGhpcy5mb250ID0ge1xuICAgICAgZmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG4gICAgICBzaXplOiAxMixcbiAgICAgIHN0eWxlOiBcIm5vcm1hbFwiLFxuICAgICAgbGluZUhlaWdodDogMS4yLFxuICAgICAgd2VpZ2h0OiBudWxsXG4gICAgfSwgdGhpcy5ob3ZlciA9IHt9LCB0aGlzLmhvdmVyQmFja2dyb3VuZENvbG9yID0gZnVuY3Rpb24gKHMsIG4pIHtcbiAgICAgIHJldHVybiBuaShuLmJhY2tncm91bmRDb2xvcik7XG4gICAgfSwgdGhpcy5ob3ZlckJvcmRlckNvbG9yID0gZnVuY3Rpb24gKHMsIG4pIHtcbiAgICAgIHJldHVybiBuaShuLmJvcmRlckNvbG9yKTtcbiAgICB9LCB0aGlzLmhvdmVyQ29sb3IgPSBmdW5jdGlvbiAocywgbikge1xuICAgICAgcmV0dXJuIG5pKG4uY29sb3IpO1xuICAgIH0sIHRoaXMuaW5kZXhBeGlzID0gXCJ4XCIsIHRoaXMuaW50ZXJhY3Rpb24gPSB7XG4gICAgICBtb2RlOiBcIm5lYXJlc3RcIixcbiAgICAgIGludGVyc2VjdDogITAsXG4gICAgICBpbmNsdWRlSW52aXNpYmxlOiAhMVxuICAgIH0sIHRoaXMubWFpbnRhaW5Bc3BlY3RSYXRpbyA9ICEwLCB0aGlzLm9uSG92ZXIgPSBudWxsLCB0aGlzLm9uQ2xpY2sgPSBudWxsLCB0aGlzLnBhcnNpbmcgPSAhMCwgdGhpcy5wbHVnaW5zID0ge30sIHRoaXMucmVzcG9uc2l2ZSA9ICEwLCB0aGlzLnNjYWxlID0gdm9pZCAwLCB0aGlzLnNjYWxlcyA9IHt9LCB0aGlzLnNob3dMaW5lID0gITAsIHRoaXMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSAhMCwgdGhpcy5kZXNjcmliZSh0KSwgdGhpcy5hcHBseShlKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKGxyLCBbe1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KHQsIGUpIHtcbiAgICAgIHJldHVybiBvaSh0aGlzLCB0LCBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldCh0KSB7XG4gICAgICByZXR1cm4gZGUodGhpcywgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc2NyaWJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc2NyaWJlKHQsIGUpIHtcbiAgICAgIHJldHVybiBvaShNaSwgdCwgZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm92ZXJyaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG92ZXJyaWRlKHQsIGUpIHtcbiAgICAgIHJldHVybiBvaSh6dCwgdCwgZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdXRlKHQsIGUsIHMsIG4pIHtcbiAgICAgIHZhciBvID0gZGUodGhpcywgdCksXG4gICAgICAgIHIgPSBkZSh0aGlzLCBzKSxcbiAgICAgICAgYSA9IFwiX1wiICsgZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG8sIF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoe30sIGEsIHtcbiAgICAgICAgdmFsdWU6IG9bZV0sXG4gICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgfSksIGUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHZhciBsID0gdGhpc1thXSxcbiAgICAgICAgICAgIGMgPSByW25dO1xuICAgICAgICAgIHJldHVybiBUKGwpID8gT2JqZWN0LmFzc2lnbih7fSwgYywgbCkgOiBEKGwsIGMpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChsKSB7XG4gICAgICAgICAgdGhpc1thXSA9IGw7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkodCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB0LmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUoX3RoaXMyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xufSgpO1xudmFyIFcgPSAvKiBAX19QVVJFX18gKi9uZXcgbHIoe1xuICBfc2NyaXB0YWJsZTogZnVuY3Rpb24gX3NjcmlwdGFibGUoaSkge1xuICAgIHJldHVybiAhaS5zdGFydHNXaXRoKFwib25cIik7XG4gIH0sXG4gIF9pbmRleGFibGU6IGZ1bmN0aW9uIF9pbmRleGFibGUoaSkge1xuICAgIHJldHVybiBpICE9PSBcImV2ZW50c1wiO1xuICB9LFxuICBob3Zlcjoge1xuICAgIF9mYWxsYmFjazogXCJpbnRlcmFjdGlvblwiXG4gIH0sXG4gIGludGVyYWN0aW9uOiB7XG4gICAgX3NjcmlwdGFibGU6ICExLFxuICAgIF9pbmRleGFibGU6ICExXG4gIH1cbn0sIFtpciwgc3IsIGFyXSk7XG5mdW5jdGlvbiBjcihpKSB7XG4gIHJldHVybiAhaSB8fCBSKGkuc2l6ZSkgfHwgUihpLmZhbWlseSkgPyBudWxsIDogKGkuc3R5bGUgPyBpLnN0eWxlICsgXCIgXCIgOiBcIlwiKSArIChpLndlaWdodCA/IGkud2VpZ2h0ICsgXCIgXCIgOiBcIlwiKSArIGkuc2l6ZSArIFwicHggXCIgKyBpLmZhbWlseTtcbn1cbmZ1bmN0aW9uIGxzKGksIHQsIGUsIHMsIG4pIHtcbiAgdmFyIG8gPSB0W25dO1xuICByZXR1cm4gbyB8fCAobyA9IHRbbl0gPSBpLm1lYXN1cmVUZXh0KG4pLndpZHRoLCBlLnB1c2gobikpLCBvID4gcyAmJiAocyA9IG8pLCBzO1xufVxuZnVuY3Rpb24gT3QoaSwgdCwgZSkge1xuICB2YXIgcyA9IGkuY3VycmVudERldmljZVBpeGVsUmF0aW8sXG4gICAgbiA9IGUgIT09IDAgPyBNYXRoLm1heChlIC8gMiwgMC41KSA6IDA7XG4gIHJldHVybiBNYXRoLnJvdW5kKCh0IC0gbikgKiBzKSAvIHMgKyBuO1xufVxuZnVuY3Rpb24gY3MoaSwgdCkge1xuICAhdCAmJiAhaSB8fCAodCA9IHQgfHwgaS5nZXRDb250ZXh0KFwiMmRcIiksIHQuc2F2ZSgpLCB0LnJlc2V0VHJhbnNmb3JtKCksIHQuY2xlYXJSZWN0KDAsIDAsIGkud2lkdGgsIGkuaGVpZ2h0KSwgdC5yZXN0b3JlKCkpO1xufVxuZnVuY3Rpb24gU2koaSwgdCwgZSwgcykge1xuICBDbihpLCB0LCBlLCBzLCBudWxsKTtcbn1cbmZ1bmN0aW9uIENuKGksIHQsIGUsIHMsIG4pIHtcbiAgdmFyIG8sIHIsIGEsIGwsIGMsIGgsIGQsIHU7XG4gIHZhciBmID0gdC5wb2ludFN0eWxlLFxuICAgIHAgPSB0LnJvdGF0aW9uLFxuICAgIGcgPSB0LnJhZGl1cztcbiAgdmFyIG0gPSAocCB8fCAwKSAqIE5vO1xuICBpZiAoZiAmJiBfdHlwZW9mKGYpID09IFwib2JqZWN0XCIgJiYgKG8gPSBmLnRvU3RyaW5nKCksIG8gPT09IFwiW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XVwiIHx8IG8gPT09IFwiW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF1cIikpIHtcbiAgICBpLnNhdmUoKSwgaS50cmFuc2xhdGUoZSwgcyksIGkucm90YXRlKG0pLCBpLmRyYXdJbWFnZShmLCAtZi53aWR0aCAvIDIsIC1mLmhlaWdodCAvIDIsIGYud2lkdGgsIGYuaGVpZ2h0KSwgaS5yZXN0b3JlKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKGlzTmFOKGcpIHx8IGcgPD0gMCkpIHtcbiAgICBzd2l0Y2ggKGkuYmVnaW5QYXRoKCksIGYpIHtcbiAgICAgIC8vIERlZmF1bHQgaW5jbHVkZXMgY2lyY2xlXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBuID8gaS5lbGxpcHNlKGUsIHMsIG4gLyAyLCBnLCAwLCAwLCBCKSA6IGkuYXJjKGUsIHMsIGcsIDAsIEIpLCBpLmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0cmlhbmdsZVwiOlxuICAgICAgICBoID0gbiA/IG4gLyAyIDogZywgaS5tb3ZlVG8oZSArIE1hdGguc2luKG0pICogaCwgcyAtIE1hdGguY29zKG0pICogZyksIG0gKz0gdHMsIGkubGluZVRvKGUgKyBNYXRoLnNpbihtKSAqIGgsIHMgLSBNYXRoLmNvcyhtKSAqIGcpLCBtICs9IHRzLCBpLmxpbmVUbyhlICsgTWF0aC5zaW4obSkgKiBoLCBzIC0gTWF0aC5jb3MobSkgKiBnKSwgaS5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmVjdFJvdW5kZWRcIjpcbiAgICAgICAgYyA9IGcgKiAwLjUxNiwgbCA9IGcgLSBjLCByID0gTWF0aC5jb3MobSArIEN0KSAqIGwsIGQgPSBNYXRoLmNvcyhtICsgQ3QpICogKG4gPyBuIC8gMiAtIGMgOiBsKSwgYSA9IE1hdGguc2luKG0gKyBDdCkgKiBsLCB1ID0gTWF0aC5zaW4obSArIEN0KSAqIChuID8gbiAvIDIgLSBjIDogbCksIGkuYXJjKGUgLSBkLCBzIC0gYSwgYywgbSAtIEUsIG0gLSBWKSwgaS5hcmMoZSArIHUsIHMgLSByLCBjLCBtIC0gViwgbSksIGkuYXJjKGUgKyBkLCBzICsgYSwgYywgbSwgbSArIFYpLCBpLmFyYyhlIC0gdSwgcyArIHIsIGMsIG0gKyBWLCBtICsgRSksIGkuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJlY3RcIjpcbiAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgbCA9IE1hdGguU1FSVDFfMiAqIGcsIGggPSBuID8gbiAvIDIgOiBsLCBpLnJlY3QoZSAtIGgsIHMgLSBsLCAyICogaCwgMiAqIGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG0gKz0gQ3Q7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFwicmVjdFJvdFwiOlxuICAgICAgICBkID0gTWF0aC5jb3MobSkgKiAobiA/IG4gLyAyIDogZyksIHIgPSBNYXRoLmNvcyhtKSAqIGcsIGEgPSBNYXRoLnNpbihtKSAqIGcsIHUgPSBNYXRoLnNpbihtKSAqIChuID8gbiAvIDIgOiBnKSwgaS5tb3ZlVG8oZSAtIGQsIHMgLSBhKSwgaS5saW5lVG8oZSArIHUsIHMgLSByKSwgaS5saW5lVG8oZSArIGQsIHMgKyBhKSwgaS5saW5lVG8oZSAtIHUsIHMgKyByKSwgaS5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY3Jvc3NSb3RcIjpcbiAgICAgICAgbSArPSBDdDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgXCJjcm9zc1wiOlxuICAgICAgICBkID0gTWF0aC5jb3MobSkgKiAobiA/IG4gLyAyIDogZyksIHIgPSBNYXRoLmNvcyhtKSAqIGcsIGEgPSBNYXRoLnNpbihtKSAqIGcsIHUgPSBNYXRoLnNpbihtKSAqIChuID8gbiAvIDIgOiBnKSwgaS5tb3ZlVG8oZSAtIGQsIHMgLSBhKSwgaS5saW5lVG8oZSArIGQsIHMgKyBhKSwgaS5tb3ZlVG8oZSArIHUsIHMgLSByKSwgaS5saW5lVG8oZSAtIHUsIHMgKyByKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3RhclwiOlxuICAgICAgICBkID0gTWF0aC5jb3MobSkgKiAobiA/IG4gLyAyIDogZyksIHIgPSBNYXRoLmNvcyhtKSAqIGcsIGEgPSBNYXRoLnNpbihtKSAqIGcsIHUgPSBNYXRoLnNpbihtKSAqIChuID8gbiAvIDIgOiBnKSwgaS5tb3ZlVG8oZSAtIGQsIHMgLSBhKSwgaS5saW5lVG8oZSArIGQsIHMgKyBhKSwgaS5tb3ZlVG8oZSArIHUsIHMgLSByKSwgaS5saW5lVG8oZSAtIHUsIHMgKyByKSwgbSArPSBDdCwgZCA9IE1hdGguY29zKG0pICogKG4gPyBuIC8gMiA6IGcpLCByID0gTWF0aC5jb3MobSkgKiBnLCBhID0gTWF0aC5zaW4obSkgKiBnLCB1ID0gTWF0aC5zaW4obSkgKiAobiA/IG4gLyAyIDogZyksIGkubW92ZVRvKGUgLSBkLCBzIC0gYSksIGkubGluZVRvKGUgKyBkLCBzICsgYSksIGkubW92ZVRvKGUgKyB1LCBzIC0gciksIGkubGluZVRvKGUgLSB1LCBzICsgcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImxpbmVcIjpcbiAgICAgICAgciA9IG4gPyBuIC8gMiA6IE1hdGguY29zKG0pICogZywgYSA9IE1hdGguc2luKG0pICogZywgaS5tb3ZlVG8oZSAtIHIsIHMgLSBhKSwgaS5saW5lVG8oZSArIHIsIHMgKyBhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGFzaFwiOlxuICAgICAgICBpLm1vdmVUbyhlLCBzKSwgaS5saW5lVG8oZSArIE1hdGguY29zKG0pICogKG4gPyBuIC8gMiA6IGcpLCBzICsgTWF0aC5zaW4obSkgKiBnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICExOlxuICAgICAgICBpLmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaS5maWxsKCksIHQuYm9yZGVyV2lkdGggPiAwICYmIGkuc3Ryb2tlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1lKGksIHQsIGUpIHtcbiAgcmV0dXJuIGUgPSBlIHx8IDAuNSwgIXQgfHwgaSAmJiBpLnggPiB0LmxlZnQgLSBlICYmIGkueCA8IHQucmlnaHQgKyBlICYmIGkueSA+IHQudG9wIC0gZSAmJiBpLnkgPCB0LmJvdHRvbSArIGU7XG59XG5mdW5jdGlvbiBKZShpLCB0KSB7XG4gIGkuc2F2ZSgpLCBpLmJlZ2luUGF0aCgpLCBpLnJlY3QodC5sZWZ0LCB0LnRvcCwgdC5yaWdodCAtIHQubGVmdCwgdC5ib3R0b20gLSB0LnRvcCksIGkuY2xpcCgpO1xufVxuZnVuY3Rpb24gWmUoaSkge1xuICBpLnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGhyKGksIHQsIGUsIHMsIG4pIHtcbiAgaWYgKCF0KSByZXR1cm4gaS5saW5lVG8oZS54LCBlLnkpO1xuICBpZiAobiA9PT0gXCJtaWRkbGVcIikge1xuICAgIHZhciBvID0gKHQueCArIGUueCkgLyAyO1xuICAgIGkubGluZVRvKG8sIHQueSksIGkubGluZVRvKG8sIGUueSk7XG4gIH0gZWxzZSBuID09PSBcImFmdGVyXCIgIT0gISFzID8gaS5saW5lVG8odC54LCBlLnkpIDogaS5saW5lVG8oZS54LCB0LnkpO1xuICBpLmxpbmVUbyhlLngsIGUueSk7XG59XG5mdW5jdGlvbiBkcihpLCB0LCBlLCBzKSB7XG4gIGlmICghdCkgcmV0dXJuIGkubGluZVRvKGUueCwgZS55KTtcbiAgaS5iZXppZXJDdXJ2ZVRvKHMgPyB0LmNwMXggOiB0LmNwMngsIHMgPyB0LmNwMXkgOiB0LmNwMnksIHMgPyBlLmNwMnggOiBlLmNwMXgsIHMgPyBlLmNwMnkgOiBlLmNwMXksIGUueCwgZS55KTtcbn1cbmZ1bmN0aW9uIHVyKGksIHQpIHtcbiAgdC50cmFuc2xhdGlvbiAmJiBpLnRyYW5zbGF0ZSh0LnRyYW5zbGF0aW9uWzBdLCB0LnRyYW5zbGF0aW9uWzFdKSwgUih0LnJvdGF0aW9uKSB8fCBpLnJvdGF0ZSh0LnJvdGF0aW9uKSwgdC5jb2xvciAmJiAoaS5maWxsU3R5bGUgPSB0LmNvbG9yKSwgdC50ZXh0QWxpZ24gJiYgKGkudGV4dEFsaWduID0gdC50ZXh0QWxpZ24pLCB0LnRleHRCYXNlbGluZSAmJiAoaS50ZXh0QmFzZWxpbmUgPSB0LnRleHRCYXNlbGluZSk7XG59XG5mdW5jdGlvbiBmcihpLCB0LCBlLCBzLCBuKSB7XG4gIGlmIChuLnN0cmlrZXRocm91Z2ggfHwgbi51bmRlcmxpbmUpIHtcbiAgICB2YXIgbyA9IGkubWVhc3VyZVRleHQocyksXG4gICAgICByID0gdCAtIG8uYWN0dWFsQm91bmRpbmdCb3hMZWZ0LFxuICAgICAgYSA9IHQgKyBvLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQsXG4gICAgICBsID0gZSAtIG8uYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQsXG4gICAgICBjID0gZSArIG8uYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgaCA9IG4uc3RyaWtldGhyb3VnaCA/IChsICsgYykgLyAyIDogYztcbiAgICBpLnN0cm9rZVN0eWxlID0gaS5maWxsU3R5bGUsIGkuYmVnaW5QYXRoKCksIGkubGluZVdpZHRoID0gbi5kZWNvcmF0aW9uV2lkdGggfHwgMiwgaS5tb3ZlVG8ociwgaCksIGkubGluZVRvKGEsIGgpLCBpLnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBncihpLCB0KSB7XG4gIHZhciBlID0gaS5maWxsU3R5bGU7XG4gIGkuZmlsbFN0eWxlID0gdC5jb2xvciwgaS5maWxsUmVjdCh0LmxlZnQsIHQudG9wLCB0LndpZHRoLCB0LmhlaWdodCksIGkuZmlsbFN0eWxlID0gZTtcbn1cbmZ1bmN0aW9uIGJlKGksIHQsIGUsIHMsIG4pIHtcbiAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICB2YXIgciA9IE4odCkgPyB0IDogW3RdLFxuICAgIGEgPSBvLnN0cm9rZVdpZHRoID4gMCAmJiBvLnN0cm9rZUNvbG9yICE9PSBcIlwiO1xuICB2YXIgbCwgYztcbiAgZm9yIChpLnNhdmUoKSwgaS5mb250ID0gbi5zdHJpbmcsIHVyKGksIG8pLCBsID0gMDsgbCA8IHIubGVuZ3RoOyArK2wpIGMgPSByW2xdLCBvLmJhY2tkcm9wICYmIGdyKGksIG8uYmFja2Ryb3ApLCBhICYmIChvLnN0cm9rZUNvbG9yICYmIChpLnN0cm9rZVN0eWxlID0gby5zdHJva2VDb2xvciksIFIoby5zdHJva2VXaWR0aCkgfHwgKGkubGluZVdpZHRoID0gby5zdHJva2VXaWR0aCksIGkuc3Ryb2tlVGV4dChjLCBlLCBzLCBvLm1heFdpZHRoKSksIGkuZmlsbFRleHQoYywgZSwgcywgby5tYXhXaWR0aCksIGZyKGksIGUsIHMsIGMsIG8pLCBzICs9IE51bWJlcihuLmxpbmVIZWlnaHQpO1xuICBpLnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIFVlKGksIHQpIHtcbiAgdmFyIGUgPSB0LngsXG4gICAgcyA9IHQueSxcbiAgICBuID0gdC53LFxuICAgIG8gPSB0LmgsXG4gICAgciA9IHQucmFkaXVzO1xuICBpLmFyYyhlICsgci50b3BMZWZ0LCBzICsgci50b3BMZWZ0LCByLnRvcExlZnQsIDEuNSAqIEUsIEUsICEwKSwgaS5saW5lVG8oZSwgcyArIG8gLSByLmJvdHRvbUxlZnQpLCBpLmFyYyhlICsgci5ib3R0b21MZWZ0LCBzICsgbyAtIHIuYm90dG9tTGVmdCwgci5ib3R0b21MZWZ0LCBFLCBWLCAhMCksIGkubGluZVRvKGUgKyBuIC0gci5ib3R0b21SaWdodCwgcyArIG8pLCBpLmFyYyhlICsgbiAtIHIuYm90dG9tUmlnaHQsIHMgKyBvIC0gci5ib3R0b21SaWdodCwgci5ib3R0b21SaWdodCwgViwgMCwgITApLCBpLmxpbmVUbyhlICsgbiwgcyArIHIudG9wUmlnaHQpLCBpLmFyYyhlICsgbiAtIHIudG9wUmlnaHQsIHMgKyByLnRvcFJpZ2h0LCByLnRvcFJpZ2h0LCAwLCAtViwgITApLCBpLmxpbmVUbyhlICsgci50b3BMZWZ0LCBzKTtcbn1cbnZhciBwciA9IC9eKG5vcm1hbHwoXFxkKyg/OlxcLlxcZCspPykocHh8ZW18JSk/KSQvLFxuICBtciA9IC9eKG5vcm1hbHxpdGFsaWN8aW5pdGlhbHxpbmhlcml0fHVuc2V0fChvYmxpcXVlKCAtP1swLTldP1swLTldZGVnKT8pKSQvO1xuZnVuY3Rpb24gYnIoaSwgdCkge1xuICB2YXIgZSA9IChcIlwiICsgaSkubWF0Y2gocHIpO1xuICBpZiAoIWUgfHwgZVsxXSA9PT0gXCJub3JtYWxcIikgcmV0dXJuIHQgKiAxLjI7XG4gIHN3aXRjaCAoaSA9ICtlWzJdLCBlWzNdKSB7XG4gICAgY2FzZSBcInB4XCI6XG4gICAgICByZXR1cm4gaTtcbiAgICBjYXNlIFwiJVwiOlxuICAgICAgaSAvPSAxMDA7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gdCAqIGk7XG59XG52YXIgX3IgPSBmdW5jdGlvbiBfcihpKSB7XG4gIHJldHVybiAraSB8fCAwO1xufTtcbmZ1bmN0aW9uIFdpKGksIHQpIHtcbiAgdmFyIGUgPSB7fSxcbiAgICBzID0gVCh0KSxcbiAgICBuID0gcyA/IE9iamVjdC5rZXlzKHQpIDogdCxcbiAgICBvID0gVChpKSA/IHMgPyBmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIEQoaVtyXSwgaVt0W3JdXSk7XG4gICAgfSA6IGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gaVtyXTtcbiAgICB9IDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfTtcbiAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihuKSxcbiAgICBfc3RlcDQ7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciByID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgZVtyXSA9IF9yKG8ocikpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yNC5mKCk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBPbihpKSB7XG4gIHJldHVybiBXaShpLCB7XG4gICAgdG9wOiBcInlcIixcbiAgICByaWdodDogXCJ4XCIsXG4gICAgYm90dG9tOiBcInlcIixcbiAgICBsZWZ0OiBcInhcIlxuICB9KTtcbn1cbmZ1bmN0aW9uIFl0KGkpIHtcbiAgcmV0dXJuIFdpKGksIFtcInRvcExlZnRcIiwgXCJ0b3BSaWdodFwiLCBcImJvdHRvbUxlZnRcIiwgXCJib3R0b21SaWdodFwiXSk7XG59XG5mdW5jdGlvbiBldChpKSB7XG4gIHZhciB0ID0gT24oaSk7XG4gIHJldHVybiB0LndpZHRoID0gdC5sZWZ0ICsgdC5yaWdodCwgdC5oZWlnaHQgPSB0LnRvcCArIHQuYm90dG9tLCB0O1xufVxuZnVuY3Rpb24gWChpLCB0KSB7XG4gIGkgPSBpIHx8IHt9LCB0ID0gdCB8fCBXLmZvbnQ7XG4gIHZhciBlID0gRChpLnNpemUsIHQuc2l6ZSk7XG4gIHR5cGVvZiBlID09IFwic3RyaW5nXCIgJiYgKGUgPSBwYXJzZUludChlLCAxMCkpO1xuICB2YXIgcyA9IEQoaS5zdHlsZSwgdC5zdHlsZSk7XG4gIHMgJiYgIShcIlwiICsgcykubWF0Y2gobXIpICYmIChjb25zb2xlLndhcm4oJ0ludmFsaWQgZm9udCBzdHlsZSBzcGVjaWZpZWQ6IFwiJyArIHMgKyAnXCInKSwgcyA9IHZvaWQgMCk7XG4gIHZhciBuID0ge1xuICAgIGZhbWlseTogRChpLmZhbWlseSwgdC5mYW1pbHkpLFxuICAgIGxpbmVIZWlnaHQ6IGJyKEQoaS5saW5lSGVpZ2h0LCB0LmxpbmVIZWlnaHQpLCBlKSxcbiAgICBzaXplOiBlLFxuICAgIHN0eWxlOiBzLFxuICAgIHdlaWdodDogRChpLndlaWdodCwgdC53ZWlnaHQpLFxuICAgIHN0cmluZzogXCJcIlxuICB9O1xuICByZXR1cm4gbi5zdHJpbmcgPSBjcihuKSwgbjtcbn1cbmZ1bmN0aW9uIHdlKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4sIG8sIHI7XG4gIGZvciAobiA9IDAsIG8gPSBpLmxlbmd0aDsgbiA8IG87ICsrbikgaWYgKHIgPSBpW25dLCByICE9PSB2b2lkIDAgJiYgciAhPT0gdm9pZCAwKSByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHhyKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBpLm1pbixcbiAgICBuID0gaS5tYXgsXG4gICAgbyA9IGJuKHQsIChuIC0gcykgLyAyKSxcbiAgICByID0gZnVuY3Rpb24gcihhLCBsKSB7XG4gICAgICByZXR1cm4gZSAmJiBhID09PSAwID8gMCA6IGEgKyBsO1xuICAgIH07XG4gIHJldHVybiB7XG4gICAgbWluOiByKHMsIC1NYXRoLmFicyhvKSksXG4gICAgbWF4OiByKG4sIG8pXG4gIH07XG59XG5mdW5jdGlvbiBCdChpLCB0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoaSksIHQpO1xufVxuZnVuY3Rpb24gTmkoaSkge1xuICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW1wiXCJdO1xuICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpWzBdO1xuICB9O1xuICB2YXIgbyA9IGUgfHwgaTtcbiAgX3R5cGVvZihzKSA+IFwidVwiICYmIChzID0gTG4oXCJfZmFsbGJhY2tcIiwgaSkpO1xuICB2YXIgciA9IF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eSh7fSwgU3ltYm9sLnRvU3RyaW5nVGFnLCBcIk9iamVjdFwiKSwgXCJfY2FjaGVhYmxlXCIsICEwKSwgXCJfc2NvcGVzXCIsIGkpLCBcIl9yb290U2NvcGVzXCIsIG8pLCBcIl9mYWxsYmFja1wiLCBzKSwgXCJfZ2V0VGFyZ2V0XCIsIG4pLCBcIm92ZXJyaWRlXCIsIGZ1bmN0aW9uIG92ZXJyaWRlKGEpIHtcbiAgICByZXR1cm4gTmkoW2FdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoaSkpLCB0LCBvLCBzKTtcbiAgfSk7XG4gIHJldHVybiBuZXcgUHJveHkociwge1xuICAgIC8qKlxuICAgICogQSB0cmFwIGZvciB0aGUgZGVsZXRlIG9wZXJhdG9yLlxuICAgICovXG4gICAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KGEsIGwpIHtcbiAgICAgIHJldHVybiBkZWxldGUgYVtsXSwgZGVsZXRlIGEuX2tleXMsIGRlbGV0ZSBpWzBdW2xdLCAhMDtcbiAgICB9LFxuICAgIC8qKlxuICAgICogQSB0cmFwIGZvciBnZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KGEsIGwpIHtcbiAgICAgIHJldHVybiBBbihhLCBsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEcihsLCB0LCBpLCBhKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuXG4gICAgKiBBbHNvIHVzZWQgYnkgT2JqZWN0Lmhhc093blByb3BlcnR5LlxuICAgICovXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYSwgbCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGEuX3Njb3Blc1swXSwgbCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mLlxuICAgICovXG4gICAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YoaVswXSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAqIEEgdHJhcCBmb3IgdGhlIGluIG9wZXJhdG9yLlxuICAgICovXG4gICAgaGFzOiBmdW5jdGlvbiBoYXMoYSwgbCkge1xuICAgICAgcmV0dXJuIGRzKGEpLmluY2x1ZGVzKGwpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIGFuZCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLlxuICAgICovXG4gICAgb3duS2V5czogZnVuY3Rpb24gb3duS2V5cyhhKSB7XG4gICAgICByZXR1cm4gZHMoYSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAqIEEgdHJhcCBmb3Igc2V0dGluZyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChhLCBsLCBjKSB7XG4gICAgICB2YXIgaCA9IGEuX3N0b3JhZ2UgfHwgKGEuX3N0b3JhZ2UgPSBuKCkpO1xuICAgICAgcmV0dXJuIGFbbF0gPSBoW2xdID0gYywgZGVsZXRlIGEuX2tleXMsICEwO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBxdChpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0ge1xuICAgIF9jYWNoZWFibGU6ICExLFxuICAgIF9wcm94eTogaSxcbiAgICBfY29udGV4dDogdCxcbiAgICBfc3ViUHJveHk6IGUsXG4gICAgX3N0YWNrOiAvKiBAX19QVVJFX18gKi9uZXcgU2V0KCksXG4gICAgX2Rlc2NyaXB0b3JzOiBUbihpLCBzKSxcbiAgICBzZXRDb250ZXh0OiBmdW5jdGlvbiBzZXRDb250ZXh0KG8pIHtcbiAgICAgIHJldHVybiBxdChpLCBvLCBlLCBzKTtcbiAgICB9LFxuICAgIG92ZXJyaWRlOiBmdW5jdGlvbiBvdmVycmlkZShvKSB7XG4gICAgICByZXR1cm4gcXQoaS5vdmVycmlkZShvKSwgdCwgZSwgcyk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KG4sIHtcbiAgICAvKipcbiAgICAqIEEgdHJhcCBmb3IgdGhlIGRlbGV0ZSBvcGVyYXRvci5cbiAgICAqL1xuICAgIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eShvLCByKSB7XG4gICAgICByZXR1cm4gZGVsZXRlIG9bcl0sIGRlbGV0ZSBpW3JdLCAhMDtcbiAgICB9LFxuICAgIC8qKlxuICAgICogQSB0cmFwIGZvciBnZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KG8sIHIsIGEpIHtcbiAgICAgIHJldHVybiBBbihvLCByLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2cihvLCByLCBhKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuXG4gICAgKiBBbHNvIHVzZWQgYnkgT2JqZWN0Lmhhc093blByb3BlcnR5LlxuICAgICovXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobywgcikge1xuICAgICAgcmV0dXJuIG8uX2Rlc2NyaXB0b3JzLmFsbEtleXMgPyBSZWZsZWN0LmhhcyhpLCByKSA/IHtcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0gOiB2b2lkIDAgOiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpLCByKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YuXG4gICAgKi9cbiAgICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICogQSB0cmFwIGZvciB0aGUgaW4gb3BlcmF0b3IuXG4gICAgKi9cbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyhvLCByKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXMoaSwgcik7XG4gICAgfSxcbiAgICAvKipcbiAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgYW5kIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMuXG4gICAgKi9cbiAgICBvd25LZXlzOiBmdW5jdGlvbiBvd25LZXlzKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICogQSB0cmFwIGZvciBzZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gc2V0KG8sIHIsIGEpIHtcbiAgICAgIHJldHVybiBpW3JdID0gYSwgZGVsZXRlIG9bcl0sICEwO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBUbihpKSB7XG4gIHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgc2NyaXB0YWJsZTogITAsXG4gICAgaW5kZXhhYmxlOiAhMFxuICB9O1xuICB2YXIgX2kkX3NjcmlwdGFibGUgPSBpLl9zY3JpcHRhYmxlLFxuICAgIGUgPSBfaSRfc2NyaXB0YWJsZSA9PT0gdm9pZCAwID8gdC5zY3JpcHRhYmxlIDogX2kkX3NjcmlwdGFibGUsXG4gICAgX2kkX2luZGV4YWJsZSA9IGkuX2luZGV4YWJsZSxcbiAgICBzID0gX2kkX2luZGV4YWJsZSA9PT0gdm9pZCAwID8gdC5pbmRleGFibGUgOiBfaSRfaW5kZXhhYmxlLFxuICAgIF9pJF9hbGxLZXlzID0gaS5fYWxsS2V5cyxcbiAgICBuID0gX2kkX2FsbEtleXMgPT09IHZvaWQgMCA/IHQuYWxsS2V5cyA6IF9pJF9hbGxLZXlzO1xuICByZXR1cm4ge1xuICAgIGFsbEtleXM6IG4sXG4gICAgc2NyaXB0YWJsZTogZSxcbiAgICBpbmRleGFibGU6IHMsXG4gICAgaXNTY3JpcHRhYmxlOiB3dChlKSA/IGUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9LFxuICAgIGlzSW5kZXhhYmxlOiB3dChzKSA/IHMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gIH07XG59XG52YXIgeXIgPSBmdW5jdGlvbiB5cihpLCB0KSB7XG4gICAgcmV0dXJuIGkgPyBpICsgRmkodCkgOiB0O1xuICB9LFxuICBWaSA9IGZ1bmN0aW9uIFZpKGksIHQpIHtcbiAgICByZXR1cm4gVCh0KSAmJiBpICE9PSBcImFkYXB0ZXJzXCIgJiYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSA9PT0gbnVsbCB8fCB0LmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xuICB9O1xuZnVuY3Rpb24gQW4oaSwgdCwgZSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGksIHQpIHx8IHQgPT09IFwiY29uc3RydWN0b3JcIikgcmV0dXJuIGlbdF07XG4gIHZhciBzID0gZSgpO1xuICByZXR1cm4gaVt0XSA9IHMsIHM7XG59XG5mdW5jdGlvbiB2cihpLCB0LCBlKSB7XG4gIHZhciBzID0gaS5fcHJveHksXG4gICAgbiA9IGkuX2NvbnRleHQsXG4gICAgbyA9IGkuX3N1YlByb3h5LFxuICAgIHIgPSBpLl9kZXNjcmlwdG9ycztcbiAgdmFyIGEgPSBzW3RdO1xuICByZXR1cm4gd3QoYSkgJiYgci5pc1NjcmlwdGFibGUodCkgJiYgKGEgPSBNcih0LCBhLCBpLCBlKSksIE4oYSkgJiYgYS5sZW5ndGggJiYgKGEgPSBTcih0LCBhLCBpLCByLmlzSW5kZXhhYmxlKSksIFZpKHQsIGEpICYmIChhID0gcXQoYSwgbiwgbyAmJiBvW3RdLCByKSksIGE7XG59XG5mdW5jdGlvbiBNcihpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gZS5fcHJveHksXG4gICAgbyA9IGUuX2NvbnRleHQsXG4gICAgciA9IGUuX3N1YlByb3h5LFxuICAgIGEgPSBlLl9zdGFjaztcbiAgaWYgKGEuaGFzKGkpKSB0aHJvdyBuZXcgRXJyb3IoXCJSZWN1cnNpb24gZGV0ZWN0ZWQ6IFwiICsgQXJyYXkuZnJvbShhKS5qb2luKFwiLT5cIikgKyBcIi0+XCIgKyBpKTtcbiAgYS5hZGQoaSk7XG4gIHZhciBsID0gdChvLCByIHx8IHMpO1xuICByZXR1cm4gYVtcImRlbGV0ZVwiXShpKSwgVmkoaSwgbCkgJiYgKGwgPSBqaShuLl9zY29wZXMsIG4sIGksIGwpKSwgbDtcbn1cbmZ1bmN0aW9uIFNyKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBlLl9wcm94eSxcbiAgICBvID0gZS5fY29udGV4dCxcbiAgICByID0gZS5fc3ViUHJveHksXG4gICAgYSA9IGUuX2Rlc2NyaXB0b3JzO1xuICBpZiAoX3R5cGVvZihvLmluZGV4KSA8IFwidVwiICYmIHMoaSkpIHJldHVybiB0W28uaW5kZXggJSB0Lmxlbmd0aF07XG4gIGlmIChUKHRbMF0pKSB7XG4gICAgdmFyIGwgPSB0LFxuICAgICAgYyA9IG4uX3Njb3Blcy5maWx0ZXIoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIGggIT09IGw7XG4gICAgICB9KTtcbiAgICB0ID0gW107XG4gICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihsKSxcbiAgICAgIF9zdGVwNTtcbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGggPSBfc3RlcDUudmFsdWU7XG4gICAgICAgIHZhciBkID0gamkoYywgbiwgaSwgaCk7XG4gICAgICAgIHQucHVzaChxdChkLCBvLCByICYmIHJbaV0sIGEpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBSbihpLCB0LCBlKSB7XG4gIHJldHVybiB3dChpKSA/IGkodCwgZSkgOiBpO1xufVxudmFyIGtyID0gZnVuY3Rpb24ga3IoaSwgdCkge1xuICByZXR1cm4gaSA9PT0gITAgPyB0IDogdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiA/IEl0KHQsIGkpIDogdm9pZCAwO1xufTtcbmZ1bmN0aW9uIHdyKGksIHQsIGUsIHMsIG4pIHtcbiAgdmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0KSxcbiAgICBfc3RlcDY7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBvID0gX3N0ZXA2LnZhbHVlO1xuICAgICAgdmFyIHIgPSBrcihlLCBvKTtcbiAgICAgIGlmIChyKSB7XG4gICAgICAgIGkuYWRkKHIpO1xuICAgICAgICB2YXIgYSA9IFJuKHIuX2ZhbGxiYWNrLCBlLCBuKTtcbiAgICAgICAgaWYgKF90eXBlb2YoYSkgPCBcInVcIiAmJiBhICE9PSBlICYmIGEgIT09IHMpIHJldHVybiBhO1xuICAgICAgfSBlbHNlIGlmIChyID09PSAhMSAmJiBfdHlwZW9mKHMpIDwgXCJ1XCIgJiYgZSAhPT0gcykgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3I2LmYoKTtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBqaShpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gdC5fcm9vdFNjb3BlcyxcbiAgICBvID0gUm4odC5fZmFsbGJhY2ssIGUsIHMpLFxuICAgIHIgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGkpLCBfdG9Db25zdW1hYmxlQXJyYXkobikpLFxuICAgIGEgPSAvKiBAX19QVVJFX18gKi9uZXcgU2V0KCk7XG4gIGEuYWRkKHMpO1xuICB2YXIgbCA9IGhzKGEsIHIsIGUsIG8gfHwgZSwgcyk7XG4gIHJldHVybiBsID09PSBudWxsIHx8IF90eXBlb2YobykgPCBcInVcIiAmJiBvICE9PSBlICYmIChsID0gaHMoYSwgciwgbywgbCwgcyksIGwgPT09IG51bGwpID8gITEgOiBOaShBcnJheS5mcm9tKGEpLCBbXCJcIl0sIG4sIG8sIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUHIodCwgZSwgcyk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaHMoaSwgdCwgZSwgcywgbikge1xuICBmb3IgKDsgZTspIGUgPSB3cihpLCB0LCBlLCBzLCBuKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBQcihpLCB0LCBlKSB7XG4gIHZhciBzID0gaS5fZ2V0VGFyZ2V0KCk7XG4gIHQgaW4gcyB8fCAoc1t0XSA9IHt9KTtcbiAgdmFyIG4gPSBzW3RdO1xuICByZXR1cm4gTihuKSAmJiBUKGUpID8gZSA6IG4gfHwge307XG59XG5mdW5jdGlvbiBEcihpLCB0LCBlLCBzKSB7XG4gIHZhciBuO1xuICB2YXIgX2l0ZXJhdG9yNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHQpLFxuICAgIF9zdGVwNztcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjcucygpOyAhKF9zdGVwNyA9IF9pdGVyYXRvcjcubigpKS5kb25lOykge1xuICAgICAgdmFyIG8gPSBfc3RlcDcudmFsdWU7XG4gICAgICBpZiAobiA9IExuKHlyKG8sIGkpLCBlKSwgX3R5cGVvZihuKSA8IFwidVwiKSByZXR1cm4gVmkoaSwgbikgPyBqaShlLCBzLCBpLCBuKSA6IG47XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3I3LmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3I3LmYoKTtcbiAgfVxufVxuZnVuY3Rpb24gTG4oaSwgdCkge1xuICB2YXIgX2l0ZXJhdG9yOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHQpLFxuICAgIF9zdGVwODtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjgucygpOyAhKF9zdGVwOCA9IF9pdGVyYXRvcjgubigpKS5kb25lOykge1xuICAgICAgdmFyIGUgPSBfc3RlcDgudmFsdWU7XG4gICAgICBpZiAoIWUpIGNvbnRpbnVlO1xuICAgICAgdmFyIHMgPSBlW2ldO1xuICAgICAgaWYgKF90eXBlb2YocykgPCBcInVcIikgcmV0dXJuIHM7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3I4LmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3I4LmYoKTtcbiAgfVxufVxuZnVuY3Rpb24gZHMoaSkge1xuICB2YXIgdCA9IGkuX2tleXM7XG4gIHJldHVybiB0IHx8ICh0ID0gaS5fa2V5cyA9IENyKGkuX3Njb3BlcykpLCB0O1xufVxuZnVuY3Rpb24gQ3IoaSkge1xuICB2YXIgdCA9IC8qIEBfX1BVUkVfXyAqL25ldyBTZXQoKTtcbiAgdmFyIF9pdGVyYXRvcjkgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpKSxcbiAgICBfc3RlcDk7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3I5LnMoKTsgIShfc3RlcDkgPSBfaXRlcmF0b3I5Lm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBlID0gX3N0ZXA5LnZhbHVlO1xuICAgICAgdmFyIF9pdGVyYXRvcjAgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihPYmplY3Qua2V5cyhlKS5maWx0ZXIoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gIW4uc3RhcnRzV2l0aChcIl9cIik7XG4gICAgICAgIH0pKSxcbiAgICAgICAgX3N0ZXAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IwLnMoKTsgIShfc3RlcDAgPSBfaXRlcmF0b3IwLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcyA9IF9zdGVwMC52YWx1ZTtcbiAgICAgICAgICB0LmFkZChzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjAuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMC5mKCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3I5LmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3I5LmYoKTtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbSh0KTtcbn1cbnZhciBPciA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0LFxuICBLdCA9IGZ1bmN0aW9uIEt0KGksIHQpIHtcbiAgICByZXR1cm4gdCA8IGkubGVuZ3RoICYmICFpW3RdLnNraXAgJiYgaVt0XTtcbiAgfSxcbiAgRW4gPSBmdW5jdGlvbiBFbihpKSB7XG4gICAgcmV0dXJuIGkgPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIjtcbiAgfTtcbmZ1bmN0aW9uIFRyKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBpLnNraXAgPyB0IDogaSxcbiAgICBvID0gdCxcbiAgICByID0gZS5za2lwID8gdCA6IGUsXG4gICAgYSA9IHZpKG8sIG4pLFxuICAgIGwgPSB2aShyLCBvKTtcbiAgdmFyIGMgPSBhIC8gKGEgKyBsKSxcbiAgICBoID0gbCAvIChhICsgbCk7XG4gIGMgPSBpc05hTihjKSA/IDAgOiBjLCBoID0gaXNOYU4oaCkgPyAwIDogaDtcbiAgdmFyIGQgPSBzICogYyxcbiAgICB1ID0gcyAqIGg7XG4gIHJldHVybiB7XG4gICAgcHJldmlvdXM6IHtcbiAgICAgIHg6IG8ueCAtIGQgKiAoci54IC0gbi54KSxcbiAgICAgIHk6IG8ueSAtIGQgKiAoci55IC0gbi55KVxuICAgIH0sXG4gICAgbmV4dDoge1xuICAgICAgeDogby54ICsgdSAqIChyLnggLSBuLngpLFxuICAgICAgeTogby55ICsgdSAqIChyLnkgLSBuLnkpXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gQXIoaSwgdCwgZSkge1xuICB2YXIgcyA9IGkubGVuZ3RoO1xuICB2YXIgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYSxcbiAgICBsLFxuICAgIGMgPSBLdChpLCAwKTtcbiAgZm9yICh2YXIgaCA9IDA7IGggPCBzIC0gMTsgKytoKSBpZiAobCA9IGMsIGMgPSBLdChpLCBoICsgMSksICEoIWwgfHwgIWMpKSB7XG4gICAgaWYgKGNlKHRbaF0sIDAsIE9yKSkge1xuICAgICAgZVtoXSA9IGVbaCArIDFdID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBuID0gZVtoXSAvIHRbaF0sIG8gPSBlW2ggKyAxXSAvIHRbaF0sIGEgPSBNYXRoLnBvdyhuLCAyKSArIE1hdGgucG93KG8sIDIpLCAhKGEgPD0gOSkgJiYgKHIgPSAzIC8gTWF0aC5zcXJ0KGEpLCBlW2hdID0gbiAqIHIgKiB0W2hdLCBlW2ggKyAxXSA9IG8gKiByICogdFtoXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIFJyKGksIHQpIHtcbiAgdmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwieFwiO1xuICB2YXIgcyA9IEVuKGUpLFxuICAgIG4gPSBpLmxlbmd0aDtcbiAgdmFyIG8sXG4gICAgcixcbiAgICBhLFxuICAgIGwgPSBLdChpLCAwKTtcbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBuOyArK2MpIHtcbiAgICBpZiAociA9IGEsIGEgPSBsLCBsID0gS3QoaSwgYyArIDEpLCAhYSkgY29udGludWU7XG4gICAgdmFyIGggPSBhW2VdLFxuICAgICAgZCA9IGFbc107XG4gICAgciAmJiAobyA9IChoIC0gcltlXSkgLyAzLCBhW1wiY3AxXCIuY29uY2F0KGUpXSA9IGggLSBvLCBhW1wiY3AxXCIuY29uY2F0KHMpXSA9IGQgLSBvICogdFtjXSksIGwgJiYgKG8gPSAobFtlXSAtIGgpIC8gMywgYVtcImNwMlwiLmNvbmNhdChlKV0gPSBoICsgbywgYVtcImNwMlwiLmNvbmNhdChzKV0gPSBkICsgbyAqIHRbY10pO1xuICB9XG59XG5mdW5jdGlvbiBMcihpKSB7XG4gIHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcInhcIjtcbiAgdmFyIGUgPSBFbih0KSxcbiAgICBzID0gaS5sZW5ndGgsXG4gICAgbiA9IEFycmF5KHMpLmZpbGwoMCksXG4gICAgbyA9IEFycmF5KHMpO1xuICB2YXIgcixcbiAgICBhLFxuICAgIGwsXG4gICAgYyA9IEt0KGksIDApO1xuICBmb3IgKHIgPSAwOyByIDwgczsgKytyKSBpZiAoYSA9IGwsIGwgPSBjLCBjID0gS3QoaSwgciArIDEpLCAhIWwpIHtcbiAgICBpZiAoYykge1xuICAgICAgdmFyIGggPSBjW3RdIC0gbFt0XTtcbiAgICAgIG5bcl0gPSBoICE9PSAwID8gKGNbZV0gLSBsW2VdKSAvIGggOiAwO1xuICAgIH1cbiAgICBvW3JdID0gYSA/IGMgPyBsdChuW3IgLSAxXSkgIT09IGx0KG5bcl0pID8gMCA6IChuW3IgLSAxXSArIG5bcl0pIC8gMiA6IG5bciAtIDFdIDogbltyXTtcbiAgfVxuICBBcihpLCBuLCBvKSwgUnIoaSwgbywgdCk7XG59XG5mdW5jdGlvbiBQZShpLCB0LCBlKSB7XG4gIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihpLCBlKSwgdCk7XG59XG5mdW5jdGlvbiBFcihpLCB0KSB7XG4gIHZhciBlLFxuICAgIHMsXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYSA9IG1lKGlbMF0sIHQpO1xuICBmb3IgKGUgPSAwLCBzID0gaS5sZW5ndGg7IGUgPCBzOyArK2UpIHIgPSBvLCBvID0gYSwgYSA9IGUgPCBzIC0gMSAmJiBtZShpW2UgKyAxXSwgdCksIG8gJiYgKG4gPSBpW2VdLCByICYmIChuLmNwMXggPSBQZShuLmNwMXgsIHQubGVmdCwgdC5yaWdodCksIG4uY3AxeSA9IFBlKG4uY3AxeSwgdC50b3AsIHQuYm90dG9tKSksIGEgJiYgKG4uY3AyeCA9IFBlKG4uY3AyeCwgdC5sZWZ0LCB0LnJpZ2h0KSwgbi5jcDJ5ID0gUGUobi5jcDJ5LCB0LnRvcCwgdC5ib3R0b20pKSk7XG59XG5mdW5jdGlvbiBGcihpLCB0LCBlLCBzLCBuKSB7XG4gIHZhciBvLCByLCBhLCBsO1xuICBpZiAodC5zcGFuR2FwcyAmJiAoaSA9IGkuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICFjLnNraXA7XG4gIH0pKSwgdC5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSBcIm1vbm90b25lXCIpIExyKGksIG4pO2Vsc2Uge1xuICAgIHZhciBjID0gcyA/IGlbaS5sZW5ndGggLSAxXSA6IGlbMF07XG4gICAgZm9yIChvID0gMCwgciA9IGkubGVuZ3RoOyBvIDwgcjsgKytvKSBhID0gaVtvXSwgbCA9IFRyKGMsIGEsIGlbTWF0aC5taW4obyArIDEsIHIgLSAocyA/IDAgOiAxKSkgJSByXSwgdC50ZW5zaW9uKSwgYS5jcDF4ID0gbC5wcmV2aW91cy54LCBhLmNwMXkgPSBsLnByZXZpb3VzLnksIGEuY3AyeCA9IGwubmV4dC54LCBhLmNwMnkgPSBsLm5leHQueSwgYyA9IGE7XG4gIH1cbiAgdC5jYXBCZXppZXJQb2ludHMgJiYgRXIoaSwgZSk7XG59XG5mdW5jdGlvbiAkaSgpIHtcbiAgcmV0dXJuICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yod2luZG93KSkgPCBcInVcIiAmJiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZG9jdW1lbnQpKSA8IFwidVwiO1xufVxuZnVuY3Rpb24gWWkoaSkge1xuICB2YXIgdCA9IGkucGFyZW50Tm9kZTtcbiAgcmV0dXJuIHQgJiYgdC50b1N0cmluZygpID09PSBcIltvYmplY3QgU2hhZG93Um9vdF1cIiAmJiAodCA9IHQuaG9zdCksIHQ7XG59XG5mdW5jdGlvbiBYZShpLCB0LCBlKSB7XG4gIHZhciBzO1xuICByZXR1cm4gdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiA/IChzID0gcGFyc2VJbnQoaSwgMTApLCBpLmluZGV4T2YoXCIlXCIpICE9PSAtMSAmJiAocyA9IHMgLyAxMDAgKiB0LnBhcmVudE5vZGVbZV0pKSA6IHMgPSBpLCBzO1xufVxudmFyIFFlID0gZnVuY3Rpb24gUWUoaSkge1xuICByZXR1cm4gaS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoaSwgbnVsbCk7XG59O1xuZnVuY3Rpb24gSXIoaSwgdCkge1xuICByZXR1cm4gUWUoaSkuZ2V0UHJvcGVydHlWYWx1ZSh0KTtcbn1cbnZhciB6ciA9IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXTtcbmZ1bmN0aW9uIEZ0KGksIHQsIGUpIHtcbiAgdmFyIHMgPSB7fTtcbiAgZSA9IGUgPyBcIi1cIiArIGUgOiBcIlwiO1xuICBmb3IgKHZhciBuID0gMDsgbiA8IDQ7IG4rKykge1xuICAgIHZhciBvID0genJbbl07XG4gICAgc1tvXSA9IHBhcnNlRmxvYXQoaVt0ICsgXCItXCIgKyBvICsgZV0pIHx8IDA7XG4gIH1cbiAgcmV0dXJuIHMud2lkdGggPSBzLmxlZnQgKyBzLnJpZ2h0LCBzLmhlaWdodCA9IHMudG9wICsgcy5ib3R0b20sIHM7XG59XG52YXIgQnIgPSBmdW5jdGlvbiBCcihpLCB0LCBlKSB7XG4gIHJldHVybiAoaSA+IDAgfHwgdCA+IDApICYmICghZSB8fCAhZS5zaGFkb3dSb290KTtcbn07XG5mdW5jdGlvbiBIcihpLCB0KSB7XG4gIHZhciBlID0gaS50b3VjaGVzLFxuICAgIHMgPSBlICYmIGUubGVuZ3RoID8gZVswXSA6IGksXG4gICAgbiA9IHMub2Zmc2V0WCxcbiAgICBvID0gcy5vZmZzZXRZO1xuICB2YXIgciA9ICExLFxuICAgIGEsXG4gICAgbDtcbiAgaWYgKEJyKG4sIG8sIGkudGFyZ2V0KSkgYSA9IG4sIGwgPSBvO2Vsc2Uge1xuICAgIHZhciBjID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBhID0gcy5jbGllbnRYIC0gYy5sZWZ0LCBsID0gcy5jbGllbnRZIC0gYy50b3AsIHIgPSAhMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IGEsXG4gICAgeTogbCxcbiAgICBib3g6IHJcbiAgfTtcbn1cbmZ1bmN0aW9uIEF0KGksIHQpIHtcbiAgaWYgKFwibmF0aXZlXCIgaW4gaSkgcmV0dXJuIGk7XG4gIHZhciBlID0gdC5jYW52YXMsXG4gICAgcyA9IHQuY3VycmVudERldmljZVBpeGVsUmF0aW8sXG4gICAgbiA9IFFlKGUpLFxuICAgIG8gPSBuLmJveFNpemluZyA9PT0gXCJib3JkZXItYm94XCIsXG4gICAgciA9IEZ0KG4sIFwicGFkZGluZ1wiKSxcbiAgICBhID0gRnQobiwgXCJib3JkZXJcIiwgXCJ3aWR0aFwiKSxcbiAgICBfSHIgPSBIcihpLCBlKSxcbiAgICBsID0gX0hyLngsXG4gICAgYyA9IF9Ici55LFxuICAgIGggPSBfSHIuYm94LFxuICAgIGQgPSByLmxlZnQgKyAoaCAmJiBhLmxlZnQpLFxuICAgIHUgPSByLnRvcCArIChoICYmIGEudG9wKTtcbiAgdmFyIGYgPSB0LndpZHRoLFxuICAgIHAgPSB0LmhlaWdodDtcbiAgcmV0dXJuIG8gJiYgKGYgLT0gci53aWR0aCArIGEud2lkdGgsIHAgLT0gci5oZWlnaHQgKyBhLmhlaWdodCksIHtcbiAgICB4OiBNYXRoLnJvdW5kKChsIC0gZCkgLyBmICogZS53aWR0aCAvIHMpLFxuICAgIHk6IE1hdGgucm91bmQoKGMgLSB1KSAvIHAgKiBlLmhlaWdodCAvIHMpXG4gIH07XG59XG5mdW5jdGlvbiBXcihpLCB0LCBlKSB7XG4gIHZhciBzLCBuO1xuICBpZiAodCA9PT0gdm9pZCAwIHx8IGUgPT09IHZvaWQgMCkge1xuICAgIHZhciBvID0gaSAmJiBZaShpKTtcbiAgICBpZiAoIW8pIHQgPSBpLmNsaWVudFdpZHRoLCBlID0gaS5jbGllbnRIZWlnaHQ7ZWxzZSB7XG4gICAgICB2YXIgciA9IG8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGEgPSBRZShvKSxcbiAgICAgICAgbCA9IEZ0KGEsIFwiYm9yZGVyXCIsIFwid2lkdGhcIiksXG4gICAgICAgIGMgPSBGdChhLCBcInBhZGRpbmdcIik7XG4gICAgICB0ID0gci53aWR0aCAtIGMud2lkdGggLSBsLndpZHRoLCBlID0gci5oZWlnaHQgLSBjLmhlaWdodCAtIGwuaGVpZ2h0LCBzID0gWGUoYS5tYXhXaWR0aCwgbywgXCJjbGllbnRXaWR0aFwiKSwgbiA9IFhlKGEubWF4SGVpZ2h0LCBvLCBcImNsaWVudEhlaWdodFwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogdCxcbiAgICBoZWlnaHQ6IGUsXG4gICAgbWF4V2lkdGg6IHMgfHwgWWUsXG4gICAgbWF4SGVpZ2h0OiBuIHx8IFllXG4gIH07XG59XG52YXIgeXQgPSBmdW5jdGlvbiB5dChpKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGkgKiAxMCkgLyAxMDtcbn07XG5mdW5jdGlvbiBOcihpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gUWUoaSksXG4gICAgbyA9IEZ0KG4sIFwibWFyZ2luXCIpLFxuICAgIHIgPSBYZShuLm1heFdpZHRoLCBpLCBcImNsaWVudFdpZHRoXCIpIHx8IFllLFxuICAgIGEgPSBYZShuLm1heEhlaWdodCwgaSwgXCJjbGllbnRIZWlnaHRcIikgfHwgWWUsXG4gICAgbCA9IFdyKGksIHQsIGUpO1xuICB2YXIgYyA9IGwud2lkdGgsXG4gICAgaCA9IGwuaGVpZ2h0O1xuICBpZiAobi5ib3hTaXppbmcgPT09IFwiY29udGVudC1ib3hcIikge1xuICAgIHZhciB1ID0gRnQobiwgXCJib3JkZXJcIiwgXCJ3aWR0aFwiKSxcbiAgICAgIGYgPSBGdChuLCBcInBhZGRpbmdcIik7XG4gICAgYyAtPSBmLndpZHRoICsgdS53aWR0aCwgaCAtPSBmLmhlaWdodCArIHUuaGVpZ2h0O1xuICB9XG4gIHJldHVybiBjID0gTWF0aC5tYXgoMCwgYyAtIG8ud2lkdGgpLCBoID0gTWF0aC5tYXgoMCwgcyA/IGMgLyBzIDogaCAtIG8uaGVpZ2h0KSwgYyA9IHl0KE1hdGgubWluKGMsIHIsIGwubWF4V2lkdGgpKSwgaCA9IHl0KE1hdGgubWluKGgsIGEsIGwubWF4SGVpZ2h0KSksIGMgJiYgIWggJiYgKGggPSB5dChjIC8gMikpLCAodCAhPT0gdm9pZCAwIHx8IGUgIT09IHZvaWQgMCkgJiYgcyAmJiBsLmhlaWdodCAmJiBoID4gbC5oZWlnaHQgJiYgKGggPSBsLmhlaWdodCwgYyA9IHl0KE1hdGguZmxvb3IoaCAqIHMpKSksIHtcbiAgICB3aWR0aDogYyxcbiAgICBoZWlnaHQ6IGhcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzKGksIHQsIGUpIHtcbiAgdmFyIHMgPSB0IHx8IDEsXG4gICAgbiA9IHl0KGkuaGVpZ2h0ICogcyksXG4gICAgbyA9IHl0KGkud2lkdGggKiBzKTtcbiAgaS5oZWlnaHQgPSB5dChpLmhlaWdodCksIGkud2lkdGggPSB5dChpLndpZHRoKTtcbiAgdmFyIHIgPSBpLmNhbnZhcztcbiAgcmV0dXJuIHIuc3R5bGUgJiYgKGUgfHwgIXIuc3R5bGUuaGVpZ2h0ICYmICFyLnN0eWxlLndpZHRoKSAmJiAoci5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChpLmhlaWdodCwgXCJweFwiKSwgci5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KGkud2lkdGgsIFwicHhcIikpLCBpLmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBzIHx8IHIuaGVpZ2h0ICE9PSBuIHx8IHIud2lkdGggIT09IG8gPyAoaS5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHMsIHIuaGVpZ2h0ID0gbiwgci53aWR0aCA9IG8sIGkuY3R4LnNldFRyYW5zZm9ybShzLCAwLCAwLCBzLCAwLCAwKSwgITApIDogITE7XG59XG52YXIgVnIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpID0gITE7XG4gIHRyeSB7XG4gICAgdmFyIHQgPSB7XG4gICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgcmV0dXJuIGkgPSAhMCwgITE7XG4gICAgICB9XG4gICAgfTtcbiAgICAkaSgpICYmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RcIiwgbnVsbCwgdCksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFwiLCBudWxsLCB0KSk7XG4gIH0gY2F0Y2ggKF91bnVzZWQpIHt9XG4gIHJldHVybiBpO1xufSgpO1xuZnVuY3Rpb24gZnMoaSwgdCkge1xuICB2YXIgZSA9IElyKGksIHQpLFxuICAgIHMgPSBlICYmIGUubWF0Y2goL14oXFxkKykoXFwuXFxkKyk/cHgkLyk7XG4gIHJldHVybiBzID8gK3NbMV0gOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBSdChpLCB0LCBlLCBzKSB7XG4gIHJldHVybiB7XG4gICAgeDogaS54ICsgZSAqICh0LnggLSBpLngpLFxuICAgIHk6IGkueSArIGUgKiAodC55IC0gaS55KVxuICB9O1xufVxuZnVuY3Rpb24ganIoaSwgdCwgZSwgcykge1xuICByZXR1cm4ge1xuICAgIHg6IGkueCArIGUgKiAodC54IC0gaS54KSxcbiAgICB5OiBzID09PSBcIm1pZGRsZVwiID8gZSA8IDAuNSA/IGkueSA6IHQueSA6IHMgPT09IFwiYWZ0ZXJcIiA/IGUgPCAxID8gaS55IDogdC55IDogZSA+IDAgPyB0LnkgOiBpLnlcbiAgfTtcbn1cbmZ1bmN0aW9uICRyKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSB7XG4gICAgICB4OiBpLmNwMngsXG4gICAgICB5OiBpLmNwMnlcbiAgICB9LFxuICAgIG8gPSB7XG4gICAgICB4OiB0LmNwMXgsXG4gICAgICB5OiB0LmNwMXlcbiAgICB9LFxuICAgIHIgPSBSdChpLCBuLCBlKSxcbiAgICBhID0gUnQobiwgbywgZSksXG4gICAgbCA9IFJ0KG8sIHQsIGUpLFxuICAgIGMgPSBSdChyLCBhLCBlKSxcbiAgICBoID0gUnQoYSwgbCwgZSk7XG4gIHJldHVybiBSdChjLCBoLCBlKTtcbn1cbnZhciBZciA9IGZ1bmN0aW9uIFlyKGksIHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZnVuY3Rpb24geChlKSB7XG4gICAgICAgIHJldHVybiBpICsgaSArIHQgLSBlO1xuICAgICAgfSxcbiAgICAgIHNldFdpZHRoOiBmdW5jdGlvbiBzZXRXaWR0aChlKSB7XG4gICAgICAgIHQgPSBlO1xuICAgICAgfSxcbiAgICAgIHRleHRBbGlnbjogZnVuY3Rpb24gdGV4dEFsaWduKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgPT09IFwiY2VudGVyXCIgPyBlIDogZSA9PT0gXCJyaWdodFwiID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XG4gICAgICB9LFxuICAgICAgeFBsdXM6IGZ1bmN0aW9uIHhQbHVzKGUsIHMpIHtcbiAgICAgICAgcmV0dXJuIGUgLSBzO1xuICAgICAgfSxcbiAgICAgIGxlZnRGb3JMdHI6IGZ1bmN0aW9uIGxlZnRGb3JMdHIoZSwgcykge1xuICAgICAgICByZXR1cm4gZSAtIHM7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgVXIgPSBmdW5jdGlvbiBVcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZnVuY3Rpb24geChpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfSxcbiAgICAgIHNldFdpZHRoOiBmdW5jdGlvbiBzZXRXaWR0aChpKSB7fSxcbiAgICAgIHRleHRBbGlnbjogZnVuY3Rpb24gdGV4dEFsaWduKGkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9LFxuICAgICAgeFBsdXM6IGZ1bmN0aW9uIHhQbHVzKGksIHQpIHtcbiAgICAgICAgcmV0dXJuIGkgKyB0O1xuICAgICAgfSxcbiAgICAgIGxlZnRGb3JMdHI6IGZ1bmN0aW9uIGxlZnRGb3JMdHIoaSwgdCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuZnVuY3Rpb24gVXQoaSwgdCwgZSkge1xuICByZXR1cm4gaSA/IFlyKHQsIGUpIDogVXIoKTtcbn1cbmZ1bmN0aW9uIEZuKGksIHQpIHtcbiAgdmFyIGUsIHM7XG4gICh0ID09PSBcImx0clwiIHx8IHQgPT09IFwicnRsXCIpICYmIChlID0gaS5jYW52YXMuc3R5bGUsIHMgPSBbZS5nZXRQcm9wZXJ0eVZhbHVlKFwiZGlyZWN0aW9uXCIpLCBlLmdldFByb3BlcnR5UHJpb3JpdHkoXCJkaXJlY3Rpb25cIildLCBlLnNldFByb3BlcnR5KFwiZGlyZWN0aW9uXCIsIHQsIFwiaW1wb3J0YW50XCIpLCBpLnByZXZUZXh0RGlyZWN0aW9uID0gcyk7XG59XG5mdW5jdGlvbiBJbihpLCB0KSB7XG4gIHQgIT09IHZvaWQgMCAmJiAoZGVsZXRlIGkucHJldlRleHREaXJlY3Rpb24sIGkuY2FudmFzLnN0eWxlLnNldFByb3BlcnR5KFwiZGlyZWN0aW9uXCIsIHRbMF0sIHRbMV0pKTtcbn1cbmZ1bmN0aW9uIHpuKGkpIHtcbiAgcmV0dXJuIGkgPT09IFwiYW5nbGVcIiA/IHtcbiAgICBiZXR3ZWVuOiBwZSxcbiAgICBjb21wYXJlOiBYbyxcbiAgICBub3JtYWxpemU6IFpcbiAgfSA6IHtcbiAgICBiZXR3ZWVuOiBfdCxcbiAgICBjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKHQsIGUpIHtcbiAgICAgIHJldHVybiB0IC0gZTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24gbm9ybWFsaXplKHQpIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdzKF9yZWYpIHtcbiAgdmFyIGkgPSBfcmVmLnN0YXJ0LFxuICAgIHQgPSBfcmVmLmVuZCxcbiAgICBlID0gX3JlZi5jb3VudCxcbiAgICBzID0gX3JlZi5sb29wLFxuICAgIG4gPSBfcmVmLnN0eWxlO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBpICUgZSxcbiAgICBlbmQ6IHQgJSBlLFxuICAgIGxvb3A6IHMgJiYgKHQgLSBpICsgMSkgJSBlID09PSAwLFxuICAgIHN0eWxlOiBuXG4gIH07XG59XG5mdW5jdGlvbiBYcihpLCB0LCBlKSB7XG4gIHZhciBzID0gZS5wcm9wZXJ0eSxcbiAgICBuID0gZS5zdGFydCxcbiAgICBvID0gZS5lbmQsXG4gICAgX3puID0gem4ocyksXG4gICAgciA9IF96bi5iZXR3ZWVuLFxuICAgIGEgPSBfem4ubm9ybWFsaXplLFxuICAgIGwgPSB0Lmxlbmd0aDtcbiAgdmFyIGMgPSBpLnN0YXJ0LFxuICAgIGggPSBpLmVuZCxcbiAgICBkID0gaS5sb29wLFxuICAgIHUsXG4gICAgZjtcbiAgaWYgKGQpIHtcbiAgICBmb3IgKGMgKz0gbCwgaCArPSBsLCB1ID0gMCwgZiA9IGw7IHUgPCBmICYmIHIoYSh0W2MgJSBsXVtzXSksIG4sIG8pOyArK3UpIGMtLSwgaC0tO1xuICAgIGMgJT0gbCwgaCAlPSBsO1xuICB9XG4gIHJldHVybiBoIDwgYyAmJiAoaCArPSBsKSwge1xuICAgIHN0YXJ0OiBjLFxuICAgIGVuZDogaCxcbiAgICBsb29wOiBkLFxuICAgIHN0eWxlOiBpLnN0eWxlXG4gIH07XG59XG5mdW5jdGlvbiBCbihpLCB0LCBlKSB7XG4gIGlmICghZSkgcmV0dXJuIFtpXTtcbiAgdmFyIHMgPSBlLnByb3BlcnR5LFxuICAgIG4gPSBlLnN0YXJ0LFxuICAgIG8gPSBlLmVuZCxcbiAgICByID0gdC5sZW5ndGgsXG4gICAgX3puMiA9IHpuKHMpLFxuICAgIGEgPSBfem4yLmNvbXBhcmUsXG4gICAgbCA9IF96bjIuYmV0d2VlbixcbiAgICBjID0gX3puMi5ub3JtYWxpemUsXG4gICAgX1hyID0gWHIoaSwgdCwgZSksXG4gICAgaCA9IF9Yci5zdGFydCxcbiAgICBkID0gX1hyLmVuZCxcbiAgICB1ID0gX1hyLmxvb3AsXG4gICAgZiA9IF9Yci5zdHlsZSxcbiAgICBwID0gW107XG4gIHZhciBnID0gITEsXG4gICAgbSA9IG51bGwsXG4gICAgYixcbiAgICBfLFxuICAgIHY7XG4gIHZhciB5ID0gZnVuY3Rpb24geSgpIHtcbiAgICAgIHJldHVybiBsKG4sIHYsIGIpICYmIGEobiwgdikgIT09IDA7XG4gICAgfSxcbiAgICB4ID0gZnVuY3Rpb24geCgpIHtcbiAgICAgIHJldHVybiBhKG8sIGIpID09PSAwIHx8IGwobywgdiwgYik7XG4gICAgfSxcbiAgICBNID0gZnVuY3Rpb24gTSgpIHtcbiAgICAgIHJldHVybiBnIHx8IHkoKTtcbiAgICB9LFxuICAgIFMgPSBmdW5jdGlvbiBTKCkge1xuICAgICAgcmV0dXJuICFnIHx8IHgoKTtcbiAgICB9O1xuICBmb3IgKHZhciBrID0gaCwgUCA9IGg7IGsgPD0gZDsgKytrKSBfID0gdFtrICUgcl0sICFfLnNraXAgJiYgKGIgPSBjKF9bc10pLCBiICE9PSB2ICYmIChnID0gbChiLCBuLCBvKSwgbSA9PT0gbnVsbCAmJiBNKCkgJiYgKG0gPSBhKGIsIG4pID09PSAwID8gayA6IFApLCBtICE9PSBudWxsICYmIFMoKSAmJiAocC5wdXNoKGdzKHtcbiAgICBzdGFydDogbSxcbiAgICBlbmQ6IGssXG4gICAgbG9vcDogdSxcbiAgICBjb3VudDogcixcbiAgICBzdHlsZTogZlxuICB9KSksIG0gPSBudWxsKSwgUCA9IGssIHYgPSBiKSk7XG4gIHJldHVybiBtICE9PSBudWxsICYmIHAucHVzaChncyh7XG4gICAgc3RhcnQ6IG0sXG4gICAgZW5kOiBkLFxuICAgIGxvb3A6IHUsXG4gICAgY291bnQ6IHIsXG4gICAgc3R5bGU6IGZcbiAgfSkpLCBwO1xufVxuZnVuY3Rpb24gSG4oaSwgdCkge1xuICB2YXIgZSA9IFtdLFxuICAgIHMgPSBpLnNlZ21lbnRzO1xuICBmb3IgKHZhciBuID0gMDsgbiA8IHMubGVuZ3RoOyBuKyspIHtcbiAgICB2YXIgbyA9IEJuKHNbbl0sIGkucG9pbnRzLCB0KTtcbiAgICBvLmxlbmd0aCAmJiBlLnB1c2guYXBwbHkoZSwgX3RvQ29uc3VtYWJsZUFycmF5KG8pKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHFyKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSAwLFxuICAgIG8gPSB0IC0gMTtcbiAgaWYgKGUgJiYgIXMpIGZvciAoOyBuIDwgdCAmJiAhaVtuXS5za2lwOykgbisrO1xuICBmb3IgKDsgbiA8IHQgJiYgaVtuXS5za2lwOykgbisrO1xuICBmb3IgKG4gJT0gdCwgZSAmJiAobyArPSBuKTsgbyA+IG4gJiYgaVtvICUgdF0uc2tpcDspIG8tLTtcbiAgcmV0dXJuIG8gJT0gdCwge1xuICAgIHN0YXJ0OiBuLFxuICAgIGVuZDogb1xuICB9O1xufVxuZnVuY3Rpb24gS3IoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IGkubGVuZ3RoLFxuICAgIG8gPSBbXTtcbiAgdmFyIHIgPSB0LFxuICAgIGEgPSBpW3RdLFxuICAgIGw7XG4gIGZvciAobCA9IHQgKyAxOyBsIDw9IGU7ICsrbCkge1xuICAgIHZhciBjID0gaVtsICUgbl07XG4gICAgYy5za2lwIHx8IGMuc3RvcCA/IGEuc2tpcCB8fCAocyA9ICExLCBvLnB1c2goe1xuICAgICAgc3RhcnQ6IHQgJSBuLFxuICAgICAgZW5kOiAobCAtIDEpICUgbixcbiAgICAgIGxvb3A6IHNcbiAgICB9KSwgdCA9IHIgPSBjLnN0b3AgPyBsIDogbnVsbCkgOiAociA9IGwsIGEuc2tpcCAmJiAodCA9IGwpKSwgYSA9IGM7XG4gIH1cbiAgcmV0dXJuIHIgIT09IG51bGwgJiYgby5wdXNoKHtcbiAgICBzdGFydDogdCAlIG4sXG4gICAgZW5kOiByICUgbixcbiAgICBsb29wOiBzXG4gIH0pLCBvO1xufVxuZnVuY3Rpb24gR3IoaSwgdCkge1xuICB2YXIgZSA9IGkucG9pbnRzLFxuICAgIHMgPSBpLm9wdGlvbnMuc3BhbkdhcHMsXG4gICAgbiA9IGUubGVuZ3RoO1xuICBpZiAoIW4pIHJldHVybiBbXTtcbiAgdmFyIG8gPSAhIWkuX2xvb3AsXG4gICAgX3FyID0gcXIoZSwgbiwgbywgcyksXG4gICAgciA9IF9xci5zdGFydCxcbiAgICBhID0gX3FyLmVuZDtcbiAgaWYgKHMgPT09ICEwKSByZXR1cm4gcHMoaSwgW3tcbiAgICBzdGFydDogcixcbiAgICBlbmQ6IGEsXG4gICAgbG9vcDogb1xuICB9XSwgZSwgdCk7XG4gIHZhciBsID0gYSA8IHIgPyBhICsgbiA6IGEsXG4gICAgYyA9ICEhaS5fZnVsbExvb3AgJiYgciA9PT0gMCAmJiBhID09PSBuIC0gMTtcbiAgcmV0dXJuIHBzKGksIEtyKGUsIHIsIGwsIGMpLCBlLCB0KTtcbn1cbmZ1bmN0aW9uIHBzKGksIHQsIGUsIHMpIHtcbiAgcmV0dXJuICFzIHx8ICFzLnNldENvbnRleHQgfHwgIWUgPyB0IDogSnIoaSwgdCwgZSwgcyk7XG59XG5mdW5jdGlvbiBKcihpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gaS5fY2hhcnQuZ2V0Q29udGV4dCgpLFxuICAgIG8gPSBtcyhpLm9wdGlvbnMpLFxuICAgIHIgPSBpLl9kYXRhc2V0SW5kZXgsXG4gICAgYSA9IGkub3B0aW9ucy5zcGFuR2FwcyxcbiAgICBsID0gZS5sZW5ndGgsXG4gICAgYyA9IFtdO1xuICB2YXIgaCA9IG8sXG4gICAgZCA9IHRbMF0uc3RhcnQsXG4gICAgdSA9IGQ7XG4gIGZ1bmN0aW9uIGYocCwgZywgbSwgYikge1xuICAgIHZhciBfID0gYSA/IC0xIDogMTtcbiAgICBpZiAocCAhPT0gZykge1xuICAgICAgZm9yIChwICs9IGw7IGVbcCAlIGxdLnNraXA7KSBwIC09IF87XG4gICAgICBmb3IgKDsgZVtnICUgbF0uc2tpcDspIGcgKz0gXztcbiAgICAgIHAgJSBsICE9PSBnICUgbCAmJiAoYy5wdXNoKHtcbiAgICAgICAgc3RhcnQ6IHAgJSBsLFxuICAgICAgICBlbmQ6IGcgJSBsLFxuICAgICAgICBsb29wOiBtLFxuICAgICAgICBzdHlsZTogYlxuICAgICAgfSksIGggPSBiLCBkID0gZyAlIGwpO1xuICAgIH1cbiAgfVxuICB2YXIgX2l0ZXJhdG9yMSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHQpLFxuICAgIF9zdGVwMTtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjEucygpOyAhKF9zdGVwMSA9IF9pdGVyYXRvcjEubigpKS5kb25lOykge1xuICAgICAgdmFyIHAgPSBfc3RlcDEudmFsdWU7XG4gICAgICBkID0gYSA/IGQgOiBwLnN0YXJ0O1xuICAgICAgdmFyIGcgPSBlW2QgJSBsXSxcbiAgICAgICAgbSA9IHZvaWQgMDtcbiAgICAgIGZvciAodSA9IGQgKyAxOyB1IDw9IHAuZW5kOyB1KyspIHtcbiAgICAgICAgdmFyIGIgPSBlW3UgJSBsXTtcbiAgICAgICAgbSA9IG1zKHMuc2V0Q29udGV4dChCdChuLCB7XG4gICAgICAgICAgdHlwZTogXCJzZWdtZW50XCIsXG4gICAgICAgICAgcDA6IGcsXG4gICAgICAgICAgcDE6IGIsXG4gICAgICAgICAgcDBEYXRhSW5kZXg6ICh1IC0gMSkgJSBsLFxuICAgICAgICAgIHAxRGF0YUluZGV4OiB1ICUgbCxcbiAgICAgICAgICBkYXRhc2V0SW5kZXg6IHJcbiAgICAgICAgfSkpKSwgWnIobSwgaCkgJiYgZihkLCB1IC0gMSwgcC5sb29wLCBoKSwgZyA9IGIsIGggPSBtO1xuICAgICAgfVxuICAgICAgZCA8IHUgLSAxICYmIGYoZCwgdSAtIDEsIHAubG9vcCwgaCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IxLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IxLmYoKTtcbiAgfVxuICByZXR1cm4gYztcbn1cbmZ1bmN0aW9uIG1zKGkpIHtcbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGkuYmFja2dyb3VuZENvbG9yLFxuICAgIGJvcmRlckNhcFN0eWxlOiBpLmJvcmRlckNhcFN0eWxlLFxuICAgIGJvcmRlckRhc2g6IGkuYm9yZGVyRGFzaCxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiBpLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgYm9yZGVySm9pblN0eWxlOiBpLmJvcmRlckpvaW5TdHlsZSxcbiAgICBib3JkZXJXaWR0aDogaS5ib3JkZXJXaWR0aCxcbiAgICBib3JkZXJDb2xvcjogaS5ib3JkZXJDb2xvclxuICB9O1xufVxuZnVuY3Rpb24gWnIoaSwgdCkge1xuICBpZiAoIXQpIHJldHVybiAhMTtcbiAgdmFyIGUgPSBbXSxcbiAgICBzID0gZnVuY3Rpb24gcyhuLCBvKSB7XG4gICAgICByZXR1cm4gQmkobykgPyAoZS5pbmNsdWRlcyhvKSB8fCBlLnB1c2gobyksIGUuaW5kZXhPZihvKSkgOiBvO1xuICAgIH07XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShpLCBzKSAhPT0gSlNPTi5zdHJpbmdpZnkodCwgcyk7XG59XG5mdW5jdGlvbiBEZShpLCB0LCBlKSB7XG4gIHJldHVybiBpLm9wdGlvbnMuY2xpcCA/IGlbZV0gOiB0W2VdO1xufVxuZnVuY3Rpb24gUXIoaSwgdCkge1xuICB2YXIgZSA9IGkueFNjYWxlLFxuICAgIHMgPSBpLnlTY2FsZTtcbiAgcmV0dXJuIGUgJiYgcyA/IHtcbiAgICBsZWZ0OiBEZShlLCB0LCBcImxlZnRcIiksXG4gICAgcmlnaHQ6IERlKGUsIHQsIFwicmlnaHRcIiksXG4gICAgdG9wOiBEZShzLCB0LCBcInRvcFwiKSxcbiAgICBib3R0b206IERlKHMsIHQsIFwiYm90dG9tXCIpXG4gIH0gOiB0O1xufVxuZnVuY3Rpb24gV24oaSwgdCkge1xuICB2YXIgZSA9IHQuX2NsaXA7XG4gIGlmIChlLmRpc2FibGVkKSByZXR1cm4gITE7XG4gIHZhciBzID0gUXIodCwgaS5jaGFydEFyZWEpO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGUubGVmdCA9PT0gITEgPyAwIDogcy5sZWZ0IC0gKGUubGVmdCA9PT0gITAgPyAwIDogZS5sZWZ0KSxcbiAgICByaWdodDogZS5yaWdodCA9PT0gITEgPyBpLndpZHRoIDogcy5yaWdodCArIChlLnJpZ2h0ID09PSAhMCA/IDAgOiBlLnJpZ2h0KSxcbiAgICB0b3A6IGUudG9wID09PSAhMSA/IDAgOiBzLnRvcCAtIChlLnRvcCA9PT0gITAgPyAwIDogZS50b3ApLFxuICAgIGJvdHRvbTogZS5ib3R0b20gPT09ICExID8gaS5oZWlnaHQgOiBzLmJvdHRvbSArIChlLmJvdHRvbSA9PT0gITAgPyAwIDogZS5ib3R0b20pXG4gIH07XG59XG4vKiFcbiAqIENoYXJ0LmpzIHY0LjUuMVxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDI1IENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbnZhciB0YSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHRhKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCB0YSk7XG4gICAgdGhpcy5fcmVxdWVzdCA9IG51bGwsIHRoaXMuX2NoYXJ0cyA9IC8qIEBfX1BVUkVfXyAqL25ldyBNYXAoKSwgdGhpcy5fcnVubmluZyA9ICExLCB0aGlzLl9sYXN0RGF0ZSA9IHZvaWQgMDtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKHRhLCBbe1xuICAgIGtleTogXCJfbm90aWZ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ub3RpZnkodCwgZSwgcywgbikge1xuICAgICAgdmFyIG8gPSBlLmxpc3RlbmVyc1tuXSxcbiAgICAgICAgciA9IGUuZHVyYXRpb247XG4gICAgICBvLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGEoe1xuICAgICAgICAgIGNoYXJ0OiB0LFxuICAgICAgICAgIGluaXRpYWw6IGUuaW5pdGlhbCxcbiAgICAgICAgICBudW1TdGVwczogcixcbiAgICAgICAgICBjdXJyZW50U3RlcDogTWF0aC5taW4ocyAtIGUuc3RhcnQsIHIpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWZyZXNoKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB0aGlzLl9yZXF1ZXN0IHx8ICh0aGlzLl9ydW5uaW5nID0gITAsIHRoaXMuX3JlcXVlc3QgPSBTbi5jYWxsKHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMuX3VwZGF0ZSgpLCBfdGhpczMuX3JlcXVlc3QgPSBudWxsLCBfdGhpczMuX3J1bm5pbmcgJiYgX3RoaXMzLl9yZWZyZXNoKCk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IERhdGUubm93KCk7XG4gICAgICB2YXIgZSA9IDA7XG4gICAgICB0aGlzLl9jaGFydHMuZm9yRWFjaChmdW5jdGlvbiAocywgbikge1xuICAgICAgICBpZiAoIXMucnVubmluZyB8fCAhcy5pdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgdmFyIG8gPSBzLml0ZW1zO1xuICAgICAgICB2YXIgciA9IG8ubGVuZ3RoIC0gMSxcbiAgICAgICAgICBhID0gITEsXG4gICAgICAgICAgbDtcbiAgICAgICAgZm9yICg7IHIgPj0gMDsgLS1yKSBsID0gb1tyXSwgbC5fYWN0aXZlID8gKGwuX3RvdGFsID4gcy5kdXJhdGlvbiAmJiAocy5kdXJhdGlvbiA9IGwuX3RvdGFsKSwgbC50aWNrKHQpLCBhID0gITApIDogKG9bcl0gPSBvW28ubGVuZ3RoIC0gMV0sIG8ucG9wKCkpO1xuICAgICAgICBhICYmIChuLmRyYXcoKSwgX3RoaXM0Ll9ub3RpZnkobiwgcywgdCwgXCJwcm9ncmVzc1wiKSksIG8ubGVuZ3RoIHx8IChzLnJ1bm5pbmcgPSAhMSwgX3RoaXM0Ll9ub3RpZnkobiwgcywgdCwgXCJjb21wbGV0ZVwiKSwgcy5pbml0aWFsID0gITEpLCBlICs9IG8ubGVuZ3RoO1xuICAgICAgfSksIHRoaXMuX2xhc3REYXRlID0gdCwgZSA9PT0gMCAmJiAodGhpcy5fcnVubmluZyA9ICExKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEFuaW1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBbmltcyh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2NoYXJ0cztcbiAgICAgIHZhciBzID0gZS5nZXQodCk7XG4gICAgICByZXR1cm4gcyB8fCAocyA9IHtcbiAgICAgICAgcnVubmluZzogITEsXG4gICAgICAgIGluaXRpYWw6ICEwLFxuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgIGNvbXBsZXRlOiBbXSxcbiAgICAgICAgICBwcm9ncmVzczogW11cbiAgICAgICAgfVxuICAgICAgfSwgZS5zZXQodCwgcykpLCBzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsaXN0ZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuKHQsIGUsIHMpIHtcbiAgICAgIHRoaXMuX2dldEFuaW1zKHQpLmxpc3RlbmVyc1tlXS5wdXNoKHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHQsIGUpIHtcbiAgICAgIHZhciBfdGhpcyRfZ2V0QW5pbXMkaXRlbXM7XG4gICAgICAhZSB8fCAhZS5sZW5ndGggfHwgKF90aGlzJF9nZXRBbmltcyRpdGVtcyA9IHRoaXMuX2dldEFuaW1zKHQpLml0ZW1zKS5wdXNoLmFwcGx5KF90aGlzJF9nZXRBbmltcyRpdGVtcywgX3RvQ29uc3VtYWJsZUFycmF5KGUpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0QW5pbXModCkuaXRlbXMubGVuZ3RoID4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9jaGFydHMuZ2V0KHQpO1xuICAgICAgZSAmJiAoZS5ydW5uaW5nID0gITAsIGUuc3RhcnQgPSBEYXRlLm5vdygpLCBlLmR1cmF0aW9uID0gZS5pdGVtcy5yZWR1Y2UoZnVuY3Rpb24gKHMsIG4pIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHMsIG4uX2R1cmF0aW9uKTtcbiAgICAgIH0sIDApLCB0aGlzLl9yZWZyZXNoKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJydW5uaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bm5pbmcodCkge1xuICAgICAgaWYgKCF0aGlzLl9ydW5uaW5nKSByZXR1cm4gITE7XG4gICAgICB2YXIgZSA9IHRoaXMuX2NoYXJ0cy5nZXQodCk7XG4gICAgICByZXR1cm4gISghZSB8fCAhZS5ydW5uaW5nIHx8ICFlLml0ZW1zLmxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0b3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2NoYXJ0cy5nZXQodCk7XG4gICAgICBpZiAoIWUgfHwgIWUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gICAgICB2YXIgcyA9IGUuaXRlbXM7XG4gICAgICB2YXIgbiA9IHMubGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoOyBuID49IDA7IC0tbikgc1tuXS5jYW5jZWwoKTtcbiAgICAgIGUuaXRlbXMgPSBbXSwgdGhpcy5fbm90aWZ5KHQsIGUsIERhdGUubm93KCksIFwiY29tcGxldGVcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NoYXJ0c1tcImRlbGV0ZVwiXSh0KTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbnZhciB1dCA9IC8qIEBfX1BVUkVfXyAqL25ldyB0YSgpO1xudmFyIGJzID0gXCJ0cmFuc3BhcmVudFwiLFxuICBlYSA9IHtcbiAgICBcImJvb2xlYW5cIjogZnVuY3Rpb24gYm9vbGVhbihpLCB0LCBlKSB7XG4gICAgICByZXR1cm4gZSA+IDAuNSA/IHQgOiBpO1xuICAgIH0sXG4gICAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKGksIHQsIGUpIHtcbiAgICAgIHZhciBzID0gcnMoaSB8fCBicyksXG4gICAgICAgIG4gPSBzLnZhbGlkICYmIHJzKHQgfHwgYnMpO1xuICAgICAgcmV0dXJuIG4gJiYgbi52YWxpZCA/IG4ubWl4KHMsIGUpLmhleFN0cmluZygpIDogdDtcbiAgICB9LFxuICAgIG51bWJlcjogZnVuY3Rpb24gbnVtYmVyKGksIHQsIGUpIHtcbiAgICAgIHJldHVybiBpICsgKHQgLSBpKSAqIGU7XG4gICAgfVxuICB9O1xudmFyIGlhID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gaWEodCwgZSwgcywgbikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBpYSk7XG4gICAgdmFyIG8gPSBlW3NdO1xuICAgIG4gPSB3ZShbdC50bywgbiwgbywgdC5mcm9tXSk7XG4gICAgdmFyIHIgPSB3ZShbdC5mcm9tLCBvLCBuXSk7XG4gICAgdGhpcy5fYWN0aXZlID0gITAsIHRoaXMuX2ZuID0gdC5mbiB8fCBlYVt0LnR5cGUgfHwgX3R5cGVvZihyKV0sIHRoaXMuX2Vhc2luZyA9IGhlW3QuZWFzaW5nXSB8fCBoZS5saW5lYXIsIHRoaXMuX3N0YXJ0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpICsgKHQuZGVsYXkgfHwgMCkpLCB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsID0gTWF0aC5mbG9vcih0LmR1cmF0aW9uKSwgdGhpcy5fbG9vcCA9ICEhdC5sb29wLCB0aGlzLl90YXJnZXQgPSBlLCB0aGlzLl9wcm9wID0gcywgdGhpcy5fZnJvbSA9IHIsIHRoaXMuX3RvID0gbiwgdGhpcy5fcHJvbWlzZXMgPSB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhpYSwgW3tcbiAgICBrZXk6IFwiYWN0aXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjdGl2ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUodCwgZSwgcykge1xuICAgICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICB0aGlzLl9ub3RpZnkoITEpO1xuICAgICAgICB2YXIgbiA9IHRoaXMuX3RhcmdldFt0aGlzLl9wcm9wXSxcbiAgICAgICAgICBvID0gcyAtIHRoaXMuX3N0YXJ0LFxuICAgICAgICAgIHIgPSB0aGlzLl9kdXJhdGlvbiAtIG87XG4gICAgICAgIHRoaXMuX3N0YXJ0ID0gcywgdGhpcy5fZHVyYXRpb24gPSBNYXRoLmZsb29yKE1hdGgubWF4KHIsIHQuZHVyYXRpb24pKSwgdGhpcy5fdG90YWwgKz0gbywgdGhpcy5fbG9vcCA9ICEhdC5sb29wLCB0aGlzLl90byA9IHdlKFt0LnRvLCBlLCBuLCB0LmZyb21dKSwgdGhpcy5fZnJvbSA9IHdlKFt0LmZyb20sIG4sIGVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuY2VsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSAmJiAodGhpcy50aWNrKERhdGUubm93KCkpLCB0aGlzLl9hY3RpdmUgPSAhMSwgdGhpcy5fbm90aWZ5KCExKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGljayh0KSB7XG4gICAgICB2YXIgZSA9IHQgLSB0aGlzLl9zdGFydCxcbiAgICAgICAgcyA9IHRoaXMuX2R1cmF0aW9uLFxuICAgICAgICBuID0gdGhpcy5fcHJvcCxcbiAgICAgICAgbyA9IHRoaXMuX2Zyb20sXG4gICAgICAgIHIgPSB0aGlzLl9sb29wLFxuICAgICAgICBhID0gdGhpcy5fdG87XG4gICAgICB2YXIgbDtcbiAgICAgIGlmICh0aGlzLl9hY3RpdmUgPSBvICE9PSBhICYmIChyIHx8IGUgPCBzKSwgIXRoaXMuX2FjdGl2ZSkge1xuICAgICAgICB0aGlzLl90YXJnZXRbbl0gPSBhLCB0aGlzLl9ub3RpZnkoITApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZSA8IDApIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0W25dID0gbztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbCA9IGUgLyBzICUgMiwgbCA9IHIgJiYgbCA+IDEgPyAyIC0gbCA6IGwsIGwgPSB0aGlzLl9lYXNpbmcoTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgbCkpKSwgdGhpcy5fdGFyZ2V0W25dID0gdGhpcy5fZm4obywgYSwgbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndhaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2FpdCgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fcHJvbWlzZXMgfHwgKHRoaXMuX3Byb21pc2VzID0gW10pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChlLCBzKSB7XG4gICAgICAgIHQucHVzaCh7XG4gICAgICAgICAgcmVzOiBlLFxuICAgICAgICAgIHJlajogc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbm90aWZ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ub3RpZnkodCkge1xuICAgICAgdmFyIGUgPSB0ID8gXCJyZXNcIiA6IFwicmVqXCIsXG4gICAgICAgIHMgPSB0aGlzLl9wcm9taXNlcyB8fCBbXTtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgcy5sZW5ndGg7IG4rKykgc1tuXVtlXSgpO1xuICAgIH1cbiAgfV0pO1xufSgpO1xudmFyIE5uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm4odCwgZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBObik7XG4gICAgdGhpcy5fY2hhcnQgPSB0LCB0aGlzLl9wcm9wZXJ0aWVzID0gLyogQF9fUFVSRV9fICovbmV3IE1hcCgpLCB0aGlzLmNvbmZpZ3VyZShlKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKE5uLCBbe1xuICAgIGtleTogXCJjb25maWd1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uZmlndXJlKHQpIHtcbiAgICAgIGlmICghVCh0KSkgcmV0dXJuO1xuICAgICAgdmFyIGUgPSBPYmplY3Qua2V5cyhXLmFuaW1hdGlvbiksXG4gICAgICAgIHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCkuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICB2YXIgbyA9IHRbbl07XG4gICAgICAgIGlmICghVChvKSkgcmV0dXJuO1xuICAgICAgICB2YXIgciA9IHt9O1xuICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfZTIgPSBlOyBfaTIgPCBfZTIubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBhID0gX2UyW19pMl07XG4gICAgICAgICAgclthXSA9IG9bYV07XG4gICAgICAgIH1cbiAgICAgICAgKE4oby5wcm9wZXJ0aWVzKSAmJiBvLnByb3BlcnRpZXMgfHwgW25dKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgKGEgPT09IG4gfHwgIXMuaGFzKGEpKSAmJiBzLnNldChhLCByKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2FuaW1hdGVPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hbmltYXRlT3B0aW9ucyh0LCBlKSB7XG4gICAgICB2YXIgcyA9IGUub3B0aW9ucyxcbiAgICAgICAgbiA9IG5hKHQsIHMpO1xuICAgICAgaWYgKCFuKSByZXR1cm4gW107XG4gICAgICB2YXIgbyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnMobiwgcyk7XG4gICAgICByZXR1cm4gcy4kc2hhcmVkICYmIHNhKHQub3B0aW9ucy4kYW5pbWF0aW9ucywgcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHQub3B0aW9ucyA9IHM7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7fSksIG87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVBbmltYXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVBbmltYXRpb25zKHQsIGUpIHtcbiAgICAgIHZhciBzID0gdGhpcy5fcHJvcGVydGllcyxcbiAgICAgICAgbiA9IFtdLFxuICAgICAgICBvID0gdC4kYW5pbWF0aW9ucyB8fCAodC4kYW5pbWF0aW9ucyA9IHt9KSxcbiAgICAgICAgciA9IE9iamVjdC5rZXlzKGUpLFxuICAgICAgICBhID0gRGF0ZS5ub3coKTtcbiAgICAgIHZhciBsO1xuICAgICAgZm9yIChsID0gci5sZW5ndGggLSAxOyBsID49IDA7IC0tbCkge1xuICAgICAgICB2YXIgYyA9IHJbbF07XG4gICAgICAgIGlmIChjLmNoYXJBdCgwKSA9PT0gXCIkXCIpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoYyA9PT0gXCJvcHRpb25zXCIpIHtcbiAgICAgICAgICBuLnB1c2guYXBwbHkobiwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX2FuaW1hdGVPcHRpb25zKHQsIGUpKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGggPSBlW2NdO1xuICAgICAgICB2YXIgZCA9IG9bY107XG4gICAgICAgIHZhciB1ID0gcy5nZXQoYyk7XG4gICAgICAgIGlmIChkKSBpZiAodSAmJiBkLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgZC51cGRhdGUodSwgaCwgYSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBkLmNhbmNlbCgpO1xuICAgICAgICBpZiAoIXUgfHwgIXUuZHVyYXRpb24pIHtcbiAgICAgICAgICB0W2NdID0gaDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvW2NdID0gZCA9IG5ldyBpYSh1LCB0LCBjLCBoKSwgbi5wdXNoKGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUodCwgZSkge1xuICAgICAgaWYgKHRoaXMuX3Byb3BlcnRpZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHQsIGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnModCwgZSk7XG4gICAgICBpZiAocy5sZW5ndGgpIHJldHVybiB1dC5hZGQodGhpcy5fY2hhcnQsIHMpLCAhMDtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbmZ1bmN0aW9uIHNhKGksIHQpIHtcbiAgdmFyIGUgPSBbXSxcbiAgICBzID0gT2JqZWN0LmtleXModCk7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgcy5sZW5ndGg7IG4rKykge1xuICAgIHZhciBvID0gaVtzW25dXTtcbiAgICBvICYmIG8uYWN0aXZlKCkgJiYgZS5wdXNoKG8ud2FpdCgpKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoZSk7XG59XG5mdW5jdGlvbiBuYShpLCB0KSB7XG4gIGlmICghdCkgcmV0dXJuO1xuICB2YXIgZSA9IGkub3B0aW9ucztcbiAgaWYgKCFlKSB7XG4gICAgaS5vcHRpb25zID0gdDtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIGUuJHNoYXJlZCAmJiAoaS5vcHRpb25zID0gZSA9IE9iamVjdC5hc3NpZ24oe30sIGUsIHtcbiAgICAkc2hhcmVkOiAhMSxcbiAgICAkYW5pbWF0aW9uczoge31cbiAgfSkpLCBlO1xufVxuZnVuY3Rpb24gX3MoaSwgdCkge1xuICB2YXIgZSA9IGkgJiYgaS5vcHRpb25zIHx8IHt9LFxuICAgIHMgPSBlLnJldmVyc2UsXG4gICAgbiA9IGUubWluID09PSB2b2lkIDAgPyB0IDogMCxcbiAgICBvID0gZS5tYXggPT09IHZvaWQgMCA/IHQgOiAwO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzID8gbyA6IG4sXG4gICAgZW5kOiBzID8gbiA6IG9cbiAgfTtcbn1cbmZ1bmN0aW9uIG9hKGksIHQsIGUpIHtcbiAgaWYgKGUgPT09ICExKSByZXR1cm4gITE7XG4gIHZhciBzID0gX3MoaSwgZSksXG4gICAgbiA9IF9zKHQsIGUpO1xuICByZXR1cm4ge1xuICAgIHRvcDogbi5lbmQsXG4gICAgcmlnaHQ6IHMuZW5kLFxuICAgIGJvdHRvbTogbi5zdGFydCxcbiAgICBsZWZ0OiBzLnN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiByYShpKSB7XG4gIHZhciB0LCBlLCBzLCBuO1xuICByZXR1cm4gVChpKSA/ICh0ID0gaS50b3AsIGUgPSBpLnJpZ2h0LCBzID0gaS5ib3R0b20sIG4gPSBpLmxlZnQpIDogdCA9IGUgPSBzID0gbiA9IGksIHtcbiAgICB0b3A6IHQsXG4gICAgcmlnaHQ6IGUsXG4gICAgYm90dG9tOiBzLFxuICAgIGxlZnQ6IG4sXG4gICAgZGlzYWJsZWQ6IGkgPT09ICExXG4gIH07XG59XG5mdW5jdGlvbiBWbihpLCB0KSB7XG4gIHZhciBlID0gW10sXG4gICAgcyA9IGkuX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0KTtcbiAgdmFyIG4sIG87XG4gIGZvciAobiA9IDAsIG8gPSBzLmxlbmd0aDsgbiA8IG87ICsrbikgZS5wdXNoKHNbbl0uaW5kZXgpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHhzKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICB2YXIgbiA9IGkua2V5cyxcbiAgICBvID0gcy5tb2RlID09PSBcInNpbmdsZVwiO1xuICB2YXIgciwgYSwgbCwgYztcbiAgaWYgKHQgPT09IG51bGwpIHJldHVybjtcbiAgdmFyIGggPSAhMTtcbiAgZm9yIChyID0gMCwgYSA9IG4ubGVuZ3RoOyByIDwgYTsgKytyKSB7XG4gICAgaWYgKGwgPSArbltyXSwgbCA9PT0gZSkge1xuICAgICAgaWYgKGggPSAhMCwgcy5hbGwpIGNvbnRpbnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGMgPSBpLnZhbHVlc1tsXSwgcShjKSAmJiAobyB8fCB0ID09PSAwIHx8IGx0KHQpID09PSBsdChjKSkgJiYgKHQgKz0gYyk7XG4gIH1cbiAgcmV0dXJuICFoICYmICFzLmFsbCA/IDAgOiB0O1xufVxuZnVuY3Rpb24gYWEoaSwgdCkge1xuICB2YXIgZSA9IHQuaVNjYWxlLFxuICAgIHMgPSB0LnZTY2FsZSxcbiAgICBuID0gZS5heGlzID09PSBcInhcIiA/IFwieFwiIDogXCJ5XCIsXG4gICAgbyA9IHMuYXhpcyA9PT0gXCJ4XCIgPyBcInhcIiA6IFwieVwiLFxuICAgIHIgPSBPYmplY3Qua2V5cyhpKSxcbiAgICBhID0gbmV3IEFycmF5KHIubGVuZ3RoKTtcbiAgdmFyIGwsIGMsIGg7XG4gIGZvciAobCA9IDAsIGMgPSByLmxlbmd0aDsgbCA8IGM7ICsrbCkgaCA9IHJbbF0sIGFbbF0gPSBfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KHt9LCBuLCBoKSwgbywgaVtoXSk7XG4gIHJldHVybiBhO1xufVxuZnVuY3Rpb24gcmkoaSwgdCkge1xuICB2YXIgZSA9IGkgJiYgaS5vcHRpb25zLnN0YWNrZWQ7XG4gIHJldHVybiBlIHx8IGUgPT09IHZvaWQgMCAmJiB0LnN0YWNrICE9PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBsYShpLCB0LCBlKSB7XG4gIHJldHVybiBcIlwiLmNvbmNhdChpLmlkLCBcIi5cIikuY29uY2F0KHQuaWQsIFwiLlwiKS5jb25jYXQoZS5zdGFjayB8fCBlLnR5cGUpO1xufVxuZnVuY3Rpb24gY2EoaSkge1xuICB2YXIgX2kkZ2V0VXNlckJvdW5kcyA9IGkuZ2V0VXNlckJvdW5kcygpLFxuICAgIHQgPSBfaSRnZXRVc2VyQm91bmRzLm1pbixcbiAgICBlID0gX2kkZ2V0VXNlckJvdW5kcy5tYXgsXG4gICAgcyA9IF9pJGdldFVzZXJCb3VuZHMubWluRGVmaW5lZCxcbiAgICBuID0gX2kkZ2V0VXNlckJvdW5kcy5tYXhEZWZpbmVkO1xuICByZXR1cm4ge1xuICAgIG1pbjogcyA/IHQgOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgbWF4OiBuID8gZSA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICB9O1xufVxuZnVuY3Rpb24gaGEoaSwgdCwgZSkge1xuICB2YXIgcyA9IGlbdF0gfHwgKGlbdF0gPSB7fSk7XG4gIHJldHVybiBzW2VdIHx8IChzW2VdID0ge30pO1xufVxuZnVuY3Rpb24geXMoaSwgdCwgZSwgcykge1xuICB2YXIgX2l0ZXJhdG9yMTAgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0LmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHMpLnJldmVyc2UoKSksXG4gICAgX3N0ZXAxMDtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjEwLnMoKTsgIShfc3RlcDEwID0gX2l0ZXJhdG9yMTAubigpKS5kb25lOykge1xuICAgICAgdmFyIG4gPSBfc3RlcDEwLnZhbHVlO1xuICAgICAgdmFyIG8gPSBpW24uaW5kZXhdO1xuICAgICAgaWYgKGUgJiYgbyA+IDAgfHwgIWUgJiYgbyA8IDApIHJldHVybiBuLmluZGV4O1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMTAuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjEwLmYoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHZzKGksIHQpIHtcbiAgdmFyIGUgPSBpLmNoYXJ0LFxuICAgIHMgPSBpLl9jYWNoZWRNZXRhLFxuICAgIG4gPSBlLl9zdGFja3MgfHwgKGUuX3N0YWNrcyA9IHt9KSxcbiAgICBvID0gcy5pU2NhbGUsXG4gICAgciA9IHMudlNjYWxlLFxuICAgIGEgPSBzLmluZGV4LFxuICAgIGwgPSBvLmF4aXMsXG4gICAgYyA9IHIuYXhpcyxcbiAgICBoID0gbGEobywgciwgcyksXG4gICAgZCA9IHQubGVuZ3RoO1xuICB2YXIgdTtcbiAgZm9yICh2YXIgZiA9IDA7IGYgPCBkOyArK2YpIHtcbiAgICB2YXIgcCA9IHRbZl0sXG4gICAgICBnID0gcFtsXSxcbiAgICAgIG0gPSBwW2NdLFxuICAgICAgYiA9IHAuX3N0YWNrcyB8fCAocC5fc3RhY2tzID0ge30pO1xuICAgIHUgPSBiW2NdID0gaGEobiwgaCwgZyksIHVbYV0gPSBtLCB1Ll90b3AgPSB5cyh1LCByLCAhMCwgcy50eXBlKSwgdS5fYm90dG9tID0geXModSwgciwgITEsIHMudHlwZSk7XG4gICAgdmFyIF8gPSB1Ll92aXN1YWxWYWx1ZXMgfHwgKHUuX3Zpc3VhbFZhbHVlcyA9IHt9KTtcbiAgICBfW2FdID0gbTtcbiAgfVxufVxuZnVuY3Rpb24gYWkoaSwgdCkge1xuICB2YXIgZSA9IGkuc2NhbGVzO1xuICByZXR1cm4gT2JqZWN0LmtleXMoZSkuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIGVbc10uYXhpcyA9PT0gdDtcbiAgfSkuc2hpZnQoKTtcbn1cbmZ1bmN0aW9uIGRhKGksIHQpIHtcbiAgcmV0dXJuIEJ0KGksIHtcbiAgICBhY3RpdmU6ICExLFxuICAgIGRhdGFzZXQ6IHZvaWQgMCxcbiAgICBkYXRhc2V0SW5kZXg6IHQsXG4gICAgaW5kZXg6IHQsXG4gICAgbW9kZTogXCJkZWZhdWx0XCIsXG4gICAgdHlwZTogXCJkYXRhc2V0XCJcbiAgfSk7XG59XG5mdW5jdGlvbiB1YShpLCB0LCBlKSB7XG4gIHJldHVybiBCdChpLCB7XG4gICAgYWN0aXZlOiAhMSxcbiAgICBkYXRhSW5kZXg6IHQsXG4gICAgcGFyc2VkOiB2b2lkIDAsXG4gICAgcmF3OiB2b2lkIDAsXG4gICAgZWxlbWVudDogZSxcbiAgICBpbmRleDogdCxcbiAgICBtb2RlOiBcImRlZmF1bHRcIixcbiAgICB0eXBlOiBcImRhdGFcIlxuICB9KTtcbn1cbmZ1bmN0aW9uIFF0KGksIHQpIHtcbiAgdmFyIGUgPSBpLmNvbnRyb2xsZXIuaW5kZXgsXG4gICAgcyA9IGkudlNjYWxlICYmIGkudlNjYWxlLmF4aXM7XG4gIGlmIChzKSB7XG4gICAgdCA9IHQgfHwgaS5fcGFyc2VkO1xuICAgIHZhciBfaXRlcmF0b3IxMSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHQpLFxuICAgICAgX3N0ZXAxMTtcbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IxMS5zKCk7ICEoX3N0ZXAxMSA9IF9pdGVyYXRvcjExLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIG4gPSBfc3RlcDExLnZhbHVlO1xuICAgICAgICB2YXIgbyA9IG4uX3N0YWNrcztcbiAgICAgICAgaWYgKCFvIHx8IG9bc10gPT09IHZvaWQgMCB8fCBvW3NdW2VdID09PSB2b2lkIDApIHJldHVybjtcbiAgICAgICAgZGVsZXRlIG9bc11bZV0sIG9bc10uX3Zpc3VhbFZhbHVlcyAhPT0gdm9pZCAwICYmIG9bc10uX3Zpc3VhbFZhbHVlc1tlXSAhPT0gdm9pZCAwICYmIGRlbGV0ZSBvW3NdLl92aXN1YWxWYWx1ZXNbZV07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IxMS5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjExLmYoKTtcbiAgICB9XG4gIH1cbn1cbnZhciBsaSA9IGZ1bmN0aW9uIGxpKGkpIHtcbiAgICByZXR1cm4gaSA9PT0gXCJyZXNldFwiIHx8IGkgPT09IFwibm9uZVwiO1xuICB9LFxuICBNcyA9IGZ1bmN0aW9uIE1zKGksIHQpIHtcbiAgICByZXR1cm4gdCA/IGkgOiBPYmplY3QuYXNzaWduKHt9LCBpKTtcbiAgfSxcbiAgZmEgPSBmdW5jdGlvbiBmYShpLCB0LCBlKSB7XG4gICAgcmV0dXJuIGkgJiYgIXQuaGlkZGVuICYmIHQuX3N0YWNrZWQgJiYge1xuICAgICAga2V5czogVm4oZSwgITApLFxuICAgICAgdmFsdWVzOiBudWxsXG4gICAgfTtcbiAgfTtcbnZhciBrdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGt0KHQsIGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywga3QpO1xuICAgIHRoaXMuY2hhcnQgPSB0LCB0aGlzLl9jdHggPSB0LmN0eCwgdGhpcy5pbmRleCA9IGUsIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge30sIHRoaXMuX2NhY2hlZE1ldGEgPSB0aGlzLmdldE1ldGEoKSwgdGhpcy5fdHlwZSA9IHRoaXMuX2NhY2hlZE1ldGEudHlwZSwgdGhpcy5vcHRpb25zID0gdm9pZCAwLCB0aGlzLl9wYXJzaW5nID0gITEsIHRoaXMuX2RhdGEgPSB2b2lkIDAsIHRoaXMuX29iamVjdERhdGEgPSB2b2lkIDAsIHRoaXMuX3NoYXJlZE9wdGlvbnMgPSB2b2lkIDAsIHRoaXMuX2RyYXdTdGFydCA9IHZvaWQgMCwgdGhpcy5fZHJhd0NvdW50ID0gdm9pZCAwLCB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSAhMSwgdGhpcy5zdXBwb3J0c0RlY2ltYXRpb24gPSAhMSwgdGhpcy4kY29udGV4dCA9IHZvaWQgMCwgdGhpcy5fc3luY0xpc3QgPSBbXSwgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSAodGhpcyBpbnN0YW5jZW9mIGt0ID8gdGhpcy5jb25zdHJ1Y3RvciA6IHZvaWQgMCkuZGF0YXNldEVsZW1lbnRUeXBlLCB0aGlzLmRhdGFFbGVtZW50VHlwZSA9ICh0aGlzIGluc3RhbmNlb2Yga3QgPyB0aGlzLmNvbnN0cnVjdG9yIDogdm9pZCAwKS5kYXRhRWxlbWVudFR5cGUsIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3Moa3QsIFt7XG4gICAga2V5OiBcImluaXRpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgIHRoaXMuY29uZmlndXJlKCksIHRoaXMubGlua1NjYWxlcygpLCB0Ll9zdGFja2VkID0gcmkodC52U2NhbGUsIHQpLCB0aGlzLmFkZEVsZW1lbnRzKCksIHRoaXMub3B0aW9ucy5maWxsICYmICF0aGlzLmNoYXJ0LmlzUGx1Z2luRW5hYmxlZChcImZpbGxlclwiKSAmJiBjb25zb2xlLndhcm4oXCJUcmllZCB0byB1c2UgdGhlICdmaWxsJyBvcHRpb24gd2l0aG91dCB0aGUgJ0ZpbGxlcicgcGx1Z2luIGVuYWJsZWQuIFBsZWFzZSBpbXBvcnQgYW5kIHJlZ2lzdGVyIHRoZSAnRmlsbGVyJyBwbHVnaW4gYW5kIG1ha2Ugc3VyZSBpdCBpcyBub3QgZGlzYWJsZWQgaW4gdGhlIG9wdGlvbnNcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUluZGV4KHQpIHtcbiAgICAgIHRoaXMuaW5kZXggIT09IHQgJiYgUXQodGhpcy5fY2FjaGVkTWV0YSksIHRoaXMuaW5kZXggPSB0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsaW5rU2NhbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmtTY2FsZXMoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuY2hhcnQsXG4gICAgICAgIGUgPSB0aGlzLl9jYWNoZWRNZXRhLFxuICAgICAgICBzID0gdGhpcy5nZXREYXRhc2V0KCksXG4gICAgICAgIG4gPSBmdW5jdGlvbiBuKGQsIHUsIGYsIHApIHtcbiAgICAgICAgICByZXR1cm4gZCA9PT0gXCJ4XCIgPyB1IDogZCA9PT0gXCJyXCIgPyBwIDogZjtcbiAgICAgICAgfSxcbiAgICAgICAgbyA9IGUueEF4aXNJRCA9IEQocy54QXhpc0lELCBhaSh0LCBcInhcIikpLFxuICAgICAgICByID0gZS55QXhpc0lEID0gRChzLnlBeGlzSUQsIGFpKHQsIFwieVwiKSksXG4gICAgICAgIGEgPSBlLnJBeGlzSUQgPSBEKHMuckF4aXNJRCwgYWkodCwgXCJyXCIpKSxcbiAgICAgICAgbCA9IGUuaW5kZXhBeGlzLFxuICAgICAgICBjID0gZS5pQXhpc0lEID0gbihsLCBvLCByLCBhKSxcbiAgICAgICAgaCA9IGUudkF4aXNJRCA9IG4obCwgciwgbywgYSk7XG4gICAgICBlLnhTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChvKSwgZS55U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQociksIGUuclNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKGEpLCBlLmlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChjKSwgZS52U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoaCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERhdGFzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGF0YXNldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbdGhpcy5pbmRleF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1ldGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWV0YSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTY2FsZUZvcklkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNjYWxlRm9ySWQodCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhcnQuc2NhbGVzW3RdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0T3RoZXJTY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0T3RoZXJTY2FsZSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICByZXR1cm4gdCA9PT0gZS5pU2NhbGUgPyBlLnZTY2FsZSA6IGUuaVNjYWxlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShcInJlc2V0XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgIHRoaXMuX2RhdGEgJiYgc3ModGhpcy5fZGF0YSwgdGhpcyksIHQuX3N0YWNrZWQgJiYgUXQodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kYXRhQ2hlY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RhdGFDaGVjaygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5nZXREYXRhc2V0KCksXG4gICAgICAgIGUgPSB0LmRhdGEgfHwgKHQuZGF0YSA9IFtdKSxcbiAgICAgICAgcyA9IHRoaXMuX2RhdGE7XG4gICAgICBpZiAoVChlKSkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBhYShlLCBuKTtcbiAgICAgIH0gZWxzZSBpZiAocyAhPT0gZSkge1xuICAgICAgICBpZiAocykge1xuICAgICAgICAgIHNzKHMsIHRoaXMpO1xuICAgICAgICAgIHZhciBfbjIgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICAgIFF0KF9uMiksIF9uMi5fcGFyc2VkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGUpICYmIEpvKGUsIHRoaXMpLCB0aGlzLl9zeW5jTGlzdCA9IFtdLCB0aGlzLl9kYXRhID0gZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWxlbWVudHMoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICB0aGlzLl9kYXRhQ2hlY2soKSwgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgJiYgKHQuZGF0YXNldCA9IG5ldyB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRPclVwZGF0ZUVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkT3JVcGRhdGVFbGVtZW50cyh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIHMgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICAgIHZhciBuID0gITE7XG4gICAgICB0aGlzLl9kYXRhQ2hlY2soKTtcbiAgICAgIHZhciBvID0gZS5fc3RhY2tlZDtcbiAgICAgIGUuX3N0YWNrZWQgPSByaShlLnZTY2FsZSwgZSksIGUuc3RhY2sgIT09IHMuc3RhY2sgJiYgKG4gPSAhMCwgUXQoZSksIGUuc3RhY2sgPSBzLnN0YWNrKSwgdGhpcy5fcmVzeW5jRWxlbWVudHModCksIChuIHx8IG8gIT09IGUuX3N0YWNrZWQpICYmICh2cyh0aGlzLCBlLl9wYXJzZWQpLCBlLl9zdGFja2VkID0gcmkoZS52U2NhbGUsIGUpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29uZmlndXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmZpZ3VyZSgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5jaGFydC5jb25maWcsXG4gICAgICAgIGUgPSB0LmRhdGFzZXRTY29wZUtleXModGhpcy5fdHlwZSksXG4gICAgICAgIHMgPSB0LmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgZSwgITApO1xuICAgICAgdGhpcy5vcHRpb25zID0gdC5jcmVhdGVSZXNvbHZlcihzLCB0aGlzLmdldENvbnRleHQoKSksIHRoaXMuX3BhcnNpbmcgPSB0aGlzLm9wdGlvbnMucGFyc2luZywgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UodCwgZSkge1xuICAgICAgdmFyIHMgPSB0aGlzLl9jYWNoZWRNZXRhLFxuICAgICAgICBuID0gdGhpcy5fZGF0YSxcbiAgICAgICAgbyA9IHMuaVNjYWxlLFxuICAgICAgICByID0gcy5fc3RhY2tlZCxcbiAgICAgICAgYSA9IG8uYXhpcztcbiAgICAgIHZhciBsID0gdCA9PT0gMCAmJiBlID09PSBuLmxlbmd0aCA/ICEwIDogcy5fc29ydGVkLFxuICAgICAgICBjID0gdCA+IDAgJiYgcy5fcGFyc2VkW3QgLSAxXSxcbiAgICAgICAgaCxcbiAgICAgICAgZCxcbiAgICAgICAgdTtcbiAgICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSAhMSkgcy5fcGFyc2VkID0gbiwgcy5fc29ydGVkID0gITAsIHUgPSBuO2Vsc2Uge1xuICAgICAgICBOKG5bdF0pID8gdSA9IHRoaXMucGFyc2VBcnJheURhdGEocywgbiwgdCwgZSkgOiBUKG5bdF0pID8gdSA9IHRoaXMucGFyc2VPYmplY3REYXRhKHMsIG4sIHQsIGUpIDogdSA9IHRoaXMucGFyc2VQcmltaXRpdmVEYXRhKHMsIG4sIHQsIGUpO1xuICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uIGYoKSB7XG4gICAgICAgICAgcmV0dXJuIGRbYV0gPT09IG51bGwgfHwgYyAmJiBkW2FdIDwgY1thXTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChoID0gMDsgaCA8IGU7ICsraCkgcy5fcGFyc2VkW2ggKyB0XSA9IGQgPSB1W2hdLCBsICYmIChmKCkgJiYgKGwgPSAhMSksIGMgPSBkKTtcbiAgICAgICAgcy5fc29ydGVkID0gbDtcbiAgICAgIH1cbiAgICAgIHIgJiYgdnModGhpcywgdSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlUHJpbWl0aXZlRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVByaW1pdGl2ZURhdGEodCwgZSwgcywgbikge1xuICAgICAgdmFyIG8gPSB0LmlTY2FsZSxcbiAgICAgICAgciA9IHQudlNjYWxlLFxuICAgICAgICBhID0gby5heGlzLFxuICAgICAgICBsID0gci5heGlzLFxuICAgICAgICBjID0gby5nZXRMYWJlbHMoKSxcbiAgICAgICAgaCA9IG8gPT09IHIsXG4gICAgICAgIGQgPSBuZXcgQXJyYXkobik7XG4gICAgICB2YXIgdSwgZiwgcDtcbiAgICAgIGZvciAodSA9IDAsIGYgPSBuOyB1IDwgZjsgKyt1KSBwID0gdSArIHMsIGRbdV0gPSBfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KHt9LCBhLCBoIHx8IG8ucGFyc2UoY1twXSwgcCkpLCBsLCByLnBhcnNlKGVbcF0sIHApKTtcbiAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZUFycmF5RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUFycmF5RGF0YSh0LCBlLCBzLCBuKSB7XG4gICAgICB2YXIgbyA9IHQueFNjYWxlLFxuICAgICAgICByID0gdC55U2NhbGUsXG4gICAgICAgIGEgPSBuZXcgQXJyYXkobik7XG4gICAgICB2YXIgbCwgYywgaCwgZDtcbiAgICAgIGZvciAobCA9IDAsIGMgPSBuOyBsIDwgYzsgKytsKSBoID0gbCArIHMsIGQgPSBlW2hdLCBhW2xdID0ge1xuICAgICAgICB4OiBvLnBhcnNlKGRbMF0sIGgpLFxuICAgICAgICB5OiByLnBhcnNlKGRbMV0sIGgpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlT2JqZWN0RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZU9iamVjdERhdGEodCwgZSwgcywgbikge1xuICAgICAgdmFyIG8gPSB0LnhTY2FsZSxcbiAgICAgICAgciA9IHQueVNjYWxlLFxuICAgICAgICBfdGhpcyRfcGFyc2luZyA9IHRoaXMuX3BhcnNpbmcsXG4gICAgICAgIF90aGlzJF9wYXJzaW5nJHhBeGlzSyA9IF90aGlzJF9wYXJzaW5nLnhBeGlzS2V5LFxuICAgICAgICBhID0gX3RoaXMkX3BhcnNpbmckeEF4aXNLID09PSB2b2lkIDAgPyBcInhcIiA6IF90aGlzJF9wYXJzaW5nJHhBeGlzSyxcbiAgICAgICAgX3RoaXMkX3BhcnNpbmckeUF4aXNLID0gX3RoaXMkX3BhcnNpbmcueUF4aXNLZXksXG4gICAgICAgIGwgPSBfdGhpcyRfcGFyc2luZyR5QXhpc0sgPT09IHZvaWQgMCA/IFwieVwiIDogX3RoaXMkX3BhcnNpbmckeUF4aXNLLFxuICAgICAgICBjID0gbmV3IEFycmF5KG4pO1xuICAgICAgdmFyIGgsIGQsIHUsIGY7XG4gICAgICBmb3IgKGggPSAwLCBkID0gbjsgaCA8IGQ7ICsraCkgdSA9IGggKyBzLCBmID0gZVt1XSwgY1toXSA9IHtcbiAgICAgICAgeDogby5wYXJzZShJdChmLCBhKSwgdSksXG4gICAgICAgIHk6IHIucGFyc2UoSXQoZiwgbCksIHUpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBhcnNlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYXJzZWQodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZFt0XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGF0YUVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGF0YUVsZW1lbnQodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuZGF0YVt0XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlTdGFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseVN0YWNrKHQsIGUsIHMpIHtcbiAgICAgIHZhciBuID0gdGhpcy5jaGFydCxcbiAgICAgICAgbyA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIHIgPSBlW3QuYXhpc10sXG4gICAgICAgIGEgPSB7XG4gICAgICAgICAga2V5czogVm4obiwgITApLFxuICAgICAgICAgIHZhbHVlczogZS5fc3RhY2tzW3QuYXhpc10uX3Zpc3VhbFZhbHVlc1xuICAgICAgICB9O1xuICAgICAgcmV0dXJuIHhzKGEsIHIsIG8uaW5kZXgsIHtcbiAgICAgICAgbW9kZTogc1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVJhbmdlRnJvbVBhcnNlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVSYW5nZUZyb21QYXJzZWQodCwgZSwgcywgbikge1xuICAgICAgdmFyIG8gPSBzW2UuYXhpc107XG4gICAgICB2YXIgciA9IG8gPT09IG51bGwgPyBOYU4gOiBvO1xuICAgICAgdmFyIGEgPSBuICYmIHMuX3N0YWNrc1tlLmF4aXNdO1xuICAgICAgbiAmJiBhICYmIChuLnZhbHVlcyA9IGEsIHIgPSB4cyhuLCBvLCB0aGlzLl9jYWNoZWRNZXRhLmluZGV4KSksIHQubWluID0gTWF0aC5taW4odC5taW4sIHIpLCB0Lm1heCA9IE1hdGgubWF4KHQubWF4LCByKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWluTWF4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1pbk1heCh0LCBlKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIG4gPSBzLl9wYXJzZWQsXG4gICAgICAgIG8gPSBzLl9zb3J0ZWQgJiYgdCA9PT0gcy5pU2NhbGUsXG4gICAgICAgIHIgPSBuLmxlbmd0aCxcbiAgICAgICAgYSA9IHRoaXMuX2dldE90aGVyU2NhbGUodCksXG4gICAgICAgIGwgPSBmYShlLCBzLCB0aGlzLmNoYXJ0KSxcbiAgICAgICAgYyA9IHtcbiAgICAgICAgICBtaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICAgICAgICB9LFxuICAgICAgICBfY2EgPSBjYShhKSxcbiAgICAgICAgaCA9IF9jYS5taW4sXG4gICAgICAgIGQgPSBfY2EubWF4O1xuICAgICAgdmFyIHUsIGY7XG4gICAgICBmdW5jdGlvbiBwKCkge1xuICAgICAgICBmID0gblt1XTtcbiAgICAgICAgdmFyIGcgPSBmW2EuYXhpc107XG4gICAgICAgIHJldHVybiAhcShmW3QuYXhpc10pIHx8IGggPiBnIHx8IGQgPCBnO1xuICAgICAgfVxuICAgICAgZm9yICh1ID0gMDsgdSA8IHIgJiYgISghcCgpICYmICh0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChjLCB0LCBmLCBsKSwgbykpOyArK3UpO1xuICAgICAgaWYgKG8pIHtcbiAgICAgICAgZm9yICh1ID0gciAtIDE7IHUgPj0gMDsgLS11KSBpZiAoIXAoKSkge1xuICAgICAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKGMsIHQsIGYsIGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QWxsUGFyc2VkVmFsdWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFsbFBhcnNlZFZhbHVlcyh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZCxcbiAgICAgICAgcyA9IFtdO1xuICAgICAgdmFyIG4sIG8sIHI7XG4gICAgICBmb3IgKG4gPSAwLCBvID0gZS5sZW5ndGg7IG4gPCBvOyArK24pIHIgPSBlW25dW3QuYXhpc10sIHEocikgJiYgcy5wdXNoKHIpO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1heE92ZXJmbG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1heE92ZXJmbG93KCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMYWJlbEFuZFZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhYmVsQW5kVmFsdWUodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9jYWNoZWRNZXRhLFxuICAgICAgICBzID0gZS5pU2NhbGUsXG4gICAgICAgIG4gPSBlLnZTY2FsZSxcbiAgICAgICAgbyA9IHRoaXMuZ2V0UGFyc2VkKHQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFiZWw6IHMgPyBcIlwiICsgcy5nZXRMYWJlbEZvclZhbHVlKG9bcy5heGlzXSkgOiBcIlwiLFxuICAgICAgICB2YWx1ZTogbiA/IFwiXCIgKyBuLmdldExhYmVsRm9yVmFsdWUob1tuLmF4aXNdKSA6IFwiXCJcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICB0aGlzLnVwZGF0ZSh0IHx8IFwiZGVmYXVsdFwiKSwgZS5fY2xpcCA9IHJhKEQodGhpcy5vcHRpb25zLmNsaXAsIG9hKGUueFNjYWxlLCBlLnlTY2FsZSwgdGhpcy5nZXRNYXhPdmVyZmxvdygpKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKHQpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9jdHgsXG4gICAgICAgIGUgPSB0aGlzLmNoYXJ0LFxuICAgICAgICBzID0gdGhpcy5fY2FjaGVkTWV0YSxcbiAgICAgICAgbiA9IHMuZGF0YSB8fCBbXSxcbiAgICAgICAgbyA9IGUuY2hhcnRBcmVhLFxuICAgICAgICByID0gW10sXG4gICAgICAgIGEgPSB0aGlzLl9kcmF3U3RhcnQgfHwgMCxcbiAgICAgICAgbCA9IHRoaXMuX2RyYXdDb3VudCB8fCBuLmxlbmd0aCAtIGEsXG4gICAgICAgIGMgPSB0aGlzLm9wdGlvbnMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3A7XG4gICAgICB2YXIgaDtcbiAgICAgIGZvciAocy5kYXRhc2V0ICYmIHMuZGF0YXNldC5kcmF3KHQsIG8sIGEsIGwpLCBoID0gYTsgaCA8IGEgKyBsOyArK2gpIHtcbiAgICAgICAgdmFyIGQgPSBuW2hdO1xuICAgICAgICBkLmhpZGRlbiB8fCAoZC5hY3RpdmUgJiYgYyA/IHIucHVzaChkKSA6IGQuZHJhdyh0LCBvKSk7XG4gICAgICB9XG4gICAgICBmb3IgKGggPSAwOyBoIDwgci5sZW5ndGg7ICsraCkgcltoXS5kcmF3KHQsIG8pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdHlsZSh0LCBlKSB7XG4gICAgICB2YXIgcyA9IGUgPyBcImFjdGl2ZVwiIDogXCJkZWZhdWx0XCI7XG4gICAgICByZXR1cm4gdCA9PT0gdm9pZCAwICYmIHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldCA/IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhzKSA6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyh0IHx8IDAsIHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbnRleHQodCwgZSwgcykge1xuICAgICAgdmFyIG4gPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICAgIHZhciBvO1xuICAgICAgaWYgKHQgPj0gMCAmJiB0IDwgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCkge1xuICAgICAgICB2YXIgciA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YVt0XTtcbiAgICAgICAgbyA9IHIuJGNvbnRleHQgfHwgKHIuJGNvbnRleHQgPSB1YSh0aGlzLmdldENvbnRleHQoKSwgdCwgcikpLCBvLnBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKHQpLCBvLnJhdyA9IG4uZGF0YVt0XSwgby5pbmRleCA9IG8uZGF0YUluZGV4ID0gdDtcbiAgICAgIH0gZWxzZSBvID0gdGhpcy4kY29udGV4dCB8fCAodGhpcy4kY29udGV4dCA9IGRhKHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLmluZGV4KSksIG8uZGF0YXNldCA9IG4sIG8uaW5kZXggPSBvLmRhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICByZXR1cm4gby5hY3RpdmUgPSAhIWUsIG8ubW9kZSA9IHMsIG87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlLmlkLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZURhdGFFbGVtZW50T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHQsIGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhRWxlbWVudFR5cGUuaWQsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVzb2x2ZUVsZW1lbnRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNvbHZlRWxlbWVudE9wdGlvbnModCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJkZWZhdWx0XCI7XG4gICAgICB2YXIgcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG4gPSBlID09PSBcImFjdGl2ZVwiLFxuICAgICAgICBvID0gdGhpcy5fY2FjaGVkRGF0YU9wdHMsXG4gICAgICAgIHIgPSB0ICsgXCItXCIgKyBlLFxuICAgICAgICBhID0gb1tyXSxcbiAgICAgICAgbCA9IHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyAmJiBnZShzKTtcbiAgICAgIGlmIChhKSByZXR1cm4gTXMoYSwgbCk7XG4gICAgICB2YXIgYyA9IHRoaXMuY2hhcnQuY29uZmlnLFxuICAgICAgICBoID0gYy5kYXRhc2V0RWxlbWVudFNjb3BlS2V5cyh0aGlzLl90eXBlLCB0KSxcbiAgICAgICAgZCA9IG4gPyBbXCJcIi5jb25jYXQodCwgXCJIb3ZlclwiKSwgXCJob3ZlclwiLCB0LCBcIlwiXSA6IFt0LCBcIlwiXSxcbiAgICAgICAgdSA9IGMuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBoKSxcbiAgICAgICAgZiA9IE9iamVjdC5rZXlzKFcuZWxlbWVudHNbdF0pLFxuICAgICAgICBwID0gZnVuY3Rpb24gcCgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM1LmdldENvbnRleHQocywgbiwgZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGcgPSBjLnJlc29sdmVOYW1lZE9wdGlvbnModSwgZiwgcCwgZCk7XG4gICAgICByZXR1cm4gZy4kc2hhcmVkICYmIChnLiRzaGFyZWQgPSBsLCBvW3JdID0gT2JqZWN0LmZyZWV6ZShNcyhnLCBsKSkpLCBnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVzb2x2ZUFuaW1hdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc29sdmVBbmltYXRpb25zKHQsIGUsIHMpIHtcbiAgICAgIHZhciBuID0gdGhpcy5jaGFydCxcbiAgICAgICAgbyA9IHRoaXMuX2NhY2hlZERhdGFPcHRzLFxuICAgICAgICByID0gXCJhbmltYXRpb24tXCIuY29uY2F0KGUpLFxuICAgICAgICBhID0gb1tyXTtcbiAgICAgIGlmIChhKSByZXR1cm4gYTtcbiAgICAgIHZhciBsO1xuICAgICAgaWYgKG4ub3B0aW9ucy5hbmltYXRpb24gIT09ICExKSB7XG4gICAgICAgIHZhciBoID0gdGhpcy5jaGFydC5jb25maWcsXG4gICAgICAgICAgZCA9IGguZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyh0aGlzLl90eXBlLCBlKSxcbiAgICAgICAgICB1ID0gaC5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIGQpO1xuICAgICAgICBsID0gaC5jcmVhdGVSZXNvbHZlcih1LCB0aGlzLmdldENvbnRleHQodCwgcywgZSkpO1xuICAgICAgfVxuICAgICAgdmFyIGMgPSBuZXcgTm4obiwgbCAmJiBsLmFuaW1hdGlvbnMpO1xuICAgICAgcmV0dXJuIGwgJiYgbC5fY2FjaGVhYmxlICYmIChvW3JdID0gT2JqZWN0LmZyZWV6ZShjKSksIGM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNoYXJlZE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2hhcmVkT3B0aW9ucyh0KSB7XG4gICAgICBpZiAodC4kc2hhcmVkKSByZXR1cm4gdGhpcy5fc2hhcmVkT3B0aW9ucyB8fCAodGhpcy5fc2hhcmVkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5jbHVkZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5jbHVkZU9wdGlvbnModCwgZSkge1xuICAgICAgcmV0dXJuICFlIHx8IGxpKHQpIHx8IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFNoYXJlZE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNoYXJlZE9wdGlvbnModCwgZSkge1xuICAgICAgdmFyIHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnModCwgZSksXG4gICAgICAgIG4gPSB0aGlzLl9zaGFyZWRPcHRpb25zLFxuICAgICAgICBvID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKHMpLFxuICAgICAgICByID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhlLCBvKSB8fCBvICE9PSBuO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhvLCBlLCBzKSwge1xuICAgICAgICBzaGFyZWRPcHRpb25zOiBvLFxuICAgICAgICBpbmNsdWRlT3B0aW9uczogclxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHQsIGUsIHMsIG4pIHtcbiAgICAgIGxpKG4pID8gT2JqZWN0LmFzc2lnbih0LCBzKSA6IHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGUsIG4pLnVwZGF0ZSh0LCBzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU2hhcmVkT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTaGFyZWRPcHRpb25zKHQsIGUsIHMpIHtcbiAgICAgIHQgJiYgIWxpKGUpICYmIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKHZvaWQgMCwgZSkudXBkYXRlKHQsIHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0U3R5bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFN0eWxlKHQsIGUsIHMsIG4pIHtcbiAgICAgIHQuYWN0aXZlID0gbjtcbiAgICAgIHZhciBvID0gdGhpcy5nZXRTdHlsZShlLCBuKTtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGUsIHMsIG4pLnVwZGF0ZSh0LCB7XG4gICAgICAgIG9wdGlvbnM6ICFuICYmIHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhvKSB8fCBvXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlSG92ZXJTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVIb3ZlclN0eWxlKHQsIGUsIHMpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKHQsIHMsIFwiYWN0aXZlXCIsICExKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0SG92ZXJTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRIb3ZlclN0eWxlKHQsIGUsIHMpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKHQsIHMsIFwiYWN0aXZlXCIsICEwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuICAgICAgdCAmJiB0aGlzLl9zZXRTdHlsZSh0LCB2b2lkIDAsIFwiYWN0aXZlXCIsICExKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldERhdGFzZXRIb3ZlclN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXREYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuICAgICAgdCAmJiB0aGlzLl9zZXRTdHlsZSh0LCB2b2lkIDAsIFwiYWN0aXZlXCIsICEwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc3luY0VsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXN5bmNFbGVtZW50cyh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2RhdGEsXG4gICAgICAgIHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgICB2YXIgX2l0ZXJhdG9yMTIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLl9zeW5jTGlzdCksXG4gICAgICAgIF9zdGVwMTI7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjEyLnMoKTsgIShfc3RlcDEyID0gX2l0ZXJhdG9yMTIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDEyJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAxMi52YWx1ZSwgMyksXG4gICAgICAgICAgICBhID0gX3N0ZXAxMiR2YWx1ZVswXSxcbiAgICAgICAgICAgIGwgPSBfc3RlcDEyJHZhbHVlWzFdLFxuICAgICAgICAgICAgYyA9IF9zdGVwMTIkdmFsdWVbMl07XG4gICAgICAgICAgdGhpc1thXShsLCBjKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjEyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjEyLmYoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgICB2YXIgbiA9IHMubGVuZ3RoLFxuICAgICAgICBvID0gZS5sZW5ndGgsXG4gICAgICAgIHIgPSBNYXRoLm1pbihvLCBuKTtcbiAgICAgIHIgJiYgdGhpcy5wYXJzZSgwLCByKSwgbyA+IG4gPyB0aGlzLl9pbnNlcnRFbGVtZW50cyhuLCBvIC0gbiwgdCkgOiBvIDwgbiAmJiB0aGlzLl9yZW1vdmVFbGVtZW50cyhvLCBuIC0gbyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pbnNlcnRFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5zZXJ0RWxlbWVudHModCwgZSkge1xuICAgICAgdmFyIHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICEwO1xuICAgICAgdmFyIG4gPSB0aGlzLl9jYWNoZWRNZXRhLFxuICAgICAgICBvID0gbi5kYXRhLFxuICAgICAgICByID0gdCArIGU7XG4gICAgICB2YXIgYTtcbiAgICAgIHZhciBsID0gZnVuY3Rpb24gbChjKSB7XG4gICAgICAgIGZvciAoYy5sZW5ndGggKz0gZSwgYSA9IGMubGVuZ3RoIC0gMTsgYSA+PSByOyBhLS0pIGNbYV0gPSBjW2EgLSBlXTtcbiAgICAgIH07XG4gICAgICBmb3IgKGwobyksIGEgPSB0OyBhIDwgcjsgKythKSBvW2FdID0gbmV3IHRoaXMuZGF0YUVsZW1lbnRUeXBlKCk7XG4gICAgICB0aGlzLl9wYXJzaW5nICYmIGwobi5fcGFyc2VkKSwgdGhpcy5wYXJzZSh0LCBlKSwgcyAmJiB0aGlzLnVwZGF0ZUVsZW1lbnRzKG8sIHQsIGUsIFwicmVzZXRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnRzKHQsIGUsIHMsIG4pIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZUVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVFbGVtZW50cyh0LCBlKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgICB2YXIgbiA9IHMuX3BhcnNlZC5zcGxpY2UodCwgZSk7XG4gICAgICAgIHMuX3N0YWNrZWQgJiYgUXQocywgbik7XG4gICAgICB9XG4gICAgICBzLmRhdGEuc3BsaWNlKHQsIGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc3luY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3luYyh0KSB7XG4gICAgICBpZiAodGhpcy5fcGFyc2luZykgdGhpcy5fc3luY0xpc3QucHVzaCh0KTtlbHNlIHtcbiAgICAgICAgdmFyIF90MiA9IF9zbGljZWRUb0FycmF5KHQsIDMpLFxuICAgICAgICAgIGUgPSBfdDJbMF0sXG4gICAgICAgICAgcyA9IF90MlsxXSxcbiAgICAgICAgICBuID0gX3QyWzJdO1xuICAgICAgICB0aGlzW2VdKHMsIG4pO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGFydC5fZGF0YUNoYW5nZXMucHVzaChbdGhpcy5pbmRleF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0KSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25EYXRhUHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25EYXRhUHVzaCgpIHtcbiAgICAgIHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHRoaXMuX3N5bmMoW1wiX2luc2VydEVsZW1lbnRzXCIsIHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEubGVuZ3RoIC0gdCwgdF0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25EYXRhUG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRhdGFQb3AoKSB7XG4gICAgICB0aGlzLl9zeW5jKFtcIl9yZW1vdmVFbGVtZW50c1wiLCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoIC0gMSwgMV0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25EYXRhU2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRGF0YVNoaWZ0KCkge1xuICAgICAgdGhpcy5fc3luYyhbXCJfcmVtb3ZlRWxlbWVudHNcIiwgMCwgMV0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25EYXRhU3BsaWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRhdGFTcGxpY2UodCwgZSkge1xuICAgICAgZSAmJiB0aGlzLl9zeW5jKFtcIl9yZW1vdmVFbGVtZW50c1wiLCB0LCBlXSk7XG4gICAgICB2YXIgcyA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgICAgcyAmJiB0aGlzLl9zeW5jKFtcIl9pbnNlcnRFbGVtZW50c1wiLCB0LCBzXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vbkRhdGFVbnNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRhdGFVbnNoaWZ0KCkge1xuICAgICAgdGhpcy5fc3luYyhbXCJfaW5zZXJ0RWxlbWVudHNcIiwgMCwgYXJndW1lbnRzLmxlbmd0aF0pO1xuICAgIH1cbiAgfV0pO1xufSgpO1xudyhrdCwgXCJkZWZhdWx0c1wiLCB7fSksIHcoa3QsIFwiZGF0YXNldEVsZW1lbnRUeXBlXCIsIG51bGwpLCB3KGt0LCBcImRhdGFFbGVtZW50VHlwZVwiLCBudWxsKTtcbmZ1bmN0aW9uIGdhKGksIHQpIHtcbiAgaWYgKCFpLl9jYWNoZS4kYmFyKSB7XG4gICAgdmFyIGUgPSBpLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHQpO1xuICAgIHZhciBzID0gW107XG4gICAgZm9yICh2YXIgbiA9IDAsIG8gPSBlLmxlbmd0aDsgbiA8IG87IG4rKykgcyA9IHMuY29uY2F0KGVbbl0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXMoaSkpO1xuICAgIGkuX2NhY2hlLiRiYXIgPSBNbihzLnNvcnQoZnVuY3Rpb24gKG4sIG8pIHtcbiAgICAgIHJldHVybiBuIC0gbztcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIGkuX2NhY2hlLiRiYXI7XG59XG5mdW5jdGlvbiBwYShpKSB7XG4gIHZhciB0ID0gaS5pU2NhbGUsXG4gICAgZSA9IGdhKHQsIGkudHlwZSk7XG4gIHZhciBzID0gdC5fbGVuZ3RoLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIGE7XG4gIHZhciBsID0gZnVuY3Rpb24gbCgpIHtcbiAgICByID09PSAzMjc2NyB8fCByID09PSAtMzI3NjggfHwgKGdlKGEpICYmIChzID0gTWF0aC5taW4ocywgTWF0aC5hYnMociAtIGEpIHx8IHMpKSwgYSA9IHIpO1xuICB9O1xuICBmb3IgKG4gPSAwLCBvID0gZS5sZW5ndGg7IG4gPCBvOyArK24pIHIgPSB0LmdldFBpeGVsRm9yVmFsdWUoZVtuXSksIGwoKTtcbiAgZm9yIChhID0gdm9pZCAwLCBuID0gMCwgbyA9IHQudGlja3MubGVuZ3RoOyBuIDwgbzsgKytuKSByID0gdC5nZXRQaXhlbEZvclRpY2sobiksIGwoKTtcbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBtYShpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gZS5iYXJUaGlja25lc3M7XG4gIHZhciBvLCByO1xuICByZXR1cm4gUihuKSA/IChvID0gdC5taW4gKiBlLmNhdGVnb3J5UGVyY2VudGFnZSwgciA9IGUuYmFyUGVyY2VudGFnZSkgOiAobyA9IG4gKiBzLCByID0gMSksIHtcbiAgICBjaHVuazogbyAvIHMsXG4gICAgcmF0aW86IHIsXG4gICAgc3RhcnQ6IHQucGl4ZWxzW2ldIC0gbyAvIDJcbiAgfTtcbn1cbmZ1bmN0aW9uIGJhKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSB0LnBpeGVscyxcbiAgICBvID0gbltpXTtcbiAgdmFyIHIgPSBpID4gMCA/IG5baSAtIDFdIDogbnVsbCxcbiAgICBhID0gaSA8IG4ubGVuZ3RoIC0gMSA/IG5baSArIDFdIDogbnVsbDtcbiAgdmFyIGwgPSBlLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgciA9PT0gbnVsbCAmJiAociA9IG8gLSAoYSA9PT0gbnVsbCA/IHQuZW5kIC0gdC5zdGFydCA6IGEgLSBvKSksIGEgPT09IG51bGwgJiYgKGEgPSBvICsgbyAtIHIpO1xuICB2YXIgYyA9IG8gLSAobyAtIE1hdGgubWluKHIsIGEpKSAvIDIgKiBsO1xuICByZXR1cm4ge1xuICAgIGNodW5rOiBNYXRoLmFicyhhIC0gcikgLyAyICogbCAvIHMsXG4gICAgcmF0aW86IGUuYmFyUGVyY2VudGFnZSxcbiAgICBzdGFydDogY1xuICB9O1xufVxuZnVuY3Rpb24gX2EoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IGUucGFyc2UoaVswXSwgcyksXG4gICAgbyA9IGUucGFyc2UoaVsxXSwgcyksXG4gICAgciA9IE1hdGgubWluKG4sIG8pLFxuICAgIGEgPSBNYXRoLm1heChuLCBvKTtcbiAgdmFyIGwgPSByLFxuICAgIGMgPSBhO1xuICBNYXRoLmFicyhyKSA+IE1hdGguYWJzKGEpICYmIChsID0gYSwgYyA9IHIpLCB0W2UuYXhpc10gPSBjLCB0Ll9jdXN0b20gPSB7XG4gICAgYmFyU3RhcnQ6IGwsXG4gICAgYmFyRW5kOiBjLFxuICAgIHN0YXJ0OiBuLFxuICAgIGVuZDogbyxcbiAgICBtaW46IHIsXG4gICAgbWF4OiBhXG4gIH07XG59XG5mdW5jdGlvbiBqbihpLCB0LCBlLCBzKSB7XG4gIHJldHVybiBOKGkpID8gX2EoaSwgdCwgZSwgcykgOiB0W2UuYXhpc10gPSBlLnBhcnNlKGksIHMpLCB0O1xufVxuZnVuY3Rpb24gU3MoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IGkuaVNjYWxlLFxuICAgIG8gPSBpLnZTY2FsZSxcbiAgICByID0gbi5nZXRMYWJlbHMoKSxcbiAgICBhID0gbiA9PT0gbyxcbiAgICBsID0gW107XG4gIHZhciBjLCBoLCBkLCB1O1xuICBmb3IgKGMgPSBlLCBoID0gZSArIHM7IGMgPCBoOyArK2MpIHUgPSB0W2NdLCBkID0ge30sIGRbbi5heGlzXSA9IGEgfHwgbi5wYXJzZShyW2NdLCBjKSwgbC5wdXNoKGpuKHUsIGQsIG8sIGMpKTtcbiAgcmV0dXJuIGw7XG59XG5mdW5jdGlvbiBjaShpKSB7XG4gIHJldHVybiBpICYmIGkuYmFyU3RhcnQgIT09IHZvaWQgMCAmJiBpLmJhckVuZCAhPT0gdm9pZCAwO1xufVxuZnVuY3Rpb24geGEoaSwgdCwgZSkge1xuICByZXR1cm4gaSAhPT0gMCA/IGx0KGkpIDogKHQuaXNIb3Jpem9udGFsKCkgPyAxIDogLTEpICogKHQubWluID49IGUgPyAxIDogLTEpO1xufVxuZnVuY3Rpb24geWEoaSkge1xuICB2YXIgdCwgZSwgcywgbiwgbztcbiAgcmV0dXJuIGkuaG9yaXpvbnRhbCA/ICh0ID0gaS5iYXNlID4gaS54LCBlID0gXCJsZWZ0XCIsIHMgPSBcInJpZ2h0XCIpIDogKHQgPSBpLmJhc2UgPCBpLnksIGUgPSBcImJvdHRvbVwiLCBzID0gXCJ0b3BcIiksIHQgPyAobiA9IFwiZW5kXCIsIG8gPSBcInN0YXJ0XCIpIDogKG4gPSBcInN0YXJ0XCIsIG8gPSBcImVuZFwiKSwge1xuICAgIHN0YXJ0OiBlLFxuICAgIGVuZDogcyxcbiAgICByZXZlcnNlOiB0LFxuICAgIHRvcDogbixcbiAgICBib3R0b206IG9cbiAgfTtcbn1cbmZ1bmN0aW9uIHZhKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSB0LmJvcmRlclNraXBwZWQ7XG4gIHZhciBvID0ge307XG4gIGlmICghbikge1xuICAgIGkuYm9yZGVyU2tpcHBlZCA9IG87XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChuID09PSAhMCkge1xuICAgIGkuYm9yZGVyU2tpcHBlZCA9IHtcbiAgICAgIHRvcDogITAsXG4gICAgICByaWdodDogITAsXG4gICAgICBib3R0b206ICEwLFxuICAgICAgbGVmdDogITBcbiAgICB9O1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgX3lhID0geWEoaSksXG4gICAgciA9IF95YS5zdGFydCxcbiAgICBhID0gX3lhLmVuZCxcbiAgICBsID0gX3lhLnJldmVyc2UsXG4gICAgYyA9IF95YS50b3AsXG4gICAgaCA9IF95YS5ib3R0b207XG4gIG4gPT09IFwibWlkZGxlXCIgJiYgZSAmJiAoaS5lbmFibGVCb3JkZXJSYWRpdXMgPSAhMCwgKGUuX3RvcCB8fCAwKSA9PT0gcyA/IG4gPSBjIDogKGUuX2JvdHRvbSB8fCAwKSA9PT0gcyA/IG4gPSBoIDogKG9ba3MoaCwgciwgYSwgbCldID0gITAsIG4gPSBjKSksIG9ba3MobiwgciwgYSwgbCldID0gITAsIGkuYm9yZGVyU2tpcHBlZCA9IG87XG59XG5mdW5jdGlvbiBrcyhpLCB0LCBlLCBzKSB7XG4gIHJldHVybiBzID8gKGkgPSBNYShpLCB0LCBlKSwgaSA9IHdzKGksIGUsIHQpKSA6IGkgPSB3cyhpLCB0LCBlKSwgaTtcbn1cbmZ1bmN0aW9uIE1hKGksIHQsIGUpIHtcbiAgcmV0dXJuIGkgPT09IHQgPyBlIDogaSA9PT0gZSA/IHQgOiBpO1xufVxuZnVuY3Rpb24gd3MoaSwgdCwgZSkge1xuICByZXR1cm4gaSA9PT0gXCJzdGFydFwiID8gdCA6IGkgPT09IFwiZW5kXCIgPyBlIDogaTtcbn1cbmZ1bmN0aW9uIFNhKGksIF9yZWYyLCBlKSB7XG4gIHZhciB0ID0gX3JlZjIuaW5mbGF0ZUFtb3VudDtcbiAgaS5pbmZsYXRlQW1vdW50ID0gdCA9PT0gXCJhdXRvXCIgPyBlID09PSAxID8gMC4zMyA6IDAgOiB0O1xufVxudmFyIEVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfa3QpIHtcbiAgZnVuY3Rpb24gRWUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVlKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBFZSwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoRWUsIF9rdCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRWUsIFt7XG4gICAga2V5OiBcInBhcnNlUHJpbWl0aXZlRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVByaW1pdGl2ZURhdGEodCwgZSwgcywgbikge1xuICAgICAgcmV0dXJuIFNzKHQsIGUsIHMsIG4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZUFycmF5RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUFycmF5RGF0YSh0LCBlLCBzLCBuKSB7XG4gICAgICByZXR1cm4gU3ModCwgZSwgcywgbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlT2JqZWN0RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZU9iamVjdERhdGEodCwgZSwgcywgbikge1xuICAgICAgdmFyIG8gPSB0LmlTY2FsZSxcbiAgICAgICAgciA9IHQudlNjYWxlLFxuICAgICAgICBfdGhpcyRfcGFyc2luZzIgPSB0aGlzLl9wYXJzaW5nLFxuICAgICAgICBfdGhpcyRfcGFyc2luZzIkeEF4aXMgPSBfdGhpcyRfcGFyc2luZzIueEF4aXNLZXksXG4gICAgICAgIGEgPSBfdGhpcyRfcGFyc2luZzIkeEF4aXMgPT09IHZvaWQgMCA/IFwieFwiIDogX3RoaXMkX3BhcnNpbmcyJHhBeGlzLFxuICAgICAgICBfdGhpcyRfcGFyc2luZzIkeUF4aXMgPSBfdGhpcyRfcGFyc2luZzIueUF4aXNLZXksXG4gICAgICAgIGwgPSBfdGhpcyRfcGFyc2luZzIkeUF4aXMgPT09IHZvaWQgMCA/IFwieVwiIDogX3RoaXMkX3BhcnNpbmcyJHlBeGlzLFxuICAgICAgICBjID0gby5heGlzID09PSBcInhcIiA/IGEgOiBsLFxuICAgICAgICBoID0gci5heGlzID09PSBcInhcIiA/IGEgOiBsLFxuICAgICAgICBkID0gW107XG4gICAgICB2YXIgdSwgZiwgcCwgZztcbiAgICAgIGZvciAodSA9IHMsIGYgPSBzICsgbjsgdSA8IGY7ICsrdSkgZyA9IGVbdV0sIHAgPSB7fSwgcFtvLmF4aXNdID0gby5wYXJzZShJdChnLCBjKSwgdSksIGQucHVzaChqbihJdChnLCBoKSwgcCwgciwgdSkpO1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVJhbmdlRnJvbVBhcnNlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVSYW5nZUZyb21QYXJzZWQodCwgZSwgcywgbikge1xuICAgICAgX3N1cGVyUHJvcEdldChFZSwgXCJ1cGRhdGVSYW5nZUZyb21QYXJzZWRcIiwgdGhpcywgMykoW3QsIGUsIHMsIG5dKTtcbiAgICAgIHZhciBvID0gcy5fY3VzdG9tO1xuICAgICAgbyAmJiBlID09PSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZSAmJiAodC5taW4gPSBNYXRoLm1pbih0Lm1pbiwgby5taW4pLCB0Lm1heCA9IE1hdGgubWF4KHQubWF4LCBvLm1heCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXhPdmVyZmxvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMYWJlbEFuZFZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhYmVsQW5kVmFsdWUodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9jYWNoZWRNZXRhLFxuICAgICAgICBzID0gZS5pU2NhbGUsXG4gICAgICAgIG4gPSBlLnZTY2FsZSxcbiAgICAgICAgbyA9IHRoaXMuZ2V0UGFyc2VkKHQpLFxuICAgICAgICByID0gby5fY3VzdG9tLFxuICAgICAgICBhID0gY2kocikgPyBcIltcIiArIHIuc3RhcnQgKyBcIiwgXCIgKyByLmVuZCArIFwiXVwiIDogXCJcIiArIG4uZ2V0TGFiZWxGb3JWYWx1ZShvW24uYXhpc10pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFiZWw6IFwiXCIgKyBzLmdldExhYmVsRm9yVmFsdWUob1tzLmF4aXNdKSxcbiAgICAgICAgdmFsdWU6IGFcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9ICEwLCBfc3VwZXJQcm9wR2V0KEVlLCBcImluaXRpYWxpemVcIiwgdGhpcywgMykoW10pO1xuICAgICAgdmFyIHQgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgdC5zdGFjayA9IHRoaXMuZ2V0RGF0YXNldCgpLnN0YWNrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudHMoZS5kYXRhLCAwLCBlLmRhdGEubGVuZ3RoLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRWxlbWVudHModCwgZSwgcywgbikge1xuICAgICAgdmFyIG8gPSBuID09PSBcInJlc2V0XCIsXG4gICAgICAgIHIgPSB0aGlzLmluZGV4LFxuICAgICAgICBhID0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGUsXG4gICAgICAgIGwgPSBhLmdldEJhc2VQaXhlbCgpLFxuICAgICAgICBjID0gYS5pc0hvcml6b250YWwoKSxcbiAgICAgICAgaCA9IHRoaXMuX2dldFJ1bGVyKCksXG4gICAgICAgIF90aGlzJF9nZXRTaGFyZWRPcHRpbyA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoZSwgbiksXG4gICAgICAgIGQgPSBfdGhpcyRfZ2V0U2hhcmVkT3B0aW8uc2hhcmVkT3B0aW9ucyxcbiAgICAgICAgdSA9IF90aGlzJF9nZXRTaGFyZWRPcHRpby5pbmNsdWRlT3B0aW9ucztcbiAgICAgIGZvciAodmFyIGYgPSBlOyBmIDwgZSArIHM7IGYrKykge1xuICAgICAgICB2YXIgcCA9IHRoaXMuZ2V0UGFyc2VkKGYpLFxuICAgICAgICAgIGcgPSBvIHx8IFIocFthLmF4aXNdKSA/IHtcbiAgICAgICAgICAgIGJhc2U6IGwsXG4gICAgICAgICAgICBoZWFkOiBsXG4gICAgICAgICAgfSA6IHRoaXMuX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGYpLFxuICAgICAgICAgIG0gPSB0aGlzLl9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhmLCBoKSxcbiAgICAgICAgICBiID0gKHAuX3N0YWNrcyB8fCB7fSlbYS5heGlzXSxcbiAgICAgICAgICBfID0ge1xuICAgICAgICAgICAgaG9yaXpvbnRhbDogYyxcbiAgICAgICAgICAgIGJhc2U6IGcuYmFzZSxcbiAgICAgICAgICAgIGVuYWJsZUJvcmRlclJhZGl1czogIWIgfHwgY2kocC5fY3VzdG9tKSB8fCByID09PSBiLl90b3AgfHwgciA9PT0gYi5fYm90dG9tLFxuICAgICAgICAgICAgeDogYyA/IGcuaGVhZCA6IG0uY2VudGVyLFxuICAgICAgICAgICAgeTogYyA/IG0uY2VudGVyIDogZy5oZWFkLFxuICAgICAgICAgICAgaGVpZ2h0OiBjID8gbS5zaXplIDogTWF0aC5hYnMoZy5zaXplKSxcbiAgICAgICAgICAgIHdpZHRoOiBjID8gTWF0aC5hYnMoZy5zaXplKSA6IG0uc2l6ZVxuICAgICAgICAgIH07XG4gICAgICAgIHUgJiYgKF8ub3B0aW9ucyA9IGQgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGYsIHRbZl0uYWN0aXZlID8gXCJhY3RpdmVcIiA6IG4pKTtcbiAgICAgICAgdmFyIHYgPSBfLm9wdGlvbnMgfHwgdFtmXS5vcHRpb25zO1xuICAgICAgICB2YShfLCB2LCBiLCByKSwgU2EoXywgdiwgaC5yYXRpbyksIHRoaXMudXBkYXRlRWxlbWVudCh0W2ZdLCBmLCBfLCBuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFN0YWNrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RhY2tzKHQsIGUpIHtcbiAgICAgIHZhciBzID0gdGhpcy5fY2FjaGVkTWV0YS5pU2NhbGUsXG4gICAgICAgIG4gPSBzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHRoaXMuX3R5cGUpLmZpbHRlcihmdW5jdGlvbiAoaCkge1xuICAgICAgICAgIHJldHVybiBoLmNvbnRyb2xsZXIub3B0aW9ucy5ncm91cGVkO1xuICAgICAgICB9KSxcbiAgICAgICAgbyA9IHMub3B0aW9ucy5zdGFja2VkLFxuICAgICAgICByID0gW10sXG4gICAgICAgIGEgPSB0aGlzLl9jYWNoZWRNZXRhLmNvbnRyb2xsZXIuZ2V0UGFyc2VkKGUpLFxuICAgICAgICBsID0gYSAmJiBhW3MuYXhpc10sXG4gICAgICAgIGMgPSBmdW5jdGlvbiBjKGgpIHtcbiAgICAgICAgICB2YXIgZCA9IGguX3BhcnNlZC5maW5kKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmW3MuYXhpc10gPT09IGw7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHUgPSBkICYmIGRbaC52U2NhbGUuYXhpc107XG4gICAgICAgICAgaWYgKFIodSkgfHwgaXNOYU4odSkpIHJldHVybiAhMDtcbiAgICAgICAgfTtcbiAgICAgIHZhciBfaXRlcmF0b3IxMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG4pLFxuICAgICAgICBfc3RlcDEzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IxMy5zKCk7ICEoX3N0ZXAxMyA9IF9pdGVyYXRvcjEzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgaCA9IF9zdGVwMTMudmFsdWU7XG4gICAgICAgICAgaWYgKCEoZSAhPT0gdm9pZCAwICYmIGMoaCkpICYmICgobyA9PT0gITEgfHwgci5pbmRleE9mKGguc3RhY2spID09PSAtMSB8fCBvID09PSB2b2lkIDAgJiYgaC5zdGFjayA9PT0gdm9pZCAwKSAmJiByLnB1c2goaC5zdGFjayksIGguaW5kZXggPT09IHQpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjEzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjEzLmYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByLmxlbmd0aCB8fCByLnB1c2godm9pZCAwKSwgcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFN0YWNrQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0YWNrQ291bnQodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFN0YWNrcyh2b2lkIDAsIHQpLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEF4aXNDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QXhpc0NvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldEF4aXMoKS5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZpcnN0U2NhbGVJZEZvckluZGV4QXhpc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaXJzdFNjYWxlSWRGb3JJbmRleEF4aXMoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuY2hhcnQuc2NhbGVzLFxuICAgICAgICBlID0gdGhpcy5jaGFydC5vcHRpb25zLmluZGV4QXhpcztcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0KS5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRbc10uYXhpcyA9PT0gZTtcbiAgICAgIH0pLnNoaWZ0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRBeGlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBeGlzKCkge1xuICAgICAgdmFyIHQgPSB7fSxcbiAgICAgICAgZSA9IHRoaXMuZ2V0Rmlyc3RTY2FsZUlkRm9ySW5kZXhBeGlzKCk7XG4gICAgICB2YXIgX2l0ZXJhdG9yMTQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMpLFxuICAgICAgICBfc3RlcDE0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IxNC5zKCk7ICEoX3N0ZXAxNCA9IF9pdGVyYXRvcjE0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcyA9IF9zdGVwMTQudmFsdWU7XG4gICAgICAgICAgdFtEKHRoaXMuY2hhcnQub3B0aW9ucy5pbmRleEF4aXMgPT09IFwieFwiID8gcy54QXhpc0lEIDogcy55QXhpc0lELCBlKV0gPSAhMDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjE0LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjE0LmYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFN0YWNrSW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0YWNrSW5kZXgodCwgZSwgcykge1xuICAgICAgdmFyIG4gPSB0aGlzLl9nZXRTdGFja3ModCwgcyksXG4gICAgICAgIG8gPSBlICE9PSB2b2lkIDAgPyBuLmluZGV4T2YoZSkgOiAtMTtcbiAgICAgIHJldHVybiBvID09PSAtMSA/IG4ubGVuZ3RoIC0gMSA6IG87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRSdWxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0UnVsZXIoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZSA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIHMgPSBlLmlTY2FsZSxcbiAgICAgICAgbiA9IFtdO1xuICAgICAgdmFyIG8sIHI7XG4gICAgICBmb3IgKG8gPSAwLCByID0gZS5kYXRhLmxlbmd0aDsgbyA8IHI7ICsrbykgbi5wdXNoKHMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChvKVtzLmF4aXNdLCBvKSk7XG4gICAgICB2YXIgYSA9IHQuYmFyVGhpY2tuZXNzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiBhIHx8IHBhKGUpLFxuICAgICAgICBwaXhlbHM6IG4sXG4gICAgICAgIHN0YXJ0OiBzLl9zdGFydFBpeGVsLFxuICAgICAgICBlbmQ6IHMuX2VuZFBpeGVsLFxuICAgICAgICBzdGFja0NvdW50OiB0aGlzLl9nZXRTdGFja0NvdW50KCksXG4gICAgICAgIHNjYWxlOiBzLFxuICAgICAgICBncm91cGVkOiB0Lmdyb3VwZWQsXG4gICAgICAgIHJhdGlvOiBhID8gMSA6IHQuY2F0ZWdvcnlQZXJjZW50YWdlICogdC5iYXJQZXJjZW50YWdlXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKHQpIHtcbiAgICAgIHZhciBfdGhpcyRfY2FjaGVkTWV0YSA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIGUgPSBfdGhpcyRfY2FjaGVkTWV0YS52U2NhbGUsXG4gICAgICAgIHMgPSBfdGhpcyRfY2FjaGVkTWV0YS5fc3RhY2tlZCxcbiAgICAgICAgbiA9IF90aGlzJF9jYWNoZWRNZXRhLmluZGV4LFxuICAgICAgICBfdGhpcyRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBvID0gX3RoaXMkb3B0aW9ucy5iYXNlLFxuICAgICAgICByID0gX3RoaXMkb3B0aW9ucy5taW5CYXJMZW5ndGgsXG4gICAgICAgIGEgPSBvIHx8IDAsXG4gICAgICAgIGwgPSB0aGlzLmdldFBhcnNlZCh0KSxcbiAgICAgICAgYyA9IGwuX2N1c3RvbSxcbiAgICAgICAgaCA9IGNpKGMpO1xuICAgICAgdmFyIGQgPSBsW2UuYXhpc10sXG4gICAgICAgIHUgPSAwLFxuICAgICAgICBmID0gcyA/IHRoaXMuYXBwbHlTdGFjayhlLCBsLCBzKSA6IGQsXG4gICAgICAgIHAsXG4gICAgICAgIGc7XG4gICAgICBmICE9PSBkICYmICh1ID0gZiAtIGQsIGYgPSBkKSwgaCAmJiAoZCA9IGMuYmFyU3RhcnQsIGYgPSBjLmJhckVuZCAtIGMuYmFyU3RhcnQsIGQgIT09IDAgJiYgbHQoZCkgIT09IGx0KGMuYmFyRW5kKSAmJiAodSA9IDApLCB1ICs9IGQpO1xuICAgICAgdmFyIG0gPSAhUihvKSAmJiAhaCA/IG8gOiB1O1xuICAgICAgdmFyIGIgPSBlLmdldFBpeGVsRm9yVmFsdWUobSk7XG4gICAgICBpZiAodGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eSh0KSA/IHAgPSBlLmdldFBpeGVsRm9yVmFsdWUodSArIGYpIDogcCA9IGIsIGcgPSBwIC0gYiwgTWF0aC5hYnMoZykgPCByKSB7XG4gICAgICAgIGcgPSB4YShnLCBlLCBhKSAqIHIsIGQgPT09IGEgJiYgKGIgLT0gZyAvIDIpO1xuICAgICAgICB2YXIgXyA9IGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDApLFxuICAgICAgICAgIHYgPSBlLmdldFBpeGVsRm9yRGVjaW1hbCgxKSxcbiAgICAgICAgICB5ID0gTWF0aC5taW4oXywgdiksXG4gICAgICAgICAgeCA9IE1hdGgubWF4KF8sIHYpO1xuICAgICAgICBiID0gTWF0aC5tYXgoTWF0aC5taW4oYiwgeCksIHkpLCBwID0gYiArIGcsIHMgJiYgIWggJiYgKGwuX3N0YWNrc1tlLmF4aXNdLl92aXN1YWxWYWx1ZXNbbl0gPSBlLmdldFZhbHVlRm9yUGl4ZWwocCkgLSBlLmdldFZhbHVlRm9yUGl4ZWwoYikpO1xuICAgICAgfVxuICAgICAgaWYgKGIgPT09IGUuZ2V0UGl4ZWxGb3JWYWx1ZShhKSkge1xuICAgICAgICB2YXIgXzIgPSBsdChnKSAqIGUuZ2V0TGluZVdpZHRoRm9yVmFsdWUoYSkgLyAyO1xuICAgICAgICBiICs9IF8yLCBnIC09IF8yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2l6ZTogZyxcbiAgICAgICAgYmFzZTogYixcbiAgICAgICAgaGVhZDogcCxcbiAgICAgICAgY2VudGVyOiBwICsgZyAvIDJcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jYWxjdWxhdGVCYXJJbmRleFBpeGVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHModCwgZSkge1xuICAgICAgdmFyIHMgPSBlLnNjYWxlLFxuICAgICAgICBuID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBvID0gbi5za2lwTnVsbCxcbiAgICAgICAgciA9IEQobi5tYXhCYXJUaGlja25lc3MsIDEgLyAwKTtcbiAgICAgIHZhciBhLCBsO1xuICAgICAgdmFyIGMgPSB0aGlzLl9nZXRBeGlzQ291bnQoKTtcbiAgICAgIGlmIChlLmdyb3VwZWQpIHtcbiAgICAgICAgdmFyIGggPSBvID8gdGhpcy5fZ2V0U3RhY2tDb3VudCh0KSA6IGUuc3RhY2tDb3VudCxcbiAgICAgICAgICBkID0gbi5iYXJUaGlja25lc3MgPT09IFwiZmxleFwiID8gYmEodCwgZSwgbiwgaCAqIGMpIDogbWEodCwgZSwgbiwgaCAqIGMpLFxuICAgICAgICAgIHUgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMuaW5kZXhBeGlzID09PSBcInhcIiA/IHRoaXMuZ2V0RGF0YXNldCgpLnhBeGlzSUQgOiB0aGlzLmdldERhdGFzZXQoKS55QXhpc0lELFxuICAgICAgICAgIGYgPSB0aGlzLl9nZXRBeGlzKCkuaW5kZXhPZihEKHUsIHRoaXMuZ2V0Rmlyc3RTY2FsZUlkRm9ySW5kZXhBeGlzKCkpKSxcbiAgICAgICAgICBwID0gdGhpcy5fZ2V0U3RhY2tJbmRleCh0aGlzLmluZGV4LCB0aGlzLl9jYWNoZWRNZXRhLnN0YWNrLCBvID8gdCA6IHZvaWQgMCkgKyBmO1xuICAgICAgICBhID0gZC5zdGFydCArIGQuY2h1bmsgKiBwICsgZC5jaHVuayAvIDIsIGwgPSBNYXRoLm1pbihyLCBkLmNodW5rICogZC5yYXRpbyk7XG4gICAgICB9IGVsc2UgYSA9IHMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZCh0KVtzLmF4aXNdLCB0KSwgbCA9IE1hdGgubWluKHIsIGUubWluICogZS5yYXRpbyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlOiBhIC0gbCAvIDIsXG4gICAgICAgIGhlYWQ6IGEgKyBsIC8gMixcbiAgICAgICAgY2VudGVyOiBhLFxuICAgICAgICBzaXplOiBsXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIGUgPSB0LnZTY2FsZSxcbiAgICAgICAgcyA9IHQuZGF0YSxcbiAgICAgICAgbiA9IHMubGVuZ3RoO1xuICAgICAgdmFyIG8gPSAwO1xuICAgICAgZm9yICg7IG8gPCBuOyArK28pIHRoaXMuZ2V0UGFyc2VkKG8pW2UuYXhpc10gIT09IG51bGwgJiYgIXNbb10uaGlkZGVuICYmIHNbb10uZHJhdyh0aGlzLl9jdHgpO1xuICAgIH1cbiAgfV0pO1xufShrdCk7XG53KEVlLCBcImlkXCIsIFwiYmFyXCIpLCB3KEVlLCBcImRlZmF1bHRzXCIsIHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiAhMSxcbiAgZGF0YUVsZW1lbnRUeXBlOiBcImJhclwiLFxuICBjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcbiAgYmFyUGVyY2VudGFnZTogMC45LFxuICBncm91cGVkOiAhMCxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBwcm9wZXJ0aWVzOiBbXCJ4XCIsIFwieVwiLCBcImJhc2VcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXVxuICAgIH1cbiAgfVxufSksIHcoRWUsIFwib3ZlcnJpZGVzXCIsIHtcbiAgc2NhbGVzOiB7XG4gICAgX2luZGV4Xzoge1xuICAgICAgdHlwZTogXCJjYXRlZ29yeVwiLFxuICAgICAgb2Zmc2V0OiAhMCxcbiAgICAgIGdyaWQ6IHtcbiAgICAgICAgb2Zmc2V0OiAhMFxuICAgICAgfVxuICAgIH0sXG4gICAgX3ZhbHVlXzoge1xuICAgICAgdHlwZTogXCJsaW5lYXJcIixcbiAgICAgIGJlZ2luQXRaZXJvOiAhMFxuICAgIH1cbiAgfVxufSk7XG5mdW5jdGlvbiBrYShpLCB0LCBlKSB7XG4gIHZhciBzID0gMSxcbiAgICBuID0gMSxcbiAgICBvID0gMCxcbiAgICByID0gMDtcbiAgaWYgKHQgPCBCKSB7XG4gICAgdmFyIGEgPSBpLFxuICAgICAgbCA9IGEgKyB0LFxuICAgICAgYyA9IE1hdGguY29zKGEpLFxuICAgICAgaCA9IE1hdGguc2luKGEpLFxuICAgICAgZCA9IE1hdGguY29zKGwpLFxuICAgICAgdSA9IE1hdGguc2luKGwpLFxuICAgICAgZiA9IGZ1bmN0aW9uIGYodiwgeSwgeCkge1xuICAgICAgICByZXR1cm4gcGUodiwgYSwgbCwgITApID8gMSA6IE1hdGgubWF4KHksIHkgKiBlLCB4LCB4ICogZSk7XG4gICAgICB9LFxuICAgICAgcCA9IGZ1bmN0aW9uIHAodiwgeSwgeCkge1xuICAgICAgICByZXR1cm4gcGUodiwgYSwgbCwgITApID8gLTEgOiBNYXRoLm1pbih5LCB5ICogZSwgeCwgeCAqIGUpO1xuICAgICAgfSxcbiAgICAgIGcgPSBmKDAsIGMsIGQpLFxuICAgICAgbSA9IGYoViwgaCwgdSksXG4gICAgICBiID0gcChFLCBjLCBkKSxcbiAgICAgIF8gPSBwKEUgKyBWLCBoLCB1KTtcbiAgICBzID0gKGcgLSBiKSAvIDIsIG4gPSAobSAtIF8pIC8gMiwgbyA9IC0oZyArIGIpIC8gMiwgciA9IC0obSArIF8pIC8gMjtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJhdGlvWDogcyxcbiAgICByYXRpb1k6IG4sXG4gICAgb2Zmc2V0WDogbyxcbiAgICBvZmZzZXRZOiByXG4gIH07XG59XG52YXIganQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9rdDIpIHtcbiAgZnVuY3Rpb24ganQodCwgZSkge1xuICAgIHZhciBfdGhpczY7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIGp0KTtcbiAgICBfdGhpczYgPSBfY2FsbFN1cGVyKHRoaXMsIGp0LCBbdCwgZV0pLCBfdGhpczYuZW5hYmxlT3B0aW9uU2hhcmluZyA9ICEwLCBfdGhpczYuaW5uZXJSYWRpdXMgPSB2b2lkIDAsIF90aGlzNi5vdXRlclJhZGl1cyA9IHZvaWQgMCwgX3RoaXM2Lm9mZnNldFggPSB2b2lkIDAsIF90aGlzNi5vZmZzZXRZID0gdm9pZCAwO1xuICAgIHJldHVybiBfdGhpczY7XG4gIH1cbiAgX2luaGVyaXRzKGp0LCBfa3QyKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhqdCwgW3tcbiAgICBrZXk6IFwibGlua1NjYWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5rU2NhbGVzKCkge31cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZSh0LCBlKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEsXG4gICAgICAgIG4gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09ICExKSBuLl9wYXJzZWQgPSBzO2Vsc2Uge1xuICAgICAgICB2YXIgbyA9IGZ1bmN0aW9uIG8obCkge1xuICAgICAgICAgIHJldHVybiArc1tsXTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFQoc1t0XSkpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkX3BhcnNpbmcka2V5ID0gdGhpcy5fcGFyc2luZy5rZXksXG4gICAgICAgICAgICBsID0gX3RoaXMkX3BhcnNpbmcka2V5ID09PSB2b2lkIDAgPyBcInZhbHVlXCIgOiBfdGhpcyRfcGFyc2luZyRrZXk7XG4gICAgICAgICAgbyA9IGZ1bmN0aW9uIG8oYykge1xuICAgICAgICAgICAgcmV0dXJuICtJdChzW2NdLCBsKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciByLCBhO1xuICAgICAgICBmb3IgKHIgPSB0LCBhID0gdCArIGU7IHIgPCBhOyArK3IpIG4uX3BhcnNlZFtyXSA9IG8ocik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRSb3RhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Um90YXRpb24oKSB7XG4gICAgICByZXR1cm4gYnQodGhpcy5vcHRpb25zLnJvdGF0aW9uIC0gOTApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q2lyY3VtZmVyZW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2lyY3VtZmVyZW5jZSgpIHtcbiAgICAgIHJldHVybiBidCh0aGlzLm9wdGlvbnMuY2lyY3VtZmVyZW5jZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRSb3RhdGlvbkV4dGVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFJvdGF0aW9uRXh0ZW50cygpIHtcbiAgICAgIHZhciB0ID0gQixcbiAgICAgICAgZSA9IC1CO1xuICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyArK3MpIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUocykgJiYgdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShzKS50eXBlID09PSB0aGlzLl90eXBlKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShzKS5jb250cm9sbGVyLFxuICAgICAgICAgIG8gPSBuLl9nZXRSb3RhdGlvbigpLFxuICAgICAgICAgIHIgPSBuLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgICAgIHQgPSBNYXRoLm1pbih0LCBvKSwgZSA9IE1hdGgubWF4KGUsIG8gKyByKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvdGF0aW9uOiB0LFxuICAgICAgICBjaXJjdW1mZXJlbmNlOiBlIC0gdFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuY2hhcnQsXG4gICAgICAgIHMgPSBlLmNoYXJ0QXJlYSxcbiAgICAgICAgbiA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIG8gPSBuLmRhdGEsXG4gICAgICAgIHIgPSB0aGlzLmdldE1heEJvcmRlcldpZHRoKCkgKyB0aGlzLmdldE1heE9mZnNldChvKSArIHRoaXMub3B0aW9ucy5zcGFjaW5nLFxuICAgICAgICBhID0gTWF0aC5tYXgoKE1hdGgubWluKHMud2lkdGgsIHMuaGVpZ2h0KSAtIHIpIC8gMiwgMCksXG4gICAgICAgIGwgPSBNYXRoLm1pbihFbyh0aGlzLm9wdGlvbnMuY3V0b3V0LCBhKSwgMSksXG4gICAgICAgIGMgPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KHRoaXMuaW5kZXgpLFxuICAgICAgICBfdGhpcyRfZ2V0Um90YXRpb25FeHQgPSB0aGlzLl9nZXRSb3RhdGlvbkV4dGVudHMoKSxcbiAgICAgICAgaCA9IF90aGlzJF9nZXRSb3RhdGlvbkV4dC5jaXJjdW1mZXJlbmNlLFxuICAgICAgICBkID0gX3RoaXMkX2dldFJvdGF0aW9uRXh0LnJvdGF0aW9uLFxuICAgICAgICBfa2EgPSBrYShkLCBoLCBsKSxcbiAgICAgICAgdSA9IF9rYS5yYXRpb1gsXG4gICAgICAgIGYgPSBfa2EucmF0aW9ZLFxuICAgICAgICBwID0gX2thLm9mZnNldFgsXG4gICAgICAgIGcgPSBfa2Eub2Zmc2V0WSxcbiAgICAgICAgbSA9IChzLndpZHRoIC0gcikgLyB1LFxuICAgICAgICBiID0gKHMuaGVpZ2h0IC0gcikgLyBmLFxuICAgICAgICBfID0gTWF0aC5tYXgoTWF0aC5taW4obSwgYikgLyAyLCAwKSxcbiAgICAgICAgdiA9IGJuKHRoaXMub3B0aW9ucy5yYWRpdXMsIF8pLFxuICAgICAgICB5ID0gTWF0aC5tYXgodiAqIGwsIDApLFxuICAgICAgICB4ID0gKHYgLSB5KSAvIHRoaXMuX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKTtcbiAgICAgIHRoaXMub2Zmc2V0WCA9IHAgKiB2LCB0aGlzLm9mZnNldFkgPSBnICogdiwgbi50b3RhbCA9IHRoaXMuY2FsY3VsYXRlVG90YWwoKSwgdGhpcy5vdXRlclJhZGl1cyA9IHYgLSB4ICogdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmluZGV4KSwgdGhpcy5pbm5lclJhZGl1cyA9IE1hdGgubWF4KHRoaXMub3V0ZXJSYWRpdXMgLSB4ICogYywgMCksIHRoaXMudXBkYXRlRWxlbWVudHMobywgMCwgby5sZW5ndGgsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2lyY3VtZmVyZW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2lyY3VtZmVyZW5jZSh0LCBlKSB7XG4gICAgICB2YXIgcyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgbiA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIG8gPSB0aGlzLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgICByZXR1cm4gZSAmJiBzLmFuaW1hdGlvbi5hbmltYXRlUm90YXRlIHx8ICF0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KHQpIHx8IG4uX3BhcnNlZFt0XSA9PT0gbnVsbCB8fCBuLmRhdGFbdF0uaGlkZGVuID8gMCA6IHRoaXMuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShuLl9wYXJzZWRbdF0gKiBvIC8gQik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnRzKHQsIGUsIHMsIG4pIHtcbiAgICAgIHZhciBvID0gbiA9PT0gXCJyZXNldFwiLFxuICAgICAgICByID0gdGhpcy5jaGFydCxcbiAgICAgICAgYSA9IHIuY2hhcnRBcmVhLFxuICAgICAgICBjID0gci5vcHRpb25zLmFuaW1hdGlvbixcbiAgICAgICAgaCA9IChhLmxlZnQgKyBhLnJpZ2h0KSAvIDIsXG4gICAgICAgIGQgPSAoYS50b3AgKyBhLmJvdHRvbSkgLyAyLFxuICAgICAgICB1ID0gbyAmJiBjLmFuaW1hdGVTY2FsZSxcbiAgICAgICAgZiA9IHUgPyAwIDogdGhpcy5pbm5lclJhZGl1cyxcbiAgICAgICAgcCA9IHUgPyAwIDogdGhpcy5vdXRlclJhZGl1cyxcbiAgICAgICAgX3RoaXMkX2dldFNoYXJlZE9wdGlvMiA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoZSwgbiksXG4gICAgICAgIGcgPSBfdGhpcyRfZ2V0U2hhcmVkT3B0aW8yLnNoYXJlZE9wdGlvbnMsXG4gICAgICAgIG0gPSBfdGhpcyRfZ2V0U2hhcmVkT3B0aW8yLmluY2x1ZGVPcHRpb25zO1xuICAgICAgdmFyIGIgPSB0aGlzLl9nZXRSb3RhdGlvbigpLFxuICAgICAgICBfO1xuICAgICAgZm9yIChfID0gMDsgXyA8IGU7ICsrXykgYiArPSB0aGlzLl9jaXJjdW1mZXJlbmNlKF8sIG8pO1xuICAgICAgZm9yIChfID0gZTsgXyA8IGUgKyBzOyArK18pIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLl9jaXJjdW1mZXJlbmNlKF8sIG8pLFxuICAgICAgICAgIHkgPSB0W19dLFxuICAgICAgICAgIHggPSB7XG4gICAgICAgICAgICB4OiBoICsgdGhpcy5vZmZzZXRYLFxuICAgICAgICAgICAgeTogZCArIHRoaXMub2Zmc2V0WSxcbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IGIsXG4gICAgICAgICAgICBlbmRBbmdsZTogYiArIHYsXG4gICAgICAgICAgICBjaXJjdW1mZXJlbmNlOiB2LFxuICAgICAgICAgICAgb3V0ZXJSYWRpdXM6IHAsXG4gICAgICAgICAgICBpbm5lclJhZGl1czogZlxuICAgICAgICAgIH07XG4gICAgICAgIG0gJiYgKHgub3B0aW9ucyA9IGcgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKF8sIHkuYWN0aXZlID8gXCJhY3RpdmVcIiA6IG4pKSwgYiArPSB2LCB0aGlzLnVwZGF0ZUVsZW1lbnQoeSwgXywgeCwgbik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGN1bGF0ZVRvdGFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVRvdGFsKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9jYWNoZWRNZXRhLFxuICAgICAgICBlID0gdC5kYXRhO1xuICAgICAgdmFyIHMgPSAwLFxuICAgICAgICBuO1xuICAgICAgZm9yIChuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgdmFyIG8gPSB0Ll9wYXJzZWRbbl07XG4gICAgICAgIG8gIT09IG51bGwgJiYgIWlzTmFOKG8pICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkobikgJiYgIWVbbl0uaGlkZGVuICYmIChzICs9IE1hdGguYWJzKG8pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVDaXJjdW1mZXJlbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9jYWNoZWRNZXRhLnRvdGFsO1xuICAgICAgcmV0dXJuIGUgPiAwICYmICFpc05hTih0KSA/IEIgKiAoTWF0aC5hYnModCkgLyBlKSA6IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsQW5kVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxBbmRWYWx1ZSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIHMgPSB0aGlzLmNoYXJ0LFxuICAgICAgICBuID0gcy5kYXRhLmxhYmVscyB8fCBbXSxcbiAgICAgICAgbyA9IEhpKGUuX3BhcnNlZFt0XSwgcy5vcHRpb25zLmxvY2FsZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYWJlbDogblt0XSB8fCBcIlwiLFxuICAgICAgICB2YWx1ZTogb1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWF4Qm9yZGVyV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWF4Qm9yZGVyV2lkdGgodCkge1xuICAgICAgdmFyIGUgPSAwO1xuICAgICAgdmFyIHMgPSB0aGlzLmNoYXJ0O1xuICAgICAgdmFyIG4sIG8sIHIsIGEsIGw7XG4gICAgICBpZiAoIXQpIHtcbiAgICAgICAgZm9yIChuID0gMCwgbyA9IHMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IG4gPCBvOyArK24pIGlmIChzLmlzRGF0YXNldFZpc2libGUobikpIHtcbiAgICAgICAgICByID0gcy5nZXREYXRhc2V0TWV0YShuKSwgdCA9IHIuZGF0YSwgYSA9IHIuY29udHJvbGxlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0KSByZXR1cm4gMDtcbiAgICAgIGZvciAobiA9IDAsIG8gPSB0Lmxlbmd0aDsgbiA8IG87ICsrbikgbCA9IGEucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhuKSwgbC5ib3JkZXJBbGlnbiAhPT0gXCJpbm5lclwiICYmIChlID0gTWF0aC5tYXgoZSwgbC5ib3JkZXJXaWR0aCB8fCAwLCBsLmhvdmVyQm9yZGVyV2lkdGggfHwgMCkpO1xuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1heE9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhPZmZzZXQodCkge1xuICAgICAgdmFyIGUgPSAwO1xuICAgICAgZm9yICh2YXIgcyA9IDAsIG4gPSB0Lmxlbmd0aDsgcyA8IG47ICsrcykge1xuICAgICAgICB2YXIgbyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzKTtcbiAgICAgICAgZSA9IE1hdGgubWF4KGUsIG8ub2Zmc2V0IHx8IDAsIG8uaG92ZXJPZmZzZXQgfHwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFJpbmdXZWlnaHRPZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFJpbmdXZWlnaHRPZmZzZXQodCkge1xuICAgICAgdmFyIGUgPSAwO1xuICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCB0OyArK3MpIHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShzKSAmJiAoZSArPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KHMpKTtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0UmluZ1dlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0UmluZ1dlaWdodCh0KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoRCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbdF0ud2VpZ2h0LCAxKSwgMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aCkgfHwgMTtcbiAgICB9XG4gIH1dKTtcbn0oa3QpO1xudyhqdCwgXCJpZFwiLCBcImRvdWdobnV0XCIpLCB3KGp0LCBcImRlZmF1bHRzXCIsIHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiAhMSxcbiAgZGF0YUVsZW1lbnRUeXBlOiBcImFyY1wiLFxuICBhbmltYXRpb246IHtcbiAgICBhbmltYXRlUm90YXRlOiAhMCxcbiAgICBhbmltYXRlU2NhbGU6ICExXG4gIH0sXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgcHJvcGVydGllczogW1wiY2lyY3VtZmVyZW5jZVwiLCBcImVuZEFuZ2xlXCIsIFwiaW5uZXJSYWRpdXNcIiwgXCJvdXRlclJhZGl1c1wiLCBcInN0YXJ0QW5nbGVcIiwgXCJ4XCIsIFwieVwiLCBcIm9mZnNldFwiLCBcImJvcmRlcldpZHRoXCIsIFwic3BhY2luZ1wiXVxuICAgIH1cbiAgfSxcbiAgY3V0b3V0OiBcIjUwJVwiLFxuICByb3RhdGlvbjogMCxcbiAgY2lyY3VtZmVyZW5jZTogMzYwLFxuICByYWRpdXM6IFwiMTAwJVwiLFxuICBzcGFjaW5nOiAwLFxuICBpbmRleEF4aXM6IFwiclwiXG59KSwgdyhqdCwgXCJkZXNjcmlwdG9yc1wiLCB7XG4gIF9zY3JpcHRhYmxlOiBmdW5jdGlvbiBfc2NyaXB0YWJsZSh0KSB7XG4gICAgcmV0dXJuIHQgIT09IFwic3BhY2luZ1wiO1xuICB9LFxuICBfaW5kZXhhYmxlOiBmdW5jdGlvbiBfaW5kZXhhYmxlKHQpIHtcbiAgICByZXR1cm4gdCAhPT0gXCJzcGFjaW5nXCIgJiYgIXQuc3RhcnRzV2l0aChcImJvcmRlckRhc2hcIikgJiYgIXQuc3RhcnRzV2l0aChcImhvdmVyQm9yZGVyRGFzaFwiKTtcbiAgfVxufSksIHcoanQsIFwib3ZlcnJpZGVzXCIsIHtcbiAgYXNwZWN0UmF0aW86IDEsXG4gIHBsdWdpbnM6IHtcbiAgICBsZWdlbmQ6IHtcbiAgICAgIGxhYmVsczoge1xuICAgICAgICBnZW5lcmF0ZUxhYmVsczogZnVuY3Rpb24gZ2VuZXJhdGVMYWJlbHModCkge1xuICAgICAgICAgIHZhciBlID0gdC5kYXRhLFxuICAgICAgICAgICAgX3QkbGVnZW5kJG9wdGlvbnMkbGFiID0gdC5sZWdlbmQub3B0aW9ucy5sYWJlbHMsXG4gICAgICAgICAgICBzID0gX3QkbGVnZW5kJG9wdGlvbnMkbGFiLnBvaW50U3R5bGUsXG4gICAgICAgICAgICBuID0gX3QkbGVnZW5kJG9wdGlvbnMkbGFiLnRleHRBbGlnbixcbiAgICAgICAgICAgIG8gPSBfdCRsZWdlbmQkb3B0aW9ucyRsYWIuY29sb3IsXG4gICAgICAgICAgICByID0gX3QkbGVnZW5kJG9wdGlvbnMkbGFiLnVzZUJvcmRlclJhZGl1cyxcbiAgICAgICAgICAgIGEgPSBfdCRsZWdlbmQkb3B0aW9ucyRsYWIuYm9yZGVyUmFkaXVzO1xuICAgICAgICAgIHJldHVybiBlLmxhYmVscy5sZW5ndGggJiYgZS5kYXRhc2V0cy5sZW5ndGggPyBlLmxhYmVscy5tYXAoZnVuY3Rpb24gKGwsIGMpIHtcbiAgICAgICAgICAgIHZhciBkID0gdC5nZXREYXRhc2V0TWV0YSgwKS5jb250cm9sbGVyLmdldFN0eWxlKGMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdGV4dDogbCxcbiAgICAgICAgICAgICAgZmlsbFN0eWxlOiBkLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgZm9udENvbG9yOiBvLFxuICAgICAgICAgICAgICBoaWRkZW46ICF0LmdldERhdGFWaXNpYmlsaXR5KGMpLFxuICAgICAgICAgICAgICBsaW5lRGFzaDogZC5ib3JkZXJEYXNoLFxuICAgICAgICAgICAgICBsaW5lRGFzaE9mZnNldDogZC5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgICBsaW5lSm9pbjogZC5ib3JkZXJKb2luU3R5bGUsXG4gICAgICAgICAgICAgIGxpbmVXaWR0aDogZC5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IGQuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgIHRleHRBbGlnbjogbixcbiAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcyxcbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiByICYmIChhIHx8IGQuYm9yZGVyUmFkaXVzKSxcbiAgICAgICAgICAgICAgaW5kZXg6IGNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkgOiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2sodCwgZSwgcykge1xuICAgICAgICBzLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGUuaW5kZXgpLCBzLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG52YXIgRmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9rdDMpIHtcbiAgZnVuY3Rpb24gRmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZlKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBGZSwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoRmUsIF9rdDMpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEZlLCBbe1xuICAgIGtleTogXCJpbml0aWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSAhMCwgdGhpcy5zdXBwb3J0c0RlY2ltYXRpb24gPSAhMCwgX3N1cGVyUHJvcEdldChGZSwgXCJpbml0aWFsaXplXCIsIHRoaXMsIDMpKFtdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIHMgPSBlLmRhdGFzZXQsXG4gICAgICAgIF9lJGRhdGEgPSBlLmRhdGEsXG4gICAgICAgIG4gPSBfZSRkYXRhID09PSB2b2lkIDAgPyBbXSA6IF9lJGRhdGEsXG4gICAgICAgIG8gPSBlLl9kYXRhc2V0LFxuICAgICAgICByID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgICAgdmFyIF93biA9IHduKGUsIG4sIHIpLFxuICAgICAgICBhID0gX3duLnN0YXJ0LFxuICAgICAgICBsID0gX3duLmNvdW50O1xuICAgICAgdGhpcy5fZHJhd1N0YXJ0ID0gYSwgdGhpcy5fZHJhd0NvdW50ID0gbCwgUG4oZSkgJiYgKGEgPSAwLCBsID0gbi5sZW5ndGgpLCBzLl9jaGFydCA9IHRoaXMuY2hhcnQsIHMuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXgsIHMuX2RlY2ltYXRlZCA9ICEhby5fZGVjaW1hdGVkLCBzLnBvaW50cyA9IG47XG4gICAgICB2YXIgYyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyh0KTtcbiAgICAgIHRoaXMub3B0aW9ucy5zaG93TGluZSB8fCAoYy5ib3JkZXJXaWR0aCA9IDApLCBjLnNlZ21lbnQgPSB0aGlzLm9wdGlvbnMuc2VnbWVudCwgdGhpcy51cGRhdGVFbGVtZW50KHMsIHZvaWQgMCwge1xuICAgICAgICBhbmltYXRlZDogIXIsXG4gICAgICAgIG9wdGlvbnM6IGNcbiAgICAgIH0sIHQpLCB0aGlzLnVwZGF0ZUVsZW1lbnRzKG4sIGEsIGwsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVFbGVtZW50cyh0LCBlLCBzLCBuKSB7XG4gICAgICB2YXIgbyA9IG4gPT09IFwicmVzZXRcIixcbiAgICAgICAgX3RoaXMkX2NhY2hlZE1ldGEyID0gdGhpcy5fY2FjaGVkTWV0YSxcbiAgICAgICAgciA9IF90aGlzJF9jYWNoZWRNZXRhMi5pU2NhbGUsXG4gICAgICAgIGEgPSBfdGhpcyRfY2FjaGVkTWV0YTIudlNjYWxlLFxuICAgICAgICBsID0gX3RoaXMkX2NhY2hlZE1ldGEyLl9zdGFja2VkLFxuICAgICAgICBjID0gX3RoaXMkX2NhY2hlZE1ldGEyLl9kYXRhc2V0LFxuICAgICAgICBfdGhpcyRfZ2V0U2hhcmVkT3B0aW8zID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhlLCBuKSxcbiAgICAgICAgaCA9IF90aGlzJF9nZXRTaGFyZWRPcHRpbzMuc2hhcmVkT3B0aW9ucyxcbiAgICAgICAgZCA9IF90aGlzJF9nZXRTaGFyZWRPcHRpbzMuaW5jbHVkZU9wdGlvbnMsXG4gICAgICAgIHUgPSByLmF4aXMsXG4gICAgICAgIGYgPSBhLmF4aXMsXG4gICAgICAgIF90aGlzJG9wdGlvbnMyID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBwID0gX3RoaXMkb3B0aW9uczIuc3BhbkdhcHMsXG4gICAgICAgIGcgPSBfdGhpcyRvcHRpb25zMi5zZWdtZW50LFxuICAgICAgICBtID0gWHQocCkgPyBwIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICBiID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IG8gfHwgbiA9PT0gXCJub25lXCIsXG4gICAgICAgIF8gPSBlICsgcyxcbiAgICAgICAgdiA9IHQubGVuZ3RoO1xuICAgICAgdmFyIHkgPSBlID4gMCAmJiB0aGlzLmdldFBhcnNlZChlIC0gMSk7XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHY7ICsreCkge1xuICAgICAgICB2YXIgTSA9IHRbeF0sXG4gICAgICAgICAgUyA9IGIgPyBNIDoge307XG4gICAgICAgIGlmICh4IDwgZSB8fCB4ID49IF8pIHtcbiAgICAgICAgICBTLnNraXAgPSAhMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgayA9IHRoaXMuZ2V0UGFyc2VkKHgpLFxuICAgICAgICAgIFAgPSBSKGtbZl0pLFxuICAgICAgICAgIEMgPSBTW3VdID0gci5nZXRQaXhlbEZvclZhbHVlKGtbdV0sIHgpLFxuICAgICAgICAgIE8gPSBTW2ZdID0gbyB8fCBQID8gYS5nZXRCYXNlUGl4ZWwoKSA6IGEuZ2V0UGl4ZWxGb3JWYWx1ZShsID8gdGhpcy5hcHBseVN0YWNrKGEsIGssIGwpIDoga1tmXSwgeCk7XG4gICAgICAgIFMuc2tpcCA9IGlzTmFOKEMpIHx8IGlzTmFOKE8pIHx8IFAsIFMuc3RvcCA9IHggPiAwICYmIE1hdGguYWJzKGtbdV0gLSB5W3VdKSA+IG0sIGcgJiYgKFMucGFyc2VkID0gaywgUy5yYXcgPSBjLmRhdGFbeF0pLCBkICYmIChTLm9wdGlvbnMgPSBoIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyh4LCBNLmFjdGl2ZSA/IFwiYWN0aXZlXCIgOiBuKSksIGIgfHwgdGhpcy51cGRhdGVFbGVtZW50KE0sIHgsIFMsIG4pLCB5ID0gaztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWF4T3ZlcmZsb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIGUgPSB0LmRhdGFzZXQsXG4gICAgICAgIHMgPSBlLm9wdGlvbnMgJiYgZS5vcHRpb25zLmJvcmRlcldpZHRoIHx8IDAsXG4gICAgICAgIG4gPSB0LmRhdGEgfHwgW107XG4gICAgICBpZiAoIW4ubGVuZ3RoKSByZXR1cm4gcztcbiAgICAgIHZhciBvID0gblswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSksXG4gICAgICAgIHIgPSBuW24ubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMobi5sZW5ndGggLSAxKSk7XG4gICAgICByZXR1cm4gTWF0aC5tYXgocywgbywgcikgLyAyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICB0LmRhdGFzZXQudXBkYXRlQ29udHJvbFBvaW50cyh0aGlzLmNoYXJ0LmNoYXJ0QXJlYSwgdC5pU2NhbGUuYXhpcyksIF9zdXBlclByb3BHZXQoRmUsIFwiZHJhd1wiLCB0aGlzLCAzKShbXSk7XG4gICAgfVxuICB9XSk7XG59KGt0KTtcbncoRmUsIFwiaWRcIiwgXCJsaW5lXCIpLCB3KEZlLCBcImRlZmF1bHRzXCIsIHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBcImxpbmVcIixcbiAgZGF0YUVsZW1lbnRUeXBlOiBcInBvaW50XCIsXG4gIHNob3dMaW5lOiAhMCxcbiAgc3BhbkdhcHM6ICExXG59KSwgdyhGZSwgXCJvdmVycmlkZXNcIiwge1xuICBzY2FsZXM6IHtcbiAgICBfaW5kZXhfOiB7XG4gICAgICB0eXBlOiBcImNhdGVnb3J5XCJcbiAgICB9LFxuICAgIF92YWx1ZV86IHtcbiAgICAgIHR5cGU6IFwibGluZWFyXCJcbiAgICB9XG4gIH1cbn0pO1xudmFyIGtpID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfanQpIHtcbiAgZnVuY3Rpb24ga2koKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIGtpKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBraSwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoa2ksIF9qdCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3Moa2kpO1xufShqdCk7XG53KGtpLCBcImlkXCIsIFwicGllXCIpLCB3KGtpLCBcImRlZmF1bHRzXCIsIHtcbiAgY3V0b3V0OiAwLFxuICByb3RhdGlvbjogMCxcbiAgY2lyY3VtZmVyZW5jZTogMzYwLFxuICByYWRpdXM6IFwiMTAwJVwiXG59KTtcbnZhciBJZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2t0NCkge1xuICBmdW5jdGlvbiBJZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSWUpO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEllLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhJZSwgX2t0NCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoSWUsIFt7XG4gICAga2V5OiBcImdldExhYmVsQW5kVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxBbmRWYWx1ZSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIHMgPSB0aGlzLmNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdLFxuICAgICAgICBuID0gZS54U2NhbGUsXG4gICAgICAgIG8gPSBlLnlTY2FsZSxcbiAgICAgICAgciA9IHRoaXMuZ2V0UGFyc2VkKHQpLFxuICAgICAgICBhID0gbi5nZXRMYWJlbEZvclZhbHVlKHIueCksXG4gICAgICAgIGwgPSBvLmdldExhYmVsRm9yVmFsdWUoci55KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhYmVsOiBzW3RdIHx8IFwiXCIsXG4gICAgICAgIHZhbHVlOiBcIihcIiArIGEgKyBcIiwgXCIgKyBsICsgXCIpXCJcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9jYWNoZWRNZXRhLFxuICAgICAgICBfZSRkYXRhMiA9IGUuZGF0YSxcbiAgICAgICAgcyA9IF9lJGRhdGEyID09PSB2b2lkIDAgPyBbXSA6IF9lJGRhdGEyLFxuICAgICAgICBuID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgICAgdmFyIF93bjIgPSB3bihlLCBzLCBuKSxcbiAgICAgICAgbyA9IF93bjIuc3RhcnQsXG4gICAgICAgIHIgPSBfd24yLmNvdW50O1xuICAgICAgaWYgKHRoaXMuX2RyYXdTdGFydCA9IG8sIHRoaXMuX2RyYXdDb3VudCA9IHIsIFBuKGUpICYmIChvID0gMCwgciA9IHMubGVuZ3RoKSwgdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICAgIHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlIHx8IHRoaXMuYWRkRWxlbWVudHMoKTtcbiAgICAgICAgdmFyIGEgPSBlLmRhdGFzZXQsXG4gICAgICAgICAgbCA9IGUuX2RhdGFzZXQ7XG4gICAgICAgIGEuX2NoYXJ0ID0gdGhpcy5jaGFydCwgYS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleCwgYS5fZGVjaW1hdGVkID0gISFsLl9kZWNpbWF0ZWQsIGEucG9pbnRzID0gcztcbiAgICAgICAgdmFyIGMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnModCk7XG4gICAgICAgIGMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50LCB0aGlzLnVwZGF0ZUVsZW1lbnQoYSwgdm9pZCAwLCB7XG4gICAgICAgICAgYW5pbWF0ZWQ6ICFuLFxuICAgICAgICAgIG9wdGlvbnM6IGNcbiAgICAgICAgfSwgdCk7XG4gICAgICB9IGVsc2UgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgJiYgKGRlbGV0ZSBlLmRhdGFzZXQsIHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlID0gITEpO1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50cyhzLCBvLCByLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWxlbWVudHMoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMub3B0aW9ucy5zaG93TGluZTtcbiAgICAgICF0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSAmJiB0ICYmICh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IHRoaXMuY2hhcnQucmVnaXN0cnkuZ2V0RWxlbWVudChcImxpbmVcIikpLCBfc3VwZXJQcm9wR2V0KEllLCBcImFkZEVsZW1lbnRzXCIsIHRoaXMsIDMpKFtdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRWxlbWVudHModCwgZSwgcywgbikge1xuICAgICAgdmFyIG8gPSBuID09PSBcInJlc2V0XCIsXG4gICAgICAgIF90aGlzJF9jYWNoZWRNZXRhMyA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIHIgPSBfdGhpcyRfY2FjaGVkTWV0YTMuaVNjYWxlLFxuICAgICAgICBhID0gX3RoaXMkX2NhY2hlZE1ldGEzLnZTY2FsZSxcbiAgICAgICAgbCA9IF90aGlzJF9jYWNoZWRNZXRhMy5fc3RhY2tlZCxcbiAgICAgICAgYyA9IF90aGlzJF9jYWNoZWRNZXRhMy5fZGF0YXNldCxcbiAgICAgICAgaCA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhlLCBuKSxcbiAgICAgICAgZCA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhoKSxcbiAgICAgICAgdSA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobiwgZCksXG4gICAgICAgIGYgPSByLmF4aXMsXG4gICAgICAgIHAgPSBhLmF4aXMsXG4gICAgICAgIF90aGlzJG9wdGlvbnMzID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBnID0gX3RoaXMkb3B0aW9uczMuc3BhbkdhcHMsXG4gICAgICAgIG0gPSBfdGhpcyRvcHRpb25zMy5zZWdtZW50LFxuICAgICAgICBiID0gWHQoZykgPyBnIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICBfID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IG8gfHwgbiA9PT0gXCJub25lXCI7XG4gICAgICB2YXIgdiA9IGUgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKGUgLSAxKTtcbiAgICAgIGZvciAodmFyIHkgPSBlOyB5IDwgZSArIHM7ICsreSkge1xuICAgICAgICB2YXIgeCA9IHRbeV0sXG4gICAgICAgICAgTSA9IHRoaXMuZ2V0UGFyc2VkKHkpLFxuICAgICAgICAgIFMgPSBfID8geCA6IHt9LFxuICAgICAgICAgIGsgPSBSKE1bcF0pLFxuICAgICAgICAgIFAgPSBTW2ZdID0gci5nZXRQaXhlbEZvclZhbHVlKE1bZl0sIHkpLFxuICAgICAgICAgIEMgPSBTW3BdID0gbyB8fCBrID8gYS5nZXRCYXNlUGl4ZWwoKSA6IGEuZ2V0UGl4ZWxGb3JWYWx1ZShsID8gdGhpcy5hcHBseVN0YWNrKGEsIE0sIGwpIDogTVtwXSwgeSk7XG4gICAgICAgIFMuc2tpcCA9IGlzTmFOKFApIHx8IGlzTmFOKEMpIHx8IGssIFMuc3RvcCA9IHkgPiAwICYmIE1hdGguYWJzKE1bZl0gLSB2W2ZdKSA+IGIsIG0gJiYgKFMucGFyc2VkID0gTSwgUy5yYXcgPSBjLmRhdGFbeV0pLCB1ICYmIChTLm9wdGlvbnMgPSBkIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyh5LCB4LmFjdGl2ZSA/IFwiYWN0aXZlXCIgOiBuKSksIF8gfHwgdGhpcy51cGRhdGVFbGVtZW50KHgsIHksIFMsIG4pLCB2ID0gTTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhkLCBuLCBoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWF4T3ZlcmZsb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2NhY2hlZE1ldGEsXG4gICAgICAgIGUgPSB0LmRhdGEgfHwgW107XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgICB2YXIgYSA9IDA7XG4gICAgICAgIGZvciAodmFyIGwgPSBlLmxlbmd0aCAtIDE7IGwgPj0gMDsgLS1sKSBhID0gTWF0aC5tYXgoYSwgZVtsXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhsKSkgLyAyKTtcbiAgICAgICAgcmV0dXJuIGEgPiAwICYmIGE7XG4gICAgICB9XG4gICAgICB2YXIgcyA9IHQuZGF0YXNldCxcbiAgICAgICAgbiA9IHMub3B0aW9ucyAmJiBzLm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICAgIGlmICghZS5sZW5ndGgpIHJldHVybiBuO1xuICAgICAgdmFyIG8gPSBlWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKSxcbiAgICAgICAgciA9IGVbZS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhlLmxlbmd0aCAtIDEpKTtcbiAgICAgIHJldHVybiBNYXRoLm1heChuLCBvLCByKSAvIDI7XG4gICAgfVxuICB9XSk7XG59KGt0KTtcbncoSWUsIFwiaWRcIiwgXCJzY2F0dGVyXCIpLCB3KEllLCBcImRlZmF1bHRzXCIsIHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiAhMSxcbiAgZGF0YUVsZW1lbnRUeXBlOiBcInBvaW50XCIsXG4gIHNob3dMaW5lOiAhMSxcbiAgZmlsbDogITFcbn0pLCB3KEllLCBcIm92ZXJyaWRlc1wiLCB7XG4gIGludGVyYWN0aW9uOiB7XG4gICAgbW9kZTogXCJwb2ludFwiXG4gIH0sXG4gIHNjYWxlczoge1xuICAgIHg6IHtcbiAgICAgIHR5cGU6IFwibGluZWFyXCJcbiAgICB9LFxuICAgIHk6IHtcbiAgICAgIHR5cGU6IFwibGluZWFyXCJcbiAgICB9XG4gIH1cbn0pO1xuZnVuY3Rpb24gVHQoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZDogQ2hlY2sgdGhhdCBhIGNvbXBsZXRlIGRhdGUgYWRhcHRlciBpcyBwcm92aWRlZC5cIik7XG59XG52YXIgVWkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBVaSh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFVpKTtcbiAgICB3KHRoaXMsIFwib3B0aW9uc1wiKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB0IHx8IHt9O1xuICB9XG4gIC8qKlxuICAqIE92ZXJyaWRlIGRlZmF1bHQgZGF0ZSBhZGFwdGVyIG1ldGhvZHMuXG4gICogQWNjZXB0cyB0eXBlIHBhcmFtZXRlciB0byBkZWZpbmUgb3B0aW9ucyB0eXBlLlxuICAqIEBleGFtcGxlXG4gICogQ2hhcnQuX2FkYXB0ZXJzLl9kYXRlLm92ZXJyaWRlPHtteUFkYXB0ZXJPcHRpb246IHN0cmluZ30+KHtcbiAgKiAgIGluaXQoKSB7XG4gICogICAgIGNvbnNvbGUubG9nKHRoaXMub3B0aW9ucy5teUFkYXB0ZXJPcHRpb24pO1xuICAqICAgfVxuICAqIH0pXG4gICovXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVWksIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTpcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gICAgZnVuY3Rpb24gaW5pdCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKCkge1xuICAgICAgcmV0dXJuIFR0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKCkge1xuICAgICAgcmV0dXJuIFR0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQoKSB7XG4gICAgICByZXR1cm4gVHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCgpIHtcbiAgICAgIHJldHVybiBUdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaWZmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpZmYoKSB7XG4gICAgICByZXR1cm4gVHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRPZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydE9mKCkge1xuICAgICAgcmV0dXJuIFR0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZE9mXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZE9mKCkge1xuICAgICAgcmV0dXJuIFR0KCk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwib3ZlcnJpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3ZlcnJpZGUodCkge1xuICAgICAgT2JqZWN0LmFzc2lnbihVaS5wcm90b3R5cGUsIHQpO1xuICAgIH1cbiAgfV0pO1xufSgpO1xudmFyIHdhID0ge1xuICBfZGF0ZTogVWlcbn07XG5mdW5jdGlvbiBQYShpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gaS5jb250cm9sbGVyLFxuICAgIG8gPSBpLmRhdGEsXG4gICAgciA9IGkuX3NvcnRlZCxcbiAgICBhID0gbi5fY2FjaGVkTWV0YS5pU2NhbGUsXG4gICAgbCA9IGkuZGF0YXNldCAmJiBpLmRhdGFzZXQub3B0aW9ucyA/IGkuZGF0YXNldC5vcHRpb25zLnNwYW5HYXBzIDogbnVsbDtcbiAgaWYgKGEgJiYgdCA9PT0gYS5heGlzICYmIHQgIT09IFwiclwiICYmIHIgJiYgby5sZW5ndGgpIHtcbiAgICB2YXIgYyA9IGEuX3JldmVyc2VQaXhlbHMgPyBLbyA6IEV0O1xuICAgIGlmIChzKSB7XG4gICAgICBpZiAobi5fc2hhcmVkT3B0aW9ucykge1xuICAgICAgICB2YXIgaCA9IG9bMF0sXG4gICAgICAgICAgZCA9IHR5cGVvZiBoLmdldFJhbmdlID09IFwiZnVuY3Rpb25cIiAmJiBoLmdldFJhbmdlKHQpO1xuICAgICAgICBpZiAoZCkge1xuICAgICAgICAgIHZhciB1ID0gYyhvLCB0LCBlIC0gZCksXG4gICAgICAgICAgICBmID0gYyhvLCB0LCBlICsgZCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvOiB1LmxvLFxuICAgICAgICAgICAgaGk6IGYuaGlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfaCA9IGMobywgdCwgZSk7XG4gICAgICBpZiAobCkge1xuICAgICAgICB2YXIgX2QgPSBuLl9jYWNoZWRNZXRhLnZTY2FsZSxcbiAgICAgICAgICBfdSA9IGkuX3BhcnNlZCxcbiAgICAgICAgICBfZiA9IF91LnNsaWNlKDAsIF9oLmxvICsgMSkucmV2ZXJzZSgpLmZpbmRJbmRleChmdW5jdGlvbiAoZykge1xuICAgICAgICAgICAgcmV0dXJuICFSKGdbX2QuYXhpc10pO1xuICAgICAgICAgIH0pO1xuICAgICAgICBfaC5sbyAtPSBNYXRoLm1heCgwLCBfZik7XG4gICAgICAgIHZhciBwID0gX3Uuc2xpY2UoX2guaGkpLmZpbmRJbmRleChmdW5jdGlvbiAoZykge1xuICAgICAgICAgIHJldHVybiAhUihnW19kLmF4aXNdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF9oLmhpICs9IE1hdGgubWF4KDAsIHApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9oO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGxvOiAwLFxuICAgIGhpOiBvLmxlbmd0aCAtIDFcbiAgfTtcbn1cbmZ1bmN0aW9uIHRpKGksIHQsIGUsIHMsIG4pIHtcbiAgdmFyIG8gPSBpLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKSxcbiAgICByID0gZVt0XTtcbiAgZm9yICh2YXIgYSA9IDAsIGwgPSBvLmxlbmd0aDsgYSA8IGw7ICsrYSkge1xuICAgIHZhciBfbyRhID0gb1thXSxcbiAgICAgIGMgPSBfbyRhLmluZGV4LFxuICAgICAgaCA9IF9vJGEuZGF0YSxcbiAgICAgIF9QYSA9IFBhKG9bYV0sIHQsIHIsIG4pLFxuICAgICAgZCA9IF9QYS5sbyxcbiAgICAgIHUgPSBfUGEuaGk7XG4gICAgZm9yICh2YXIgZiA9IGQ7IGYgPD0gdTsgKytmKSB7XG4gICAgICB2YXIgcCA9IGhbZl07XG4gICAgICBwLnNraXAgfHwgcyhwLCBjLCBmKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIERhKGkpIHtcbiAgdmFyIHQgPSBpLmluZGV4T2YoXCJ4XCIpICE9PSAtMSxcbiAgICBlID0gaS5pbmRleE9mKFwieVwiKSAhPT0gLTE7XG4gIHJldHVybiBmdW5jdGlvbiAocywgbikge1xuICAgIHZhciBvID0gdCA/IE1hdGguYWJzKHMueCAtIG4ueCkgOiAwLFxuICAgICAgciA9IGUgPyBNYXRoLmFicyhzLnkgLSBuLnkpIDogMDtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KG8sIDIpICsgTWF0aC5wb3cociwgMikpO1xuICB9O1xufVxuZnVuY3Rpb24gaGkoaSwgdCwgZSwgcywgbikge1xuICB2YXIgbyA9IFtdO1xuICByZXR1cm4gIW4gJiYgIWkuaXNQb2ludEluQXJlYSh0KSB8fCB0aShpLCBlLCB0LCBmdW5jdGlvbiAoYSwgbCwgYykge1xuICAgICFuICYmICFtZShhLCBpLmNoYXJ0QXJlYSwgMCkgfHwgYS5pblJhbmdlKHQueCwgdC55LCBzKSAmJiBvLnB1c2goe1xuICAgICAgZWxlbWVudDogYSxcbiAgICAgIGRhdGFzZXRJbmRleDogbCxcbiAgICAgIGluZGV4OiBjXG4gICAgfSk7XG4gIH0sICEwKSwgbztcbn1cbmZ1bmN0aW9uIENhKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBbXTtcbiAgZnVuY3Rpb24gbyhyLCBhLCBsKSB7XG4gICAgdmFyIF9yJGdldFByb3BzID0gci5nZXRQcm9wcyhbXCJzdGFydEFuZ2xlXCIsIFwiZW5kQW5nbGVcIl0sIHMpLFxuICAgICAgYyA9IF9yJGdldFByb3BzLnN0YXJ0QW5nbGUsXG4gICAgICBoID0gX3IkZ2V0UHJvcHMuZW5kQW5nbGUsXG4gICAgICBfeW4gPSB5bihyLCB7XG4gICAgICAgIHg6IHQueCxcbiAgICAgICAgeTogdC55XG4gICAgICB9KSxcbiAgICAgIGQgPSBfeW4uYW5nbGU7XG4gICAgcGUoZCwgYywgaCkgJiYgbi5wdXNoKHtcbiAgICAgIGVsZW1lbnQ6IHIsXG4gICAgICBkYXRhc2V0SW5kZXg6IGEsXG4gICAgICBpbmRleDogbFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aShpLCBlLCB0LCBvKSwgbjtcbn1cbmZ1bmN0aW9uIE9hKGksIHQsIGUsIHMsIG4sIG8pIHtcbiAgdmFyIHIgPSBbXTtcbiAgdmFyIGEgPSBEYShlKTtcbiAgdmFyIGwgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGZ1bmN0aW9uIGMoaCwgZCwgdSkge1xuICAgIHZhciBmID0gaC5pblJhbmdlKHQueCwgdC55LCBuKTtcbiAgICBpZiAocyAmJiAhZikgcmV0dXJuO1xuICAgIHZhciBwID0gaC5nZXRDZW50ZXJQb2ludChuKTtcbiAgICBpZiAoISghIW8gfHwgaS5pc1BvaW50SW5BcmVhKHApKSAmJiAhZikgcmV0dXJuO1xuICAgIHZhciBtID0gYSh0LCBwKTtcbiAgICBtIDwgbCA/IChyID0gW3tcbiAgICAgIGVsZW1lbnQ6IGgsXG4gICAgICBkYXRhc2V0SW5kZXg6IGQsXG4gICAgICBpbmRleDogdVxuICAgIH1dLCBsID0gbSkgOiBtID09PSBsICYmIHIucHVzaCh7XG4gICAgICBlbGVtZW50OiBoLFxuICAgICAgZGF0YXNldEluZGV4OiBkLFxuICAgICAgaW5kZXg6IHVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGkoaSwgZSwgdCwgYyksIHI7XG59XG5mdW5jdGlvbiBkaShpLCB0LCBlLCBzLCBuLCBvKSB7XG4gIHJldHVybiAhbyAmJiAhaS5pc1BvaW50SW5BcmVhKHQpID8gW10gOiBlID09PSBcInJcIiAmJiAhcyA/IENhKGksIHQsIGUsIG4pIDogT2EoaSwgdCwgZSwgcywgbiwgbyk7XG59XG5mdW5jdGlvbiBQcyhpLCB0LCBlLCBzLCBuKSB7XG4gIHZhciBvID0gW10sXG4gICAgciA9IGUgPT09IFwieFwiID8gXCJpblhSYW5nZVwiIDogXCJpbllSYW5nZVwiO1xuICB2YXIgYSA9ICExO1xuICByZXR1cm4gdGkoaSwgZSwgdCwgZnVuY3Rpb24gKGwsIGMsIGgpIHtcbiAgICBsW3JdICYmIGxbcl0odFtlXSwgbikgJiYgKG8ucHVzaCh7XG4gICAgICBlbGVtZW50OiBsLFxuICAgICAgZGF0YXNldEluZGV4OiBjLFxuICAgICAgaW5kZXg6IGhcbiAgICB9KSwgYSA9IGEgfHwgbC5pblJhbmdlKHQueCwgdC55LCBuKSk7XG4gIH0pLCBzICYmICFhID8gW10gOiBvO1xufVxudmFyIFRhID0ge1xuICBtb2Rlczoge1xuICAgIGluZGV4OiBmdW5jdGlvbiBpbmRleChpLCB0LCBlLCBzKSB7XG4gICAgICB2YXIgbiA9IEF0KHQsIGkpLFxuICAgICAgICBvID0gZS5heGlzIHx8IFwieFwiLFxuICAgICAgICByID0gZS5pbmNsdWRlSW52aXNpYmxlIHx8ICExLFxuICAgICAgICBhID0gZS5pbnRlcnNlY3QgPyBoaShpLCBuLCBvLCBzLCByKSA6IGRpKGksIG4sIG8sICExLCBzLCByKSxcbiAgICAgICAgbCA9IFtdO1xuICAgICAgcmV0dXJuIGEubGVuZ3RoID8gKGkuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGggPSBhWzBdLmluZGV4LFxuICAgICAgICAgIGQgPSBjLmRhdGFbaF07XG4gICAgICAgIGQgJiYgIWQuc2tpcCAmJiBsLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGQsXG4gICAgICAgICAgZGF0YXNldEluZGV4OiBjLmluZGV4LFxuICAgICAgICAgIGluZGV4OiBoXG4gICAgICAgIH0pO1xuICAgICAgfSksIGwpIDogW107XG4gICAgfSxcbiAgICBkYXRhc2V0OiBmdW5jdGlvbiBkYXRhc2V0KGksIHQsIGUsIHMpIHtcbiAgICAgIHZhciBuID0gQXQodCwgaSksXG4gICAgICAgIG8gPSBlLmF4aXMgfHwgXCJ4eVwiLFxuICAgICAgICByID0gZS5pbmNsdWRlSW52aXNpYmxlIHx8ICExO1xuICAgICAgdmFyIGEgPSBlLmludGVyc2VjdCA/IGhpKGksIG4sIG8sIHMsIHIpIDogZGkoaSwgbiwgbywgITEsIHMsIHIpO1xuICAgICAgaWYgKGEubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbCA9IGFbMF0uZGF0YXNldEluZGV4LFxuICAgICAgICAgIGMgPSBpLmdldERhdGFzZXRNZXRhKGwpLmRhdGE7XG4gICAgICAgIGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCBjLmxlbmd0aDsgKytoKSBhLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGNbaF0sXG4gICAgICAgICAgZGF0YXNldEluZGV4OiBsLFxuICAgICAgICAgIGluZGV4OiBoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGE7XG4gICAgfSxcbiAgICBwb2ludDogZnVuY3Rpb24gcG9pbnQoaSwgdCwgZSwgcykge1xuICAgICAgdmFyIG4gPSBBdCh0LCBpKSxcbiAgICAgICAgbyA9IGUuYXhpcyB8fCBcInh5XCIsXG4gICAgICAgIHIgPSBlLmluY2x1ZGVJbnZpc2libGUgfHwgITE7XG4gICAgICByZXR1cm4gaGkoaSwgbiwgbywgcywgcik7XG4gICAgfSxcbiAgICBuZWFyZXN0OiBmdW5jdGlvbiBuZWFyZXN0KGksIHQsIGUsIHMpIHtcbiAgICAgIHZhciBuID0gQXQodCwgaSksXG4gICAgICAgIG8gPSBlLmF4aXMgfHwgXCJ4eVwiLFxuICAgICAgICByID0gZS5pbmNsdWRlSW52aXNpYmxlIHx8ICExO1xuICAgICAgcmV0dXJuIGRpKGksIG4sIG8sIGUuaW50ZXJzZWN0LCBzLCByKTtcbiAgICB9LFxuICAgIHg6IGZ1bmN0aW9uIHgoaSwgdCwgZSwgcykge1xuICAgICAgdmFyIG4gPSBBdCh0LCBpKTtcbiAgICAgIHJldHVybiBQcyhpLCBuLCBcInhcIiwgZS5pbnRlcnNlY3QsIHMpO1xuICAgIH0sXG4gICAgeTogZnVuY3Rpb24geShpLCB0LCBlLCBzKSB7XG4gICAgICB2YXIgbiA9IEF0KHQsIGkpO1xuICAgICAgcmV0dXJuIFBzKGksIG4sIFwieVwiLCBlLmludGVyc2VjdCwgcyk7XG4gICAgfVxuICB9XG59O1xudmFyICRuID0gW1wibGVmdFwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCJdO1xuZnVuY3Rpb24gdGUoaSwgdCkge1xuICByZXR1cm4gaS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZS5wb3MgPT09IHQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gRHMoaSwgdCkge1xuICByZXR1cm4gaS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gJG4uaW5kZXhPZihlLnBvcykgPT09IC0xICYmIGUuYm94LmF4aXMgPT09IHQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gZWUoaSwgdCkge1xuICByZXR1cm4gaS5zb3J0KGZ1bmN0aW9uIChlLCBzKSB7XG4gICAgdmFyIG4gPSB0ID8gcyA6IGUsXG4gICAgICBvID0gdCA/IGUgOiBzO1xuICAgIHJldHVybiBuLndlaWdodCA9PT0gby53ZWlnaHQgPyBuLmluZGV4IC0gby5pbmRleCA6IG4ud2VpZ2h0IC0gby53ZWlnaHQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gQWEoaSkge1xuICB2YXIgdCA9IFtdO1xuICB2YXIgZSwgcywgbiwgbywgciwgYTtcbiAgZm9yIChlID0gMCwgcyA9IChpIHx8IFtdKS5sZW5ndGg7IGUgPCBzOyArK2UpIHtcbiAgICB2YXIgX24zLCBfbjMkb3B0aW9ucywgX24zJG9wdGlvbnMkc3RhY2tXZWlnO1xuICAgIG4gPSBpW2VdLCBfbjMgPSBuLCBvID0gX24zLnBvc2l0aW9uLCBfbjMkb3B0aW9ucyA9IF9uMy5vcHRpb25zLCByID0gX24zJG9wdGlvbnMuc3RhY2ssIF9uMyRvcHRpb25zJHN0YWNrV2VpZyA9IF9uMyRvcHRpb25zLnN0YWNrV2VpZ2h0LCBhID0gX24zJG9wdGlvbnMkc3RhY2tXZWlnID09PSB2b2lkIDAgPyAxIDogX24zJG9wdGlvbnMkc3RhY2tXZWlnLCB0LnB1c2goe1xuICAgICAgaW5kZXg6IGUsXG4gICAgICBib3g6IG4sXG4gICAgICBwb3M6IG8sXG4gICAgICBob3Jpem9udGFsOiBuLmlzSG9yaXpvbnRhbCgpLFxuICAgICAgd2VpZ2h0OiBuLndlaWdodCxcbiAgICAgIHN0YWNrOiByICYmIG8gKyByLFxuICAgICAgc3RhY2tXZWlnaHQ6IGFcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIFJhKGkpIHtcbiAgdmFyIHQgPSB7fTtcbiAgdmFyIF9pdGVyYXRvcjE1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaSksXG4gICAgX3N0ZXAxNTtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjE1LnMoKTsgIShfc3RlcDE1ID0gX2l0ZXJhdG9yMTUubigpKS5kb25lOykge1xuICAgICAgdmFyIGUgPSBfc3RlcDE1LnZhbHVlO1xuICAgICAgdmFyIHMgPSBlLnN0YWNrLFxuICAgICAgICBuID0gZS5wb3MsXG4gICAgICAgIG8gPSBlLnN0YWNrV2VpZ2h0O1xuICAgICAgaWYgKCFzIHx8ICEkbi5pbmNsdWRlcyhuKSkgY29udGludWU7XG4gICAgICB2YXIgciA9IHRbc10gfHwgKHRbc10gPSB7XG4gICAgICAgIGNvdW50OiAwLFxuICAgICAgICBwbGFjZWQ6IDAsXG4gICAgICAgIHdlaWdodDogMCxcbiAgICAgICAgc2l6ZTogMFxuICAgICAgfSk7XG4gICAgICByLmNvdW50KyssIHIud2VpZ2h0ICs9IG87XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IxNS5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMTUuZigpO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gTGEoaSwgdCkge1xuICB2YXIgZSA9IFJhKGkpLFxuICAgIHMgPSB0LnZCb3hNYXhXaWR0aCxcbiAgICBuID0gdC5oQm94TWF4SGVpZ2h0O1xuICB2YXIgbywgciwgYTtcbiAgZm9yIChvID0gMCwgciA9IGkubGVuZ3RoOyBvIDwgcjsgKytvKSB7XG4gICAgYSA9IGlbb107XG4gICAgdmFyIGwgPSBhLmJveC5mdWxsU2l6ZSxcbiAgICAgIGMgPSBlW2Euc3RhY2tdLFxuICAgICAgaCA9IGMgJiYgYS5zdGFja1dlaWdodCAvIGMud2VpZ2h0O1xuICAgIGEuaG9yaXpvbnRhbCA/IChhLndpZHRoID0gaCA/IGggKiBzIDogbCAmJiB0LmF2YWlsYWJsZVdpZHRoLCBhLmhlaWdodCA9IG4pIDogKGEud2lkdGggPSBzLCBhLmhlaWdodCA9IGggPyBoICogbiA6IGwgJiYgdC5hdmFpbGFibGVIZWlnaHQpO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gRWEoaSkge1xuICB2YXIgdCA9IEFhKGkpLFxuICAgIGUgPSBlZSh0LmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMuYm94LmZ1bGxTaXplO1xuICAgIH0pLCAhMCksXG4gICAgcyA9IGVlKHRlKHQsIFwibGVmdFwiKSwgITApLFxuICAgIG4gPSBlZSh0ZSh0LCBcInJpZ2h0XCIpKSxcbiAgICBvID0gZWUodGUodCwgXCJ0b3BcIiksICEwKSxcbiAgICByID0gZWUodGUodCwgXCJib3R0b21cIikpLFxuICAgIGEgPSBEcyh0LCBcInhcIiksXG4gICAgbCA9IERzKHQsIFwieVwiKTtcbiAgcmV0dXJuIHtcbiAgICBmdWxsU2l6ZTogZSxcbiAgICBsZWZ0QW5kVG9wOiBzLmNvbmNhdChvKSxcbiAgICByaWdodEFuZEJvdHRvbTogbi5jb25jYXQobCkuY29uY2F0KHIpLmNvbmNhdChhKSxcbiAgICBjaGFydEFyZWE6IHRlKHQsIFwiY2hhcnRBcmVhXCIpLFxuICAgIHZlcnRpY2FsOiBzLmNvbmNhdChuKS5jb25jYXQobCksXG4gICAgaG9yaXpvbnRhbDogby5jb25jYXQocikuY29uY2F0KGEpXG4gIH07XG59XG5mdW5jdGlvbiBDcyhpLCB0LCBlLCBzKSB7XG4gIHJldHVybiBNYXRoLm1heChpW2VdLCB0W2VdKSArIE1hdGgubWF4KGlbc10sIHRbc10pO1xufVxuZnVuY3Rpb24gWW4oaSwgdCkge1xuICBpLnRvcCA9IE1hdGgubWF4KGkudG9wLCB0LnRvcCksIGkubGVmdCA9IE1hdGgubWF4KGkubGVmdCwgdC5sZWZ0KSwgaS5ib3R0b20gPSBNYXRoLm1heChpLmJvdHRvbSwgdC5ib3R0b20pLCBpLnJpZ2h0ID0gTWF0aC5tYXgoaS5yaWdodCwgdC5yaWdodCk7XG59XG5mdW5jdGlvbiBGYShpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gZS5wb3MsXG4gICAgbyA9IGUuYm94LFxuICAgIHIgPSBpLm1heFBhZGRpbmc7XG4gIGlmICghVChuKSkge1xuICAgIGUuc2l6ZSAmJiAoaVtuXSAtPSBlLnNpemUpO1xuICAgIHZhciBkID0gc1tlLnN0YWNrXSB8fCB7XG4gICAgICBzaXplOiAwLFxuICAgICAgY291bnQ6IDFcbiAgICB9O1xuICAgIGQuc2l6ZSA9IE1hdGgubWF4KGQuc2l6ZSwgZS5ob3Jpem9udGFsID8gby5oZWlnaHQgOiBvLndpZHRoKSwgZS5zaXplID0gZC5zaXplIC8gZC5jb3VudCwgaVtuXSArPSBlLnNpemU7XG4gIH1cbiAgby5nZXRQYWRkaW5nICYmIFluKHIsIG8uZ2V0UGFkZGluZygpKTtcbiAgdmFyIGEgPSBNYXRoLm1heCgwLCB0Lm91dGVyV2lkdGggLSBDcyhyLCBpLCBcImxlZnRcIiwgXCJyaWdodFwiKSksXG4gICAgbCA9IE1hdGgubWF4KDAsIHQub3V0ZXJIZWlnaHQgLSBDcyhyLCBpLCBcInRvcFwiLCBcImJvdHRvbVwiKSksXG4gICAgYyA9IGEgIT09IGkudyxcbiAgICBoID0gbCAhPT0gaS5oO1xuICByZXR1cm4gaS53ID0gYSwgaS5oID0gbCwgZS5ob3Jpem9udGFsID8ge1xuICAgIHNhbWU6IGMsXG4gICAgb3RoZXI6IGhcbiAgfSA6IHtcbiAgICBzYW1lOiBoLFxuICAgIG90aGVyOiBjXG4gIH07XG59XG5mdW5jdGlvbiBJYShpKSB7XG4gIHZhciB0ID0gaS5tYXhQYWRkaW5nO1xuICBmdW5jdGlvbiBlKHMpIHtcbiAgICB2YXIgbiA9IE1hdGgubWF4KHRbc10gLSBpW3NdLCAwKTtcbiAgICByZXR1cm4gaVtzXSArPSBuLCBuO1xuICB9XG4gIGkueSArPSBlKFwidG9wXCIpLCBpLnggKz0gZShcImxlZnRcIiksIGUoXCJyaWdodFwiKSwgZShcImJvdHRvbVwiKTtcbn1cbmZ1bmN0aW9uIHphKGksIHQpIHtcbiAgdmFyIGUgPSB0Lm1heFBhZGRpbmc7XG4gIGZ1bmN0aW9uIHMobikge1xuICAgIHZhciBvID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgICByZXR1cm4gbi5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBvW3JdID0gTWF0aC5tYXgodFtyXSwgZVtyXSk7XG4gICAgfSksIG87XG4gIH1cbiAgcmV0dXJuIHMoaSA/IFtcImxlZnRcIiwgXCJyaWdodFwiXSA6IFtcInRvcFwiLCBcImJvdHRvbVwiXSk7XG59XG5mdW5jdGlvbiBvZShpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gW107XG4gIHZhciBvLCByLCBhLCBsLCBjLCBoO1xuICBmb3IgKG8gPSAwLCByID0gaS5sZW5ndGgsIGMgPSAwOyBvIDwgcjsgKytvKSB7XG4gICAgYSA9IGlbb10sIGwgPSBhLmJveCwgbC51cGRhdGUoYS53aWR0aCB8fCB0LncsIGEuaGVpZ2h0IHx8IHQuaCwgemEoYS5ob3Jpem9udGFsLCB0KSk7XG4gICAgdmFyIF9GYSA9IEZhKHQsIGUsIGEsIHMpLFxuICAgICAgZCA9IF9GYS5zYW1lLFxuICAgICAgdSA9IF9GYS5vdGhlcjtcbiAgICBjIHw9IGQgJiYgbi5sZW5ndGgsIGggPSBoIHx8IHUsIGwuZnVsbFNpemUgfHwgbi5wdXNoKGEpO1xuICB9XG4gIHJldHVybiBjICYmIG9lKG4sIHQsIGUsIHMpIHx8IGg7XG59XG5mdW5jdGlvbiBDZShpLCB0LCBlLCBzLCBuKSB7XG4gIGkudG9wID0gZSwgaS5sZWZ0ID0gdCwgaS5yaWdodCA9IHQgKyBzLCBpLmJvdHRvbSA9IGUgKyBuLCBpLndpZHRoID0gcywgaS5oZWlnaHQgPSBuO1xufVxuZnVuY3Rpb24gT3MoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IGUucGFkZGluZztcbiAgdmFyIG8gPSB0LngsXG4gICAgciA9IHQueTtcbiAgdmFyIF9pdGVyYXRvcjE2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaSksXG4gICAgX3N0ZXAxNjtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjE2LnMoKTsgIShfc3RlcDE2ID0gX2l0ZXJhdG9yMTYubigpKS5kb25lOykge1xuICAgICAgdmFyIGEgPSBfc3RlcDE2LnZhbHVlO1xuICAgICAgdmFyIGwgPSBhLmJveCxcbiAgICAgICAgYyA9IHNbYS5zdGFja10gfHwge1xuICAgICAgICAgIHBsYWNlZDogMCxcbiAgICAgICAgICB3ZWlnaHQ6IDFcbiAgICAgICAgfSxcbiAgICAgICAgaCA9IGEuc3RhY2tXZWlnaHQgLyBjLndlaWdodCB8fCAxO1xuICAgICAgaWYgKGEuaG9yaXpvbnRhbCkge1xuICAgICAgICB2YXIgZCA9IHQudyAqIGgsXG4gICAgICAgICAgdSA9IGMuc2l6ZSB8fCBsLmhlaWdodDtcbiAgICAgICAgZ2UoYy5zdGFydCkgJiYgKHIgPSBjLnN0YXJ0KSwgbC5mdWxsU2l6ZSA/IENlKGwsIG4ubGVmdCwgciwgZS5vdXRlcldpZHRoIC0gbi5yaWdodCAtIG4ubGVmdCwgdSkgOiBDZShsLCB0LmxlZnQgKyBjLnBsYWNlZCwgciwgZCwgdSksIGMuc3RhcnQgPSByLCBjLnBsYWNlZCArPSBkLCByID0gbC5ib3R0b207XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2QyID0gdC5oICogaCxcbiAgICAgICAgICBfdTIgPSBjLnNpemUgfHwgbC53aWR0aDtcbiAgICAgICAgZ2UoYy5zdGFydCkgJiYgKG8gPSBjLnN0YXJ0KSwgbC5mdWxsU2l6ZSA/IENlKGwsIG8sIG4udG9wLCBfdTIsIGUub3V0ZXJIZWlnaHQgLSBuLmJvdHRvbSAtIG4udG9wKSA6IENlKGwsIG8sIHQudG9wICsgYy5wbGFjZWQsIF91MiwgX2QyKSwgYy5zdGFydCA9IG8sIGMucGxhY2VkICs9IF9kMiwgbyA9IGwucmlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IxNi5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMTYuZigpO1xuICB9XG4gIHQueCA9IG8sIHQueSA9IHI7XG59XG52YXIgdHQgPSB7XG4gIGFkZEJveDogZnVuY3Rpb24gYWRkQm94KGksIHQpIHtcbiAgICBpLmJveGVzIHx8IChpLmJveGVzID0gW10pLCB0LmZ1bGxTaXplID0gdC5mdWxsU2l6ZSB8fCAhMSwgdC5wb3NpdGlvbiA9IHQucG9zaXRpb24gfHwgXCJ0b3BcIiwgdC53ZWlnaHQgPSB0LndlaWdodCB8fCAwLCB0Ll9sYXllcnMgPSB0Ll9sYXllcnMgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IDAsXG4gICAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoZSkge1xuICAgICAgICAgIHQuZHJhdyhlKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfSwgaS5ib3hlcy5wdXNoKHQpO1xuICB9LFxuICByZW1vdmVCb3g6IGZ1bmN0aW9uIHJlbW92ZUJveChpLCB0KSB7XG4gICAgdmFyIGUgPSBpLmJveGVzID8gaS5ib3hlcy5pbmRleE9mKHQpIDogLTE7XG4gICAgZSAhPT0gLTEgJiYgaS5ib3hlcy5zcGxpY2UoZSwgMSk7XG4gIH0sXG4gIGNvbmZpZ3VyZTogZnVuY3Rpb24gY29uZmlndXJlKGksIHQsIGUpIHtcbiAgICB0LmZ1bGxTaXplID0gZS5mdWxsU2l6ZSwgdC5wb3NpdGlvbiA9IGUucG9zaXRpb24sIHQud2VpZ2h0ID0gZS53ZWlnaHQ7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGksIHQsIGUsIHMpIHtcbiAgICBpZiAoIWkpIHJldHVybjtcbiAgICB2YXIgbiA9IGV0KGkub3B0aW9ucy5sYXlvdXQucGFkZGluZyksXG4gICAgICBvID0gTWF0aC5tYXgodCAtIG4ud2lkdGgsIDApLFxuICAgICAgciA9IE1hdGgubWF4KGUgLSBuLmhlaWdodCwgMCksXG4gICAgICBhID0gRWEoaS5ib3hlcyksXG4gICAgICBsID0gYS52ZXJ0aWNhbCxcbiAgICAgIGMgPSBhLmhvcml6b250YWw7XG4gICAgTChpLmJveGVzLCBmdW5jdGlvbiAoZykge1xuICAgICAgdHlwZW9mIGcuYmVmb3JlTGF5b3V0ID09IFwiZnVuY3Rpb25cIiAmJiBnLmJlZm9yZUxheW91dCgpO1xuICAgIH0pO1xuICAgIHZhciBoID0gbC5yZWR1Y2UoZnVuY3Rpb24gKGcsIG0pIHtcbiAgICAgICAgcmV0dXJuIG0uYm94Lm9wdGlvbnMgJiYgbS5ib3gub3B0aW9ucy5kaXNwbGF5ID09PSAhMSA/IGcgOiBnICsgMTtcbiAgICAgIH0sIDApIHx8IDEsXG4gICAgICBkID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIG91dGVyV2lkdGg6IHQsXG4gICAgICAgIG91dGVySGVpZ2h0OiBlLFxuICAgICAgICBwYWRkaW5nOiBuLFxuICAgICAgICBhdmFpbGFibGVXaWR0aDogbyxcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0OiByLFxuICAgICAgICB2Qm94TWF4V2lkdGg6IG8gLyAyIC8gaCxcbiAgICAgICAgaEJveE1heEhlaWdodDogciAvIDJcbiAgICAgIH0pLFxuICAgICAgdSA9IE9iamVjdC5hc3NpZ24oe30sIG4pO1xuICAgIFluKHUsIGV0KHMpKTtcbiAgICB2YXIgZiA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBtYXhQYWRkaW5nOiB1LFxuICAgICAgICB3OiBvLFxuICAgICAgICBoOiByLFxuICAgICAgICB4OiBuLmxlZnQsXG4gICAgICAgIHk6IG4udG9wXG4gICAgICB9LCBuKSxcbiAgICAgIHAgPSBMYShsLmNvbmNhdChjKSwgZCk7XG4gICAgb2UoYS5mdWxsU2l6ZSwgZiwgZCwgcCksIG9lKGwsIGYsIGQsIHApLCBvZShjLCBmLCBkLCBwKSAmJiBvZShsLCBmLCBkLCBwKSwgSWEoZiksIE9zKGEubGVmdEFuZFRvcCwgZiwgZCwgcCksIGYueCArPSBmLncsIGYueSArPSBmLmgsIE9zKGEucmlnaHRBbmRCb3R0b20sIGYsIGQsIHApLCBpLmNoYXJ0QXJlYSA9IHtcbiAgICAgIGxlZnQ6IGYubGVmdCxcbiAgICAgIHRvcDogZi50b3AsXG4gICAgICByaWdodDogZi5sZWZ0ICsgZi53LFxuICAgICAgYm90dG9tOiBmLnRvcCArIGYuaCxcbiAgICAgIGhlaWdodDogZi5oLFxuICAgICAgd2lkdGg6IGYud1xuICAgIH0sIEwoYS5jaGFydEFyZWEsIGZ1bmN0aW9uIChnKSB7XG4gICAgICB2YXIgbSA9IGcuYm94O1xuICAgICAgT2JqZWN0LmFzc2lnbihtLCBpLmNoYXJ0QXJlYSksIG0udXBkYXRlKGYudywgZi5oLCB7XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIGJvdHRvbTogMFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgVW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBVbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVW4pO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVW4sIFt7XG4gICAga2V5OiBcImFjcXVpcmVDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjcXVpcmVDb250ZXh0KHQsIGUpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVsZWFzZUNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVsZWFzZUNvbnRleHQodCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodCwgZSwgcykge31cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVFdmVudExpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodCwgZSwgcykge31cbiAgfSwge1xuICAgIGtleTogXCJnZXREZXZpY2VQaXhlbFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWF4aW11bVNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWF4aW11bVNpemUodCwgZSwgcywgbikge1xuICAgICAgcmV0dXJuIGUgPSBNYXRoLm1heCgwLCBlIHx8IHQud2lkdGgpLCBzID0gcyB8fCB0LmhlaWdodCwge1xuICAgICAgICB3aWR0aDogZSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLm1heCgwLCBuID8gTWF0aC5mbG9vcihlIC8gbikgOiBzKVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNBdHRhY2hlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0F0dGFjaGVkKHQpIHtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQ29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUNvbmZpZyh0KSB7fVxuICB9XSk7XG59KCk7XG52YXIgQmEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Vbikge1xuICBmdW5jdGlvbiBCYSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmEpO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEJhLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhCYSwgX1VuKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhCYSwgW3tcbiAgICBrZXk6IFwiYWNxdWlyZUNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNxdWlyZUNvbnRleHQodCkge1xuICAgICAgcmV0dXJuIHQgJiYgdC5nZXRDb250ZXh0ICYmIHQuZ2V0Q29udGV4dChcIjJkXCIpIHx8IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUNvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVDb25maWcodCkge1xuICAgICAgdC5vcHRpb25zLmFuaW1hdGlvbiA9ICExO1xuICAgIH1cbiAgfV0pO1xufShVbik7XG52YXIgemUgPSBcIiRjaGFydGpzXCIsXG4gIEhhID0ge1xuICAgIHRvdWNoc3RhcnQ6IFwibW91c2Vkb3duXCIsXG4gICAgdG91Y2htb3ZlOiBcIm1vdXNlbW92ZVwiLFxuICAgIHRvdWNoZW5kOiBcIm1vdXNldXBcIixcbiAgICBwb2ludGVyZW50ZXI6IFwibW91c2VlbnRlclwiLFxuICAgIHBvaW50ZXJkb3duOiBcIm1vdXNlZG93blwiLFxuICAgIHBvaW50ZXJtb3ZlOiBcIm1vdXNlbW92ZVwiLFxuICAgIHBvaW50ZXJ1cDogXCJtb3VzZXVwXCIsXG4gICAgcG9pbnRlcmxlYXZlOiBcIm1vdXNlb3V0XCIsXG4gICAgcG9pbnRlcm91dDogXCJtb3VzZW91dFwiXG4gIH0sXG4gIFRzID0gZnVuY3Rpb24gVHMoaSkge1xuICAgIHJldHVybiBpID09PSBudWxsIHx8IGkgPT09IFwiXCI7XG4gIH07XG5mdW5jdGlvbiBXYShpLCB0KSB7XG4gIHZhciBlID0gaS5zdHlsZSxcbiAgICBzID0gaS5nZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiksXG4gICAgbiA9IGkuZ2V0QXR0cmlidXRlKFwid2lkdGhcIik7XG4gIGlmIChpW3plXSA9IHtcbiAgICBpbml0aWFsOiB7XG4gICAgICBoZWlnaHQ6IHMsXG4gICAgICB3aWR0aDogbixcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IGUuZGlzcGxheSxcbiAgICAgICAgaGVpZ2h0OiBlLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IGUud2lkdGhcbiAgICAgIH1cbiAgICB9XG4gIH0sIGUuZGlzcGxheSA9IGUuZGlzcGxheSB8fCBcImJsb2NrXCIsIGUuYm94U2l6aW5nID0gZS5ib3hTaXppbmcgfHwgXCJib3JkZXItYm94XCIsIFRzKG4pKSB7XG4gICAgdmFyIG8gPSBmcyhpLCBcIndpZHRoXCIpO1xuICAgIG8gIT09IHZvaWQgMCAmJiAoaS53aWR0aCA9IG8pO1xuICB9XG4gIGlmIChUcyhzKSkgaWYgKGkuc3R5bGUuaGVpZ2h0ID09PSBcIlwiKSBpLmhlaWdodCA9IGkud2lkdGggLyAodCB8fCAyKTtlbHNlIHtcbiAgICB2YXIgX28yID0gZnMoaSwgXCJoZWlnaHRcIik7XG4gICAgX28yICE9PSB2b2lkIDAgJiYgKGkuaGVpZ2h0ID0gX28yKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cbnZhciBYbiA9IFZyID8ge1xuICBwYXNzaXZlOiAhMFxufSA6ICExO1xuZnVuY3Rpb24gTmEoaSwgdCwgZSkge1xuICBpICYmIGkuYWRkRXZlbnRMaXN0ZW5lcih0LCBlLCBYbik7XG59XG5mdW5jdGlvbiBWYShpLCB0LCBlKSB7XG4gIGkgJiYgaS5jYW52YXMgJiYgaS5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LCBlLCBYbik7XG59XG5mdW5jdGlvbiBqYShpLCB0KSB7XG4gIHZhciBlID0gSGFbaS50eXBlXSB8fCBpLnR5cGUsXG4gICAgX0F0ID0gQXQoaSwgdCksXG4gICAgcyA9IF9BdC54LFxuICAgIG4gPSBfQXQueTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBlLFxuICAgIGNoYXJ0OiB0LFxuICAgIFwibmF0aXZlXCI6IGksXG4gICAgeDogcyAhPT0gdm9pZCAwID8gcyA6IG51bGwsXG4gICAgeTogbiAhPT0gdm9pZCAwID8gbiA6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIHFlKGksIHQpIHtcbiAgdmFyIF9pdGVyYXRvcjE3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaSksXG4gICAgX3N0ZXAxNztcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjE3LnMoKTsgIShfc3RlcDE3ID0gX2l0ZXJhdG9yMTcubigpKS5kb25lOykge1xuICAgICAgdmFyIGUgPSBfc3RlcDE3LnZhbHVlO1xuICAgICAgaWYgKGUgPT09IHQgfHwgZS5jb250YWlucyh0KSkgcmV0dXJuICEwO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMTcuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjE3LmYoKTtcbiAgfVxufVxuZnVuY3Rpb24gJGEoaSwgdCwgZSkge1xuICB2YXIgcyA9IGkuY2FudmFzLFxuICAgIG4gPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHIgPSAhMTtcbiAgICAgIHZhciBfaXRlcmF0b3IxOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8pLFxuICAgICAgICBfc3RlcDE4O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IxOC5zKCk7ICEoX3N0ZXAxOCA9IF9pdGVyYXRvcjE4Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgYSA9IF9zdGVwMTgudmFsdWU7XG4gICAgICAgICAgciA9IHIgfHwgcWUoYS5hZGRlZE5vZGVzLCBzKSwgciA9IHIgJiYgIXFlKGEucmVtb3ZlZE5vZGVzLCBzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjE4LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjE4LmYoKTtcbiAgICAgIH1cbiAgICAgIHIgJiYgZSgpO1xuICAgIH0pO1xuICByZXR1cm4gbi5vYnNlcnZlKGRvY3VtZW50LCB7XG4gICAgY2hpbGRMaXN0OiAhMCxcbiAgICBzdWJ0cmVlOiAhMFxuICB9KSwgbjtcbn1cbmZ1bmN0aW9uIFlhKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBpLmNhbnZhcyxcbiAgICBuID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciByID0gITE7XG4gICAgICB2YXIgX2l0ZXJhdG9yMTkgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvKSxcbiAgICAgICAgX3N0ZXAxOTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTkucygpOyAhKF9zdGVwMTkgPSBfaXRlcmF0b3IxOS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGEgPSBfc3RlcDE5LnZhbHVlO1xuICAgICAgICAgIHIgPSByIHx8IHFlKGEucmVtb3ZlZE5vZGVzLCBzKSwgciA9IHIgJiYgIXFlKGEuYWRkZWROb2Rlcywgcyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxOS5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxOS5mKCk7XG4gICAgICB9XG4gICAgICByICYmIGUoKTtcbiAgICB9KTtcbiAgcmV0dXJuIG4ub2JzZXJ2ZShkb2N1bWVudCwge1xuICAgIGNoaWxkTGlzdDogITAsXG4gICAgc3VidHJlZTogITBcbiAgfSksIG47XG59XG52YXIgX2UgPSAvKiBAX19QVVJFX18gKi9uZXcgTWFwKCk7XG52YXIgQXMgPSAwO1xuZnVuY3Rpb24gcW4oKSB7XG4gIHZhciBpID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGkgIT09IEFzICYmIChBcyA9IGksIF9lLmZvckVhY2goZnVuY3Rpb24gKHQsIGUpIHtcbiAgICBlLmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBpICYmIHQoKTtcbiAgfSkpO1xufVxuZnVuY3Rpb24gVWEoaSwgdCkge1xuICBfZS5zaXplIHx8IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHFuKSwgX2Uuc2V0KGksIHQpO1xufVxuZnVuY3Rpb24gWGEoaSkge1xuICBfZVtcImRlbGV0ZVwiXShpKSwgX2Uuc2l6ZSB8fCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBxbik7XG59XG5mdW5jdGlvbiBxYShpLCB0LCBlKSB7XG4gIHZhciBzID0gaS5jYW52YXMsXG4gICAgbiA9IHMgJiYgWWkocyk7XG4gIGlmICghbikgcmV0dXJuO1xuICB2YXIgbyA9IGtuKGZ1bmN0aW9uIChhLCBsKSB7XG4gICAgICB2YXIgYyA9IG4uY2xpZW50V2lkdGg7XG4gICAgICBlKGEsIGwpLCBjIDwgbi5jbGllbnRXaWR0aCAmJiBlKCk7XG4gICAgfSwgd2luZG93KSxcbiAgICByID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uIChhKSB7XG4gICAgICB2YXIgbCA9IGFbMF0sXG4gICAgICAgIGMgPSBsLmNvbnRlbnRSZWN0LndpZHRoLFxuICAgICAgICBoID0gbC5jb250ZW50UmVjdC5oZWlnaHQ7XG4gICAgICBjID09PSAwICYmIGggPT09IDAgfHwgbyhjLCBoKTtcbiAgICB9KTtcbiAgcmV0dXJuIHIub2JzZXJ2ZShuKSwgVWEoaSwgbyksIHI7XG59XG5mdW5jdGlvbiB1aShpLCB0LCBlKSB7XG4gIGUgJiYgZS5kaXNjb25uZWN0KCksIHQgPT09IFwicmVzaXplXCIgJiYgWGEoaSk7XG59XG5mdW5jdGlvbiBLYShpLCB0LCBlKSB7XG4gIHZhciBzID0gaS5jYW52YXMsXG4gICAgbiA9IGtuKGZ1bmN0aW9uIChvKSB7XG4gICAgICBpLmN0eCAhPT0gbnVsbCAmJiBlKGphKG8sIGkpKTtcbiAgICB9LCBpKTtcbiAgcmV0dXJuIE5hKHMsIHQsIG4pLCBuO1xufVxudmFyIEdhID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVW4yKSB7XG4gIGZ1bmN0aW9uIEdhKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHYSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgR2EsIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2luaGVyaXRzKEdhLCBfVW4yKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhHYSwgW3tcbiAgICBrZXk6IFwiYWNxdWlyZUNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWNxdWlyZUNvbnRleHQodCwgZSkge1xuICAgICAgdmFyIHMgPSB0ICYmIHQuZ2V0Q29udGV4dCAmJiB0LmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIHJldHVybiBzICYmIHMuY2FudmFzID09PSB0ID8gKFdhKHQsIGUpLCBzKSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbGVhc2VDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbGVhc2VDb250ZXh0KHQpIHtcbiAgICAgIHZhciBlID0gdC5jYW52YXM7XG4gICAgICBpZiAoIWVbemVdKSByZXR1cm4gITE7XG4gICAgICB2YXIgcyA9IGVbemVdLmluaXRpYWw7XG4gICAgICBbXCJoZWlnaHRcIiwgXCJ3aWR0aFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciByID0gc1tvXTtcbiAgICAgICAgUihyKSA/IGUucmVtb3ZlQXR0cmlidXRlKG8pIDogZS5zZXRBdHRyaWJ1dGUobywgcik7XG4gICAgICB9KTtcbiAgICAgIHZhciBuID0gcy5zdHlsZSB8fCB7fTtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIGUuc3R5bGVbb10gPSBuW29dO1xuICAgICAgfSksIGUud2lkdGggPSBlLndpZHRoLCBkZWxldGUgZVt6ZV0sICEwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodCwgZSwgcykge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHQsIGUpO1xuICAgICAgdmFyIG4gPSB0LiRwcm94aWVzIHx8ICh0LiRwcm94aWVzID0ge30pLFxuICAgICAgICByID0ge1xuICAgICAgICAgIGF0dGFjaDogJGEsXG4gICAgICAgICAgZGV0YWNoOiBZYSxcbiAgICAgICAgICByZXNpemU6IHFhXG4gICAgICAgIH1bZV0gfHwgS2E7XG4gICAgICBuW2VdID0gcih0LCBlLCBzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHQsIGUpIHtcbiAgICAgIHZhciBzID0gdC4kcHJveGllcyB8fCAodC4kcHJveGllcyA9IHt9KSxcbiAgICAgICAgbiA9IHNbZV07XG4gICAgICBpZiAoIW4pIHJldHVybjtcbiAgICAgICh7XG4gICAgICAgIGF0dGFjaDogdWksXG4gICAgICAgIGRldGFjaDogdWksXG4gICAgICAgIHJlc2l6ZTogdWlcbiAgICAgIH1bZV0gfHwgVmEpKHQsIGUsIG4pLCBzW2VdID0gdm9pZCAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREZXZpY2VQaXhlbFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1heGltdW1TaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1heGltdW1TaXplKHQsIGUsIHMsIG4pIHtcbiAgICAgIHJldHVybiBOcih0LCBlLCBzLCBuKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNBdHRhY2hlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0F0dGFjaGVkKHQpIHtcbiAgICAgIHZhciBlID0gdCAmJiBZaSh0KTtcbiAgICAgIHJldHVybiAhIShlICYmIGUuaXNDb25uZWN0ZWQpO1xuICAgIH1cbiAgfV0pO1xufShVbik7XG5mdW5jdGlvbiBKYShpKSB7XG4gIHJldHVybiAhJGkoKSB8fCAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKE9mZnNjcmVlbkNhbnZhcykpIDwgXCJ1XCIgJiYgaSBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcyA/IEJhIDogR2E7XG59XG52YXIgc3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgc3QpO1xuICAgIHcodGhpcywgXCJ4XCIpO1xuICAgIHcodGhpcywgXCJ5XCIpO1xuICAgIHcodGhpcywgXCJhY3RpdmVcIiwgITEpO1xuICAgIHcodGhpcywgXCJvcHRpb25zXCIpO1xuICAgIHcodGhpcywgXCIkYW5pbWF0aW9uc1wiKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKHN0LCBbe1xuICAgIGtleTogXCJ0b29sdGlwUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9vbHRpcFBvc2l0aW9uKHQpIHtcbiAgICAgIHZhciBfdGhpcyRnZXRQcm9wcyA9IHRoaXMuZ2V0UHJvcHMoW1wieFwiLCBcInlcIl0sIHQpLFxuICAgICAgICBlID0gX3RoaXMkZ2V0UHJvcHMueCxcbiAgICAgICAgcyA9IF90aGlzJGdldFByb3BzLnk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBlLFxuICAgICAgICB5OiBzXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBYdCh0aGlzLngpICYmIFh0KHRoaXMueSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByb3BzKHQsIGUpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgICAgdmFyIHMgPSB0aGlzLiRhbmltYXRpb25zO1xuICAgICAgaWYgKCFlIHx8ICFzKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBuID0ge307XG4gICAgICByZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIG5bb10gPSBzW29dICYmIHNbb10uYWN0aXZlKCkgPyBzW29dLl90byA6IF90aGlzN1tvXTtcbiAgICAgIH0pLCBuO1xuICAgIH1cbiAgfV0pO1xufSgpO1xudyhzdCwgXCJkZWZhdWx0c1wiLCB7fSksIHcoc3QsIFwiZGVmYXVsdFJvdXRlc1wiKTtcbmZ1bmN0aW9uIFphKGksIHQpIHtcbiAgdmFyIGUgPSBpLm9wdGlvbnMudGlja3MsXG4gICAgcyA9IFFhKGkpLFxuICAgIG4gPSBNYXRoLm1pbihlLm1heFRpY2tzTGltaXQgfHwgcywgcyksXG4gICAgbyA9IGUubWFqb3IuZW5hYmxlZCA/IGVsKHQpIDogW10sXG4gICAgciA9IG8ubGVuZ3RoLFxuICAgIGEgPSBvWzBdLFxuICAgIGwgPSBvW3IgLSAxXSxcbiAgICBjID0gW107XG4gIGlmIChyID4gbikgcmV0dXJuIGlsKHQsIGMsIG8sIHIgLyBuKSwgYztcbiAgdmFyIGggPSB0bChvLCB0LCBuKTtcbiAgaWYgKHIgPiAwKSB7XG4gICAgdmFyIGQsIHU7XG4gICAgdmFyIGYgPSByID4gMSA/IE1hdGgucm91bmQoKGwgLSBhKSAvIChyIC0gMSkpIDogbnVsbDtcbiAgICBmb3IgKE9lKHQsIGMsIGgsIFIoZikgPyAwIDogYSAtIGYsIGEpLCBkID0gMCwgdSA9IHIgLSAxOyBkIDwgdTsgZCsrKSBPZSh0LCBjLCBoLCBvW2RdLCBvW2QgKyAxXSk7XG4gICAgcmV0dXJuIE9lKHQsIGMsIGgsIGwsIFIoZikgPyB0Lmxlbmd0aCA6IGwgKyBmKSwgYztcbiAgfVxuICByZXR1cm4gT2UodCwgYywgaCksIGM7XG59XG5mdW5jdGlvbiBRYShpKSB7XG4gIHZhciB0ID0gaS5vcHRpb25zLm9mZnNldCxcbiAgICBlID0gaS5fdGlja1NpemUoKSxcbiAgICBzID0gaS5fbGVuZ3RoIC8gZSArICh0ID8gMCA6IDEpLFxuICAgIG4gPSBpLl9tYXhMZW5ndGggLyBlO1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1pbihzLCBuKSk7XG59XG5mdW5jdGlvbiB0bChpLCB0LCBlKSB7XG4gIHZhciBzID0gc2woaSksXG4gICAgbiA9IHQubGVuZ3RoIC8gZTtcbiAgaWYgKCFzKSByZXR1cm4gTWF0aC5tYXgobiwgMSk7XG4gIHZhciBvID0gVm8ocyk7XG4gIGZvciAodmFyIHIgPSAwLCBhID0gby5sZW5ndGggLSAxOyByIDwgYTsgcisrKSB7XG4gICAgdmFyIGwgPSBvW3JdO1xuICAgIGlmIChsID4gbikgcmV0dXJuIGw7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KG4sIDEpO1xufVxuZnVuY3Rpb24gZWwoaSkge1xuICB2YXIgdCA9IFtdO1xuICB2YXIgZSwgcztcbiAgZm9yIChlID0gMCwgcyA9IGkubGVuZ3RoOyBlIDwgczsgZSsrKSBpW2VdLm1ham9yICYmIHQucHVzaChlKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBpbChpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gMCxcbiAgICBvID0gZVswXSxcbiAgICByO1xuICBmb3IgKHMgPSBNYXRoLmNlaWwocyksIHIgPSAwOyByIDwgaS5sZW5ndGg7IHIrKykgciA9PT0gbyAmJiAodC5wdXNoKGlbcl0pLCBuKyssIG8gPSBlW24gKiBzXSk7XG59XG5mdW5jdGlvbiBPZShpLCB0LCBlLCBzLCBuKSB7XG4gIHZhciBvID0gRChzLCAwKSxcbiAgICByID0gTWF0aC5taW4oRChuLCBpLmxlbmd0aCksIGkubGVuZ3RoKTtcbiAgdmFyIGEgPSAwLFxuICAgIGwsXG4gICAgYyxcbiAgICBoO1xuICBmb3IgKGUgPSBNYXRoLmNlaWwoZSksIG4gJiYgKGwgPSBuIC0gcywgZSA9IGwgLyBNYXRoLmZsb29yKGwgLyBlKSksIGggPSBvOyBoIDwgMDspIGErKywgaCA9IE1hdGgucm91bmQobyArIGEgKiBlKTtcbiAgZm9yIChjID0gTWF0aC5tYXgobywgMCk7IGMgPCByOyBjKyspIGMgPT09IGggJiYgKHQucHVzaChpW2NdKSwgYSsrLCBoID0gTWF0aC5yb3VuZChvICsgYSAqIGUpKTtcbn1cbmZ1bmN0aW9uIHNsKGkpIHtcbiAgdmFyIHQgPSBpLmxlbmd0aDtcbiAgdmFyIGUsIHM7XG4gIGlmICh0IDwgMikgcmV0dXJuICExO1xuICBmb3IgKHMgPSBpWzBdLCBlID0gMTsgZSA8IHQ7ICsrZSkgaWYgKGlbZV0gLSBpW2UgLSAxXSAhPT0gcykgcmV0dXJuICExO1xuICByZXR1cm4gcztcbn1cbnZhciBubCA9IGZ1bmN0aW9uIG5sKGkpIHtcbiAgICByZXR1cm4gaSA9PT0gXCJsZWZ0XCIgPyBcInJpZ2h0XCIgOiBpID09PSBcInJpZ2h0XCIgPyBcImxlZnRcIiA6IGk7XG4gIH0sXG4gIFJzID0gZnVuY3Rpb24gUnMoaSwgdCwgZSkge1xuICAgIHJldHVybiB0ID09PSBcInRvcFwiIHx8IHQgPT09IFwibGVmdFwiID8gaVt0XSArIGUgOiBpW3RdIC0gZTtcbiAgfSxcbiAgTHMgPSBmdW5jdGlvbiBMcyhpLCB0KSB7XG4gICAgcmV0dXJuIE1hdGgubWluKHQgfHwgaSwgaSk7XG4gIH07XG5mdW5jdGlvbiBFcyhpLCB0KSB7XG4gIHZhciBlID0gW10sXG4gICAgcyA9IGkubGVuZ3RoIC8gdCxcbiAgICBuID0gaS5sZW5ndGg7XG4gIHZhciBvID0gMDtcbiAgZm9yICg7IG8gPCBuOyBvICs9IHMpIGUucHVzaChpW01hdGguZmxvb3IobyldKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBvbChpLCB0LCBlKSB7XG4gIHZhciBzID0gaS50aWNrcy5sZW5ndGgsXG4gICAgbiA9IE1hdGgubWluKHQsIHMgLSAxKSxcbiAgICBvID0gaS5fc3RhcnRQaXhlbCxcbiAgICByID0gaS5fZW5kUGl4ZWwsXG4gICAgYSA9IDFlLTY7XG4gIHZhciBsID0gaS5nZXRQaXhlbEZvclRpY2sobiksXG4gICAgYztcbiAgaWYgKCEoZSAmJiAocyA9PT0gMSA/IGMgPSBNYXRoLm1heChsIC0gbywgciAtIGwpIDogdCA9PT0gMCA/IGMgPSAoaS5nZXRQaXhlbEZvclRpY2soMSkgLSBsKSAvIDIgOiBjID0gKGwgLSBpLmdldFBpeGVsRm9yVGljayhuIC0gMSkpIC8gMiwgbCArPSBuIDwgdCA/IGMgOiAtYywgbCA8IG8gLSBhIHx8IGwgPiByICsgYSkpKSByZXR1cm4gbDtcbn1cbmZ1bmN0aW9uIHJsKGksIHQpIHtcbiAgTChpLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzID0gZS5nYyxcbiAgICAgIG4gPSBzLmxlbmd0aCAvIDI7XG4gICAgdmFyIG87XG4gICAgaWYgKG4gPiB0KSB7XG4gICAgICBmb3IgKG8gPSAwOyBvIDwgbjsgKytvKSBkZWxldGUgZS5kYXRhW3Nbb11dO1xuICAgICAgcy5zcGxpY2UoMCwgbik7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGllKGkpIHtcbiAgcmV0dXJuIGkuZHJhd1RpY2tzID8gaS50aWNrTGVuZ3RoIDogMDtcbn1cbmZ1bmN0aW9uIEZzKGksIHQpIHtcbiAgaWYgKCFpLmRpc3BsYXkpIHJldHVybiAwO1xuICB2YXIgZSA9IFgoaS5mb250LCB0KSxcbiAgICBzID0gZXQoaS5wYWRkaW5nKTtcbiAgcmV0dXJuIChOKGkudGV4dCkgPyBpLnRleHQubGVuZ3RoIDogMSkgKiBlLmxpbmVIZWlnaHQgKyBzLmhlaWdodDtcbn1cbmZ1bmN0aW9uIGFsKGksIHQpIHtcbiAgcmV0dXJuIEJ0KGksIHtcbiAgICBzY2FsZTogdCxcbiAgICB0eXBlOiBcInNjYWxlXCJcbiAgfSk7XG59XG5mdW5jdGlvbiBsbChpLCB0LCBlKSB7XG4gIHJldHVybiBCdChpLCB7XG4gICAgdGljazogZSxcbiAgICBpbmRleDogdCxcbiAgICB0eXBlOiBcInRpY2tcIlxuICB9KTtcbn1cbmZ1bmN0aW9uIGNsKGksIHQsIGUpIHtcbiAgdmFyIHMgPSB6aShpKTtcbiAgcmV0dXJuIChlICYmIHQgIT09IFwicmlnaHRcIiB8fCAhZSAmJiB0ID09PSBcInJpZ2h0XCIpICYmIChzID0gbmwocykpLCBzO1xufVxuZnVuY3Rpb24gaGwoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IGkudG9wLFxuICAgIG8gPSBpLmxlZnQsXG4gICAgciA9IGkuYm90dG9tLFxuICAgIGEgPSBpLnJpZ2h0LFxuICAgIGwgPSBpLmNoYXJ0LFxuICAgIGMgPSBsLmNoYXJ0QXJlYSxcbiAgICBoID0gbC5zY2FsZXM7XG4gIHZhciBkID0gMCxcbiAgICB1LFxuICAgIGYsXG4gICAgcDtcbiAgdmFyIGcgPSByIC0gbixcbiAgICBtID0gYSAtIG87XG4gIGlmIChpLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgaWYgKGYgPSBZKHMsIG8sIGEpLCBUKGUpKSB7XG4gICAgICB2YXIgYiA9IE9iamVjdC5rZXlzKGUpWzBdLFxuICAgICAgICBfID0gZVtiXTtcbiAgICAgIHAgPSBoW2JdLmdldFBpeGVsRm9yVmFsdWUoXykgKyBnIC0gdDtcbiAgICB9IGVsc2UgZSA9PT0gXCJjZW50ZXJcIiA/IHAgPSAoYy5ib3R0b20gKyBjLnRvcCkgLyAyICsgZyAtIHQgOiBwID0gUnMoaSwgZSwgdCk7XG4gICAgdSA9IGEgLSBvO1xuICB9IGVsc2Uge1xuICAgIGlmIChUKGUpKSB7XG4gICAgICB2YXIgX2IgPSBPYmplY3Qua2V5cyhlKVswXSxcbiAgICAgICAgXzMgPSBlW19iXTtcbiAgICAgIGYgPSBoW19iXS5nZXRQaXhlbEZvclZhbHVlKF8zKSAtIG0gKyB0O1xuICAgIH0gZWxzZSBlID09PSBcImNlbnRlclwiID8gZiA9IChjLmxlZnQgKyBjLnJpZ2h0KSAvIDIgLSBtICsgdCA6IGYgPSBScyhpLCBlLCB0KTtcbiAgICBwID0gWShzLCByLCBuKSwgZCA9IGUgPT09IFwibGVmdFwiID8gLVYgOiBWO1xuICB9XG4gIHJldHVybiB7XG4gICAgdGl0bGVYOiBmLFxuICAgIHRpdGxlWTogcCxcbiAgICBtYXhXaWR0aDogdSxcbiAgICByb3RhdGlvbjogZFxuICB9O1xufVxudmFyIEd0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3QpIHtcbiAgZnVuY3Rpb24gR3QodCkge1xuICAgIHZhciBfdGhpczg7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEd0KTtcbiAgICBfdGhpczggPSBfY2FsbFN1cGVyKHRoaXMsIEd0KSwgX3RoaXM4LmlkID0gdC5pZCwgX3RoaXM4LnR5cGUgPSB0LnR5cGUsIF90aGlzOC5vcHRpb25zID0gdm9pZCAwLCBfdGhpczguY3R4ID0gdC5jdHgsIF90aGlzOC5jaGFydCA9IHQuY2hhcnQsIF90aGlzOC50b3AgPSB2b2lkIDAsIF90aGlzOC5ib3R0b20gPSB2b2lkIDAsIF90aGlzOC5sZWZ0ID0gdm9pZCAwLCBfdGhpczgucmlnaHQgPSB2b2lkIDAsIF90aGlzOC53aWR0aCA9IHZvaWQgMCwgX3RoaXM4LmhlaWdodCA9IHZvaWQgMCwgX3RoaXM4Ll9tYXJnaW5zID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfSwgX3RoaXM4Lm1heFdpZHRoID0gdm9pZCAwLCBfdGhpczgubWF4SGVpZ2h0ID0gdm9pZCAwLCBfdGhpczgucGFkZGluZ1RvcCA9IHZvaWQgMCwgX3RoaXM4LnBhZGRpbmdCb3R0b20gPSB2b2lkIDAsIF90aGlzOC5wYWRkaW5nTGVmdCA9IHZvaWQgMCwgX3RoaXM4LnBhZGRpbmdSaWdodCA9IHZvaWQgMCwgX3RoaXM4LmF4aXMgPSB2b2lkIDAsIF90aGlzOC5sYWJlbFJvdGF0aW9uID0gdm9pZCAwLCBfdGhpczgubWluID0gdm9pZCAwLCBfdGhpczgubWF4ID0gdm9pZCAwLCBfdGhpczguX3JhbmdlID0gdm9pZCAwLCBfdGhpczgudGlja3MgPSBbXSwgX3RoaXM4Ll9ncmlkTGluZUl0ZW1zID0gbnVsbCwgX3RoaXM4Ll9sYWJlbEl0ZW1zID0gbnVsbCwgX3RoaXM4Ll9sYWJlbFNpemVzID0gbnVsbCwgX3RoaXM4Ll9sZW5ndGggPSAwLCBfdGhpczguX21heExlbmd0aCA9IDAsIF90aGlzOC5fbG9uZ2VzdFRleHRDYWNoZSA9IHt9LCBfdGhpczguX3N0YXJ0UGl4ZWwgPSB2b2lkIDAsIF90aGlzOC5fZW5kUGl4ZWwgPSB2b2lkIDAsIF90aGlzOC5fcmV2ZXJzZVBpeGVscyA9ICExLCBfdGhpczguX3VzZXJNYXggPSB2b2lkIDAsIF90aGlzOC5fdXNlck1pbiA9IHZvaWQgMCwgX3RoaXM4Ll9zdWdnZXN0ZWRNYXggPSB2b2lkIDAsIF90aGlzOC5fc3VnZ2VzdGVkTWluID0gdm9pZCAwLCBfdGhpczguX3RpY2tzTGVuZ3RoID0gMCwgX3RoaXM4Ll9ib3JkZXJWYWx1ZSA9IDAsIF90aGlzOC5fY2FjaGUgPSB7fSwgX3RoaXM4Ll9kYXRhTGltaXRzQ2FjaGVkID0gITEsIF90aGlzOC4kY29udGV4dCA9IHZvaWQgMDtcbiAgICByZXR1cm4gX3RoaXM4O1xuICB9XG4gIF9pbmhlcml0cyhHdCwgX3N0KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhHdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KHQpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSksIHRoaXMuYXhpcyA9IHQuYXhpcywgdGhpcy5fdXNlck1pbiA9IHRoaXMucGFyc2UodC5taW4pLCB0aGlzLl91c2VyTWF4ID0gdGhpcy5wYXJzZSh0Lm1heCksIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHRoaXMucGFyc2UodC5zdWdnZXN0ZWRNaW4pLCB0aGlzLl9zdWdnZXN0ZWRNYXggPSB0aGlzLnBhcnNlKHQuc3VnZ2VzdGVkTWF4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UodCwgZSkge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFVzZXJCb3VuZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VXNlckJvdW5kcygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fdXNlck1pbixcbiAgICAgICAgZSA9IHRoaXMuX3VzZXJNYXgsXG4gICAgICAgIHMgPSB0aGlzLl9zdWdnZXN0ZWRNaW4sXG4gICAgICAgIG4gPSB0aGlzLl9zdWdnZXN0ZWRNYXg7XG4gICAgICByZXR1cm4gdCA9IG90KHQsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSksIGUgPSBvdChlLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpLCBzID0gb3QocywgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSwgbiA9IG90KG4sIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSksIHtcbiAgICAgICAgbWluOiBvdCh0LCBzKSxcbiAgICAgICAgbWF4OiBvdChlLCBuKSxcbiAgICAgICAgbWluRGVmaW5lZDogcSh0KSxcbiAgICAgICAgbWF4RGVmaW5lZDogcShlKVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWluTWF4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1pbk1heCh0KSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0VXNlckJvdW5kcyA9IHRoaXMuZ2V0VXNlckJvdW5kcygpLFxuICAgICAgICBlID0gX3RoaXMkZ2V0VXNlckJvdW5kcy5taW4sXG4gICAgICAgIHMgPSBfdGhpcyRnZXRVc2VyQm91bmRzLm1heCxcbiAgICAgICAgbiA9IF90aGlzJGdldFVzZXJCb3VuZHMubWluRGVmaW5lZCxcbiAgICAgICAgbyA9IF90aGlzJGdldFVzZXJCb3VuZHMubWF4RGVmaW5lZCxcbiAgICAgICAgcjtcbiAgICAgIGlmIChuICYmIG8pIHJldHVybiB7XG4gICAgICAgIG1pbjogZSxcbiAgICAgICAgbWF4OiBzXG4gICAgICB9O1xuICAgICAgdmFyIGEgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgICBmb3IgKHZhciBsID0gMCwgYyA9IGEubGVuZ3RoOyBsIDwgYzsgKytsKSByID0gYVtsXS5jb250cm9sbGVyLmdldE1pbk1heCh0aGlzLCB0KSwgbiB8fCAoZSA9IE1hdGgubWluKGUsIHIubWluKSksIG8gfHwgKHMgPSBNYXRoLm1heChzLCByLm1heCkpO1xuICAgICAgcmV0dXJuIGUgPSBvICYmIGUgPiBzID8gcyA6IGUsIHMgPSBuICYmIGUgPiBzID8gZSA6IHMsIHtcbiAgICAgICAgbWluOiBvdChlLCBvdChzLCBlKSksXG4gICAgICAgIG1heDogb3Qocywgb3QoZSwgcykpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYWRkaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhZGRpbmcoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiB0aGlzLnBhZGRpbmdMZWZ0IHx8IDAsXG4gICAgICAgIHRvcDogdGhpcy5wYWRkaW5nVG9wIHx8IDAsXG4gICAgICAgIHJpZ2h0OiB0aGlzLnBhZGRpbmdSaWdodCB8fCAwLFxuICAgICAgICBib3R0b206IHRoaXMucGFkZGluZ0JvdHRvbSB8fCAwXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUaWNrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaWNrcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpY2tzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxzKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IHQueExhYmVscyA6IHQueUxhYmVscykgfHwgdC5sYWJlbHMgfHwgW107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsSXRlbXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxJdGVtcygpIHtcbiAgICAgIHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLmNoYXJ0LmNoYXJ0QXJlYTtcbiAgICAgIHJldHVybiB0aGlzLl9sYWJlbEl0ZW1zIHx8ICh0aGlzLl9sYWJlbEl0ZW1zID0gdGhpcy5fY29tcHV0ZUxhYmVsSXRlbXModCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiZWZvcmVMYXlvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlTGF5b3V0KCkge1xuICAgICAgdGhpcy5fY2FjaGUgPSB7fSwgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9ICExO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiZWZvcmVVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlKCkge1xuICAgICAgSSh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbdGhpc10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKHQsIGUsIHMpIHtcbiAgICAgIHZhciBfdGhpcyRvcHRpb25zNCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgbiA9IF90aGlzJG9wdGlvbnM0LmJlZ2luQXRaZXJvLFxuICAgICAgICBvID0gX3RoaXMkb3B0aW9uczQuZ3JhY2UsXG4gICAgICAgIHIgPSBfdGhpcyRvcHRpb25zNC50aWNrcyxcbiAgICAgICAgYSA9IHIuc2FtcGxlU2l6ZTtcbiAgICAgIHRoaXMuYmVmb3JlVXBkYXRlKCksIHRoaXMubWF4V2lkdGggPSB0LCB0aGlzLm1heEhlaWdodCA9IGUsIHRoaXMuX21hcmdpbnMgPSBzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGJvdHRvbTogMFxuICAgICAgfSwgcyksIHRoaXMudGlja3MgPSBudWxsLCB0aGlzLl9sYWJlbFNpemVzID0gbnVsbCwgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGwsIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsLCB0aGlzLmJlZm9yZVNldERpbWVuc2lvbnMoKSwgdGhpcy5zZXREaW1lbnNpb25zKCksIHRoaXMuYWZ0ZXJTZXREaW1lbnNpb25zKCksIHRoaXMuX21heExlbmd0aCA9IHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoICsgcy5sZWZ0ICsgcy5yaWdodCA6IHRoaXMuaGVpZ2h0ICsgcy50b3AgKyBzLmJvdHRvbSwgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCB8fCAodGhpcy5iZWZvcmVEYXRhTGltaXRzKCksIHRoaXMuZGV0ZXJtaW5lRGF0YUxpbWl0cygpLCB0aGlzLmFmdGVyRGF0YUxpbWl0cygpLCB0aGlzLl9yYW5nZSA9IHhyKHRoaXMsIG8sIG4pLCB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gITApLCB0aGlzLmJlZm9yZUJ1aWxkVGlja3MoKSwgdGhpcy50aWNrcyA9IHRoaXMuYnVpbGRUaWNrcygpIHx8IFtdLCB0aGlzLmFmdGVyQnVpbGRUaWNrcygpO1xuICAgICAgdmFyIGwgPSBhIDwgdGhpcy50aWNrcy5sZW5ndGg7XG4gICAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyhsID8gRXModGhpcy50aWNrcywgYSkgOiB0aGlzLnRpY2tzKSwgdGhpcy5jb25maWd1cmUoKSwgdGhpcy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCksIHRoaXMuY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpLCB0aGlzLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpLCByLmRpc3BsYXkgJiYgKHIuYXV0b1NraXAgfHwgci5zb3VyY2UgPT09IFwiYXV0b1wiKSAmJiAodGhpcy50aWNrcyA9IFphKHRoaXMsIHRoaXMudGlja3MpLCB0aGlzLl9sYWJlbFNpemVzID0gbnVsbCwgdGhpcy5hZnRlckF1dG9Ta2lwKCkpLCBsICYmIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRoaXMudGlja3MpLCB0aGlzLmJlZm9yZUZpdCgpLCB0aGlzLmZpdCgpLCB0aGlzLmFmdGVyRml0KCksIHRoaXMuYWZ0ZXJVcGRhdGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29uZmlndXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmZpZ3VyZSgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLnJldmVyc2UsXG4gICAgICAgIGUsXG4gICAgICAgIHM7XG4gICAgICB0aGlzLmlzSG9yaXpvbnRhbCgpID8gKGUgPSB0aGlzLmxlZnQsIHMgPSB0aGlzLnJpZ2h0KSA6IChlID0gdGhpcy50b3AsIHMgPSB0aGlzLmJvdHRvbSwgdCA9ICF0KSwgdGhpcy5fc3RhcnRQaXhlbCA9IGUsIHRoaXMuX2VuZFBpeGVsID0gcywgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IHQsIHRoaXMuX2xlbmd0aCA9IHMgLSBlLCB0aGlzLl9hbGlnblRvUGl4ZWxzID0gdGhpcy5vcHRpb25zLmFsaWduVG9QaXhlbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFmdGVyVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFmdGVyVXBkYXRlKCkge1xuICAgICAgSSh0aGlzLm9wdGlvbnMuYWZ0ZXJVcGRhdGUsIFt0aGlzXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJlZm9yZVNldERpbWVuc2lvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlU2V0RGltZW5zaW9ucygpIHtcbiAgICAgIEkodGhpcy5vcHRpb25zLmJlZm9yZVNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldERpbWVuc2lvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGltZW5zaW9ucygpIHtcbiAgICAgIHRoaXMuaXNIb3Jpem9udGFsKCkgPyAodGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGgsIHRoaXMubGVmdCA9IDAsIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoKSA6ICh0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0LCB0aGlzLnRvcCA9IDAsIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQpLCB0aGlzLnBhZGRpbmdMZWZ0ID0gMCwgdGhpcy5wYWRkaW5nVG9wID0gMCwgdGhpcy5wYWRkaW5nUmlnaHQgPSAwLCB0aGlzLnBhZGRpbmdCb3R0b20gPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZnRlclNldERpbWVuc2lvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWZ0ZXJTZXREaW1lbnNpb25zKCkge1xuICAgICAgSSh0aGlzLm9wdGlvbnMuYWZ0ZXJTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FsbEhvb2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxsSG9va3ModCkge1xuICAgICAgdGhpcy5jaGFydC5ub3RpZnlQbHVnaW5zKHQsIHRoaXMuZ2V0Q29udGV4dCgpKSwgSSh0aGlzLm9wdGlvbnNbdF0sIFt0aGlzXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJlZm9yZURhdGFMaW1pdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlRGF0YUxpbWl0cygpIHtcbiAgICAgIHRoaXMuX2NhbGxIb29rcyhcImJlZm9yZURhdGFMaW1pdHNcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRldGVybWluZURhdGFMaW1pdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWZ0ZXJEYXRhTGltaXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFmdGVyRGF0YUxpbWl0cygpIHtcbiAgICAgIHRoaXMuX2NhbGxIb29rcyhcImFmdGVyRGF0YUxpbWl0c1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmVmb3JlQnVpbGRUaWNrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmVCdWlsZFRpY2tzKCkge1xuICAgICAgdGhpcy5fY2FsbEhvb2tzKFwiYmVmb3JlQnVpbGRUaWNrc1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRUaWNrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZFRpY2tzKCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZnRlckJ1aWxkVGlja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWZ0ZXJCdWlsZFRpY2tzKCkge1xuICAgICAgdGhpcy5fY2FsbEhvb2tzKFwiYWZ0ZXJCdWlsZFRpY2tzXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgICAgSSh0aGlzLm9wdGlvbnMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZVRpY2tMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVUaWNrTGFiZWxzKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgICAgdmFyIHMsIG4sIG87XG4gICAgICBmb3IgKHMgPSAwLCBuID0gdC5sZW5ndGg7IHMgPCBuOyBzKyspIG8gPSB0W3NdLCBvLmxhYmVsID0gSShlLmNhbGxiYWNrLCBbby52YWx1ZSwgcywgdF0sIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICAgIEkodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgICBJKHRoaXMub3B0aW9ucy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVMYWJlbFJvdGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgICB2YXIgdCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZSA9IHQudGlja3MsXG4gICAgICAgIHMgPSBMcyh0aGlzLnRpY2tzLmxlbmd0aCwgdC50aWNrcy5tYXhUaWNrc0xpbWl0KSxcbiAgICAgICAgbiA9IGUubWluUm90YXRpb24gfHwgMCxcbiAgICAgICAgbyA9IGUubWF4Um90YXRpb247XG4gICAgICB2YXIgciA9IG4sXG4gICAgICAgIGEsXG4gICAgICAgIGwsXG4gICAgICAgIGM7XG4gICAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICFlLmRpc3BsYXkgfHwgbiA+PSBvIHx8IHMgPD0gMSB8fCAhdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICB0aGlzLmxhYmVsUm90YXRpb24gPSBuO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaCA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKSxcbiAgICAgICAgZCA9IGgud2lkZXN0LndpZHRoLFxuICAgICAgICB1ID0gaC5oaWdoZXN0LmhlaWdodCxcbiAgICAgICAgZiA9IFUodGhpcy5jaGFydC53aWR0aCAtIGQsIDAsIHRoaXMubWF4V2lkdGgpO1xuICAgICAgYSA9IHQub2Zmc2V0ID8gdGhpcy5tYXhXaWR0aCAvIHMgOiBmIC8gKHMgLSAxKSwgZCArIDYgPiBhICYmIChhID0gZiAvIChzIC0gKHQub2Zmc2V0ID8gMC41IDogMSkpLCBsID0gdGhpcy5tYXhIZWlnaHQgLSBpZSh0LmdyaWQpIC0gZS5wYWRkaW5nIC0gRnModC50aXRsZSwgdGhpcy5jaGFydC5vcHRpb25zLmZvbnQpLCBjID0gTWF0aC5zcXJ0KGQgKiBkICsgdSAqIHUpLCByID0gVW8oTWF0aC5taW4oTWF0aC5hc2luKFUoKGguaGlnaGVzdC5oZWlnaHQgKyA2KSAvIGEsIC0xLCAxKSksIE1hdGguYXNpbihVKGwgLyBjLCAtMSwgMSkpIC0gTWF0aC5hc2luKFUodSAvIGMsIC0xLCAxKSkpKSwgciA9IE1hdGgubWF4KG4sIE1hdGgubWluKG8sIHIpKSksIHRoaXMubGFiZWxSb3RhdGlvbiA9IHI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgICBJKHRoaXMub3B0aW9ucy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFmdGVyQXV0b1NraXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWZ0ZXJBdXRvU2tpcCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmVmb3JlRml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZm9yZUZpdCgpIHtcbiAgICAgIEkodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpdCgpIHtcbiAgICAgIHZhciB0ID0ge1xuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9LFxuICAgICAgICBlID0gdGhpcy5jaGFydCxcbiAgICAgICAgX3RoaXMkb3B0aW9uczUgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHMgPSBfdGhpcyRvcHRpb25zNS50aWNrcyxcbiAgICAgICAgbiA9IF90aGlzJG9wdGlvbnM1LnRpdGxlLFxuICAgICAgICBvID0gX3RoaXMkb3B0aW9uczUuZ3JpZCxcbiAgICAgICAgciA9IHRoaXMuX2lzVmlzaWJsZSgpLFxuICAgICAgICBhID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICAgIGlmIChyKSB7XG4gICAgICAgIHZhciBsID0gRnMobiwgZS5vcHRpb25zLmZvbnQpO1xuICAgICAgICBpZiAoYSA/ICh0LndpZHRoID0gdGhpcy5tYXhXaWR0aCwgdC5oZWlnaHQgPSBpZShvKSArIGwpIDogKHQuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQsIHQud2lkdGggPSBpZShvKSArIGwpLCBzLmRpc3BsYXkgJiYgdGhpcy50aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkX2dldExhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCksXG4gICAgICAgICAgICBjID0gX3RoaXMkX2dldExhYmVsU2l6ZXMuZmlyc3QsXG4gICAgICAgICAgICBoID0gX3RoaXMkX2dldExhYmVsU2l6ZXMubGFzdCxcbiAgICAgICAgICAgIGQgPSBfdGhpcyRfZ2V0TGFiZWxTaXplcy53aWRlc3QsXG4gICAgICAgICAgICB1ID0gX3RoaXMkX2dldExhYmVsU2l6ZXMuaGlnaGVzdCxcbiAgICAgICAgICAgIGYgPSBzLnBhZGRpbmcgKiAyLFxuICAgICAgICAgICAgcCA9IGJ0KHRoaXMubGFiZWxSb3RhdGlvbiksXG4gICAgICAgICAgICBnID0gTWF0aC5jb3MocCksXG4gICAgICAgICAgICBtID0gTWF0aC5zaW4ocCk7XG4gICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgIHZhciBiID0gcy5taXJyb3IgPyAwIDogbSAqIGQud2lkdGggKyBnICogdS5oZWlnaHQ7XG4gICAgICAgICAgICB0LmhlaWdodCA9IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCB0LmhlaWdodCArIGIgKyBmKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9iMiA9IHMubWlycm9yID8gMCA6IGcgKiBkLndpZHRoICsgbSAqIHUuaGVpZ2h0O1xuICAgICAgICAgICAgdC53aWR0aCA9IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIHQud2lkdGggKyBfYjIgKyBmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY2FsY3VsYXRlUGFkZGluZyhjLCBoLCBtLCBnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faGFuZGxlTWFyZ2lucygpLCBhID8gKHRoaXMud2lkdGggPSB0aGlzLl9sZW5ndGggPSBlLndpZHRoIC0gdGhpcy5fbWFyZ2lucy5sZWZ0IC0gdGhpcy5fbWFyZ2lucy5yaWdodCwgdGhpcy5oZWlnaHQgPSB0LmhlaWdodCkgOiAodGhpcy53aWR0aCA9IHQud2lkdGgsIHRoaXMuaGVpZ2h0ID0gdGhpcy5fbGVuZ3RoID0gZS5oZWlnaHQgLSB0aGlzLl9tYXJnaW5zLnRvcCAtIHRoaXMuX21hcmdpbnMuYm90dG9tKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZVBhZGRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZVBhZGRpbmcodCwgZSwgcywgbikge1xuICAgICAgdmFyIF90aGlzJG9wdGlvbnM2ID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBfdGhpcyRvcHRpb25zNiR0aWNrcyA9IF90aGlzJG9wdGlvbnM2LnRpY2tzLFxuICAgICAgICBvID0gX3RoaXMkb3B0aW9uczYkdGlja3MuYWxpZ24sXG4gICAgICAgIHIgPSBfdGhpcyRvcHRpb25zNiR0aWNrcy5wYWRkaW5nLFxuICAgICAgICBhID0gX3RoaXMkb3B0aW9uczYucG9zaXRpb24sXG4gICAgICAgIGwgPSB0aGlzLmxhYmVsUm90YXRpb24gIT09IDAsXG4gICAgICAgIGMgPSBhICE9PSBcInRvcFwiICYmIHRoaXMuYXhpcyA9PT0gXCJ4XCI7XG4gICAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICB2YXIgaCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKDApIC0gdGhpcy5sZWZ0LFxuICAgICAgICAgIGQgPSB0aGlzLnJpZ2h0IC0gdGhpcy5nZXRQaXhlbEZvclRpY2sodGhpcy50aWNrcy5sZW5ndGggLSAxKTtcbiAgICAgICAgdmFyIHUgPSAwLFxuICAgICAgICAgIGYgPSAwO1xuICAgICAgICBsID8gYyA/ICh1ID0gbiAqIHQud2lkdGgsIGYgPSBzICogZS5oZWlnaHQpIDogKHUgPSBzICogdC5oZWlnaHQsIGYgPSBuICogZS53aWR0aCkgOiBvID09PSBcInN0YXJ0XCIgPyBmID0gZS53aWR0aCA6IG8gPT09IFwiZW5kXCIgPyB1ID0gdC53aWR0aCA6IG8gIT09IFwiaW5uZXJcIiAmJiAodSA9IHQud2lkdGggLyAyLCBmID0gZS53aWR0aCAvIDIpLCB0aGlzLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgoKHUgLSBoICsgcikgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBoKSwgMCksIHRoaXMucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgoKGYgLSBkICsgcikgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBkKSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2gyID0gZS5oZWlnaHQgLyAyLFxuICAgICAgICAgIF9kMyA9IHQuaGVpZ2h0IC8gMjtcbiAgICAgICAgbyA9PT0gXCJzdGFydFwiID8gKF9oMiA9IDAsIF9kMyA9IHQuaGVpZ2h0KSA6IG8gPT09IFwiZW5kXCIgJiYgKF9oMiA9IGUuaGVpZ2h0LCBfZDMgPSAwKSwgdGhpcy5wYWRkaW5nVG9wID0gX2gyICsgciwgdGhpcy5wYWRkaW5nQm90dG9tID0gX2QzICsgcjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZU1hcmdpbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZU1hcmdpbnMoKSB7XG4gICAgICB0aGlzLl9tYXJnaW5zICYmICh0aGlzLl9tYXJnaW5zLmxlZnQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdMZWZ0LCB0aGlzLl9tYXJnaW5zLmxlZnQpLCB0aGlzLl9tYXJnaW5zLnRvcCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1RvcCwgdGhpcy5fbWFyZ2lucy50b3ApLCB0aGlzLl9tYXJnaW5zLnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nUmlnaHQsIHRoaXMuX21hcmdpbnMucmlnaHQpLCB0aGlzLl9tYXJnaW5zLmJvdHRvbSA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0JvdHRvbSwgdGhpcy5fbWFyZ2lucy5ib3R0b20pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWZ0ZXJGaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWZ0ZXJGaXQoKSB7XG4gICAgICBJKHRoaXMub3B0aW9ucy5hZnRlckZpdCwgW3RoaXNdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNIb3Jpem9udGFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzSG9yaXpvbnRhbCgpIHtcbiAgICAgIHZhciBfdGhpcyRvcHRpb25zNyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgdCA9IF90aGlzJG9wdGlvbnM3LmF4aXMsXG4gICAgICAgIGUgPSBfdGhpcyRvcHRpb25zNy5wb3NpdGlvbjtcbiAgICAgIHJldHVybiBlID09PSBcInRvcFwiIHx8IGUgPT09IFwiYm90dG9tXCIgfHwgdCA9PT0gXCJ4XCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRnVsbFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNGdWxsU2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZnVsbFNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jb252ZXJ0VGlja3NUb0xhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udmVydFRpY2tzVG9MYWJlbHModCkge1xuICAgICAgdGhpcy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKSwgdGhpcy5nZW5lcmF0ZVRpY2tMYWJlbHModCk7XG4gICAgICB2YXIgZSwgcztcbiAgICAgIGZvciAoZSA9IDAsIHMgPSB0Lmxlbmd0aDsgZSA8IHM7IGUrKykgUih0W2VdLmxhYmVsKSAmJiAodC5zcGxpY2UoZSwgMSksIHMtLSwgZS0tKTtcbiAgICAgIHRoaXMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldExhYmVsU2l6ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldExhYmVsU2l6ZXMoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2xhYmVsU2l6ZXM7XG4gICAgICBpZiAoIXQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLm9wdGlvbnMudGlja3Muc2FtcGxlU2l6ZTtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnRpY2tzO1xuICAgICAgICBlIDwgcy5sZW5ndGggJiYgKHMgPSBFcyhzLCBlKSksIHRoaXMuX2xhYmVsU2l6ZXMgPSB0ID0gdGhpcy5fY29tcHV0ZUxhYmVsU2l6ZXMocywgcy5sZW5ndGgsIHRoaXMub3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY29tcHV0ZUxhYmVsU2l6ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXB1dGVMYWJlbFNpemVzKHQsIGUsIHMpIHtcbiAgICAgIHZhciBuID0gdGhpcy5jdHgsXG4gICAgICAgIG8gPSB0aGlzLl9sb25nZXN0VGV4dENhY2hlLFxuICAgICAgICByID0gW10sXG4gICAgICAgIGEgPSBbXSxcbiAgICAgICAgbCA9IE1hdGguZmxvb3IoZSAvIExzKGUsIHMpKTtcbiAgICAgIHZhciBjID0gMCxcbiAgICAgICAgaCA9IDAsXG4gICAgICAgIGQsXG4gICAgICAgIHUsXG4gICAgICAgIGYsXG4gICAgICAgIHAsXG4gICAgICAgIGcsXG4gICAgICAgIG0sXG4gICAgICAgIGIsXG4gICAgICAgIF8sXG4gICAgICAgIHYsXG4gICAgICAgIHksXG4gICAgICAgIHg7XG4gICAgICBmb3IgKGQgPSAwOyBkIDwgZTsgZCArPSBsKSB7XG4gICAgICAgIGlmIChwID0gdFtkXS5sYWJlbCwgZyA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoZCksIG4uZm9udCA9IG0gPSBnLnN0cmluZywgYiA9IG9bbV0gPSBvW21dIHx8IHtcbiAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICBnYzogW11cbiAgICAgICAgfSwgXyA9IGcubGluZUhlaWdodCwgdiA9IHkgPSAwLCAhUihwKSAmJiAhTihwKSkgdiA9IGxzKG4sIGIuZGF0YSwgYi5nYywgdiwgcCksIHkgPSBfO2Vsc2UgaWYgKE4ocCkpIGZvciAodSA9IDAsIGYgPSBwLmxlbmd0aDsgdSA8IGY7ICsrdSkgeCA9IHBbdV0sICFSKHgpICYmICFOKHgpICYmICh2ID0gbHMobiwgYi5kYXRhLCBiLmdjLCB2LCB4KSwgeSArPSBfKTtcbiAgICAgICAgci5wdXNoKHYpLCBhLnB1c2goeSksIGMgPSBNYXRoLm1heCh2LCBjKSwgaCA9IE1hdGgubWF4KHksIGgpO1xuICAgICAgfVxuICAgICAgcmwobywgZSk7XG4gICAgICB2YXIgTSA9IHIuaW5kZXhPZihjKSxcbiAgICAgICAgUyA9IGEuaW5kZXhPZihoKSxcbiAgICAgICAgayA9IGZ1bmN0aW9uIGsoUCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogcltQXSB8fCAwLFxuICAgICAgICAgICAgaGVpZ2h0OiBhW1BdIHx8IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmlyc3Q6IGsoMCksXG4gICAgICAgIGxhc3Q6IGsoZSAtIDEpLFxuICAgICAgICB3aWRlc3Q6IGsoTSksXG4gICAgICAgIGhpZ2hlc3Q6IGsoUyksXG4gICAgICAgIHdpZHRoczogcixcbiAgICAgICAgaGVpZ2h0czogYVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGFiZWxGb3JWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbEZvclZhbHVlKHQpIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQaXhlbEZvclZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBpeGVsRm9yVmFsdWUodCwgZSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmFsdWVGb3JQaXhlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZUZvclBpeGVsKHQpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGl4ZWxGb3JUaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBpeGVsRm9yVGljayh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMudGlja3M7XG4gICAgICByZXR1cm4gdCA8IDAgfHwgdCA+IGUubGVuZ3RoIC0gMSA/IG51bGwgOiB0aGlzLmdldFBpeGVsRm9yVmFsdWUoZVt0XS52YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBpeGVsRm9yRGVjaW1hbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQaXhlbEZvckRlY2ltYWwodCkge1xuICAgICAgdGhpcy5fcmV2ZXJzZVBpeGVscyAmJiAodCA9IDEgLSB0KTtcbiAgICAgIHZhciBlID0gdGhpcy5fc3RhcnRQaXhlbCArIHQgKiB0aGlzLl9sZW5ndGg7XG4gICAgICByZXR1cm4gcW8odGhpcy5fYWxpZ25Ub1BpeGVscyA/IE90KHRoaXMuY2hhcnQsIGUsIDApIDogZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERlY2ltYWxGb3JQaXhlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWNpbWFsRm9yUGl4ZWwodCkge1xuICAgICAgdmFyIGUgPSAodCAtIHRoaXMuX3N0YXJ0UGl4ZWwpIC8gdGhpcy5fbGVuZ3RoO1xuICAgICAgcmV0dXJuIHRoaXMuX3JldmVyc2VQaXhlbHMgPyAxIC0gZSA6IGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJhc2VQaXhlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCYXNlVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmFzZVZhbHVlKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLm1pbixcbiAgICAgICAgZSA9IHRoaXMubWF4O1xuICAgICAgcmV0dXJuIHQgPCAwICYmIGUgPCAwID8gZSA6IHQgPiAwICYmIGUgPiAwID8gdCA6IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGV4dCh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMudGlja3MgfHwgW107XG4gICAgICBpZiAodCA+PSAwICYmIHQgPCBlLmxlbmd0aCkge1xuICAgICAgICB2YXIgcyA9IGVbdF07XG4gICAgICAgIHJldHVybiBzLiRjb250ZXh0IHx8IChzLiRjb250ZXh0ID0gbGwodGhpcy5nZXRDb250ZXh0KCksIHQsIHMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8ICh0aGlzLiRjb250ZXh0ID0gYWwodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3RpY2tTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90aWNrU2l6ZSgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLnRpY2tzLFxuICAgICAgICBlID0gYnQodGhpcy5sYWJlbFJvdGF0aW9uKSxcbiAgICAgICAgcyA9IE1hdGguYWJzKE1hdGguY29zKGUpKSxcbiAgICAgICAgbiA9IE1hdGguYWJzKE1hdGguc2luKGUpKSxcbiAgICAgICAgbyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKSxcbiAgICAgICAgciA9IHQuYXV0b1NraXBQYWRkaW5nIHx8IDAsXG4gICAgICAgIGEgPSBvID8gby53aWRlc3Qud2lkdGggKyByIDogMCxcbiAgICAgICAgbCA9IG8gPyBvLmhpZ2hlc3QuaGVpZ2h0ICsgciA6IDA7XG4gICAgICByZXR1cm4gdGhpcy5pc0hvcml6b250YWwoKSA/IGwgKiBzID4gYSAqIG4gPyBhIC8gcyA6IGwgLyBuIDogbCAqIG4gPCBhICogcyA/IGwgLyBzIDogYSAvIG47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pc1Zpc2libGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzVmlzaWJsZSgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLmRpc3BsYXk7XG4gICAgICByZXR1cm4gdCAhPT0gXCJhdXRvXCIgPyAhIXQgOiB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCkubGVuZ3RoID4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbXB1dGVHcmlkTGluZUl0ZW1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21wdXRlR3JpZExpbmVJdGVtcyh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuYXhpcyxcbiAgICAgICAgcyA9IHRoaXMuY2hhcnQsXG4gICAgICAgIG4gPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIG8gPSBuLmdyaWQsXG4gICAgICAgIHIgPSBuLnBvc2l0aW9uLFxuICAgICAgICBhID0gbi5ib3JkZXIsXG4gICAgICAgIGwgPSBvLm9mZnNldCxcbiAgICAgICAgYyA9IHRoaXMuaXNIb3Jpem9udGFsKCksXG4gICAgICAgIGQgPSB0aGlzLnRpY2tzLmxlbmd0aCArIChsID8gMSA6IDApLFxuICAgICAgICB1ID0gaWUobyksXG4gICAgICAgIGYgPSBbXSxcbiAgICAgICAgcCA9IGEuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSksXG4gICAgICAgIGcgPSBwLmRpc3BsYXkgPyBwLndpZHRoIDogMCxcbiAgICAgICAgbSA9IGcgLyAyLFxuICAgICAgICBiID0gZnVuY3Rpb24gYih6KSB7XG4gICAgICAgICAgcmV0dXJuIE90KHMsIHosIGcpO1xuICAgICAgICB9O1xuICAgICAgdmFyIF8sIHYsIHksIHgsIE0sIFMsIGssIFAsIEMsIE8sIEEsIGo7XG4gICAgICBpZiAociA9PT0gXCJ0b3BcIikgXyA9IGIodGhpcy5ib3R0b20pLCBTID0gdGhpcy5ib3R0b20gLSB1LCBQID0gXyAtIG0sIE8gPSBiKHQudG9wKSArIG0sIGogPSB0LmJvdHRvbTtlbHNlIGlmIChyID09PSBcImJvdHRvbVwiKSBfID0gYih0aGlzLnRvcCksIE8gPSB0LnRvcCwgaiA9IGIodC5ib3R0b20pIC0gbSwgUyA9IF8gKyBtLCBQID0gdGhpcy50b3AgKyB1O2Vsc2UgaWYgKHIgPT09IFwibGVmdFwiKSBfID0gYih0aGlzLnJpZ2h0KSwgTSA9IHRoaXMucmlnaHQgLSB1LCBrID0gXyAtIG0sIEMgPSBiKHQubGVmdCkgKyBtLCBBID0gdC5yaWdodDtlbHNlIGlmIChyID09PSBcInJpZ2h0XCIpIF8gPSBiKHRoaXMubGVmdCksIEMgPSB0LmxlZnQsIEEgPSBiKHQucmlnaHQpIC0gbSwgTSA9IF8gKyBtLCBrID0gdGhpcy5sZWZ0ICsgdTtlbHNlIGlmIChlID09PSBcInhcIikge1xuICAgICAgICBpZiAociA9PT0gXCJjZW50ZXJcIikgXyA9IGIoKHQudG9wICsgdC5ib3R0b20pIC8gMiArIDAuNSk7ZWxzZSBpZiAoVChyKSkge1xuICAgICAgICAgIHZhciB6ID0gT2JqZWN0LmtleXMocilbMF0sXG4gICAgICAgICAgICBIID0gclt6XTtcbiAgICAgICAgICBfID0gYih0aGlzLmNoYXJ0LnNjYWxlc1t6XS5nZXRQaXhlbEZvclZhbHVlKEgpKTtcbiAgICAgICAgfVxuICAgICAgICBPID0gdC50b3AsIGogPSB0LmJvdHRvbSwgUyA9IF8gKyBtLCBQID0gUyArIHU7XG4gICAgICB9IGVsc2UgaWYgKGUgPT09IFwieVwiKSB7XG4gICAgICAgIGlmIChyID09PSBcImNlbnRlclwiKSBfID0gYigodC5sZWZ0ICsgdC5yaWdodCkgLyAyKTtlbHNlIGlmIChUKHIpKSB7XG4gICAgICAgICAgdmFyIF96ID0gT2JqZWN0LmtleXMocilbMF0sXG4gICAgICAgICAgICBfSCA9IHJbX3pdO1xuICAgICAgICAgIF8gPSBiKHRoaXMuY2hhcnQuc2NhbGVzW196XS5nZXRQaXhlbEZvclZhbHVlKF9IKSk7XG4gICAgICAgIH1cbiAgICAgICAgTSA9IF8gLSBtLCBrID0gTSAtIHUsIEMgPSB0LmxlZnQsIEEgPSB0LnJpZ2h0O1xuICAgICAgfVxuICAgICAgdmFyIEogPSBEKG4udGlja3MubWF4VGlja3NMaW1pdCwgZCksXG4gICAgICAgIEYgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwoZCAvIEopKTtcbiAgICAgIGZvciAodiA9IDA7IHYgPCBkOyB2ICs9IEYpIHtcbiAgICAgICAgdmFyIF96MiA9IHRoaXMuZ2V0Q29udGV4dCh2KSxcbiAgICAgICAgICBfSDIgPSBvLnNldENvbnRleHQoX3oyKSxcbiAgICAgICAgICBpdCA9IGEuc2V0Q29udGV4dChfejIpLFxuICAgICAgICAgICQgPSBfSDIubGluZVdpZHRoLFxuICAgICAgICAgIEh0ID0gX0gyLmNvbG9yLFxuICAgICAgICAgIHllID0gaXQuZGFzaCB8fCBbXSxcbiAgICAgICAgICBXdCA9IGl0LmRhc2hPZmZzZXQsXG4gICAgICAgICAgSnQgPSBfSDIudGlja1dpZHRoLFxuICAgICAgICAgIFB0ID0gX0gyLnRpY2tDb2xvcixcbiAgICAgICAgICBadCA9IF9IMi50aWNrQm9yZGVyRGFzaCB8fCBbXSxcbiAgICAgICAgICBEdCA9IF9IMi50aWNrQm9yZGVyRGFzaE9mZnNldDtcbiAgICAgICAgeSA9IG9sKHRoaXMsIHYsIGwpLCB5ICE9PSB2b2lkIDAgJiYgKHggPSBPdChzLCB5LCAkKSwgYyA/IE0gPSBrID0gQyA9IEEgPSB4IDogUyA9IFAgPSBPID0gaiA9IHgsIGYucHVzaCh7XG4gICAgICAgICAgdHgxOiBNLFxuICAgICAgICAgIHR5MTogUyxcbiAgICAgICAgICB0eDI6IGssXG4gICAgICAgICAgdHkyOiBQLFxuICAgICAgICAgIHgxOiBDLFxuICAgICAgICAgIHkxOiBPLFxuICAgICAgICAgIHgyOiBBLFxuICAgICAgICAgIHkyOiBqLFxuICAgICAgICAgIHdpZHRoOiAkLFxuICAgICAgICAgIGNvbG9yOiBIdCxcbiAgICAgICAgICBib3JkZXJEYXNoOiB5ZSxcbiAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBXdCxcbiAgICAgICAgICB0aWNrV2lkdGg6IEp0LFxuICAgICAgICAgIHRpY2tDb2xvcjogUHQsXG4gICAgICAgICAgdGlja0JvcmRlckRhc2g6IFp0LFxuICAgICAgICAgIHRpY2tCb3JkZXJEYXNoT2Zmc2V0OiBEdFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fdGlja3NMZW5ndGggPSBkLCB0aGlzLl9ib3JkZXJWYWx1ZSA9IF8sIGY7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jb21wdXRlTGFiZWxJdGVtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29tcHV0ZUxhYmVsSXRlbXModCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmF4aXMsXG4gICAgICAgIHMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIG4gPSBzLnBvc2l0aW9uLFxuICAgICAgICBvID0gcy50aWNrcyxcbiAgICAgICAgciA9IHRoaXMuaXNIb3Jpem9udGFsKCksXG4gICAgICAgIGEgPSB0aGlzLnRpY2tzLFxuICAgICAgICBsID0gby5hbGlnbixcbiAgICAgICAgYyA9IG8uY3Jvc3NBbGlnbixcbiAgICAgICAgaCA9IG8ucGFkZGluZyxcbiAgICAgICAgZCA9IG8ubWlycm9yLFxuICAgICAgICB1ID0gaWUocy5ncmlkKSxcbiAgICAgICAgZiA9IHUgKyBoLFxuICAgICAgICBwID0gZCA/IC1oIDogZixcbiAgICAgICAgZyA9IC1idCh0aGlzLmxhYmVsUm90YXRpb24pLFxuICAgICAgICBtID0gW107XG4gICAgICB2YXIgYixcbiAgICAgICAgXyxcbiAgICAgICAgdixcbiAgICAgICAgeSxcbiAgICAgICAgeCxcbiAgICAgICAgTSxcbiAgICAgICAgUyxcbiAgICAgICAgayxcbiAgICAgICAgUCxcbiAgICAgICAgQyxcbiAgICAgICAgTyxcbiAgICAgICAgQSxcbiAgICAgICAgaiA9IFwibWlkZGxlXCI7XG4gICAgICBpZiAobiA9PT0gXCJ0b3BcIikgTSA9IHRoaXMuYm90dG9tIC0gcCwgUyA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtlbHNlIGlmIChuID09PSBcImJvdHRvbVwiKSBNID0gdGhpcy50b3AgKyBwLCBTID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO2Vsc2UgaWYgKG4gPT09IFwibGVmdFwiKSB7XG4gICAgICAgIHZhciBGID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh1KTtcbiAgICAgICAgUyA9IEYudGV4dEFsaWduLCB4ID0gRi54O1xuICAgICAgfSBlbHNlIGlmIChuID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgdmFyIF9GID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh1KTtcbiAgICAgICAgUyA9IF9GLnRleHRBbGlnbiwgeCA9IF9GLng7XG4gICAgICB9IGVsc2UgaWYgKGUgPT09IFwieFwiKSB7XG4gICAgICAgIGlmIChuID09PSBcImNlbnRlclwiKSBNID0gKHQudG9wICsgdC5ib3R0b20pIC8gMiArIGY7ZWxzZSBpZiAoVChuKSkge1xuICAgICAgICAgIHZhciBfRjIgPSBPYmplY3Qua2V5cyhuKVswXSxcbiAgICAgICAgICAgIHogPSBuW19GMl07XG4gICAgICAgICAgTSA9IHRoaXMuY2hhcnQuc2NhbGVzW19GMl0uZ2V0UGl4ZWxGb3JWYWx1ZSh6KSArIGY7XG4gICAgICAgIH1cbiAgICAgICAgUyA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICAgIH0gZWxzZSBpZiAoZSA9PT0gXCJ5XCIpIHtcbiAgICAgICAgaWYgKG4gPT09IFwiY2VudGVyXCIpIHggPSAodC5sZWZ0ICsgdC5yaWdodCkgLyAyIC0gZjtlbHNlIGlmIChUKG4pKSB7XG4gICAgICAgICAgdmFyIF9GMyA9IE9iamVjdC5rZXlzKG4pWzBdLFxuICAgICAgICAgICAgX3ozID0gbltfRjNdO1xuICAgICAgICAgIHggPSB0aGlzLmNoYXJ0LnNjYWxlc1tfRjNdLmdldFBpeGVsRm9yVmFsdWUoX3ozKTtcbiAgICAgICAgfVxuICAgICAgICBTID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh1KS50ZXh0QWxpZ247XG4gICAgICB9XG4gICAgICBlID09PSBcInlcIiAmJiAobCA9PT0gXCJzdGFydFwiID8gaiA9IFwidG9wXCIgOiBsID09PSBcImVuZFwiICYmIChqID0gXCJib3R0b21cIikpO1xuICAgICAgdmFyIEogPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgICBmb3IgKGIgPSAwLCBfID0gYS5sZW5ndGg7IGIgPCBfOyArK2IpIHtcbiAgICAgICAgdiA9IGFbYl0sIHkgPSB2LmxhYmVsO1xuICAgICAgICB2YXIgX0Y0ID0gby5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChiKSk7XG4gICAgICAgIGsgPSB0aGlzLmdldFBpeGVsRm9yVGljayhiKSArIG8ubGFiZWxPZmZzZXQsIFAgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGIpLCBDID0gUC5saW5lSGVpZ2h0LCBPID0gTih5KSA/IHkubGVuZ3RoIDogMTtcbiAgICAgICAgdmFyIF96NCA9IE8gLyAyLFxuICAgICAgICAgIEggPSBfRjQuY29sb3IsXG4gICAgICAgICAgaXQgPSBfRjQudGV4dFN0cm9rZUNvbG9yLFxuICAgICAgICAgICQgPSBfRjQudGV4dFN0cm9rZVdpZHRoO1xuICAgICAgICB2YXIgSHQgPSBTO1xuICAgICAgICByID8gKHggPSBrLCBTID09PSBcImlubmVyXCIgJiYgKGIgPT09IF8gLSAxID8gSHQgPSB0aGlzLm9wdGlvbnMucmV2ZXJzZSA/IFwibGVmdFwiIDogXCJyaWdodFwiIDogYiA9PT0gMCA/IEh0ID0gdGhpcy5vcHRpb25zLnJldmVyc2UgPyBcInJpZ2h0XCIgOiBcImxlZnRcIiA6IEh0ID0gXCJjZW50ZXJcIiksIG4gPT09IFwidG9wXCIgPyBjID09PSBcIm5lYXJcIiB8fCBnICE9PSAwID8gQSA9IC1PICogQyArIEMgLyAyIDogYyA9PT0gXCJjZW50ZXJcIiA/IEEgPSAtSi5oaWdoZXN0LmhlaWdodCAvIDIgLSBfejQgKiBDICsgQyA6IEEgPSAtSi5oaWdoZXN0LmhlaWdodCArIEMgLyAyIDogYyA9PT0gXCJuZWFyXCIgfHwgZyAhPT0gMCA/IEEgPSBDIC8gMiA6IGMgPT09IFwiY2VudGVyXCIgPyBBID0gSi5oaWdoZXN0LmhlaWdodCAvIDIgLSBfejQgKiBDIDogQSA9IEouaGlnaGVzdC5oZWlnaHQgLSBPICogQywgZCAmJiAoQSAqPSAtMSksIGcgIT09IDAgJiYgIV9GNC5zaG93TGFiZWxCYWNrZHJvcCAmJiAoeCArPSBDIC8gMiAqIE1hdGguc2luKGcpKSkgOiAoTSA9IGssIEEgPSAoMSAtIE8pICogQyAvIDIpO1xuICAgICAgICB2YXIgeWUgPSB2b2lkIDA7XG4gICAgICAgIGlmIChfRjQuc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgICB2YXIgV3QgPSBldChfRjQuYmFja2Ryb3BQYWRkaW5nKSxcbiAgICAgICAgICAgIEp0ID0gSi5oZWlnaHRzW2JdLFxuICAgICAgICAgICAgUHQgPSBKLndpZHRoc1tiXTtcbiAgICAgICAgICB2YXIgWnQgPSBBIC0gV3QudG9wLFxuICAgICAgICAgICAgRHQgPSAwIC0gV3QubGVmdDtcbiAgICAgICAgICBzd2l0Y2ggKGopIHtcbiAgICAgICAgICAgIGNhc2UgXCJtaWRkbGVcIjpcbiAgICAgICAgICAgICAgWnQgLT0gSnQgLyAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICAgICAgWnQgLT0gSnQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKFMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgICAgICAgICAgRHQgLT0gUHQgLyAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICBEdCAtPSBQdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaW5uZXJcIjpcbiAgICAgICAgICAgICAgYiA9PT0gXyAtIDEgPyBEdCAtPSBQdCA6IGIgPiAwICYmIChEdCAtPSBQdCAvIDIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgeWUgPSB7XG4gICAgICAgICAgICBsZWZ0OiBEdCxcbiAgICAgICAgICAgIHRvcDogWnQsXG4gICAgICAgICAgICB3aWR0aDogUHQgKyBXdC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogSnQgKyBXdC5oZWlnaHQsXG4gICAgICAgICAgICBjb2xvcjogX0Y0LmJhY2tkcm9wQ29sb3JcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIG0ucHVzaCh7XG4gICAgICAgICAgbGFiZWw6IHksXG4gICAgICAgICAgZm9udDogUCxcbiAgICAgICAgICB0ZXh0T2Zmc2V0OiBBLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHJvdGF0aW9uOiBnLFxuICAgICAgICAgICAgY29sb3I6IEgsXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogaXQsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogJCxcbiAgICAgICAgICAgIHRleHRBbGlnbjogSHQsXG4gICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IGosXG4gICAgICAgICAgICB0cmFuc2xhdGlvbjogW3gsIE1dLFxuICAgICAgICAgICAgYmFja2Ryb3A6IHllXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0WEF4aXNMYWJlbEFsaWdubWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpIHtcbiAgICAgIHZhciBfdGhpcyRvcHRpb25zOCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgdCA9IF90aGlzJG9wdGlvbnM4LnBvc2l0aW9uLFxuICAgICAgICBlID0gX3RoaXMkb3B0aW9uczgudGlja3M7XG4gICAgICBpZiAoLWJ0KHRoaXMubGFiZWxSb3RhdGlvbikpIHJldHVybiB0ID09PSBcInRvcFwiID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XG4gICAgICB2YXIgbiA9IFwiY2VudGVyXCI7XG4gICAgICByZXR1cm4gZS5hbGlnbiA9PT0gXCJzdGFydFwiID8gbiA9IFwibGVmdFwiIDogZS5hbGlnbiA9PT0gXCJlbmRcIiA/IG4gPSBcInJpZ2h0XCIgOiBlLmFsaWduID09PSBcImlubmVyXCIgJiYgKG4gPSBcImlubmVyXCIpLCBuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0WUF4aXNMYWJlbEFsaWdubWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0KSB7XG4gICAgICB2YXIgX3RoaXMkb3B0aW9uczkgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGUgPSBfdGhpcyRvcHRpb25zOS5wb3NpdGlvbixcbiAgICAgICAgX3RoaXMkb3B0aW9uczkkdGlja3MgPSBfdGhpcyRvcHRpb25zOS50aWNrcyxcbiAgICAgICAgcyA9IF90aGlzJG9wdGlvbnM5JHRpY2tzLmNyb3NzQWxpZ24sXG4gICAgICAgIG4gPSBfdGhpcyRvcHRpb25zOSR0aWNrcy5taXJyb3IsXG4gICAgICAgIG8gPSBfdGhpcyRvcHRpb25zOSR0aWNrcy5wYWRkaW5nLFxuICAgICAgICByID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpLFxuICAgICAgICBhID0gdCArIG8sXG4gICAgICAgIGwgPSByLndpZGVzdC53aWR0aDtcbiAgICAgIHZhciBjLCBoO1xuICAgICAgcmV0dXJuIGUgPT09IFwibGVmdFwiID8gbiA/IChoID0gdGhpcy5yaWdodCArIG8sIHMgPT09IFwibmVhclwiID8gYyA9IFwibGVmdFwiIDogcyA9PT0gXCJjZW50ZXJcIiA/IChjID0gXCJjZW50ZXJcIiwgaCArPSBsIC8gMikgOiAoYyA9IFwicmlnaHRcIiwgaCArPSBsKSkgOiAoaCA9IHRoaXMucmlnaHQgLSBhLCBzID09PSBcIm5lYXJcIiA/IGMgPSBcInJpZ2h0XCIgOiBzID09PSBcImNlbnRlclwiID8gKGMgPSBcImNlbnRlclwiLCBoIC09IGwgLyAyKSA6IChjID0gXCJsZWZ0XCIsIGggPSB0aGlzLmxlZnQpKSA6IGUgPT09IFwicmlnaHRcIiA/IG4gPyAoaCA9IHRoaXMubGVmdCArIG8sIHMgPT09IFwibmVhclwiID8gYyA9IFwicmlnaHRcIiA6IHMgPT09IFwiY2VudGVyXCIgPyAoYyA9IFwiY2VudGVyXCIsIGggLT0gbCAvIDIpIDogKGMgPSBcImxlZnRcIiwgaCAtPSBsKSkgOiAoaCA9IHRoaXMubGVmdCArIGEsIHMgPT09IFwibmVhclwiID8gYyA9IFwibGVmdFwiIDogcyA9PT0gXCJjZW50ZXJcIiA/IChjID0gXCJjZW50ZXJcIiwgaCArPSBsIC8gMikgOiAoYyA9IFwicmlnaHRcIiwgaCA9IHRoaXMucmlnaHQpKSA6IGMgPSBcInJpZ2h0XCIsIHtcbiAgICAgICAgdGV4dEFsaWduOiBjLFxuICAgICAgICB4OiBoXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY29tcHV0ZUxhYmVsQXJlYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29tcHV0ZUxhYmVsQXJlYSgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGlja3MubWlycm9yKSByZXR1cm47XG4gICAgICB2YXIgdCA9IHRoaXMuY2hhcnQsXG4gICAgICAgIGUgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgICBpZiAoZSA9PT0gXCJsZWZ0XCIgfHwgZSA9PT0gXCJyaWdodFwiKSByZXR1cm4ge1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IHRoaXMubGVmdCxcbiAgICAgICAgYm90dG9tOiB0LmhlaWdodCxcbiAgICAgICAgcmlnaHQ6IHRoaXMucmlnaHRcbiAgICAgIH07XG4gICAgICBpZiAoZSA9PT0gXCJ0b3BcIiB8fCBlID09PSBcImJvdHRvbVwiKSByZXR1cm4ge1xuICAgICAgICB0b3A6IHRoaXMudG9wLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBib3R0b206IHRoaXMuYm90dG9tLFxuICAgICAgICByaWdodDogdC53aWR0aFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0JhY2tncm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0JhY2tncm91bmQoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuY3R4LFxuICAgICAgICBlID0gdGhpcy5vcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgcyA9IHRoaXMubGVmdCxcbiAgICAgICAgbiA9IHRoaXMudG9wLFxuICAgICAgICBvID0gdGhpcy53aWR0aCxcbiAgICAgICAgciA9IHRoaXMuaGVpZ2h0O1xuICAgICAgZSAmJiAodC5zYXZlKCksIHQuZmlsbFN0eWxlID0gZSwgdC5maWxsUmVjdChzLCBuLCBvLCByKSwgdC5yZXN0b3JlKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMaW5lV2lkdGhGb3JWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMaW5lV2lkdGhGb3JWYWx1ZSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMub3B0aW9ucy5ncmlkO1xuICAgICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhZS5kaXNwbGF5KSByZXR1cm4gMDtcbiAgICAgIHZhciBuID0gdGhpcy50aWNrcy5maW5kSW5kZXgoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIG8udmFsdWUgPT09IHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuID49IDAgPyBlLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KG4pKS5saW5lV2lkdGggOiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3R3JpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3R3JpZCh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMub3B0aW9ucy5ncmlkLFxuICAgICAgICBzID0gdGhpcy5jdHgsXG4gICAgICAgIG4gPSB0aGlzLl9ncmlkTGluZUl0ZW1zIHx8ICh0aGlzLl9ncmlkTGluZUl0ZW1zID0gdGhpcy5fY29tcHV0ZUdyaWRMaW5lSXRlbXModCkpO1xuICAgICAgdmFyIG8sIHI7XG4gICAgICB2YXIgYSA9IGZ1bmN0aW9uIGEobCwgYywgaCkge1xuICAgICAgICAhaC53aWR0aCB8fCAhaC5jb2xvciB8fCAocy5zYXZlKCksIHMubGluZVdpZHRoID0gaC53aWR0aCwgcy5zdHJva2VTdHlsZSA9IGguY29sb3IsIHMuc2V0TGluZURhc2goaC5ib3JkZXJEYXNoIHx8IFtdKSwgcy5saW5lRGFzaE9mZnNldCA9IGguYm9yZGVyRGFzaE9mZnNldCwgcy5iZWdpblBhdGgoKSwgcy5tb3ZlVG8obC54LCBsLnkpLCBzLmxpbmVUbyhjLngsIGMueSksIHMuc3Ryb2tlKCksIHMucmVzdG9yZSgpKTtcbiAgICAgIH07XG4gICAgICBpZiAoZS5kaXNwbGF5KSBmb3IgKG8gPSAwLCByID0gbi5sZW5ndGg7IG8gPCByOyArK28pIHtcbiAgICAgICAgdmFyIGwgPSBuW29dO1xuICAgICAgICBlLmRyYXdPbkNoYXJ0QXJlYSAmJiBhKHtcbiAgICAgICAgICB4OiBsLngxLFxuICAgICAgICAgIHk6IGwueTFcbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IGwueDIsXG4gICAgICAgICAgeTogbC55MlxuICAgICAgICB9LCBsKSwgZS5kcmF3VGlja3MgJiYgYSh7XG4gICAgICAgICAgeDogbC50eDEsXG4gICAgICAgICAgeTogbC50eTFcbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IGwudHgyLFxuICAgICAgICAgIHk6IGwudHkyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjb2xvcjogbC50aWNrQ29sb3IsXG4gICAgICAgICAgd2lkdGg6IGwudGlja1dpZHRoLFxuICAgICAgICAgIGJvcmRlckRhc2g6IGwudGlja0JvcmRlckRhc2gsXG4gICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogbC50aWNrQm9yZGVyRGFzaE9mZnNldFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Qm9yZGVyKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLmNoYXJ0LFxuICAgICAgICBlID0gdGhpcy5jdHgsXG4gICAgICAgIF90aGlzJG9wdGlvbnMwID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBzID0gX3RoaXMkb3B0aW9uczAuYm9yZGVyLFxuICAgICAgICBuID0gX3RoaXMkb3B0aW9uczAuZ3JpZCxcbiAgICAgICAgbyA9IHMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSksXG4gICAgICAgIHIgPSBzLmRpc3BsYXkgPyBvLndpZHRoIDogMDtcbiAgICAgIGlmICghcikgcmV0dXJuO1xuICAgICAgdmFyIGEgPSBuLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KDApKS5saW5lV2lkdGgsXG4gICAgICAgIGwgPSB0aGlzLl9ib3JkZXJWYWx1ZTtcbiAgICAgIHZhciBjLCBoLCBkLCB1O1xuICAgICAgdGhpcy5pc0hvcml6b250YWwoKSA/IChjID0gT3QodCwgdGhpcy5sZWZ0LCByKSAtIHIgLyAyLCBoID0gT3QodCwgdGhpcy5yaWdodCwgYSkgKyBhIC8gMiwgZCA9IHUgPSBsKSA6IChkID0gT3QodCwgdGhpcy50b3AsIHIpIC0gciAvIDIsIHUgPSBPdCh0LCB0aGlzLmJvdHRvbSwgYSkgKyBhIC8gMiwgYyA9IGggPSBsKSwgZS5zYXZlKCksIGUubGluZVdpZHRoID0gby53aWR0aCwgZS5zdHJva2VTdHlsZSA9IG8uY29sb3IsIGUuYmVnaW5QYXRoKCksIGUubW92ZVRvKGMsIGQpLCBlLmxpbmVUbyhoLCB1KSwgZS5zdHJva2UoKSwgZS5yZXN0b3JlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0xhYmVscyh0KSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy50aWNrcy5kaXNwbGF5KSByZXR1cm47XG4gICAgICB2YXIgcyA9IHRoaXMuY3R4LFxuICAgICAgICBuID0gdGhpcy5fY29tcHV0ZUxhYmVsQXJlYSgpO1xuICAgICAgbiAmJiBKZShzLCBuKTtcbiAgICAgIHZhciBvID0gdGhpcy5nZXRMYWJlbEl0ZW1zKHQpO1xuICAgICAgdmFyIF9pdGVyYXRvcjIwID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobyksXG4gICAgICAgIF9zdGVwMjA7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIwLnMoKTsgIShfc3RlcDIwID0gX2l0ZXJhdG9yMjAubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciByID0gX3N0ZXAyMC52YWx1ZTtcbiAgICAgICAgICB2YXIgYSA9IHIub3B0aW9ucyxcbiAgICAgICAgICAgIGwgPSByLmZvbnQsXG4gICAgICAgICAgICBjID0gci5sYWJlbCxcbiAgICAgICAgICAgIGggPSByLnRleHRPZmZzZXQ7XG4gICAgICAgICAgYmUocywgYywgMCwgaCwgbCwgYSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyMC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyMC5mKCk7XG4gICAgICB9XG4gICAgICBuICYmIFplKHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3VGl0bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1RpdGxlKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLmN0eCxcbiAgICAgICAgX3RoaXMkb3B0aW9uczEgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGUgPSBfdGhpcyRvcHRpb25zMS5wb3NpdGlvbixcbiAgICAgICAgcyA9IF90aGlzJG9wdGlvbnMxLnRpdGxlLFxuICAgICAgICBuID0gX3RoaXMkb3B0aW9uczEucmV2ZXJzZTtcbiAgICAgIGlmICghcy5kaXNwbGF5KSByZXR1cm47XG4gICAgICB2YXIgbyA9IFgocy5mb250KSxcbiAgICAgICAgciA9IGV0KHMucGFkZGluZyksXG4gICAgICAgIGEgPSBzLmFsaWduO1xuICAgICAgdmFyIGwgPSBvLmxpbmVIZWlnaHQgLyAyO1xuICAgICAgZSA9PT0gXCJib3R0b21cIiB8fCBlID09PSBcImNlbnRlclwiIHx8IFQoZSkgPyAobCArPSByLmJvdHRvbSwgTihzLnRleHQpICYmIChsICs9IG8ubGluZUhlaWdodCAqIChzLnRleHQubGVuZ3RoIC0gMSkpKSA6IGwgKz0gci50b3A7XG4gICAgICB2YXIgX2hsID0gaGwodGhpcywgbCwgZSwgYSksXG4gICAgICAgIGMgPSBfaGwudGl0bGVYLFxuICAgICAgICBoID0gX2hsLnRpdGxlWSxcbiAgICAgICAgZCA9IF9obC5tYXhXaWR0aCxcbiAgICAgICAgdSA9IF9obC5yb3RhdGlvbjtcbiAgICAgIGJlKHQsIHMudGV4dCwgMCwgMCwgbywge1xuICAgICAgICBjb2xvcjogcy5jb2xvcixcbiAgICAgICAgbWF4V2lkdGg6IGQsXG4gICAgICAgIHJvdGF0aW9uOiB1LFxuICAgICAgICB0ZXh0QWxpZ246IGNsKGEsIGUsIG4pLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6IFwibWlkZGxlXCIsXG4gICAgICAgIHRyYW5zbGF0aW9uOiBbYywgaF1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcodCkge1xuICAgICAgdGhpcy5faXNWaXNpYmxlKCkgJiYgKHRoaXMuZHJhd0JhY2tncm91bmQoKSwgdGhpcy5kcmF3R3JpZCh0KSwgdGhpcy5kcmF3Qm9yZGVyKCksIHRoaXMuZHJhd1RpdGxlKCksIHRoaXMuZHJhd0xhYmVscyh0KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9sYXllcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xheWVycygpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGUgPSB0LnRpY2tzICYmIHQudGlja3MueiB8fCAwLFxuICAgICAgICBzID0gRCh0LmdyaWQgJiYgdC5ncmlkLnosIC0xKSxcbiAgICAgICAgbiA9IEQodC5ib3JkZXIgJiYgdC5ib3JkZXIueiwgMCk7XG4gICAgICByZXR1cm4gIXRoaXMuX2lzVmlzaWJsZSgpIHx8IHRoaXMuZHJhdyAhPT0gR3QucHJvdG90eXBlLmRyYXcgPyBbe1xuICAgICAgICB6OiBlLFxuICAgICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KG8pIHtcbiAgICAgICAgICBfdGhpczkuZHJhdyhvKTtcbiAgICAgICAgfVxuICAgICAgfV0gOiBbe1xuICAgICAgICB6OiBzLFxuICAgICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KG8pIHtcbiAgICAgICAgICBfdGhpczkuZHJhd0JhY2tncm91bmQoKSwgX3RoaXM5LmRyYXdHcmlkKG8pLCBfdGhpczkuZHJhd1RpdGxlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgejogbixcbiAgICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgICAgICBfdGhpczkuZHJhd0JvcmRlcigpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHo6IGUsXG4gICAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcobykge1xuICAgICAgICAgIF90aGlzOS5kcmF3TGFiZWxzKG8pO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKSxcbiAgICAgICAgcyA9IHRoaXMuYXhpcyArIFwiQXhpc0lEXCIsXG4gICAgICAgIG4gPSBbXTtcbiAgICAgIHZhciBvLCByO1xuICAgICAgZm9yIChvID0gMCwgciA9IGUubGVuZ3RoOyBvIDwgcjsgKytvKSB7XG4gICAgICAgIHZhciBhID0gZVtvXTtcbiAgICAgICAgYVtzXSA9PT0gdGhpcy5pZCAmJiAoIXQgfHwgYS50eXBlID09PSB0KSAmJiBuLnB1c2goYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc29sdmVUaWNrRm9udE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc29sdmVUaWNrRm9udE9wdGlvbnModCkge1xuICAgICAgdmFyIGUgPSB0aGlzLm9wdGlvbnMudGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQodCkpO1xuICAgICAgcmV0dXJuIFgoZS5mb250KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX21heERpZ2l0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWF4RGlnaXRzKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLmxpbmVIZWlnaHQ7XG4gICAgICByZXR1cm4gKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQpIC8gdDtcbiAgICB9XG4gIH1dKTtcbn0oc3QpO1xudmFyIFRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGUodCwgZSwgcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZSk7XG4gICAgdGhpcy50eXBlID0gdCwgdGhpcy5zY29wZSA9IGUsIHRoaXMub3ZlcnJpZGUgPSBzLCB0aGlzLml0ZW1zID0gLyogQF9fUFVSRV9fICovT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFRlLCBbe1xuICAgIGtleTogXCJpc0ZvclR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNGb3JUeXBlKHQpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbCh0aGlzLnR5cGUucHJvdG90eXBlLCB0LnByb3RvdHlwZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZ2lzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKHQpIHtcbiAgICAgIHZhciBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO1xuICAgICAgdmFyIHM7XG4gICAgICBmbChlKSAmJiAocyA9IHRoaXMucmVnaXN0ZXIoZSkpO1xuICAgICAgdmFyIG4gPSB0aGlzLml0ZW1zLFxuICAgICAgICBvID0gdC5pZCxcbiAgICAgICAgciA9IHRoaXMuc2NvcGUgKyBcIi5cIiArIG87XG4gICAgICBpZiAoIW8pIHRocm93IG5ldyBFcnJvcihcImNsYXNzIGRvZXMgbm90IGhhdmUgaWQ6IFwiICsgdCk7XG4gICAgICByZXR1cm4gbyBpbiBuIHx8IChuW29dID0gdCwgZGwodCwgciwgcyksIHRoaXMub3ZlcnJpZGUgJiYgVy5vdmVycmlkZSh0LmlkLCB0Lm92ZXJyaWRlcykpLCByO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KHQpIHtcbiAgICAgIHJldHVybiB0aGlzLml0ZW1zW3RdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnJlZ2lzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVucmVnaXN0ZXIodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLml0ZW1zLFxuICAgICAgICBzID0gdC5pZCxcbiAgICAgICAgbiA9IHRoaXMuc2NvcGU7XG4gICAgICBzIGluIGUgJiYgZGVsZXRlIGVbc10sIG4gJiYgcyBpbiBXW25dICYmIChkZWxldGUgV1tuXVtzXSwgdGhpcy5vdmVycmlkZSAmJiBkZWxldGUgenRbc10pO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuZnVuY3Rpb24gZGwoaSwgdCwgZSkge1xuICB2YXIgcyA9IGZlKC8qIEBfX1BVUkVfXyAqL09iamVjdC5jcmVhdGUobnVsbCksIFtlID8gVy5nZXQoZSkgOiB7fSwgVy5nZXQodCksIGkuZGVmYXVsdHNdKTtcbiAgVy5zZXQodCwgcyksIGkuZGVmYXVsdFJvdXRlcyAmJiB1bCh0LCBpLmRlZmF1bHRSb3V0ZXMpLCBpLmRlc2NyaXB0b3JzICYmIFcuZGVzY3JpYmUodCwgaS5kZXNjcmlwdG9ycyk7XG59XG5mdW5jdGlvbiB1bChpLCB0KSB7XG4gIE9iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgcyA9IGUuc3BsaXQoXCIuXCIpLFxuICAgICAgbiA9IHMucG9wKCksXG4gICAgICBvID0gW2ldLmNvbmNhdChzKS5qb2luKFwiLlwiKSxcbiAgICAgIHIgPSB0W2VdLnNwbGl0KFwiLlwiKSxcbiAgICAgIGEgPSByLnBvcCgpLFxuICAgICAgbCA9IHIuam9pbihcIi5cIik7XG4gICAgVy5yb3V0ZShvLCBuLCBsLCBhKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBmbChpKSB7XG4gIHJldHVybiBcImlkXCIgaW4gaSAmJiBcImRlZmF1bHRzXCIgaW4gaTtcbn1cbnZhciBnbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGdsKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBnbCk7XG4gICAgdGhpcy5jb250cm9sbGVycyA9IG5ldyBUZShrdCwgXCJkYXRhc2V0c1wiLCAhMCksIHRoaXMuZWxlbWVudHMgPSBuZXcgVGUoc3QsIFwiZWxlbWVudHNcIiksIHRoaXMucGx1Z2lucyA9IG5ldyBUZShPYmplY3QsIFwicGx1Z2luc1wiKSwgdGhpcy5zY2FsZXMgPSBuZXcgVGUoR3QsIFwic2NhbGVzXCIpLCB0aGlzLl90eXBlZFJlZ2lzdHJpZXMgPSBbdGhpcy5jb250cm9sbGVycywgdGhpcy5zY2FsZXMsIHRoaXMuZWxlbWVudHNdO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoZ2wsIFt7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgdFtfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWFjaChcInJlZ2lzdGVyXCIsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICAgIHRbX2tleTVdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VhY2goXCJ1bnJlZ2lzdGVyXCIsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRDb250cm9sbGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDb250cm9sbGVycygpIHtcbiAgICAgIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgICB0W19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgICB9XG4gICAgICB0aGlzLl9lYWNoKFwicmVnaXN0ZXJcIiwgdCwgdGhpcy5jb250cm9sbGVycyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEVsZW1lbnRzKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjcgPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KF9sZW43KSwgX2tleTcgPSAwOyBfa2V5NyA8IF9sZW43OyBfa2V5NysrKSB7XG4gICAgICAgIHRbX2tleTddID0gYXJndW1lbnRzW19rZXk3XTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VhY2goXCJyZWdpc3RlclwiLCB0LCB0aGlzLmVsZW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUGx1Z2luc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRQbHVnaW5zKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjggPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KF9sZW44KSwgX2tleTggPSAwOyBfa2V5OCA8IF9sZW44OyBfa2V5OCsrKSB7XG4gICAgICAgIHRbX2tleThdID0gYXJndW1lbnRzW19rZXk4XTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VhY2goXCJyZWdpc3RlclwiLCB0LCB0aGlzLnBsdWdpbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRTY2FsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU2NhbGVzKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjkgPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KF9sZW45KSwgX2tleTkgPSAwOyBfa2V5OSA8IF9sZW45OyBfa2V5OSsrKSB7XG4gICAgICAgIHRbX2tleTldID0gYXJndW1lbnRzW19rZXk5XTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VhY2goXCJyZWdpc3RlclwiLCB0LCB0aGlzLnNjYWxlcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENvbnRyb2xsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udHJvbGxlcih0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0KHQsIHRoaXMuY29udHJvbGxlcnMsIFwiY29udHJvbGxlclwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50KHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXQodCwgdGhpcy5lbGVtZW50cywgXCJlbGVtZW50XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQbHVnaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGx1Z2luKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXQodCwgdGhpcy5wbHVnaW5zLCBcInBsdWdpblwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2NhbGUodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldCh0LCB0aGlzLnNjYWxlcywgXCJzY2FsZVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlQ29udHJvbGxlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQ29udHJvbGxlcnMoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMCA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoX2xlbjApLCBfa2V5MCA9IDA7IF9rZXkwIDwgX2xlbjA7IF9rZXkwKyspIHtcbiAgICAgICAgdFtfa2V5MF0gPSBhcmd1bWVudHNbX2tleTBdO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWFjaChcInVucmVnaXN0ZXJcIiwgdCwgdGhpcy5jb250cm9sbGVycyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnRzKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjEgPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KF9sZW4xKSwgX2tleTEgPSAwOyBfa2V5MSA8IF9sZW4xOyBfa2V5MSsrKSB7XG4gICAgICAgIHRbX2tleTFdID0gYXJndW1lbnRzW19rZXkxXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VhY2goXCJ1bnJlZ2lzdGVyXCIsIHQsIHRoaXMuZWxlbWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVQbHVnaW5zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVBsdWdpbnMoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTAgPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KF9sZW4xMCksIF9rZXkxMCA9IDA7IF9rZXkxMCA8IF9sZW4xMDsgX2tleTEwKyspIHtcbiAgICAgICAgdFtfa2V5MTBdID0gYXJndW1lbnRzW19rZXkxMF07XG4gICAgICB9XG4gICAgICB0aGlzLl9lYWNoKFwidW5yZWdpc3RlclwiLCB0LCB0aGlzLnBsdWdpbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVTY2FsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlU2NhbGVzKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjExID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShfbGVuMTEpLCBfa2V5MTEgPSAwOyBfa2V5MTEgPCBfbGVuMTE7IF9rZXkxMSsrKSB7XG4gICAgICAgIHRbX2tleTExXSA9IGFyZ3VtZW50c1tfa2V5MTFdO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWFjaChcInVucmVnaXN0ZXJcIiwgdCwgdGhpcy5zY2FsZXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZWFjaCh0LCBlLCBzKSB7XG4gICAgICB2YXIgX3RoaXMwID0gdGhpcztcbiAgICAgIF90b0NvbnN1bWFibGVBcnJheShlKS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHZhciBvID0gcyB8fCBfdGhpczAuX2dldFJlZ2lzdHJ5Rm9yVHlwZShuKTtcbiAgICAgICAgcyB8fCBvLmlzRm9yVHlwZShuKSB8fCBvID09PSBfdGhpczAucGx1Z2lucyAmJiBuLmlkID8gX3RoaXMwLl9leGVjKHQsIG8sIG4pIDogTChuLCBmdW5jdGlvbiAocikge1xuICAgICAgICAgIHZhciBhID0gcyB8fCBfdGhpczAuX2dldFJlZ2lzdHJ5Rm9yVHlwZShyKTtcbiAgICAgICAgICBfdGhpczAuX2V4ZWModCwgYSwgcik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9leGVjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9leGVjKHQsIGUsIHMpIHtcbiAgICAgIHZhciBuID0gRmkodCk7XG4gICAgICBJKHNbXCJiZWZvcmVcIiArIG5dLCBbXSwgcyksIGVbdF0ocyksIEkoc1tcImFmdGVyXCIgKyBuXSwgW10sIHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0UmVnaXN0cnlGb3JUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRSZWdpc3RyeUZvclR5cGUodCkge1xuICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLl90eXBlZFJlZ2lzdHJpZXMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLl90eXBlZFJlZ2lzdHJpZXNbZV07XG4gICAgICAgIGlmIChzLmlzRm9yVHlwZSh0KSkgcmV0dXJuIHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wbHVnaW5zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXQodCwgZSwgcykge1xuICAgICAgdmFyIG4gPSBlLmdldCh0KTtcbiAgICAgIGlmIChuID09PSB2b2lkIDApIHRocm93IG5ldyBFcnJvcignXCInICsgdCArICdcIiBpcyBub3QgYSByZWdpc3RlcmVkICcgKyBzICsgXCIuXCIpO1xuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICB9XSk7XG59KCk7XG52YXIgYXQgPSAvKiBAX19QVVJFX18gKi9uZXcgZ2woKTtcbnZhciBwbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHBsKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBwbCk7XG4gICAgdGhpcy5faW5pdCA9IHZvaWQgMDtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKHBsLCBbe1xuICAgIGtleTogXCJub3RpZnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm90aWZ5KHQsIGUsIHMsIG4pIHtcbiAgICAgIGlmIChlID09PSBcImJlZm9yZUluaXRcIiAmJiAodGhpcy5faW5pdCA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKHQsICEwKSwgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIHQsIFwiaW5zdGFsbFwiKSksIHRoaXMuX2luaXQgPT09IHZvaWQgMCkgcmV0dXJuO1xuICAgICAgdmFyIG8gPSBuID8gdGhpcy5fZGVzY3JpcHRvcnModCkuZmlsdGVyKG4pIDogdGhpcy5fZGVzY3JpcHRvcnModCksXG4gICAgICAgIHIgPSB0aGlzLl9ub3RpZnkobywgdCwgZSwgcyk7XG4gICAgICByZXR1cm4gZSA9PT0gXCJhZnRlckRlc3Ryb3lcIiAmJiAodGhpcy5fbm90aWZ5KG8sIHQsIFwic3RvcFwiKSwgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIHQsIFwidW5pbnN0YWxsXCIpLCB0aGlzLl9pbml0ID0gdm9pZCAwKSwgcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX25vdGlmeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbm90aWZ5KHQsIGUsIHMsIG4pIHtcbiAgICAgIG4gPSBuIHx8IHt9O1xuICAgICAgdmFyIF9pdGVyYXRvcjIxID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodCksXG4gICAgICAgIF9zdGVwMjE7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIxLnMoKTsgIShfc3RlcDIxID0gX2l0ZXJhdG9yMjEubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBvID0gX3N0ZXAyMS52YWx1ZTtcbiAgICAgICAgICB2YXIgciA9IG8ucGx1Z2luLFxuICAgICAgICAgICAgYSA9IHJbc10sXG4gICAgICAgICAgICBsID0gW2UsIG4sIG8ub3B0aW9uc107XG4gICAgICAgICAgaWYgKEkoYSwgbCwgcikgPT09ICExICYmIG4uY2FuY2VsYWJsZSkgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMjEuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMjEuZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZhbGlkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWRhdGUoKSB7XG4gICAgICBSKHRoaXMuX2NhY2hlKSB8fCAodGhpcy5fb2xkQ2FjaGUgPSB0aGlzLl9jYWNoZSwgdGhpcy5fY2FjaGUgPSB2b2lkIDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZGVzY3JpcHRvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc2NyaXB0b3JzKHQpIHtcbiAgICAgIGlmICh0aGlzLl9jYWNoZSkgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICAgICAgdmFyIGUgPSB0aGlzLl9jYWNoZSA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKHQpO1xuICAgICAgcmV0dXJuIHRoaXMuX25vdGlmeVN0YXRlQ2hhbmdlcyh0KSwgZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZURlc2NyaXB0b3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVEZXNjcmlwdG9ycyh0LCBlKSB7XG4gICAgICB2YXIgcyA9IHQgJiYgdC5jb25maWcsXG4gICAgICAgIG4gPSBEKHMub3B0aW9ucyAmJiBzLm9wdGlvbnMucGx1Z2lucywge30pLFxuICAgICAgICBvID0gbWwocyk7XG4gICAgICByZXR1cm4gbiA9PT0gITEgJiYgIWUgPyBbXSA6IF9sKHQsIG8sIG4sIGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbm90aWZ5U3RhdGVDaGFuZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ub3RpZnlTdGF0ZUNoYW5nZXModCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9vbGRDYWNoZSB8fCBbXSxcbiAgICAgICAgcyA9IHRoaXMuX2NhY2hlLFxuICAgICAgICBuID0gZnVuY3Rpb24gbihvLCByKSB7XG4gICAgICAgICAgcmV0dXJuIG8uZmlsdGVyKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gIXIuc29tZShmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgICByZXR1cm4gYS5wbHVnaW4uaWQgPT09IGwucGx1Z2luLmlkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB0aGlzLl9ub3RpZnkobihlLCBzKSwgdCwgXCJzdG9wXCIpLCB0aGlzLl9ub3RpZnkobihzLCBlKSwgdCwgXCJzdGFydFwiKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbmZ1bmN0aW9uIG1sKGkpIHtcbiAgdmFyIHQgPSB7fSxcbiAgICBlID0gW10sXG4gICAgcyA9IE9iamVjdC5rZXlzKGF0LnBsdWdpbnMuaXRlbXMpO1xuICBmb3IgKHZhciBvID0gMDsgbyA8IHMubGVuZ3RoOyBvKyspIGUucHVzaChhdC5nZXRQbHVnaW4oc1tvXSkpO1xuICB2YXIgbiA9IGkucGx1Z2lucyB8fCBbXTtcbiAgZm9yICh2YXIgX28zID0gMDsgX28zIDwgbi5sZW5ndGg7IF9vMysrKSB7XG4gICAgdmFyIHIgPSBuW19vM107XG4gICAgZS5pbmRleE9mKHIpID09PSAtMSAmJiAoZS5wdXNoKHIpLCB0W3IuaWRdID0gITApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcGx1Z2luczogZSxcbiAgICBsb2NhbElkczogdFxuICB9O1xufVxuZnVuY3Rpb24gYmwoaSwgdCkge1xuICByZXR1cm4gIXQgJiYgaSA9PT0gITEgPyBudWxsIDogaSA9PT0gITAgPyB7fSA6IGk7XG59XG5mdW5jdGlvbiBfbChpLCBfcmVmMywgcywgbikge1xuICB2YXIgdCA9IF9yZWYzLnBsdWdpbnMsXG4gICAgZSA9IF9yZWYzLmxvY2FsSWRzO1xuICB2YXIgbyA9IFtdLFxuICAgIHIgPSBpLmdldENvbnRleHQoKTtcbiAgdmFyIF9pdGVyYXRvcjIyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodCksXG4gICAgX3N0ZXAyMjtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjIyLnMoKTsgIShfc3RlcDIyID0gX2l0ZXJhdG9yMjIubigpKS5kb25lOykge1xuICAgICAgdmFyIGEgPSBfc3RlcDIyLnZhbHVlO1xuICAgICAgdmFyIGwgPSBhLmlkLFxuICAgICAgICBjID0gYmwoc1tsXSwgbik7XG4gICAgICBjICE9PSBudWxsICYmIG8ucHVzaCh7XG4gICAgICAgIHBsdWdpbjogYSxcbiAgICAgICAgb3B0aW9uczogeGwoaS5jb25maWcsIHtcbiAgICAgICAgICBwbHVnaW46IGEsXG4gICAgICAgICAgbG9jYWw6IGVbbF1cbiAgICAgICAgfSwgYywgcilcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMjIuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjIyLmYoKTtcbiAgfVxuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIHhsKGksIF9yZWY0LCBzLCBuKSB7XG4gIHZhciB0ID0gX3JlZjQucGx1Z2luLFxuICAgIGUgPSBfcmVmNC5sb2NhbDtcbiAgdmFyIG8gPSBpLnBsdWdpblNjb3BlS2V5cyh0KSxcbiAgICByID0gaS5nZXRPcHRpb25TY29wZXMocywgbyk7XG4gIHJldHVybiBlICYmIHQuZGVmYXVsdHMgJiYgci5wdXNoKHQuZGVmYXVsdHMpLCBpLmNyZWF0ZVJlc29sdmVyKHIsIG4sIFtcIlwiXSwge1xuICAgIHNjcmlwdGFibGU6ICExLFxuICAgIGluZGV4YWJsZTogITEsXG4gICAgYWxsS2V5czogITBcbiAgfSk7XG59XG5mdW5jdGlvbiB3aShpLCB0KSB7XG4gIHZhciBlID0gVy5kYXRhc2V0c1tpXSB8fCB7fTtcbiAgcmV0dXJuICgodC5kYXRhc2V0cyB8fCB7fSlbaV0gfHwge30pLmluZGV4QXhpcyB8fCB0LmluZGV4QXhpcyB8fCBlLmluZGV4QXhpcyB8fCBcInhcIjtcbn1cbmZ1bmN0aW9uIHlsKGksIHQpIHtcbiAgdmFyIGUgPSBpO1xuICByZXR1cm4gaSA9PT0gXCJfaW5kZXhfXCIgPyBlID0gdCA6IGkgPT09IFwiX3ZhbHVlX1wiICYmIChlID0gdCA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwiKSwgZTtcbn1cbmZ1bmN0aW9uIHZsKGksIHQpIHtcbiAgcmV0dXJuIGkgPT09IHQgPyBcIl9pbmRleF9cIiA6IFwiX3ZhbHVlX1wiO1xufVxuZnVuY3Rpb24gSXMoaSkge1xuICBpZiAoaSA9PT0gXCJ4XCIgfHwgaSA9PT0gXCJ5XCIgfHwgaSA9PT0gXCJyXCIpIHJldHVybiBpO1xufVxuZnVuY3Rpb24gTWwoaSkge1xuICBpZiAoaSA9PT0gXCJ0b3BcIiB8fCBpID09PSBcImJvdHRvbVwiKSByZXR1cm4gXCJ4XCI7XG4gIGlmIChpID09PSBcImxlZnRcIiB8fCBpID09PSBcInJpZ2h0XCIpIHJldHVybiBcInlcIjtcbn1cbmZ1bmN0aW9uIFBpKGkpIHtcbiAgaWYgKElzKGkpKSByZXR1cm4gaTtcbiAgZm9yICh2YXIgX2xlbjEyID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShfbGVuMTIgPiAxID8gX2xlbjEyIC0gMSA6IDApLCBfa2V5MTIgPSAxOyBfa2V5MTIgPCBfbGVuMTI7IF9rZXkxMisrKSB7XG4gICAgdFtfa2V5MTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5MTJdO1xuICB9XG4gIGZvciAodmFyIF9pMyA9IDAsIF90MyA9IHQ7IF9pMyA8IF90My5sZW5ndGg7IF9pMysrKSB7XG4gICAgdmFyIGUgPSBfdDNbX2kzXTtcbiAgICB2YXIgcyA9IGUuYXhpcyB8fCBNbChlLnBvc2l0aW9uKSB8fCBpLmxlbmd0aCA+IDEgJiYgSXMoaVswXS50b0xvd2VyQ2FzZSgpKTtcbiAgICBpZiAocykgcmV0dXJuIHM7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRldGVybWluZSB0eXBlIG9mICdcIi5jb25jYXQoaSwgXCInIGF4aXMuIFBsZWFzZSBwcm92aWRlICdheGlzJyBvciAncG9zaXRpb24nIG9wdGlvbi5cIikpO1xufVxuZnVuY3Rpb24genMoaSwgdCwgZSkge1xuICBpZiAoZVt0ICsgXCJBeGlzSURcIl0gPT09IGkpIHJldHVybiB7XG4gICAgYXhpczogdFxuICB9O1xufVxuZnVuY3Rpb24gU2woaSwgdCkge1xuICBpZiAodC5kYXRhICYmIHQuZGF0YS5kYXRhc2V0cykge1xuICAgIHZhciBlID0gdC5kYXRhLmRhdGFzZXRzLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMueEF4aXNJRCA9PT0gaSB8fCBzLnlBeGlzSUQgPT09IGk7XG4gICAgfSk7XG4gICAgaWYgKGUubGVuZ3RoKSByZXR1cm4genMoaSwgXCJ4XCIsIGVbMF0pIHx8IHpzKGksIFwieVwiLCBlWzBdKTtcbiAgfVxuICByZXR1cm4ge307XG59XG5mdW5jdGlvbiBrbChpLCB0KSB7XG4gIHZhciBlID0genRbaS50eXBlXSB8fCB7XG4gICAgICBzY2FsZXM6IHt9XG4gICAgfSxcbiAgICBzID0gdC5zY2FsZXMgfHwge30sXG4gICAgbiA9IHdpKGkudHlwZSwgdCksXG4gICAgbyA9IC8qIEBfX1BVUkVfXyAqL09iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgdmFyIGEgPSBzW3JdO1xuICAgIGlmICghVChhKSkgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIHNjYWxlIGNvbmZpZ3VyYXRpb24gZm9yIHNjYWxlOiBcIi5jb25jYXQocikpO1xuICAgIGlmIChhLl9wcm94eSkgcmV0dXJuIGNvbnNvbGUud2FybihcIklnbm9yaW5nIHJlc29sdmVyIHBhc3NlZCBhcyBvcHRpb25zIGZvciBzY2FsZTogXCIuY29uY2F0KHIpKTtcbiAgICB2YXIgbCA9IFBpKHIsIGEsIFNsKHIsIGkpLCBXLnNjYWxlc1thLnR5cGVdKSxcbiAgICAgIGMgPSB2bChsLCBuKSxcbiAgICAgIGggPSBlLnNjYWxlcyB8fCB7fTtcbiAgICBvW3JdID0gbGUoLyogQF9fUFVSRV9fICovT2JqZWN0LmNyZWF0ZShudWxsKSwgW3tcbiAgICAgIGF4aXM6IGxcbiAgICB9LCBhLCBoW2xdLCBoW2NdXSk7XG4gIH0pLCBpLmRhdGEuZGF0YXNldHMuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgIHZhciBhID0gci50eXBlIHx8IGkudHlwZSxcbiAgICAgIGwgPSByLmluZGV4QXhpcyB8fCB3aShhLCB0KSxcbiAgICAgIGggPSAoenRbYV0gfHwge30pLnNjYWxlcyB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhoKS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgdSA9IHlsKGQsIGwpLFxuICAgICAgICBmID0gclt1ICsgXCJBeGlzSURcIl0gfHwgdTtcbiAgICAgIG9bZl0gPSBvW2ZdIHx8IC8qIEBfX1BVUkVfXyAqL09iamVjdC5jcmVhdGUobnVsbCksIGxlKG9bZl0sIFt7XG4gICAgICAgIGF4aXM6IHVcbiAgICAgIH0sIHNbZl0sIGhbZF1dKTtcbiAgICB9KTtcbiAgfSksIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICB2YXIgYSA9IG9bcl07XG4gICAgbGUoYSwgW1cuc2NhbGVzW2EudHlwZV0sIFcuc2NhbGVdKTtcbiAgfSksIG87XG59XG5mdW5jdGlvbiBLbihpKSB7XG4gIHZhciB0ID0gaS5vcHRpb25zIHx8IChpLm9wdGlvbnMgPSB7fSk7XG4gIHQucGx1Z2lucyA9IEQodC5wbHVnaW5zLCB7fSksIHQuc2NhbGVzID0ga2woaSwgdCk7XG59XG5mdW5jdGlvbiBHbihpKSB7XG4gIHJldHVybiBpID0gaSB8fCB7fSwgaS5kYXRhc2V0cyA9IGkuZGF0YXNldHMgfHwgW10sIGkubGFiZWxzID0gaS5sYWJlbHMgfHwgW10sIGk7XG59XG5mdW5jdGlvbiB3bChpKSB7XG4gIHJldHVybiBpID0gaSB8fCB7fSwgaS5kYXRhID0gR24oaS5kYXRhKSwgS24oaSksIGk7XG59XG52YXIgQnMgPSAvKiBAX19QVVJFX18gKi9uZXcgTWFwKCksXG4gIEpuID0gLyogQF9fUFVSRV9fICovbmV3IFNldCgpO1xuZnVuY3Rpb24gQWUoaSwgdCkge1xuICB2YXIgZSA9IEJzLmdldChpKTtcbiAgcmV0dXJuIGUgfHwgKGUgPSB0KCksIEJzLnNldChpLCBlKSwgSm4uYWRkKGUpKSwgZTtcbn1cbnZhciBzZSA9IGZ1bmN0aW9uIHNlKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBJdCh0LCBlKTtcbiAgcyAhPT0gdm9pZCAwICYmIGkuYWRkKHMpO1xufTtcbnZhciBQbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBsKHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGwpO1xuICAgIHRoaXMuX2NvbmZpZyA9IHdsKHQpLCB0aGlzLl9zY29wZUNhY2hlID0gLyogQF9fUFVSRV9fICovbmV3IE1hcCgpLCB0aGlzLl9yZXNvbHZlckNhY2hlID0gLyogQF9fUFVSRV9fICovbmV3IE1hcCgpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUGwsIFt7XG4gICAga2V5OiBcInBsYXRmb3JtXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsYXRmb3JtO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29uZmlnLnR5cGU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0KSB7XG4gICAgICB0aGlzLl9jb25maWcudHlwZSA9IHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhdGFcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb25maWcuZGF0YTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHQpIHtcbiAgICAgIHRoaXMuX2NvbmZpZy5kYXRhID0gR24odCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9wdGlvbnNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb25maWcub3B0aW9ucztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHQpIHtcbiAgICAgIHRoaXMuX2NvbmZpZy5vcHRpb25zID0gdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGx1Z2luc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbHVnaW5zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9jb25maWc7XG4gICAgICB0aGlzLmNsZWFyQ2FjaGUoKSwgS24odCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyQ2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgICAgIHRoaXMuX3Njb3BlQ2FjaGUuY2xlYXIoKSwgdGhpcy5fcmVzb2x2ZXJDYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXRhc2V0U2NvcGVLZXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRhdGFzZXRTY29wZUtleXModCkge1xuICAgICAgcmV0dXJuIEFlKHQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtbXCJkYXRhc2V0cy5cIi5jb25jYXQodCksIFwiXCJdXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRhdGFzZXRBbmltYXRpb25TY29wZUtleXModCwgZSkge1xuICAgICAgcmV0dXJuIEFlKFwiXCIuY29uY2F0KHQsIFwiLnRyYW5zaXRpb24uXCIpLmNvbmNhdChlKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1tcImRhdGFzZXRzLlwiLmNvbmNhdCh0LCBcIi50cmFuc2l0aW9ucy5cIikuY29uY2F0KGUpLCBcInRyYW5zaXRpb25zLlwiLmNvbmNhdChlKV0sIFtcImRhdGFzZXRzLlwiLmNvbmNhdCh0KSwgXCJcIl1dO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhdGFzZXRFbGVtZW50U2NvcGVLZXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKHQsIGUpIHtcbiAgICAgIHJldHVybiBBZShcIlwiLmNvbmNhdCh0LCBcIi1cIikuY29uY2F0KGUpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbW1wiZGF0YXNldHMuXCIuY29uY2F0KHQsIFwiLmVsZW1lbnRzLlwiKS5jb25jYXQoZSksIFwiZGF0YXNldHMuXCIuY29uY2F0KHQpLCBcImVsZW1lbnRzLlwiLmNvbmNhdChlKSwgXCJcIl1dO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBsdWdpblNjb3BlS2V5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbHVnaW5TY29wZUtleXModCkge1xuICAgICAgdmFyIGUgPSB0LmlkLFxuICAgICAgICBzID0gdGhpcy50eXBlO1xuICAgICAgcmV0dXJuIEFlKFwiXCIuY29uY2F0KHMsIFwiLXBsdWdpbi1cIikuY29uY2F0KGUpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbW1wicGx1Z2lucy5cIi5jb25jYXQoZSldLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodC5hZGRpdGlvbmFsT3B0aW9uU2NvcGVzIHx8IFtdKSldO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jYWNoZWRTY29wZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhY2hlZFNjb3Blcyh0LCBlKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuX3Njb3BlQ2FjaGU7XG4gICAgICB2YXIgbiA9IHMuZ2V0KHQpO1xuICAgICAgcmV0dXJuICghbiB8fCBlKSAmJiAobiA9IC8qIEBfX1BVUkVfXyAqL25ldyBNYXAoKSwgcy5zZXQodCwgbikpLCBuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPcHRpb25TY29wZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3B0aW9uU2NvcGVzKHQsIGUsIHMpIHtcbiAgICAgIHZhciBuID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBvID0gdGhpcy50eXBlLFxuICAgICAgICByID0gdGhpcy5fY2FjaGVkU2NvcGVzKHQsIHMpLFxuICAgICAgICBhID0gci5nZXQoZSk7XG4gICAgICBpZiAoYSkgcmV0dXJuIGE7XG4gICAgICB2YXIgbCA9IC8qIEBfX1BVUkVfXyAqL25ldyBTZXQoKTtcbiAgICAgIGUuZm9yRWFjaChmdW5jdGlvbiAoaCkge1xuICAgICAgICB0ICYmIChsLmFkZCh0KSwgaC5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIHNlKGwsIHQsIGQpO1xuICAgICAgICB9KSksIGguZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBzZShsLCBuLCBkKTtcbiAgICAgICAgfSksIGguZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBzZShsLCB6dFtvXSB8fCB7fSwgZCk7XG4gICAgICAgIH0pLCBoLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gc2UobCwgVywgZCk7XG4gICAgICAgIH0pLCBoLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gc2UobCwgTWksIGQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGMgPSBBcnJheS5mcm9tKGwpO1xuICAgICAgcmV0dXJuIGMubGVuZ3RoID09PSAwICYmIGMucHVzaCgvKiBAX19QVVJFX18gKi9PYmplY3QuY3JlYXRlKG51bGwpKSwgSm4uaGFzKGUpICYmIHIuc2V0KGUsIGMpLCBjO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGFydE9wdGlvblNjb3Blc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFydE9wdGlvblNjb3BlcygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBlID0gdGhpcy50eXBlO1xuICAgICAgcmV0dXJuIFt0LCB6dFtlXSB8fCB7fSwgVy5kYXRhc2V0c1tlXSB8fCB7fSwge1xuICAgICAgICB0eXBlOiBlXG4gICAgICB9LCBXLCBNaV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVOYW1lZE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZU5hbWVkT3B0aW9ucyh0LCBlLCBzKSB7XG4gICAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogW1wiXCJdO1xuICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgJHNoYXJlZDogITBcbiAgICAgICAgfSxcbiAgICAgICAgX0hzID0gSHModGhpcy5fcmVzb2x2ZXJDYWNoZSwgdCwgbiksXG4gICAgICAgIHIgPSBfSHMucmVzb2x2ZXIsXG4gICAgICAgIGEgPSBfSHMuc3ViUHJlZml4ZXM7XG4gICAgICB2YXIgbCA9IHI7XG4gICAgICBpZiAoQ2wociwgZSkpIHtcbiAgICAgICAgby4kc2hhcmVkID0gITEsIHMgPSB3dChzKSA/IHMoKSA6IHM7XG4gICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVSZXNvbHZlcih0LCBzLCBhKTtcbiAgICAgICAgbCA9IHF0KHIsIHMsIGMpO1xuICAgICAgfVxuICAgICAgdmFyIF9pdGVyYXRvcjIzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZSksXG4gICAgICAgIF9zdGVwMjM7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIzLnMoKTsgIShfc3RlcDIzID0gX2l0ZXJhdG9yMjMubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfYzIgPSBfc3RlcDIzLnZhbHVlO1xuICAgICAgICAgIG9bX2MyXSA9IGxbX2MyXTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIzLmYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVSZXNvbHZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSZXNvbHZlcih0LCBlKSB7XG4gICAgICB2YXIgcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW1wiXCJdO1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBfSHMyID0gSHModGhpcy5fcmVzb2x2ZXJDYWNoZSwgdCwgcyksXG4gICAgICAgIG8gPSBfSHMyLnJlc29sdmVyO1xuICAgICAgcmV0dXJuIFQoZSkgPyBxdChvLCBlLCB2b2lkIDAsIG4pIDogbztcbiAgICB9XG4gIH1dKTtcbn0oKTtcbmZ1bmN0aW9uIEhzKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBpLmdldCh0KTtcbiAgcyB8fCAocyA9IC8qIEBfX1BVUkVfXyAqL25ldyBNYXAoKSwgaS5zZXQodCwgcykpO1xuICB2YXIgbiA9IGUuam9pbigpO1xuICB2YXIgbyA9IHMuZ2V0KG4pO1xuICByZXR1cm4gbyB8fCAobyA9IHtcbiAgICByZXNvbHZlcjogTmkodCwgZSksXG4gICAgc3ViUHJlZml4ZXM6IGUuZmlsdGVyKGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gIWEudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImhvdmVyXCIpO1xuICAgIH0pXG4gIH0sIHMuc2V0KG4sIG8pKSwgbztcbn1cbnZhciBEbCA9IGZ1bmN0aW9uIERsKGkpIHtcbiAgcmV0dXJuIFQoaSkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaSkuc29tZShmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB3dChpW3RdKTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gQ2woaSwgdCkge1xuICB2YXIgX1RuID0gVG4oaSksXG4gICAgZSA9IF9Ubi5pc1NjcmlwdGFibGUsXG4gICAgcyA9IF9Ubi5pc0luZGV4YWJsZTtcbiAgdmFyIF9pdGVyYXRvcjI0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodCksXG4gICAgX3N0ZXAyNDtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjI0LnMoKTsgIShfc3RlcDI0ID0gX2l0ZXJhdG9yMjQubigpKS5kb25lOykge1xuICAgICAgdmFyIG4gPSBfc3RlcDI0LnZhbHVlO1xuICAgICAgdmFyIG8gPSBlKG4pLFxuICAgICAgICByID0gcyhuKSxcbiAgICAgICAgYSA9IChyIHx8IG8pICYmIGlbbl07XG4gICAgICBpZiAobyAmJiAod3QoYSkgfHwgRGwoYSkpIHx8IHIgJiYgTihhKSkgcmV0dXJuICEwO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMjQuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjI0LmYoKTtcbiAgfVxuICByZXR1cm4gITE7XG59XG52YXIgT2wgPSBcIjQuNS4xXCI7XG52YXIgVGwgPSBbXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJjaGFydEFyZWFcIl07XG5mdW5jdGlvbiBXcyhpLCB0KSB7XG4gIHJldHVybiBpID09PSBcInRvcFwiIHx8IGkgPT09IFwiYm90dG9tXCIgfHwgVGwuaW5kZXhPZihpKSA9PT0gLTEgJiYgdCA9PT0gXCJ4XCI7XG59XG5mdW5jdGlvbiBOcyhpLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZSwgcykge1xuICAgIHJldHVybiBlW2ldID09PSBzW2ldID8gZVt0XSAtIHNbdF0gOiBlW2ldIC0gc1tpXTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFZzKGkpIHtcbiAgdmFyIHQgPSBpLmNoYXJ0LFxuICAgIGUgPSB0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICB0Lm5vdGlmeVBsdWdpbnMoXCJhZnRlclJlbmRlclwiKSwgSShlICYmIGUub25Db21wbGV0ZSwgW2ldLCB0KTtcbn1cbmZ1bmN0aW9uIEFsKGkpIHtcbiAgdmFyIHQgPSBpLmNoYXJ0LFxuICAgIGUgPSB0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICBJKGUgJiYgZS5vblByb2dyZXNzLCBbaV0sIHQpO1xufVxuZnVuY3Rpb24gWm4oaSkge1xuICByZXR1cm4gJGkoKSAmJiB0eXBlb2YgaSA9PSBcInN0cmluZ1wiID8gaSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGkpIDogaSAmJiBpLmxlbmd0aCAmJiAoaSA9IGlbMF0pLCBpICYmIGkuY2FudmFzICYmIChpID0gaS5jYW52YXMpLCBpO1xufVxudmFyIEJlID0ge30sXG4gIGpzID0gZnVuY3Rpb24ganMoaSkge1xuICAgIHZhciB0ID0gWm4oaSk7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoQmUpLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGUuY2FudmFzID09PSB0O1xuICAgIH0pLnBvcCgpO1xuICB9O1xuZnVuY3Rpb24gUmwoaSwgdCwgZSkge1xuICB2YXIgcyA9IE9iamVjdC5rZXlzKGkpO1xuICBmb3IgKHZhciBfaTQgPSAwLCBfczIgPSBzOyBfaTQgPCBfczIubGVuZ3RoOyBfaTQrKykge1xuICAgIHZhciBuID0gX3MyW19pNF07XG4gICAgdmFyIG8gPSArbjtcbiAgICBpZiAobyA+PSB0KSB7XG4gICAgICB2YXIgciA9IGlbbl07XG4gICAgICBkZWxldGUgaVtuXSwgKGUgPiAwIHx8IG8gPiB0KSAmJiAoaVtvICsgZV0gPSByKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIExsKGksIHQsIGUsIHMpIHtcbiAgcmV0dXJuICFlIHx8IGkudHlwZSA9PT0gXCJtb3VzZW91dFwiID8gbnVsbCA6IHMgPyB0IDogaTtcbn1cbnZhciBtdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIG10KHQsIGUpIHtcbiAgICB2YXIgX3RoaXMxID0gdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgbXQpO1xuICAgIHZhciBzID0gdGhpcy5jb25maWcgPSBuZXcgUGwoZSksXG4gICAgICBuID0gWm4odCksXG4gICAgICBvID0ganMobik7XG4gICAgaWYgKG8pIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBpcyBhbHJlYWR5IGluIHVzZS4gQ2hhcnQgd2l0aCBJRCAnXCIgKyBvLmlkICsgXCInIG11c3QgYmUgZGVzdHJveWVkIGJlZm9yZSB0aGUgY2FudmFzIHdpdGggSUQgJ1wiICsgby5jYW52YXMuaWQgKyBcIicgY2FuIGJlIHJldXNlZC5cIik7XG4gICAgdmFyIHIgPSBzLmNyZWF0ZVJlc29sdmVyKHMuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMucGxhdGZvcm0gPSBuZXcgKHMucGxhdGZvcm0gfHwgSmEobikpKCksIHRoaXMucGxhdGZvcm0udXBkYXRlQ29uZmlnKHMpO1xuICAgIHZhciBhID0gdGhpcy5wbGF0Zm9ybS5hY3F1aXJlQ29udGV4dChuLCByLmFzcGVjdFJhdGlvKSxcbiAgICAgIGwgPSBhICYmIGEuY2FudmFzLFxuICAgICAgYyA9IGwgJiYgbC5oZWlnaHQsXG4gICAgICBoID0gbCAmJiBsLndpZHRoO1xuICAgIGlmICh0aGlzLmlkID0gTG8oKSwgdGhpcy5jdHggPSBhLCB0aGlzLmNhbnZhcyA9IGwsIHRoaXMud2lkdGggPSBoLCB0aGlzLmhlaWdodCA9IGMsIHRoaXMuX29wdGlvbnMgPSByLCB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW8sIHRoaXMuX2xheWVycyA9IFtdLCB0aGlzLl9tZXRhc2V0cyA9IFtdLCB0aGlzLl9zdGFja3MgPSB2b2lkIDAsIHRoaXMuYm94ZXMgPSBbXSwgdGhpcy5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHZvaWQgMCwgdGhpcy5jaGFydEFyZWEgPSB2b2lkIDAsIHRoaXMuX2FjdGl2ZSA9IFtdLCB0aGlzLl9sYXN0RXZlbnQgPSB2b2lkIDAsIHRoaXMuX2xpc3RlbmVycyA9IHt9LCB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdm9pZCAwLCB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IFtdLCB0aGlzLnNjYWxlcyA9IHt9LCB0aGlzLl9wbHVnaW5zID0gbmV3IHBsKCksIHRoaXMuJHByb3hpZXMgPSB7fSwgdGhpcy5faGlkZGVuSW5kaWNlcyA9IHt9LCB0aGlzLmF0dGFjaGVkID0gITEsIHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9IHZvaWQgMCwgdGhpcy4kY29udGV4dCA9IHZvaWQgMCwgdGhpcy5fZG9SZXNpemUgPSBabyhmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIF90aGlzMS51cGRhdGUoZCk7XG4gICAgfSwgci5yZXNpemVEZWxheSB8fCAwKSwgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXSwgQmVbdGhpcy5pZF0gPSB0aGlzLCAhYSB8fCAhbCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2hhcnQ6IGNhbid0IGFjcXVpcmUgY29udGV4dCBmcm9tIHRoZSBnaXZlbiBpdGVtXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1dC5saXN0ZW4odGhpcywgXCJjb21wbGV0ZVwiLCBWcyksIHV0Lmxpc3Rlbih0aGlzLCBcInByb2dyZXNzXCIsIEFsKSwgdGhpcy5faW5pdGlhbGl6ZSgpLCB0aGlzLmF0dGFjaGVkICYmIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhtdCwgW3tcbiAgICBrZXk6IFwiYXNwZWN0UmF0aW9cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfdGhpcyRvcHRpb25zMTAgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHQgPSBfdGhpcyRvcHRpb25zMTAuYXNwZWN0UmF0aW8sXG4gICAgICAgIGUgPSBfdGhpcyRvcHRpb25zMTAubWFpbnRhaW5Bc3BlY3RSYXRpbyxcbiAgICAgICAgcyA9IHRoaXMud2lkdGgsXG4gICAgICAgIG4gPSB0aGlzLmhlaWdodCxcbiAgICAgICAgbyA9IHRoaXMuX2FzcGVjdFJhdGlvO1xuICAgICAgcmV0dXJuIFIodCkgPyBlICYmIG8gPyBvIDogbiA/IHMgLyBuIDogbnVsbCA6IHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhdGFcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodCkge1xuICAgICAgdGhpcy5jb25maWcuZGF0YSA9IHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9wdGlvbnNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodCkge1xuICAgICAgdGhpcy5jb25maWcub3B0aW9ucyA9IHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZ2lzdHJ5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gYXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0aWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0aWFsaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZUluaXRcIiksIHRoaXMub3B0aW9ucy5yZXNwb25zaXZlID8gdGhpcy5yZXNpemUoKSA6IHVzKHRoaXMsIHRoaXMub3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKSwgdGhpcy5iaW5kRXZlbnRzKCksIHRoaXMubm90aWZ5UGx1Z2lucyhcImFmdGVySW5pdFwiKSwgdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICByZXR1cm4gY3ModGhpcy5jYW52YXMsIHRoaXMuY3R4KSwgdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgcmV0dXJuIHV0LnN0b3AodGhpcyksIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUodCwgZSkge1xuICAgICAgdXQucnVubmluZyh0aGlzKSA/IHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSB7XG4gICAgICAgIHdpZHRoOiB0LFxuICAgICAgICBoZWlnaHQ6IGVcbiAgICAgIH0gOiB0aGlzLl9yZXNpemUodCwgZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZSh0LCBlKSB7XG4gICAgICB2YXIgcyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgbiA9IHRoaXMuY2FudmFzLFxuICAgICAgICBvID0gcy5tYWludGFpbkFzcGVjdFJhdGlvICYmIHRoaXMuYXNwZWN0UmF0aW8sXG4gICAgICAgIHIgPSB0aGlzLnBsYXRmb3JtLmdldE1heGltdW1TaXplKG4sIHQsIGUsIG8pLFxuICAgICAgICBhID0gcy5kZXZpY2VQaXhlbFJhdGlvIHx8IHRoaXMucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpLFxuICAgICAgICBsID0gdGhpcy53aWR0aCA/IFwicmVzaXplXCIgOiBcImF0dGFjaFwiO1xuICAgICAgdGhpcy53aWR0aCA9IHIud2lkdGgsIHRoaXMuaGVpZ2h0ID0gci5oZWlnaHQsIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbywgdXModGhpcywgYSwgITApICYmICh0aGlzLm5vdGlmeVBsdWdpbnMoXCJyZXNpemVcIiwge1xuICAgICAgICBzaXplOiByXG4gICAgICB9KSwgSShzLm9uUmVzaXplLCBbdGhpcywgcl0sIHRoaXMpLCB0aGlzLmF0dGFjaGVkICYmIHRoaXMuX2RvUmVzaXplKGwpICYmIHRoaXMucmVuZGVyKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbnN1cmVTY2FsZXNIYXZlSURzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZVNjYWxlc0hhdmVJRHMoKSB7XG4gICAgICB2YXIgZSA9IHRoaXMub3B0aW9ucy5zY2FsZXMgfHwge307XG4gICAgICBMKGUsIGZ1bmN0aW9uIChzLCBuKSB7XG4gICAgICAgIHMuaWQgPSBuO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkT3JVcGRhdGVTY2FsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRPclVwZGF0ZVNjYWxlcygpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBlID0gdC5zY2FsZXMsXG4gICAgICAgIHMgPSB0aGlzLnNjYWxlcyxcbiAgICAgICAgbiA9IE9iamVjdC5rZXlzKHMpLnJlZHVjZShmdW5jdGlvbiAociwgYSkge1xuICAgICAgICAgIHJldHVybiByW2FdID0gITEsIHI7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgIHZhciBvID0gW107XG4gICAgICBlICYmIChvID0gby5jb25jYXQoT2JqZWN0LmtleXMoZSkubWFwKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHZhciBhID0gZVtyXSxcbiAgICAgICAgICBsID0gUGkociwgYSksXG4gICAgICAgICAgYyA9IGwgPT09IFwiclwiLFxuICAgICAgICAgIGggPSBsID09PSBcInhcIjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvcHRpb25zOiBhLFxuICAgICAgICAgIGRwb3NpdGlvbjogYyA/IFwiY2hhcnRBcmVhXCIgOiBoID8gXCJib3R0b21cIiA6IFwibGVmdFwiLFxuICAgICAgICAgIGR0eXBlOiBjID8gXCJyYWRpYWxMaW5lYXJcIiA6IGggPyBcImNhdGVnb3J5XCIgOiBcImxpbmVhclwiXG4gICAgICAgIH07XG4gICAgICB9KSkpLCBMKG8sIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHZhciBhID0gci5vcHRpb25zLFxuICAgICAgICAgIGwgPSBhLmlkLFxuICAgICAgICAgIGMgPSBQaShsLCBhKSxcbiAgICAgICAgICBoID0gRChhLnR5cGUsIHIuZHR5cGUpO1xuICAgICAgICAoYS5wb3NpdGlvbiA9PT0gdm9pZCAwIHx8IFdzKGEucG9zaXRpb24sIGMpICE9PSBXcyhyLmRwb3NpdGlvbikpICYmIChhLnBvc2l0aW9uID0gci5kcG9zaXRpb24pLCBuW2xdID0gITA7XG4gICAgICAgIHZhciBkID0gbnVsbDtcbiAgICAgICAgaWYgKGwgaW4gcyAmJiBzW2xdLnR5cGUgPT09IGgpIGQgPSBzW2xdO2Vsc2Uge1xuICAgICAgICAgIHZhciB1ID0gYXQuZ2V0U2NhbGUoaCk7XG4gICAgICAgICAgZCA9IG5ldyB1KHtcbiAgICAgICAgICAgIGlkOiBsLFxuICAgICAgICAgICAgdHlwZTogaCxcbiAgICAgICAgICAgIGN0eDogX3RoaXMxMC5jdHgsXG4gICAgICAgICAgICBjaGFydDogX3RoaXMxMFxuICAgICAgICAgIH0pLCBzW2QuaWRdID0gZDtcbiAgICAgICAgfVxuICAgICAgICBkLmluaXQoYSwgdCk7XG4gICAgICB9KSwgTChuLCBmdW5jdGlvbiAociwgYSkge1xuICAgICAgICByIHx8IGRlbGV0ZSBzW2FdO1xuICAgICAgfSksIEwocywgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgdHQuY29uZmlndXJlKF90aGlzMTAsIHIsIHIub3B0aW9ucyksIHR0LmFkZEJveChfdGhpczEwLCByKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlTWV0YXNldHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZU1ldGFzZXRzKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9tZXRhc2V0cyxcbiAgICAgICAgZSA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGgsXG4gICAgICAgIHMgPSB0Lmxlbmd0aDtcbiAgICAgIGlmICh0LnNvcnQoZnVuY3Rpb24gKG4sIG8pIHtcbiAgICAgICAgcmV0dXJuIG4uaW5kZXggLSBvLmluZGV4O1xuICAgICAgfSksIHMgPiBlKSB7XG4gICAgICAgIGZvciAodmFyIG4gPSBlOyBuIDwgczsgKytuKSB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEobik7XG4gICAgICAgIHQuc3BsaWNlKGUsIHMgLSBlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gdC5zbGljZSgwKS5zb3J0KE5zKFwib3JkZXJcIiwgXCJpbmRleFwiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKSB7XG4gICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG4gICAgICB2YXIgdCA9IHRoaXMuX21ldGFzZXRzLFxuICAgICAgICBlID0gdGhpcy5kYXRhLmRhdGFzZXRzO1xuICAgICAgdC5sZW5ndGggPiBlLmxlbmd0aCAmJiBkZWxldGUgdGhpcy5fc3RhY2tzLCB0LmZvckVhY2goZnVuY3Rpb24gKHMsIG4pIHtcbiAgICAgICAgZS5maWx0ZXIoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICByZXR1cm4gbyA9PT0gcy5fZGF0YXNldDtcbiAgICAgICAgfSkubGVuZ3RoID09PSAwICYmIF90aGlzMTEuX2Rlc3Ryb3lEYXRhc2V0TWV0YShuKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWlsZE9yVXBkYXRlQ29udHJvbGxlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCkge1xuICAgICAgdmFyIHQgPSBbXSxcbiAgICAgICAgZSA9IHRoaXMuZGF0YS5kYXRhc2V0cztcbiAgICAgIHZhciBzLCBuO1xuICAgICAgZm9yICh0aGlzLl9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpLCBzID0gMCwgbiA9IGUubGVuZ3RoOyBzIDwgbjsgcysrKSB7XG4gICAgICAgIHZhciBvID0gZVtzXTtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmdldERhdGFzZXRNZXRhKHMpO1xuICAgICAgICB2YXIgYSA9IG8udHlwZSB8fCB0aGlzLmNvbmZpZy50eXBlO1xuICAgICAgICBpZiAoci50eXBlICYmIHIudHlwZSAhPT0gYSAmJiAodGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKHMpLCByID0gdGhpcy5nZXREYXRhc2V0TWV0YShzKSksIHIudHlwZSA9IGEsIHIuaW5kZXhBeGlzID0gby5pbmRleEF4aXMgfHwgd2koYSwgdGhpcy5vcHRpb25zKSwgci5vcmRlciA9IG8ub3JkZXIgfHwgMCwgci5pbmRleCA9IHMsIHIubGFiZWwgPSBcIlwiICsgby5sYWJlbCwgci52aXNpYmxlID0gdGhpcy5pc0RhdGFzZXRWaXNpYmxlKHMpLCByLmNvbnRyb2xsZXIpIHIuY29udHJvbGxlci51cGRhdGVJbmRleChzKSwgci5jb250cm9sbGVyLmxpbmtTY2FsZXMoKTtlbHNlIHtcbiAgICAgICAgICB2YXIgbCA9IGF0LmdldENvbnRyb2xsZXIoYSksXG4gICAgICAgICAgICBfVyRkYXRhc2V0cyRhID0gVy5kYXRhc2V0c1thXSxcbiAgICAgICAgICAgIGMgPSBfVyRkYXRhc2V0cyRhLmRhdGFzZXRFbGVtZW50VHlwZSxcbiAgICAgICAgICAgIGggPSBfVyRkYXRhc2V0cyRhLmRhdGFFbGVtZW50VHlwZTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGwsIHtcbiAgICAgICAgICAgIGRhdGFFbGVtZW50VHlwZTogYXQuZ2V0RWxlbWVudChoKSxcbiAgICAgICAgICAgIGRhdGFzZXRFbGVtZW50VHlwZTogYyAmJiBhdC5nZXRFbGVtZW50KGMpXG4gICAgICAgICAgfSksIHIuY29udHJvbGxlciA9IG5ldyBsKHRoaXMsIHMpLCB0LnB1c2goci5jb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU1ldGFzZXRzKCksIHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNldEVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNldEVsZW1lbnRzKCkge1xuICAgICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuICAgICAgTCh0aGlzLmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIF90aGlzMTIuZ2V0RGF0YXNldE1ldGEoZSkuY29udHJvbGxlci5yZXNldCgpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5fcmVzZXRFbGVtZW50cygpLCB0aGlzLm5vdGlmeVBsdWdpbnMoXCJyZXNldFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuY29uZmlnO1xuICAgICAgZS51cGRhdGUoKTtcbiAgICAgIHZhciBzID0gdGhpcy5fb3B0aW9ucyA9IGUuY3JlYXRlUmVzb2x2ZXIoZS5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSksXG4gICAgICAgIG4gPSB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSAhcy5hbmltYXRpb247XG4gICAgICBpZiAodGhpcy5fdXBkYXRlU2NhbGVzKCksIHRoaXMuX2NoZWNrRXZlbnRCaW5kaW5ncygpLCB0aGlzLl91cGRhdGVIaWRkZW5JbmRpY2VzKCksIHRoaXMuX3BsdWdpbnMuaW52YWxpZGF0ZSgpLCB0aGlzLm5vdGlmeVBsdWdpbnMoXCJiZWZvcmVVcGRhdGVcIiwge1xuICAgICAgICBtb2RlOiB0LFxuICAgICAgICBjYW5jZWxhYmxlOiAhMFxuICAgICAgfSkgPT09ICExKSByZXR1cm47XG4gICAgICB2YXIgbyA9IHRoaXMuYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCk7XG4gICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoXCJiZWZvcmVFbGVtZW50c1VwZGF0ZVwiKTtcbiAgICAgIHZhciByID0gMDtcbiAgICAgIGZvciAodmFyIGMgPSAwLCBoID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgYyA8IGg7IGMrKykge1xuICAgICAgICB2YXIgX3RoaXMkZ2V0RGF0YXNldE1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGMpLFxuICAgICAgICAgIGQgPSBfdGhpcyRnZXREYXRhc2V0TWV0YS5jb250cm9sbGVyLFxuICAgICAgICAgIHUgPSAhbiAmJiBvLmluZGV4T2YoZCkgPT09IC0xO1xuICAgICAgICBkLmJ1aWxkT3JVcGRhdGVFbGVtZW50cyh1KSwgciA9IE1hdGgubWF4KCtkLmdldE1heE92ZXJmbG93KCksIHIpO1xuICAgICAgfVxuICAgICAgciA9IHRoaXMuX21pblBhZGRpbmcgPSBzLmxheW91dC5hdXRvUGFkZGluZyA/IHIgOiAwLCB0aGlzLl91cGRhdGVMYXlvdXQociksIG4gfHwgTChvLCBmdW5jdGlvbiAoYykge1xuICAgICAgICBjLnJlc2V0KCk7XG4gICAgICB9KSwgdGhpcy5fdXBkYXRlRGF0YXNldHModCksIHRoaXMubm90aWZ5UGx1Z2lucyhcImFmdGVyVXBkYXRlXCIsIHtcbiAgICAgICAgbW9kZTogdFxuICAgICAgfSksIHRoaXMuX2xheWVycy5zb3J0KE5zKFwielwiLCBcIl9pZHhcIikpO1xuICAgICAgdmFyIGEgPSB0aGlzLl9hY3RpdmUsXG4gICAgICAgIGwgPSB0aGlzLl9sYXN0RXZlbnQ7XG4gICAgICBsID8gdGhpcy5fZXZlbnRIYW5kbGVyKGwsICEwKSA6IGEubGVuZ3RoICYmIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGEsIGEsICEwKSwgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVNjYWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlU2NhbGVzKCkge1xuICAgICAgdmFyIF90aGlzMTMgPSB0aGlzO1xuICAgICAgTCh0aGlzLnNjYWxlcywgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdHQucmVtb3ZlQm94KF90aGlzMTMsIHQpO1xuICAgICAgfSksIHRoaXMuZW5zdXJlU2NhbGVzSGF2ZUlEcygpLCB0aGlzLmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NoZWNrRXZlbnRCaW5kaW5nc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tFdmVudEJpbmRpbmdzKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGUgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMuX2xpc3RlbmVycykpLFxuICAgICAgICBzID0gbmV3IFNldCh0LmV2ZW50cyk7XG4gICAgICAoIVFpKGUsIHMpIHx8ICEhdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyAhPT0gdC5yZXNwb25zaXZlKSAmJiAodGhpcy51bmJpbmRFdmVudHMoKSwgdGhpcy5iaW5kRXZlbnRzKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlSGlkZGVuSW5kaWNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlSGlkZGVuSW5kaWNlcygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5faGlkZGVuSW5kaWNlcyxcbiAgICAgICAgZSA9IHRoaXMuX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHx8IFtdO1xuICAgICAgdmFyIF9pdGVyYXRvcjI1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZSksXG4gICAgICAgIF9zdGVwMjU7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjI1LnMoKTsgIShfc3RlcDI1ID0gX2l0ZXJhdG9yMjUubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDI1JHZhbHVlID0gX3N0ZXAyNS52YWx1ZSxcbiAgICAgICAgICAgIHMgPSBfc3RlcDI1JHZhbHVlLm1ldGhvZCxcbiAgICAgICAgICAgIG4gPSBfc3RlcDI1JHZhbHVlLnN0YXJ0LFxuICAgICAgICAgICAgbyA9IF9zdGVwMjUkdmFsdWUuY291bnQ7XG4gICAgICAgICAgdmFyIHIgPSBzID09PSBcIl9yZW1vdmVFbGVtZW50c1wiID8gLW8gOiBvO1xuICAgICAgICAgIFJsKHQsIG4sIHIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMjUuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMjUuZigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2RhdGFDaGFuZ2VzO1xuICAgICAgaWYgKCF0IHx8ICF0Lmxlbmd0aCkgcmV0dXJuO1xuICAgICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcbiAgICAgIHZhciBlID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aCxcbiAgICAgICAgcyA9IGZ1bmN0aW9uIHMobykge1xuICAgICAgICAgIHJldHVybiBuZXcgU2V0KHQuZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gclswXSA9PT0gbztcbiAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHIsIGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhICsgXCIsXCIgKyByLnNwbGljZSgxKS5qb2luKFwiLFwiKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG4gPSBzKDApO1xuICAgICAgZm9yICh2YXIgbyA9IDE7IG8gPCBlOyBvKyspIGlmICghUWkobiwgcyhvKSkpIHJldHVybjtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKG4pLm1hcChmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gby5zcGxpdChcIixcIik7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtZXRob2Q6IG9bMV0sXG4gICAgICAgICAgc3RhcnQ6ICtvWzJdLFxuICAgICAgICAgIGNvdW50OiArb1szXVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVMYXlvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUxheW91dCh0KSB7XG4gICAgICB2YXIgX3RoaXMxNCA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKFwiYmVmb3JlTGF5b3V0XCIsIHtcbiAgICAgICAgY2FuY2VsYWJsZTogITBcbiAgICAgIH0pID09PSAhMSkgcmV0dXJuO1xuICAgICAgdHQudXBkYXRlKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0KTtcbiAgICAgIHZhciBlID0gdGhpcy5jaGFydEFyZWEsXG4gICAgICAgIHMgPSBlLndpZHRoIDw9IDAgfHwgZS5oZWlnaHQgPD0gMDtcbiAgICAgIHRoaXMuX2xheWVycyA9IFtdLCBMKHRoaXMuYm94ZXMsIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHZhciBfdGhpczE0JF9sYXllcnM7XG4gICAgICAgIHMgJiYgbi5wb3NpdGlvbiA9PT0gXCJjaGFydEFyZWFcIiB8fCAobi5jb25maWd1cmUgJiYgbi5jb25maWd1cmUoKSwgKF90aGlzMTQkX2xheWVycyA9IF90aGlzMTQuX2xheWVycykucHVzaC5hcHBseShfdGhpczE0JF9sYXllcnMsIF90b0NvbnN1bWFibGVBcnJheShuLl9sYXllcnMoKSkpKTtcbiAgICAgIH0sIHRoaXMpLCB0aGlzLl9sYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobiwgbykge1xuICAgICAgICBuLl9pZHggPSBvO1xuICAgICAgfSksIHRoaXMubm90aWZ5UGx1Z2lucyhcImFmdGVyTGF5b3V0XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlRGF0YXNldHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZURhdGFzZXRzKHQpIHtcbiAgICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoXCJiZWZvcmVEYXRhc2V0c1VwZGF0ZVwiLCB7XG4gICAgICAgIG1vZGU6IHQsXG4gICAgICAgIGNhbmNlbGFibGU6ICEwXG4gICAgICB9KSAhPT0gITEpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IDAsIHMgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBlIDwgczsgKytlKSB0aGlzLmdldERhdGFzZXRNZXRhKGUpLmNvbnRyb2xsZXIuY29uZmlndXJlKCk7XG4gICAgICAgIGZvciAodmFyIF9lMyA9IDAsIF9zMyA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IF9lMyA8IF9zMzsgKytfZTMpIHRoaXMuX3VwZGF0ZURhdGFzZXQoX2UzLCB3dCh0KSA/IHQoe1xuICAgICAgICAgIGRhdGFzZXRJbmRleDogX2UzXG4gICAgICAgIH0pIDogdCk7XG4gICAgICAgIHRoaXMubm90aWZ5UGx1Z2lucyhcImFmdGVyRGF0YXNldHNVcGRhdGVcIiwge1xuICAgICAgICAgIG1vZGU6IHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVEYXRhc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVEYXRhc2V0KHQsIGUpIHtcbiAgICAgIHZhciBzID0gdGhpcy5nZXREYXRhc2V0TWV0YSh0KSxcbiAgICAgICAgbiA9IHtcbiAgICAgICAgICBtZXRhOiBzLFxuICAgICAgICAgIGluZGV4OiB0LFxuICAgICAgICAgIG1vZGU6IGUsXG4gICAgICAgICAgY2FuY2VsYWJsZTogITBcbiAgICAgICAgfTtcbiAgICAgIHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZURhdGFzZXRVcGRhdGVcIiwgbikgIT09ICExICYmIChzLmNvbnRyb2xsZXIuX3VwZGF0ZShlKSwgbi5jYW5jZWxhYmxlID0gITEsIHRoaXMubm90aWZ5UGx1Z2lucyhcImFmdGVyRGF0YXNldFVwZGF0ZVwiLCBuKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoXCJiZWZvcmVSZW5kZXJcIiwge1xuICAgICAgICBjYW5jZWxhYmxlOiAhMFxuICAgICAgfSkgIT09ICExICYmICh1dC5oYXModGhpcykgPyB0aGlzLmF0dGFjaGVkICYmICF1dC5ydW5uaW5nKHRoaXMpICYmIHV0LnN0YXJ0KHRoaXMpIDogKHRoaXMuZHJhdygpLCBWcyh7XG4gICAgICAgIGNoYXJ0OiB0aGlzXG4gICAgICB9KSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgICB2YXIgdDtcbiAgICAgIGlmICh0aGlzLl9yZXNpemVCZWZvcmVEcmF3KSB7XG4gICAgICAgIHZhciBfdGhpcyRfcmVzaXplQmVmb3JlRHIgPSB0aGlzLl9yZXNpemVCZWZvcmVEcmF3LFxuICAgICAgICAgIHMgPSBfdGhpcyRfcmVzaXplQmVmb3JlRHIud2lkdGgsXG4gICAgICAgICAgbiA9IF90aGlzJF9yZXNpemVCZWZvcmVEci5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSBudWxsLCB0aGlzLl9yZXNpemUocywgbik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jbGVhcigpLCB0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCB8fCB0aGlzLm5vdGlmeVBsdWdpbnMoXCJiZWZvcmVEcmF3XCIsIHtcbiAgICAgICAgY2FuY2VsYWJsZTogITBcbiAgICAgIH0pID09PSAhMSkgcmV0dXJuO1xuICAgICAgdmFyIGUgPSB0aGlzLl9sYXllcnM7XG4gICAgICBmb3IgKHQgPSAwOyB0IDwgZS5sZW5ndGggJiYgZVt0XS56IDw9IDA7ICsrdCkgZVt0XS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcbiAgICAgIGZvciAodGhpcy5fZHJhd0RhdGFzZXRzKCk7IHQgPCBlLmxlbmd0aDsgKyt0KSBlW3RdLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYWZ0ZXJEcmF3XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0U29ydGVkRGF0YXNldE1ldGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTb3J0ZWREYXRhc2V0TWV0YXModCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9zb3J0ZWRNZXRhc2V0cyxcbiAgICAgICAgcyA9IFtdO1xuICAgICAgdmFyIG4sIG87XG4gICAgICBmb3IgKG4gPSAwLCBvID0gZS5sZW5ndGg7IG4gPCBvOyArK24pIHtcbiAgICAgICAgdmFyIHIgPSBlW25dO1xuICAgICAgICAoIXQgfHwgci52aXNpYmxlKSAmJiBzLnB1c2gocik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNvcnRlZERhdGFzZXRNZXRhcyghMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3RGF0YXNldHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdEYXRhc2V0cygpIHtcbiAgICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoXCJiZWZvcmVEYXRhc2V0c0RyYXdcIiwge1xuICAgICAgICBjYW5jZWxhYmxlOiAhMFxuICAgICAgfSkgPT09ICExKSByZXR1cm47XG4gICAgICB2YXIgdCA9IHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgICAgZm9yICh2YXIgZSA9IHQubGVuZ3RoIC0gMTsgZSA+PSAwOyAtLWUpIHRoaXMuX2RyYXdEYXRhc2V0KHRbZV0pO1xuICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYWZ0ZXJEYXRhc2V0c0RyYXdcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3RGF0YXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0RhdGFzZXQodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmN0eCxcbiAgICAgICAgcyA9IHtcbiAgICAgICAgICBtZXRhOiB0LFxuICAgICAgICAgIGluZGV4OiB0LmluZGV4LFxuICAgICAgICAgIGNhbmNlbGFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIG4gPSBXbih0aGlzLCB0KTtcbiAgICAgIHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZURhdGFzZXREcmF3XCIsIHMpICE9PSAhMSAmJiAobiAmJiBKZShlLCBuKSwgdC5jb250cm9sbGVyLmRyYXcoKSwgbiAmJiBaZShlKSwgcy5jYW5jZWxhYmxlID0gITEsIHRoaXMubm90aWZ5UGx1Z2lucyhcImFmdGVyRGF0YXNldERyYXdcIiwgcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1BvaW50SW5BcmVhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUG9pbnRJbkFyZWEodCkge1xuICAgICAgcmV0dXJuIG1lKHQsIHRoaXMuY2hhcnRBcmVhLCB0aGlzLl9taW5QYWRkaW5nKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKHQsIGUsIHMsIG4pIHtcbiAgICAgIHZhciBvID0gVGEubW9kZXNbZV07XG4gICAgICByZXR1cm4gdHlwZW9mIG8gPT0gXCJmdW5jdGlvblwiID8gbyh0aGlzLCB0LCBzLCBuKSA6IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREYXRhc2V0TWV0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREYXRhc2V0TWV0YSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuZGF0YS5kYXRhc2V0c1t0XSxcbiAgICAgICAgcyA9IHRoaXMuX21ldGFzZXRzO1xuICAgICAgdmFyIG4gPSBzLmZpbHRlcihmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gbyAmJiBvLl9kYXRhc2V0ID09PSBlO1xuICAgICAgfSkucG9wKCk7XG4gICAgICByZXR1cm4gbiB8fCAobiA9IHtcbiAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGRhdGFzZXQ6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgIGhpZGRlbjogbnVsbCxcbiAgICAgICAgeEF4aXNJRDogbnVsbCxcbiAgICAgICAgeUF4aXNJRDogbnVsbCxcbiAgICAgICAgb3JkZXI6IGUgJiYgZS5vcmRlciB8fCAwLFxuICAgICAgICBpbmRleDogdCxcbiAgICAgICAgX2RhdGFzZXQ6IGUsXG4gICAgICAgIF9wYXJzZWQ6IFtdLFxuICAgICAgICBfc29ydGVkOiAhMVxuICAgICAgfSwgcy5wdXNoKG4pKSwgbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSBCdChudWxsLCB7XG4gICAgICAgIGNoYXJ0OiB0aGlzLFxuICAgICAgICB0eXBlOiBcImNoYXJ0XCJcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmlzaWJsZURhdGFzZXRDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaXNpYmxlRGF0YXNldENvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNEYXRhc2V0VmlzaWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0RhdGFzZXRWaXNpYmxlKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5kYXRhLmRhdGFzZXRzW3RdO1xuICAgICAgaWYgKCFlKSByZXR1cm4gITE7XG4gICAgICB2YXIgcyA9IHRoaXMuZ2V0RGF0YXNldE1ldGEodCk7XG4gICAgICByZXR1cm4gdHlwZW9mIHMuaGlkZGVuID09IFwiYm9vbGVhblwiID8gIXMuaGlkZGVuIDogIWUuaGlkZGVuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXREYXRhc2V0VmlzaWJpbGl0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREYXRhc2V0VmlzaWJpbGl0eSh0LCBlKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuZ2V0RGF0YXNldE1ldGEodCk7XG4gICAgICBzLmhpZGRlbiA9ICFlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVEYXRhVmlzaWJpbGl0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVEYXRhVmlzaWJpbGl0eSh0KSB7XG4gICAgICB0aGlzLl9oaWRkZW5JbmRpY2VzW3RdID0gIXRoaXMuX2hpZGRlbkluZGljZXNbdF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERhdGFWaXNpYmlsaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERhdGFWaXNpYmlsaXR5KHQpIHtcbiAgICAgIHJldHVybiAhdGhpcy5faGlkZGVuSW5kaWNlc1t0XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVZpc2liaWxpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVZpc2liaWxpdHkodCwgZSwgcykge1xuICAgICAgdmFyIG4gPSBzID8gXCJzaG93XCIgOiBcImhpZGVcIixcbiAgICAgICAgbyA9IHRoaXMuZ2V0RGF0YXNldE1ldGEodCksXG4gICAgICAgIHIgPSBvLmNvbnRyb2xsZXIuX3Jlc29sdmVBbmltYXRpb25zKHZvaWQgMCwgbik7XG4gICAgICBnZShlKSA/IChvLmRhdGFbZV0uaGlkZGVuID0gIXMsIHRoaXMudXBkYXRlKCkpIDogKHRoaXMuc2V0RGF0YXNldFZpc2liaWxpdHkodCwgcyksIHIudXBkYXRlKG8sIHtcbiAgICAgICAgdmlzaWJsZTogc1xuICAgICAgfSksIHRoaXMudXBkYXRlKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBhLmRhdGFzZXRJbmRleCA9PT0gdCA/IG4gOiB2b2lkIDA7XG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSh0LCBlKSB7XG4gICAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KHQsIGUsICExKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KHQsIGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkodCwgZSwgITApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveURhdGFzZXRNZXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95RGF0YXNldE1ldGEodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9tZXRhc2V0c1t0XTtcbiAgICAgIGUgJiYgZS5jb250cm9sbGVyICYmIGUuY29udHJvbGxlci5fZGVzdHJveSgpLCBkZWxldGUgdGhpcy5fbWV0YXNldHNbdF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zdG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdG9wKCkge1xuICAgICAgdmFyIHQsIGU7XG4gICAgICBmb3IgKHRoaXMuc3RvcCgpLCB1dC5yZW1vdmUodGhpcyksIHQgPSAwLCBlID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgdCA8IGU7ICsrdCkgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoXCJiZWZvcmVEZXN0cm95XCIpO1xuICAgICAgdmFyIHQgPSB0aGlzLmNhbnZhcyxcbiAgICAgICAgZSA9IHRoaXMuY3R4O1xuICAgICAgdGhpcy5fc3RvcCgpLCB0aGlzLmNvbmZpZy5jbGVhckNhY2hlKCksIHQgJiYgKHRoaXMudW5iaW5kRXZlbnRzKCksIGNzKHQsIGUpLCB0aGlzLnBsYXRmb3JtLnJlbGVhc2VDb250ZXh0KGUpLCB0aGlzLmNhbnZhcyA9IG51bGwsIHRoaXMuY3R4ID0gbnVsbCksIGRlbGV0ZSBCZVt0aGlzLmlkXSwgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYWZ0ZXJEZXN0cm95XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0Jhc2U2NEltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQmFzZTY0SW1hZ2UoKSB7XG4gICAgICB2YXIgX3RoaXMkY2FudmFzO1xuICAgICAgcmV0dXJuIChfdGhpcyRjYW52YXMgPSB0aGlzLmNhbnZhcykudG9EYXRhVVJMLmFwcGx5KF90aGlzJGNhbnZhcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRzKCkge1xuICAgICAgdGhpcy5iaW5kVXNlckV2ZW50cygpLCB0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSA/IHRoaXMuYmluZFJlc3BvbnNpdmVFdmVudHMoKSA6IHRoaXMuYXR0YWNoZWQgPSAhMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZFVzZXJFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZFVzZXJFdmVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMxNSA9IHRoaXM7XG4gICAgICB2YXIgdCA9IHRoaXMuX2xpc3RlbmVycyxcbiAgICAgICAgZSA9IHRoaXMucGxhdGZvcm0sXG4gICAgICAgIHMgPSBmdW5jdGlvbiBzKG8sIHIpIHtcbiAgICAgICAgICBlLmFkZEV2ZW50TGlzdGVuZXIoX3RoaXMxNSwgbywgciksIHRbb10gPSByO1xuICAgICAgICB9LFxuICAgICAgICBuID0gZnVuY3Rpb24gbihvLCByLCBhKSB7XG4gICAgICAgICAgby5vZmZzZXRYID0gciwgby5vZmZzZXRZID0gYSwgX3RoaXMxNS5fZXZlbnRIYW5kbGVyKG8pO1xuICAgICAgICB9O1xuICAgICAgTCh0aGlzLm9wdGlvbnMuZXZlbnRzLCBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gcyhvLCBuKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiaW5kUmVzcG9uc2l2ZUV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kUmVzcG9uc2l2ZUV2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpczE2ID0gdGhpcztcbiAgICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgfHwgKHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB7fSk7XG4gICAgICB2YXIgdCA9IHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMsXG4gICAgICAgIGUgPSB0aGlzLnBsYXRmb3JtLFxuICAgICAgICBzID0gZnVuY3Rpb24gcyhsLCBjKSB7XG4gICAgICAgICAgZS5hZGRFdmVudExpc3RlbmVyKF90aGlzMTYsIGwsIGMpLCB0W2xdID0gYztcbiAgICAgICAgfSxcbiAgICAgICAgbiA9IGZ1bmN0aW9uIG4obCwgYykge1xuICAgICAgICAgIHRbbF0gJiYgKGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihfdGhpczE2LCBsLCBjKSwgZGVsZXRlIHRbbF0pO1xuICAgICAgICB9LFxuICAgICAgICBvID0gZnVuY3Rpb24gbyhsLCBjKSB7XG4gICAgICAgICAgX3RoaXMxNi5jYW52YXMgJiYgX3RoaXMxNi5yZXNpemUobCwgYyk7XG4gICAgICAgIH07XG4gICAgICB2YXIgcjtcbiAgICAgIHZhciBfYTIgPSBmdW5jdGlvbiBhKCkge1xuICAgICAgICBuKFwiYXR0YWNoXCIsIF9hMiksIF90aGlzMTYuYXR0YWNoZWQgPSAhMCwgX3RoaXMxNi5yZXNpemUoKSwgcyhcInJlc2l6ZVwiLCBvKSwgcyhcImRldGFjaFwiLCByKTtcbiAgICAgIH07XG4gICAgICByID0gZnVuY3Rpb24gcigpIHtcbiAgICAgICAgX3RoaXMxNi5hdHRhY2hlZCA9ICExLCBuKFwicmVzaXplXCIsIG8pLCBfdGhpczE2Ll9zdG9wKCksIF90aGlzMTYuX3Jlc2l6ZSgwLCAwKSwgcyhcImF0dGFjaFwiLCBfYTIpO1xuICAgICAgfSwgZS5pc0F0dGFjaGVkKHRoaXMuY2FudmFzKSA/IF9hMigpIDogcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bmJpbmRFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kRXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzMTcgPSB0aGlzO1xuICAgICAgTCh0aGlzLl9saXN0ZW5lcnMsIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIF90aGlzMTcucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihfdGhpczE3LCBlLCB0KTtcbiAgICAgIH0pLCB0aGlzLl9saXN0ZW5lcnMgPSB7fSwgTCh0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBfdGhpczE3LnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIoX3RoaXMxNywgZSwgdCk7XG4gICAgICB9KSwgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlSG92ZXJTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVIb3ZlclN0eWxlKHQsIGUsIHMpIHtcbiAgICAgIHZhciBuID0gcyA/IFwic2V0XCIgOiBcInJlbW92ZVwiO1xuICAgICAgdmFyIG8sIHIsIGEsIGw7XG4gICAgICBmb3IgKGUgPT09IFwiZGF0YXNldFwiICYmIChvID0gdGhpcy5nZXREYXRhc2V0TWV0YSh0WzBdLmRhdGFzZXRJbmRleCksIG8uY29udHJvbGxlcltcIl9cIiArIG4gKyBcIkRhdGFzZXRIb3ZlclN0eWxlXCJdKCkpLCBhID0gMCwgbCA9IHQubGVuZ3RoOyBhIDwgbDsgKythKSB7XG4gICAgICAgIHIgPSB0W2FdO1xuICAgICAgICB2YXIgYyA9IHIgJiYgdGhpcy5nZXREYXRhc2V0TWV0YShyLmRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgICAgICAgYyAmJiBjW24gKyBcIkhvdmVyU3R5bGVcIl0oci5lbGVtZW50LCByLmRhdGFzZXRJbmRleCwgci5pbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEFjdGl2ZUVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QWN0aXZlRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QWN0aXZlRWxlbWVudHModCkge1xuICAgICAgdmFyIF90aGlzMTggPSB0aGlzO1xuICAgICAgdmFyIGUgPSB0aGlzLl9hY3RpdmUgfHwgW10sXG4gICAgICAgIHMgPSB0Lm1hcChmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICAgICAgICB2YXIgbyA9IF9yZWY1LmRhdGFzZXRJbmRleCxcbiAgICAgICAgICAgIHIgPSBfcmVmNS5pbmRleDtcbiAgICAgICAgICB2YXIgYSA9IF90aGlzMTguZ2V0RGF0YXNldE1ldGEobyk7XG4gICAgICAgICAgaWYgKCFhKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBkYXRhc2V0IGZvdW5kIGF0IGluZGV4IFwiICsgbyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGFzZXRJbmRleDogbyxcbiAgICAgICAgICAgIGVsZW1lbnQ6IGEuZGF0YVtyXSxcbiAgICAgICAgICAgIGluZGV4OiByXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAhamUocywgZSkgJiYgKHRoaXMuX2FjdGl2ZSA9IHMsIHRoaXMuX2xhc3RFdmVudCA9IG51bGwsIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKHMsIGUpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm90aWZ5UGx1Z2luc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3RpZnlQbHVnaW5zKHQsIGUsIHMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLm5vdGlmeSh0aGlzLCB0LCBlLCBzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNQbHVnaW5FbmFibGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUGx1Z2luRW5hYmxlZCh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5fY2FjaGUuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLnBsdWdpbi5pZCA9PT0gdDtcbiAgICAgIH0pLmxlbmd0aCA9PT0gMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZUhvdmVyU3R5bGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVIb3ZlclN0eWxlcyh0LCBlLCBzKSB7XG4gICAgICB2YXIgbiA9IHRoaXMub3B0aW9ucy5ob3ZlcixcbiAgICAgICAgbyA9IGZ1bmN0aW9uIG8obCwgYykge1xuICAgICAgICAgIHJldHVybiBsLmZpbHRlcihmdW5jdGlvbiAoaCkge1xuICAgICAgICAgICAgcmV0dXJuICFjLnNvbWUoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGguZGF0YXNldEluZGV4ID09PSBkLmRhdGFzZXRJbmRleCAmJiBoLmluZGV4ID09PSBkLmluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHIgPSBvKGUsIHQpLFxuICAgICAgICBhID0gcyA/IHQgOiBvKHQsIGUpO1xuICAgICAgci5sZW5ndGggJiYgdGhpcy51cGRhdGVIb3ZlclN0eWxlKHIsIG4ubW9kZSwgITEpLCBhLmxlbmd0aCAmJiBuLm1vZGUgJiYgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGEsIG4ubW9kZSwgITApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZXZlbnRIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudEhhbmRsZXIodCwgZSkge1xuICAgICAgdmFyIF90aGlzMTkgPSB0aGlzO1xuICAgICAgdmFyIHMgPSB7XG4gICAgICAgICAgZXZlbnQ6IHQsXG4gICAgICAgICAgcmVwbGF5OiBlLFxuICAgICAgICAgIGNhbmNlbGFibGU6ICEwLFxuICAgICAgICAgIGluQ2hhcnRBcmVhOiB0aGlzLmlzUG9pbnRJbkFyZWEodClcbiAgICAgICAgfSxcbiAgICAgICAgbiA9IGZ1bmN0aW9uIG4ocikge1xuICAgICAgICAgIHJldHVybiAoci5vcHRpb25zLmV2ZW50cyB8fCBfdGhpczE5Lm9wdGlvbnMuZXZlbnRzKS5pbmNsdWRlcyh0W1wibmF0aXZlXCJdLnR5cGUpO1xuICAgICAgICB9O1xuICAgICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZUV2ZW50XCIsIHMsIG4pID09PSAhMSkgcmV0dXJuO1xuICAgICAgdmFyIG8gPSB0aGlzLl9oYW5kbGVFdmVudCh0LCBlLCBzLmluQ2hhcnRBcmVhKTtcbiAgICAgIHJldHVybiBzLmNhbmNlbGFibGUgPSAhMSwgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYWZ0ZXJFdmVudFwiLCBzLCBuKSwgKG8gfHwgcy5jaGFuZ2VkKSAmJiB0aGlzLnJlbmRlcigpLCB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUV2ZW50KHQsIGUsIHMpIHtcbiAgICAgIHZhciBfdGhpcyRfYWN0aXZlID0gdGhpcy5fYWN0aXZlLFxuICAgICAgICBuID0gX3RoaXMkX2FjdGl2ZSA9PT0gdm9pZCAwID8gW10gOiBfdGhpcyRfYWN0aXZlLFxuICAgICAgICBvID0gdGhpcy5vcHRpb25zLFxuICAgICAgICByID0gZSxcbiAgICAgICAgYSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKHQsIG4sIHMsIHIpLFxuICAgICAgICBsID0gSG8odCksXG4gICAgICAgIGMgPSBMbCh0LCB0aGlzLl9sYXN0RXZlbnQsIHMsIGwpO1xuICAgICAgcyAmJiAodGhpcy5fbGFzdEV2ZW50ID0gbnVsbCwgSShvLm9uSG92ZXIsIFt0LCBhLCB0aGlzXSwgdGhpcyksIGwgJiYgSShvLm9uQ2xpY2ssIFt0LCBhLCB0aGlzXSwgdGhpcykpO1xuICAgICAgdmFyIGggPSAhamUoYSwgbik7XG4gICAgICByZXR1cm4gKGggfHwgZSkgJiYgKHRoaXMuX2FjdGl2ZSA9IGEsIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGEsIG4sIGUpKSwgdGhpcy5fbGFzdEV2ZW50ID0gYywgaDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEFjdGl2ZUVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBY3RpdmVFbGVtZW50cyh0LCBlLCBzLCBuKSB7XG4gICAgICBpZiAodC50eXBlID09PSBcIm1vdXNlb3V0XCIpIHJldHVybiBbXTtcbiAgICAgIGlmICghcykgcmV0dXJuIGU7XG4gICAgICB2YXIgbyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUodCwgby5tb2RlLCBvLCBuKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJyZWdpc3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlcigpIHtcbiAgICAgIGF0LmFkZC5hcHBseShhdCwgYXJndW1lbnRzKSwgJHMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5yZWdpc3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnJlZ2lzdGVyKCkge1xuICAgICAgYXQucmVtb3ZlLmFwcGx5KGF0LCBhcmd1bWVudHMpLCAkcygpO1xuICAgIH1cbiAgfV0pO1xufSgpO1xudyhtdCwgXCJkZWZhdWx0c1wiLCBXKSwgdyhtdCwgXCJpbnN0YW5jZXNcIiwgQmUpLCB3KG10LCBcIm92ZXJyaWRlc1wiLCB6dCksIHcobXQsIFwicmVnaXN0cnlcIiwgYXQpLCB3KG10LCBcInZlcnNpb25cIiwgT2wpLCB3KG10LCBcImdldENoYXJ0XCIsIGpzKTtcbmZ1bmN0aW9uICRzKCkge1xuICByZXR1cm4gTChtdC5pbnN0YW5jZXMsIGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGkuX3BsdWdpbnMuaW52YWxpZGF0ZSgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIEVsKGksIHQsIGUpIHtcbiAgdmFyIHMgPSB0LnN0YXJ0QW5nbGUsXG4gICAgbiA9IHQueCxcbiAgICBvID0gdC55LFxuICAgIHIgPSB0Lm91dGVyUmFkaXVzLFxuICAgIGEgPSB0LmlubmVyUmFkaXVzLFxuICAgIGwgPSB0Lm9wdGlvbnMsXG4gICAgYyA9IGwuYm9yZGVyV2lkdGgsXG4gICAgaCA9IGwuYm9yZGVySm9pblN0eWxlLFxuICAgIGQgPSBNYXRoLm1pbihjIC8gciwgWihzIC0gZSkpO1xuICBpZiAoaS5iZWdpblBhdGgoKSwgaS5hcmMobiwgbywgciAtIGMgLyAyLCBzICsgZCAvIDIsIGUgLSBkIC8gMiksIGEgPiAwKSB7XG4gICAgdmFyIHUgPSBNYXRoLm1pbihjIC8gYSwgWihzIC0gZSkpO1xuICAgIGkuYXJjKG4sIG8sIGEgKyBjIC8gMiwgZSAtIHUgLyAyLCBzICsgdSAvIDIsICEwKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3UzID0gTWF0aC5taW4oYyAvIDIsIHIgKiBaKHMgLSBlKSk7XG4gICAgaWYgKGggPT09IFwicm91bmRcIikgaS5hcmMobiwgbywgX3UzLCBlIC0gRSAvIDIsIHMgKyBFIC8gMiwgITApO2Vsc2UgaWYgKGggPT09IFwiYmV2ZWxcIikge1xuICAgICAgdmFyIGYgPSAyICogX3UzICogX3UzLFxuICAgICAgICBwID0gLWYgKiBNYXRoLmNvcyhlICsgRSAvIDIpICsgbixcbiAgICAgICAgZyA9IC1mICogTWF0aC5zaW4oZSArIEUgLyAyKSArIG8sXG4gICAgICAgIG0gPSBmICogTWF0aC5jb3MocyArIEUgLyAyKSArIG4sXG4gICAgICAgIGIgPSBmICogTWF0aC5zaW4ocyArIEUgLyAyKSArIG87XG4gICAgICBpLmxpbmVUbyhwLCBnKSwgaS5saW5lVG8obSwgYik7XG4gICAgfVxuICB9XG4gIGkuY2xvc2VQYXRoKCksIGkubW92ZVRvKDAsIDApLCBpLnJlY3QoMCwgMCwgaS5jYW52YXMud2lkdGgsIGkuY2FudmFzLmhlaWdodCksIGkuY2xpcChcImV2ZW5vZGRcIik7XG59XG5mdW5jdGlvbiBGbChpLCB0LCBlKSB7XG4gIHZhciBzID0gdC5zdGFydEFuZ2xlLFxuICAgIG4gPSB0LnBpeGVsTWFyZ2luLFxuICAgIG8gPSB0LngsXG4gICAgciA9IHQueSxcbiAgICBhID0gdC5vdXRlclJhZGl1cyxcbiAgICBsID0gdC5pbm5lclJhZGl1cztcbiAgdmFyIGMgPSBuIC8gYTtcbiAgaS5iZWdpblBhdGgoKSwgaS5hcmMobywgciwgYSwgcyAtIGMsIGUgKyBjKSwgbCA+IG4gPyAoYyA9IG4gLyBsLCBpLmFyYyhvLCByLCBsLCBlICsgYywgcyAtIGMsICEwKSkgOiBpLmFyYyhvLCByLCBuLCBlICsgViwgcyAtIFYpLCBpLmNsb3NlUGF0aCgpLCBpLmNsaXAoKTtcbn1cbmZ1bmN0aW9uIElsKGkpIHtcbiAgcmV0dXJuIFdpKGksIFtcIm91dGVyU3RhcnRcIiwgXCJvdXRlckVuZFwiLCBcImlubmVyU3RhcnRcIiwgXCJpbm5lckVuZFwiXSk7XG59XG5mdW5jdGlvbiB6bChpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gSWwoaS5vcHRpb25zLmJvcmRlclJhZGl1cyksXG4gICAgbyA9IChlIC0gdCkgLyAyLFxuICAgIHIgPSBNYXRoLm1pbihvLCBzICogdCAvIDIpLFxuICAgIGEgPSBmdW5jdGlvbiBhKGwpIHtcbiAgICAgIHZhciBjID0gKGUgLSBNYXRoLm1pbihvLCBsKSkgKiBzIC8gMjtcbiAgICAgIHJldHVybiBVKGwsIDAsIE1hdGgubWluKG8sIGMpKTtcbiAgICB9O1xuICByZXR1cm4ge1xuICAgIG91dGVyU3RhcnQ6IGEobi5vdXRlclN0YXJ0KSxcbiAgICBvdXRlckVuZDogYShuLm91dGVyRW5kKSxcbiAgICBpbm5lclN0YXJ0OiBVKG4uaW5uZXJTdGFydCwgMCwgciksXG4gICAgaW5uZXJFbmQ6IFUobi5pbm5lckVuZCwgMCwgcilcbiAgfTtcbn1cbmZ1bmN0aW9uIFZ0KGksIHQsIGUsIHMpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBlICsgaSAqIE1hdGguY29zKHQpLFxuICAgIHk6IHMgKyBpICogTWF0aC5zaW4odClcbiAgfTtcbn1cbmZ1bmN0aW9uIEtlKGksIHQsIGUsIHMsIG4sIG8pIHtcbiAgdmFyIHIgPSB0LngsXG4gICAgYSA9IHQueSxcbiAgICBsID0gdC5zdGFydEFuZ2xlLFxuICAgIGMgPSB0LnBpeGVsTWFyZ2luLFxuICAgIGggPSB0LmlubmVyUmFkaXVzLFxuICAgIGQgPSBNYXRoLm1heCh0Lm91dGVyUmFkaXVzICsgcyArIGUgLSBjLCAwKSxcbiAgICB1ID0gaCA+IDAgPyBoICsgcyArIGUgKyBjIDogMDtcbiAgdmFyIGYgPSAwO1xuICB2YXIgcCA9IG4gLSBsO1xuICBpZiAocykge1xuICAgIHZhciBGID0gaCA+IDAgPyBoIC0gcyA6IDAsXG4gICAgICB6ID0gZCA+IDAgPyBkIC0gcyA6IDAsXG4gICAgICBIID0gKEYgKyB6KSAvIDIsXG4gICAgICBpdCA9IEggIT09IDAgPyBwICogSCAvIChIICsgcykgOiBwO1xuICAgIGYgPSAocCAtIGl0KSAvIDI7XG4gIH1cbiAgdmFyIGcgPSBNYXRoLm1heCgxZS0zLCBwICogZCAtIGUgLyBFKSAvIGQsXG4gICAgbSA9IChwIC0gZykgLyAyLFxuICAgIGIgPSBsICsgbSArIGYsXG4gICAgXyA9IG4gLSBtIC0gZixcbiAgICBfemwgPSB6bCh0LCB1LCBkLCBfIC0gYiksXG4gICAgdiA9IF96bC5vdXRlclN0YXJ0LFxuICAgIHkgPSBfemwub3V0ZXJFbmQsXG4gICAgeCA9IF96bC5pbm5lclN0YXJ0LFxuICAgIE0gPSBfemwuaW5uZXJFbmQsXG4gICAgUyA9IGQgLSB2LFxuICAgIGsgPSBkIC0geSxcbiAgICBQID0gYiArIHYgLyBTLFxuICAgIEMgPSBfIC0geSAvIGssXG4gICAgTyA9IHUgKyB4LFxuICAgIEEgPSB1ICsgTSxcbiAgICBqID0gYiArIHggLyBPLFxuICAgIEogPSBfIC0gTSAvIEE7XG4gIGlmIChpLmJlZ2luUGF0aCgpLCBvKSB7XG4gICAgdmFyIF9GNSA9IChQICsgQykgLyAyO1xuICAgIGlmIChpLmFyYyhyLCBhLCBkLCBQLCBfRjUpLCBpLmFyYyhyLCBhLCBkLCBfRjUsIEMpLCB5ID4gMCkge1xuICAgICAgdmFyICQgPSBWdChrLCBDLCByLCBhKTtcbiAgICAgIGkuYXJjKCQueCwgJC55LCB5LCBDLCBfICsgVik7XG4gICAgfVxuICAgIHZhciBfejUgPSBWdChBLCBfLCByLCBhKTtcbiAgICBpZiAoaS5saW5lVG8oX3o1LngsIF96NS55KSwgTSA+IDApIHtcbiAgICAgIHZhciBfJCA9IFZ0KEEsIEosIHIsIGEpO1xuICAgICAgaS5hcmMoXyQueCwgXyQueSwgTSwgXyArIFYsIEogKyBNYXRoLlBJKTtcbiAgICB9XG4gICAgdmFyIF9IMyA9IChfIC0gTSAvIHUgKyAoYiArIHggLyB1KSkgLyAyO1xuICAgIGlmIChpLmFyYyhyLCBhLCB1LCBfIC0gTSAvIHUsIF9IMywgITApLCBpLmFyYyhyLCBhLCB1LCBfSDMsIGIgKyB4IC8gdSwgITApLCB4ID4gMCkge1xuICAgICAgdmFyIF8kMiA9IFZ0KE8sIGosIHIsIGEpO1xuICAgICAgaS5hcmMoXyQyLngsIF8kMi55LCB4LCBqICsgTWF0aC5QSSwgYiAtIFYpO1xuICAgIH1cbiAgICB2YXIgX2l0ID0gVnQoUywgYiwgciwgYSk7XG4gICAgaWYgKGkubGluZVRvKF9pdC54LCBfaXQueSksIHYgPiAwKSB7XG4gICAgICB2YXIgXyQzID0gVnQoUywgUCwgciwgYSk7XG4gICAgICBpLmFyYyhfJDMueCwgXyQzLnksIHYsIGIgLSBWLCBQKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaS5tb3ZlVG8ociwgYSk7XG4gICAgdmFyIF9GNiA9IE1hdGguY29zKFApICogZCArIHIsXG4gICAgICBfejYgPSBNYXRoLnNpbihQKSAqIGQgKyBhO1xuICAgIGkubGluZVRvKF9GNiwgX3o2KTtcbiAgICB2YXIgX0g0ID0gTWF0aC5jb3MoQykgKiBkICsgcixcbiAgICAgIF9pdDIgPSBNYXRoLnNpbihDKSAqIGQgKyBhO1xuICAgIGkubGluZVRvKF9INCwgX2l0Mik7XG4gIH1cbiAgaS5jbG9zZVBhdGgoKTtcbn1cbmZ1bmN0aW9uIEJsKGksIHQsIGUsIHMsIG4pIHtcbiAgdmFyIG8gPSB0LmZ1bGxDaXJjbGVzLFxuICAgIHIgPSB0LnN0YXJ0QW5nbGUsXG4gICAgYSA9IHQuY2lyY3VtZmVyZW5jZTtcbiAgdmFyIGwgPSB0LmVuZEFuZ2xlO1xuICBpZiAobykge1xuICAgIEtlKGksIHQsIGUsIHMsIGwsIG4pO1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbzsgKytjKSBpLmZpbGwoKTtcbiAgICBpc05hTihhKSB8fCAobCA9IHIgKyAoYSAlIEIgfHwgQikpO1xuICB9XG4gIHJldHVybiBLZShpLCB0LCBlLCBzLCBsLCBuKSwgaS5maWxsKCksIGw7XG59XG5mdW5jdGlvbiBIbChpLCB0LCBlLCBzLCBuKSB7XG4gIHZhciBvID0gdC5mdWxsQ2lyY2xlcyxcbiAgICByID0gdC5zdGFydEFuZ2xlLFxuICAgIGEgPSB0LmNpcmN1bWZlcmVuY2UsXG4gICAgbCA9IHQub3B0aW9ucyxcbiAgICBjID0gbC5ib3JkZXJXaWR0aCxcbiAgICBoID0gbC5ib3JkZXJKb2luU3R5bGUsXG4gICAgZCA9IGwuYm9yZGVyRGFzaCxcbiAgICB1ID0gbC5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgIGYgPSBsLmJvcmRlclJhZGl1cyxcbiAgICBwID0gbC5ib3JkZXJBbGlnbiA9PT0gXCJpbm5lclwiO1xuICBpZiAoIWMpIHJldHVybjtcbiAgaS5zZXRMaW5lRGFzaChkIHx8IFtdKSwgaS5saW5lRGFzaE9mZnNldCA9IHUsIHAgPyAoaS5saW5lV2lkdGggPSBjICogMiwgaS5saW5lSm9pbiA9IGggfHwgXCJyb3VuZFwiKSA6IChpLmxpbmVXaWR0aCA9IGMsIGkubGluZUpvaW4gPSBoIHx8IFwiYmV2ZWxcIik7XG4gIHZhciBnID0gdC5lbmRBbmdsZTtcbiAgaWYgKG8pIHtcbiAgICBLZShpLCB0LCBlLCBzLCBnLCBuKTtcbiAgICBmb3IgKHZhciBtID0gMDsgbSA8IG87ICsrbSkgaS5zdHJva2UoKTtcbiAgICBpc05hTihhKSB8fCAoZyA9IHIgKyAoYSAlIEIgfHwgQikpO1xuICB9XG4gIHAgJiYgRmwoaSwgdCwgZyksIGwuc2VsZkpvaW4gJiYgZyAtIHIgPj0gRSAmJiBmID09PSAwICYmIGggIT09IFwibWl0ZXJcIiAmJiBFbChpLCB0LCBnKSwgbyB8fCAoS2UoaSwgdCwgZSwgcywgZywgbiksIGkuc3Ryb2tlKCkpO1xufVxudmFyIHJlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3QyKSB7XG4gIGZ1bmN0aW9uIHJlKGUpIHtcbiAgICB2YXIgX3RoaXMyMDtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgcmUpO1xuICAgIF90aGlzMjAgPSBfY2FsbFN1cGVyKHRoaXMsIHJlKTtcbiAgICB3KF90aGlzMjAsIFwiY2lyY3VtZmVyZW5jZVwiKTtcbiAgICB3KF90aGlzMjAsIFwiZW5kQW5nbGVcIik7XG4gICAgdyhfdGhpczIwLCBcImZ1bGxDaXJjbGVzXCIpO1xuICAgIHcoX3RoaXMyMCwgXCJpbm5lclJhZGl1c1wiKTtcbiAgICB3KF90aGlzMjAsIFwib3V0ZXJSYWRpdXNcIik7XG4gICAgdyhfdGhpczIwLCBcInBpeGVsTWFyZ2luXCIpO1xuICAgIHcoX3RoaXMyMCwgXCJzdGFydEFuZ2xlXCIpO1xuICAgIF90aGlzMjAub3B0aW9ucyA9IHZvaWQgMCwgX3RoaXMyMC5jaXJjdW1mZXJlbmNlID0gdm9pZCAwLCBfdGhpczIwLnN0YXJ0QW5nbGUgPSB2b2lkIDAsIF90aGlzMjAuZW5kQW5nbGUgPSB2b2lkIDAsIF90aGlzMjAuaW5uZXJSYWRpdXMgPSB2b2lkIDAsIF90aGlzMjAub3V0ZXJSYWRpdXMgPSB2b2lkIDAsIF90aGlzMjAucGl4ZWxNYXJnaW4gPSAwLCBfdGhpczIwLmZ1bGxDaXJjbGVzID0gMCwgZSAmJiBPYmplY3QuYXNzaWduKF90aGlzMjAsIGUpO1xuICAgIHJldHVybiBfdGhpczIwO1xuICB9XG4gIF9pbmhlcml0cyhyZSwgX3N0Mik7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MocmUsIFt7XG4gICAga2V5OiBcImluUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5SYW5nZShlLCBzLCBuKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuZ2V0UHJvcHMoW1wieFwiLCBcInlcIl0sIG4pLFxuICAgICAgICBfeW4yID0geW4obywge1xuICAgICAgICAgIHg6IGUsXG4gICAgICAgICAgeTogc1xuICAgICAgICB9KSxcbiAgICAgICAgciA9IF95bjIuYW5nbGUsXG4gICAgICAgIGEgPSBfeW4yLmRpc3RhbmNlLFxuICAgICAgICBfdGhpcyRnZXRQcm9wczIgPSB0aGlzLmdldFByb3BzKFtcInN0YXJ0QW5nbGVcIiwgXCJlbmRBbmdsZVwiLCBcImlubmVyUmFkaXVzXCIsIFwib3V0ZXJSYWRpdXNcIiwgXCJjaXJjdW1mZXJlbmNlXCJdLCBuKSxcbiAgICAgICAgbCA9IF90aGlzJGdldFByb3BzMi5zdGFydEFuZ2xlLFxuICAgICAgICBjID0gX3RoaXMkZ2V0UHJvcHMyLmVuZEFuZ2xlLFxuICAgICAgICBoID0gX3RoaXMkZ2V0UHJvcHMyLmlubmVyUmFkaXVzLFxuICAgICAgICBkID0gX3RoaXMkZ2V0UHJvcHMyLm91dGVyUmFkaXVzLFxuICAgICAgICB1ID0gX3RoaXMkZ2V0UHJvcHMyLmNpcmN1bWZlcmVuY2UsXG4gICAgICAgIGYgPSAodGhpcy5vcHRpb25zLnNwYWNpbmcgKyB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGgpIC8gMixcbiAgICAgICAgcCA9IEQodSwgYyAtIGwpLFxuICAgICAgICBnID0gcGUociwgbCwgYykgJiYgbCAhPT0gYyxcbiAgICAgICAgbSA9IHAgPj0gQiB8fCBnLFxuICAgICAgICBiID0gX3QoYSwgaCArIGYsIGQgKyBmKTtcbiAgICAgIHJldHVybiBtICYmIGI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENlbnRlclBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENlbnRlclBvaW50KGUpIHtcbiAgICAgIHZhciBfdGhpcyRnZXRQcm9wczMgPSB0aGlzLmdldFByb3BzKFtcInhcIiwgXCJ5XCIsIFwic3RhcnRBbmdsZVwiLCBcImVuZEFuZ2xlXCIsIFwiaW5uZXJSYWRpdXNcIiwgXCJvdXRlclJhZGl1c1wiXSwgZSksXG4gICAgICAgIHMgPSBfdGhpcyRnZXRQcm9wczMueCxcbiAgICAgICAgbiA9IF90aGlzJGdldFByb3BzMy55LFxuICAgICAgICBvID0gX3RoaXMkZ2V0UHJvcHMzLnN0YXJ0QW5nbGUsXG4gICAgICAgIHIgPSBfdGhpcyRnZXRQcm9wczMuZW5kQW5nbGUsXG4gICAgICAgIGEgPSBfdGhpcyRnZXRQcm9wczMuaW5uZXJSYWRpdXMsXG4gICAgICAgIGwgPSBfdGhpcyRnZXRQcm9wczMub3V0ZXJSYWRpdXMsXG4gICAgICAgIF90aGlzJG9wdGlvbnMxMSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgYyA9IF90aGlzJG9wdGlvbnMxMS5vZmZzZXQsXG4gICAgICAgIGggPSBfdGhpcyRvcHRpb25zMTEuc3BhY2luZyxcbiAgICAgICAgZCA9IChvICsgcikgLyAyLFxuICAgICAgICB1ID0gKGEgKyBsICsgaCArIGMpIC8gMjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHMgKyBNYXRoLmNvcyhkKSAqIHUsXG4gICAgICAgIHk6IG4gKyBNYXRoLnNpbihkKSAqIHVcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvb2x0aXBQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b29sdGlwUG9zaXRpb24oZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2VudGVyUG9pbnQoZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhlKSB7XG4gICAgICB2YXIgcyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgbiA9IHRoaXMuY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgbyA9IChzLm9mZnNldCB8fCAwKSAvIDQsXG4gICAgICAgIHIgPSAocy5zcGFjaW5nIHx8IDApIC8gMixcbiAgICAgICAgYSA9IHMuY2lyY3VsYXI7XG4gICAgICBpZiAodGhpcy5waXhlbE1hcmdpbiA9IHMuYm9yZGVyQWxpZ24gPT09IFwiaW5uZXJcIiA/IDAuMzMgOiAwLCB0aGlzLmZ1bGxDaXJjbGVzID0gbiA+IEIgPyBNYXRoLmZsb29yKG4gLyBCKSA6IDAsIG4gPT09IDAgfHwgdGhpcy5pbm5lclJhZGl1cyA8IDAgfHwgdGhpcy5vdXRlclJhZGl1cyA8IDApIHJldHVybjtcbiAgICAgIGUuc2F2ZSgpO1xuICAgICAgdmFyIGwgPSAodGhpcy5zdGFydEFuZ2xlICsgdGhpcy5lbmRBbmdsZSkgLyAyO1xuICAgICAgZS50cmFuc2xhdGUoTWF0aC5jb3MobCkgKiBvLCBNYXRoLnNpbihsKSAqIG8pO1xuICAgICAgdmFyIGMgPSAxIC0gTWF0aC5zaW4oTWF0aC5taW4oRSwgbiB8fCAwKSksXG4gICAgICAgIGggPSBvICogYztcbiAgICAgIGUuZmlsbFN0eWxlID0gcy5iYWNrZ3JvdW5kQ29sb3IsIGUuc3Ryb2tlU3R5bGUgPSBzLmJvcmRlckNvbG9yLCBCbChlLCB0aGlzLCBoLCByLCBhKSwgSGwoZSwgdGhpcywgaCwgciwgYSksIGUucmVzdG9yZSgpO1xuICAgIH1cbiAgfV0pO1xufShzdCk7XG53KHJlLCBcImlkXCIsIFwiYXJjXCIpLCB3KHJlLCBcImRlZmF1bHRzXCIsIHtcbiAgYm9yZGVyQWxpZ246IFwiY2VudGVyXCIsXG4gIGJvcmRlckNvbG9yOiBcIiNmZmZcIixcbiAgYm9yZGVyRGFzaDogW10sXG4gIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gIGJvcmRlckpvaW5TdHlsZTogdm9pZCAwLFxuICBib3JkZXJSYWRpdXM6IDAsXG4gIGJvcmRlcldpZHRoOiAyLFxuICBvZmZzZXQ6IDAsXG4gIHNwYWNpbmc6IDAsXG4gIGFuZ2xlOiB2b2lkIDAsXG4gIGNpcmN1bGFyOiAhMCxcbiAgc2VsZkpvaW46ICExXG59KSwgdyhyZSwgXCJkZWZhdWx0Um91dGVzXCIsIHtcbiAgYmFja2dyb3VuZENvbG9yOiBcImJhY2tncm91bmRDb2xvclwiXG59KSwgdyhyZSwgXCJkZXNjcmlwdG9yc1wiLCB7XG4gIF9zY3JpcHRhYmxlOiAhMCxcbiAgX2luZGV4YWJsZTogZnVuY3Rpb24gX2luZGV4YWJsZShlKSB7XG4gICAgcmV0dXJuIGUgIT09IFwiYm9yZGVyRGFzaFwiO1xuICB9XG59KTtcbmZ1bmN0aW9uIFFuKGksIHQpIHtcbiAgdmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHQ7XG4gIGkubGluZUNhcCA9IEQoZS5ib3JkZXJDYXBTdHlsZSwgdC5ib3JkZXJDYXBTdHlsZSksIGkuc2V0TGluZURhc2goRChlLmJvcmRlckRhc2gsIHQuYm9yZGVyRGFzaCkpLCBpLmxpbmVEYXNoT2Zmc2V0ID0gRChlLmJvcmRlckRhc2hPZmZzZXQsIHQuYm9yZGVyRGFzaE9mZnNldCksIGkubGluZUpvaW4gPSBEKGUuYm9yZGVySm9pblN0eWxlLCB0LmJvcmRlckpvaW5TdHlsZSksIGkubGluZVdpZHRoID0gRChlLmJvcmRlcldpZHRoLCB0LmJvcmRlcldpZHRoKSwgaS5zdHJva2VTdHlsZSA9IEQoZS5ib3JkZXJDb2xvciwgdC5ib3JkZXJDb2xvcik7XG59XG5mdW5jdGlvbiBXbChpLCB0LCBlKSB7XG4gIGkubGluZVRvKGUueCwgZS55KTtcbn1cbmZ1bmN0aW9uIE5sKGkpIHtcbiAgcmV0dXJuIGkuc3RlcHBlZCA/IGhyIDogaS50ZW5zaW9uIHx8IGkuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gXCJtb25vdG9uZVwiID8gZHIgOiBXbDtcbn1cbmZ1bmN0aW9uIHRvKGksIHQpIHtcbiAgdmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgcyA9IGkubGVuZ3RoLFxuICAgIF9lJHN0YXJ0ID0gZS5zdGFydCxcbiAgICBuID0gX2Ukc3RhcnQgPT09IHZvaWQgMCA/IDAgOiBfZSRzdGFydCxcbiAgICBfZSRlbmQgPSBlLmVuZCxcbiAgICBvID0gX2UkZW5kID09PSB2b2lkIDAgPyBzIC0gMSA6IF9lJGVuZCxcbiAgICByID0gdC5zdGFydCxcbiAgICBhID0gdC5lbmQsXG4gICAgbCA9IE1hdGgubWF4KG4sIHIpLFxuICAgIGMgPSBNYXRoLm1pbihvLCBhKSxcbiAgICBoID0gbiA8IHIgJiYgbyA8IHIgfHwgbiA+IGEgJiYgbyA+IGE7XG4gIHJldHVybiB7XG4gICAgY291bnQ6IHMsXG4gICAgc3RhcnQ6IGwsXG4gICAgbG9vcDogdC5sb29wLFxuICAgIGlsZW46IGMgPCBsICYmICFoID8gcyArIGMgLSBsIDogYyAtIGxcbiAgfTtcbn1cbmZ1bmN0aW9uIFZsKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSB0LnBvaW50cyxcbiAgICBvID0gdC5vcHRpb25zLFxuICAgIF90byA9IHRvKG4sIGUsIHMpLFxuICAgIHIgPSBfdG8uY291bnQsXG4gICAgYSA9IF90by5zdGFydCxcbiAgICBsID0gX3RvLmxvb3AsXG4gICAgYyA9IF90by5pbGVuLFxuICAgIGggPSBObChvKTtcbiAgdmFyIF9yZWY2ID0gcyB8fCB7fSxcbiAgICBfcmVmNiRtb3ZlID0gX3JlZjYubW92ZSxcbiAgICBkID0gX3JlZjYkbW92ZSA9PT0gdm9pZCAwID8gITAgOiBfcmVmNiRtb3ZlLFxuICAgIHUgPSBfcmVmNi5yZXZlcnNlLFxuICAgIGYsXG4gICAgcCxcbiAgICBnO1xuICBmb3IgKGYgPSAwOyBmIDw9IGM7ICsrZikgcCA9IG5bKGEgKyAodSA/IGMgLSBmIDogZikpICUgcl0sICFwLnNraXAgJiYgKGQgPyAoaS5tb3ZlVG8ocC54LCBwLnkpLCBkID0gITEpIDogaChpLCBnLCBwLCB1LCBvLnN0ZXBwZWQpLCBnID0gcCk7XG4gIHJldHVybiBsICYmIChwID0gblsoYSArICh1ID8gYyA6IDApKSAlIHJdLCBoKGksIGcsIHAsIHUsIG8uc3RlcHBlZCkpLCAhIWw7XG59XG5mdW5jdGlvbiBqbChpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gdC5wb2ludHMsXG4gICAgX3RvMiA9IHRvKG4sIGUsIHMpLFxuICAgIG8gPSBfdG8yLmNvdW50LFxuICAgIHIgPSBfdG8yLnN0YXJ0LFxuICAgIGEgPSBfdG8yLmlsZW4sXG4gICAgX3JlZjcgPSBzIHx8IHt9LFxuICAgIF9yZWY3JG1vdmUgPSBfcmVmNy5tb3ZlLFxuICAgIGwgPSBfcmVmNyRtb3ZlID09PSB2b2lkIDAgPyAhMCA6IF9yZWY3JG1vdmUsXG4gICAgYyA9IF9yZWY3LnJldmVyc2U7XG4gIHZhciBoID0gMCxcbiAgICBkID0gMCxcbiAgICB1LFxuICAgIGYsXG4gICAgcCxcbiAgICBnLFxuICAgIG0sXG4gICAgYjtcbiAgdmFyIF8gPSBmdW5jdGlvbiBfKHkpIHtcbiAgICAgIHJldHVybiAociArIChjID8gYSAtIHkgOiB5KSkgJSBvO1xuICAgIH0sXG4gICAgdiA9IGZ1bmN0aW9uIHYoKSB7XG4gICAgICBnICE9PSBtICYmIChpLmxpbmVUbyhoLCBtKSwgaS5saW5lVG8oaCwgZyksIGkubGluZVRvKGgsIGIpKTtcbiAgICB9O1xuICBmb3IgKGwgJiYgKGYgPSBuW18oMCldLCBpLm1vdmVUbyhmLngsIGYueSkpLCB1ID0gMDsgdSA8PSBhOyArK3UpIHtcbiAgICBpZiAoZiA9IG5bXyh1KV0sIGYuc2tpcCkgY29udGludWU7XG4gICAgdmFyIHkgPSBmLngsXG4gICAgICB4ID0gZi55LFxuICAgICAgTSA9IHkgfCAwO1xuICAgIE0gPT09IHAgPyAoeCA8IGcgPyBnID0geCA6IHggPiBtICYmIChtID0geCksIGggPSAoZCAqIGggKyB5KSAvICsrZCkgOiAodigpLCBpLmxpbmVUbyh5LCB4KSwgcCA9IE0sIGQgPSAwLCBnID0gbSA9IHgpLCBiID0geDtcbiAgfVxuICB2KCk7XG59XG5mdW5jdGlvbiBEaShpKSB7XG4gIHZhciB0ID0gaS5vcHRpb25zLFxuICAgIGUgPSB0LmJvcmRlckRhc2ggJiYgdC5ib3JkZXJEYXNoLmxlbmd0aDtcbiAgcmV0dXJuICFpLl9kZWNpbWF0ZWQgJiYgIWkuX2xvb3AgJiYgIXQudGVuc2lvbiAmJiB0LmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgIT09IFwibW9ub3RvbmVcIiAmJiAhdC5zdGVwcGVkICYmICFlID8gamwgOiBWbDtcbn1cbmZ1bmN0aW9uICRsKGkpIHtcbiAgcmV0dXJuIGkuc3RlcHBlZCA/IGpyIDogaS50ZW5zaW9uIHx8IGkuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gXCJtb25vdG9uZVwiID8gJHIgOiBSdDtcbn1cbmZ1bmN0aW9uIFlsKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSB0Ll9wYXRoO1xuICBuIHx8IChuID0gdC5fcGF0aCA9IG5ldyBQYXRoMkQoKSwgdC5wYXRoKG4sIGUsIHMpICYmIG4uY2xvc2VQYXRoKCkpLCBRbihpLCB0Lm9wdGlvbnMpLCBpLnN0cm9rZShuKTtcbn1cbmZ1bmN0aW9uIFVsKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSB0LnNlZ21lbnRzLFxuICAgIG8gPSB0Lm9wdGlvbnMsXG4gICAgciA9IERpKHQpO1xuICB2YXIgX2l0ZXJhdG9yMjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihuKSxcbiAgICBfc3RlcDI2O1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMjYucygpOyAhKF9zdGVwMjYgPSBfaXRlcmF0b3IyNi5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgYSA9IF9zdGVwMjYudmFsdWU7XG4gICAgICBRbihpLCBvLCBhLnN0eWxlKSwgaS5iZWdpblBhdGgoKSwgcihpLCB0LCBhLCB7XG4gICAgICAgIHN0YXJ0OiBlLFxuICAgICAgICBlbmQ6IGUgKyBzIC0gMVxuICAgICAgfSkgJiYgaS5jbG9zZVBhdGgoKSwgaS5zdHJva2UoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjI2LmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IyNi5mKCk7XG4gIH1cbn1cbnZhciBYbCA9IHR5cGVvZiBQYXRoMkQgPT0gXCJmdW5jdGlvblwiO1xuZnVuY3Rpb24gcWwoaSwgdCwgZSwgcykge1xuICBYbCAmJiAhdC5vcHRpb25zLnNlZ21lbnQgPyBZbChpLCB0LCBlLCBzKSA6IFVsKGksIHQsIGUsIHMpO1xufVxudmFyIHZ0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3QzKSB7XG4gIGZ1bmN0aW9uIHZ0KHQpIHtcbiAgICB2YXIgX3RoaXMyMTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgdnQpO1xuICAgIF90aGlzMjEgPSBfY2FsbFN1cGVyKHRoaXMsIHZ0KSwgX3RoaXMyMS5hbmltYXRlZCA9ICEwLCBfdGhpczIxLm9wdGlvbnMgPSB2b2lkIDAsIF90aGlzMjEuX2NoYXJ0ID0gdm9pZCAwLCBfdGhpczIxLl9sb29wID0gdm9pZCAwLCBfdGhpczIxLl9mdWxsTG9vcCA9IHZvaWQgMCwgX3RoaXMyMS5fcGF0aCA9IHZvaWQgMCwgX3RoaXMyMS5fcG9pbnRzID0gdm9pZCAwLCBfdGhpczIxLl9zZWdtZW50cyA9IHZvaWQgMCwgX3RoaXMyMS5fZGVjaW1hdGVkID0gITEsIF90aGlzMjEuX3BvaW50c1VwZGF0ZWQgPSAhMSwgX3RoaXMyMS5fZGF0YXNldEluZGV4ID0gdm9pZCAwLCB0ICYmIE9iamVjdC5hc3NpZ24oX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczIxKSwgdCk7XG4gICAgcmV0dXJuIF90aGlzMjE7XG4gIH1cbiAgX2luaGVyaXRzKHZ0LCBfc3QzKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyh2dCwgW3tcbiAgICBrZXk6IFwidXBkYXRlQ29udHJvbFBvaW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVDb250cm9sUG9pbnRzKHQsIGUpIHtcbiAgICAgIHZhciBzID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKChzLnRlbnNpb24gfHwgcy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSBcIm1vbm90b25lXCIpICYmICFzLnN0ZXBwZWQgJiYgIXRoaXMuX3BvaW50c1VwZGF0ZWQpIHtcbiAgICAgICAgdmFyIG4gPSBzLnNwYW5HYXBzID8gdGhpcy5fbG9vcCA6IHRoaXMuX2Z1bGxMb29wO1xuICAgICAgICBGcih0aGlzLl9wb2ludHMsIHMsIHQsIG4sIGUpLCB0aGlzLl9wb2ludHNVcGRhdGVkID0gITA7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvaW50c1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BvaW50cztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHQpIHtcbiAgICAgIHRoaXMuX3BvaW50cyA9IHQsIGRlbGV0ZSB0aGlzLl9zZWdtZW50cywgZGVsZXRlIHRoaXMuX3BhdGgsIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSAhMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VnbWVudHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWdtZW50cyB8fCAodGhpcy5fc2VnbWVudHMgPSBHcih0aGlzLCB0aGlzLm9wdGlvbnMuc2VnbWVudCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaXJzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5zZWdtZW50cyxcbiAgICAgICAgZSA9IHRoaXMucG9pbnRzO1xuICAgICAgcmV0dXJuIHQubGVuZ3RoICYmIGVbdFswXS5zdGFydF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxhc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGFzdCgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5zZWdtZW50cyxcbiAgICAgICAgZSA9IHRoaXMucG9pbnRzLFxuICAgICAgICBzID0gdC5sZW5ndGg7XG4gICAgICByZXR1cm4gcyAmJiBlW3RbcyAtIDFdLmVuZF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludGVycG9sYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVycG9sYXRlKHQsIGUpIHtcbiAgICAgIHZhciBzID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBuID0gdFtlXSxcbiAgICAgICAgbyA9IHRoaXMucG9pbnRzLFxuICAgICAgICByID0gSG4odGhpcywge1xuICAgICAgICAgIHByb3BlcnR5OiBlLFxuICAgICAgICAgIHN0YXJ0OiBuLFxuICAgICAgICAgIGVuZDogblxuICAgICAgICB9KTtcbiAgICAgIGlmICghci5sZW5ndGgpIHJldHVybjtcbiAgICAgIHZhciBhID0gW10sXG4gICAgICAgIGwgPSAkbChzKTtcbiAgICAgIHZhciBjLCBoO1xuICAgICAgZm9yIChjID0gMCwgaCA9IHIubGVuZ3RoOyBjIDwgaDsgKytjKSB7XG4gICAgICAgIHZhciBfciRjID0gcltjXSxcbiAgICAgICAgICBkID0gX3IkYy5zdGFydCxcbiAgICAgICAgICB1ID0gX3IkYy5lbmQsXG4gICAgICAgICAgZiA9IG9bZF0sXG4gICAgICAgICAgcCA9IG9bdV07XG4gICAgICAgIGlmIChmID09PSBwKSB7XG4gICAgICAgICAgYS5wdXNoKGYpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnID0gTWF0aC5hYnMoKG4gLSBmW2VdKSAvIChwW2VdIC0gZltlXSkpLFxuICAgICAgICAgIG0gPSBsKGYsIHAsIGcsIHMuc3RlcHBlZCk7XG4gICAgICAgIG1bZV0gPSB0W2VdLCBhLnB1c2gobSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYS5sZW5ndGggPT09IDEgPyBhWzBdIDogYTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aFNlZ21lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aFNlZ21lbnQodCwgZSwgcykge1xuICAgICAgcmV0dXJuIERpKHRoaXMpKHQsIHRoaXMsIGUsIHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGgodCwgZSwgcykge1xuICAgICAgdmFyIG4gPSB0aGlzLnNlZ21lbnRzLFxuICAgICAgICBvID0gRGkodGhpcyk7XG4gICAgICB2YXIgciA9IHRoaXMuX2xvb3A7XG4gICAgICBlID0gZSB8fCAwLCBzID0gcyB8fCB0aGlzLnBvaW50cy5sZW5ndGggLSBlO1xuICAgICAgdmFyIF9pdGVyYXRvcjI3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobiksXG4gICAgICAgIF9zdGVwMjc7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjI3LnMoKTsgIShfc3RlcDI3ID0gX2l0ZXJhdG9yMjcubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBhID0gX3N0ZXAyNy52YWx1ZTtcbiAgICAgICAgICByICY9IG8odCwgdGhpcywgYSwge1xuICAgICAgICAgICAgc3RhcnQ6IGUsXG4gICAgICAgICAgICBlbmQ6IGUgKyBzIC0gMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMjcuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMjcuZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KHQsIGUsIHMsIG4pIHtcbiAgICAgIHZhciBvID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgICAgKHRoaXMucG9pbnRzIHx8IFtdKS5sZW5ndGggJiYgby5ib3JkZXJXaWR0aCAmJiAodC5zYXZlKCksIHFsKHQsIHRoaXMsIHMsIG4pLCB0LnJlc3RvcmUoKSksIHRoaXMuYW5pbWF0ZWQgJiYgKHRoaXMuX3BvaW50c1VwZGF0ZWQgPSAhMSwgdGhpcy5fcGF0aCA9IHZvaWQgMCk7XG4gICAgfVxuICB9XSk7XG59KHN0KTtcbncodnQsIFwiaWRcIiwgXCJsaW5lXCIpLCB3KHZ0LCBcImRlZmF1bHRzXCIsIHtcbiAgYm9yZGVyQ2FwU3R5bGU6IFwiYnV0dFwiLFxuICBib3JkZXJEYXNoOiBbXSxcbiAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgYm9yZGVySm9pblN0eWxlOiBcIm1pdGVyXCIsXG4gIGJvcmRlcldpZHRoOiAzLFxuICBjYXBCZXppZXJQb2ludHM6ICEwLFxuICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiBcImRlZmF1bHRcIixcbiAgZmlsbDogITEsXG4gIHNwYW5HYXBzOiAhMSxcbiAgc3RlcHBlZDogITEsXG4gIHRlbnNpb246IDBcbn0pLCB3KHZ0LCBcImRlZmF1bHRSb3V0ZXNcIiwge1xuICBiYWNrZ3JvdW5kQ29sb3I6IFwiYmFja2dyb3VuZENvbG9yXCIsXG4gIGJvcmRlckNvbG9yOiBcImJvcmRlckNvbG9yXCJcbn0pLCB3KHZ0LCBcImRlc2NyaXB0b3JzXCIsIHtcbiAgX3NjcmlwdGFibGU6ICEwLFxuICBfaW5kZXhhYmxlOiBmdW5jdGlvbiBfaW5kZXhhYmxlKHQpIHtcbiAgICByZXR1cm4gdCAhPT0gXCJib3JkZXJEYXNoXCIgJiYgdCAhPT0gXCJmaWxsXCI7XG4gIH1cbn0pO1xuZnVuY3Rpb24gWXMoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IGkub3B0aW9ucyxcbiAgICBfaSRnZXRQcm9wcyA9IGkuZ2V0UHJvcHMoW2VdLCBzKSxcbiAgICBvID0gX2kkZ2V0UHJvcHNbZV07XG4gIHJldHVybiBNYXRoLmFicyh0IC0gbykgPCBuLnJhZGl1cyArIG4uaGl0UmFkaXVzO1xufVxudmFyIEhlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3Q0KSB7XG4gIGZ1bmN0aW9uIEhlKGUpIHtcbiAgICB2YXIgX3RoaXMyMjtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGUpO1xuICAgIF90aGlzMjIgPSBfY2FsbFN1cGVyKHRoaXMsIEhlKTtcbiAgICB3KF90aGlzMjIsIFwicGFyc2VkXCIpO1xuICAgIHcoX3RoaXMyMiwgXCJza2lwXCIpO1xuICAgIHcoX3RoaXMyMiwgXCJzdG9wXCIpO1xuICAgIF90aGlzMjIub3B0aW9ucyA9IHZvaWQgMCwgX3RoaXMyMi5wYXJzZWQgPSB2b2lkIDAsIF90aGlzMjIuc2tpcCA9IHZvaWQgMCwgX3RoaXMyMi5zdG9wID0gdm9pZCAwLCBlICYmIE9iamVjdC5hc3NpZ24oX3RoaXMyMiwgZSk7XG4gICAgcmV0dXJuIF90aGlzMjI7XG4gIH1cbiAgX2luaGVyaXRzKEhlLCBfc3Q0KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhIZSwgW3tcbiAgICBrZXk6IFwiaW5SYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpblJhbmdlKGUsIHMsIG4pIHtcbiAgICAgIHZhciBvID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBfdGhpcyRnZXRQcm9wczQgPSB0aGlzLmdldFByb3BzKFtcInhcIiwgXCJ5XCJdLCBuKSxcbiAgICAgICAgciA9IF90aGlzJGdldFByb3BzNC54LFxuICAgICAgICBhID0gX3RoaXMkZ2V0UHJvcHM0Lnk7XG4gICAgICByZXR1cm4gTWF0aC5wb3coZSAtIHIsIDIpICsgTWF0aC5wb3cocyAtIGEsIDIpIDwgTWF0aC5wb3coby5oaXRSYWRpdXMgKyBvLnJhZGl1cywgMik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluWFJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluWFJhbmdlKGUsIHMpIHtcbiAgICAgIHJldHVybiBZcyh0aGlzLCBlLCBcInhcIiwgcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluWVJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluWVJhbmdlKGUsIHMpIHtcbiAgICAgIHJldHVybiBZcyh0aGlzLCBlLCBcInlcIiwgcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENlbnRlclBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENlbnRlclBvaW50KGUpIHtcbiAgICAgIHZhciBfdGhpcyRnZXRQcm9wczUgPSB0aGlzLmdldFByb3BzKFtcInhcIiwgXCJ5XCJdLCBlKSxcbiAgICAgICAgcyA9IF90aGlzJGdldFByb3BzNS54LFxuICAgICAgICBuID0gX3RoaXMkZ2V0UHJvcHM1Lnk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBzLFxuICAgICAgICB5OiBuXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpemUoZSkge1xuICAgICAgZSA9IGUgfHwgdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIHMgPSBlLnJhZGl1cyB8fCAwO1xuICAgICAgcyA9IE1hdGgubWF4KHMsIHMgJiYgZS5ob3ZlclJhZGl1cyB8fCAwKTtcbiAgICAgIHZhciBuID0gcyAmJiBlLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgICByZXR1cm4gKHMgKyBuKSAqIDI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhlLCBzKSB7XG4gICAgICB2YXIgbiA9IHRoaXMub3B0aW9ucztcbiAgICAgIHRoaXMuc2tpcCB8fCBuLnJhZGl1cyA8IDAuMSB8fCAhbWUodGhpcywgcywgdGhpcy5zaXplKG4pIC8gMikgfHwgKGUuc3Ryb2tlU3R5bGUgPSBuLmJvcmRlckNvbG9yLCBlLmxpbmVXaWR0aCA9IG4uYm9yZGVyV2lkdGgsIGUuZmlsbFN0eWxlID0gbi5iYWNrZ3JvdW5kQ29sb3IsIFNpKGUsIG4sIHRoaXMueCwgdGhpcy55KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhbmdlKCkge1xuICAgICAgdmFyIGUgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgICByZXR1cm4gZS5yYWRpdXMgKyBlLmhpdFJhZGl1cztcbiAgICB9XG4gIH1dKTtcbn0oc3QpO1xudyhIZSwgXCJpZFwiLCBcInBvaW50XCIpLFxuLyoqXG4qIEB0eXBlIHthbnl9XG4qL1xudyhIZSwgXCJkZWZhdWx0c1wiLCB7XG4gIGJvcmRlcldpZHRoOiAxLFxuICBoaXRSYWRpdXM6IDEsXG4gIGhvdmVyQm9yZGVyV2lkdGg6IDEsXG4gIGhvdmVyUmFkaXVzOiA0LFxuICBwb2ludFN0eWxlOiBcImNpcmNsZVwiLFxuICByYWRpdXM6IDMsXG4gIHJvdGF0aW9uOiAwXG59KSxcbi8qKlxuKiBAdHlwZSB7YW55fVxuKi9cbncoSGUsIFwiZGVmYXVsdFJvdXRlc1wiLCB7XG4gIGJhY2tncm91bmRDb2xvcjogXCJiYWNrZ3JvdW5kQ29sb3JcIixcbiAgYm9yZGVyQ29sb3I6IFwiYm9yZGVyQ29sb3JcIlxufSk7XG5mdW5jdGlvbiBlbyhpLCB0KSB7XG4gIHZhciBfaSRnZXRQcm9wczIgPSBpLmdldFByb3BzKFtcInhcIiwgXCJ5XCIsIFwiYmFzZVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCJdLCB0KSxcbiAgICBlID0gX2kkZ2V0UHJvcHMyLngsXG4gICAgcyA9IF9pJGdldFByb3BzMi55LFxuICAgIG4gPSBfaSRnZXRQcm9wczIuYmFzZSxcbiAgICBvID0gX2kkZ2V0UHJvcHMyLndpZHRoLFxuICAgIHIgPSBfaSRnZXRQcm9wczIuaGVpZ2h0O1xuICB2YXIgYSwgbCwgYywgaCwgZDtcbiAgcmV0dXJuIGkuaG9yaXpvbnRhbCA/IChkID0gciAvIDIsIGEgPSBNYXRoLm1pbihlLCBuKSwgbCA9IE1hdGgubWF4KGUsIG4pLCBjID0gcyAtIGQsIGggPSBzICsgZCkgOiAoZCA9IG8gLyAyLCBhID0gZSAtIGQsIGwgPSBlICsgZCwgYyA9IE1hdGgubWluKHMsIG4pLCBoID0gTWF0aC5tYXgocywgbikpLCB7XG4gICAgbGVmdDogYSxcbiAgICB0b3A6IGMsXG4gICAgcmlnaHQ6IGwsXG4gICAgYm90dG9tOiBoXG4gIH07XG59XG5mdW5jdGlvbiBNdChpLCB0LCBlLCBzKSB7XG4gIHJldHVybiBpID8gMCA6IFUodCwgZSwgcyk7XG59XG5mdW5jdGlvbiBLbChpLCB0LCBlKSB7XG4gIHZhciBzID0gaS5vcHRpb25zLmJvcmRlcldpZHRoLFxuICAgIG4gPSBpLmJvcmRlclNraXBwZWQsXG4gICAgbyA9IE9uKHMpO1xuICByZXR1cm4ge1xuICAgIHQ6IE10KG4udG9wLCBvLnRvcCwgMCwgZSksXG4gICAgcjogTXQobi5yaWdodCwgby5yaWdodCwgMCwgdCksXG4gICAgYjogTXQobi5ib3R0b20sIG8uYm90dG9tLCAwLCBlKSxcbiAgICBsOiBNdChuLmxlZnQsIG8ubGVmdCwgMCwgdClcbiAgfTtcbn1cbmZ1bmN0aW9uIEdsKGksIHQsIGUpIHtcbiAgdmFyIF9pJGdldFByb3BzMyA9IGkuZ2V0UHJvcHMoW1wiZW5hYmxlQm9yZGVyUmFkaXVzXCJdKSxcbiAgICBzID0gX2kkZ2V0UHJvcHMzLmVuYWJsZUJvcmRlclJhZGl1cyxcbiAgICBuID0gaS5vcHRpb25zLmJvcmRlclJhZGl1cyxcbiAgICBvID0gWXQobiksXG4gICAgciA9IE1hdGgubWluKHQsIGUpLFxuICAgIGEgPSBpLmJvcmRlclNraXBwZWQsXG4gICAgbCA9IHMgfHwgVChuKTtcbiAgcmV0dXJuIHtcbiAgICB0b3BMZWZ0OiBNdCghbCB8fCBhLnRvcCB8fCBhLmxlZnQsIG8udG9wTGVmdCwgMCwgciksXG4gICAgdG9wUmlnaHQ6IE10KCFsIHx8IGEudG9wIHx8IGEucmlnaHQsIG8udG9wUmlnaHQsIDAsIHIpLFxuICAgIGJvdHRvbUxlZnQ6IE10KCFsIHx8IGEuYm90dG9tIHx8IGEubGVmdCwgby5ib3R0b21MZWZ0LCAwLCByKSxcbiAgICBib3R0b21SaWdodDogTXQoIWwgfHwgYS5ib3R0b20gfHwgYS5yaWdodCwgby5ib3R0b21SaWdodCwgMCwgcilcbiAgfTtcbn1cbmZ1bmN0aW9uIEpsKGkpIHtcbiAgdmFyIHQgPSBlbyhpKSxcbiAgICBlID0gdC5yaWdodCAtIHQubGVmdCxcbiAgICBzID0gdC5ib3R0b20gLSB0LnRvcCxcbiAgICBuID0gS2woaSwgZSAvIDIsIHMgLyAyKSxcbiAgICBvID0gR2woaSwgZSAvIDIsIHMgLyAyKTtcbiAgcmV0dXJuIHtcbiAgICBvdXRlcjoge1xuICAgICAgeDogdC5sZWZ0LFxuICAgICAgeTogdC50b3AsXG4gICAgICB3OiBlLFxuICAgICAgaDogcyxcbiAgICAgIHJhZGl1czogb1xuICAgIH0sXG4gICAgaW5uZXI6IHtcbiAgICAgIHg6IHQubGVmdCArIG4ubCxcbiAgICAgIHk6IHQudG9wICsgbi50LFxuICAgICAgdzogZSAtIG4ubCAtIG4ucixcbiAgICAgIGg6IHMgLSBuLnQgLSBuLmIsXG4gICAgICByYWRpdXM6IHtcbiAgICAgICAgdG9wTGVmdDogTWF0aC5tYXgoMCwgby50b3BMZWZ0IC0gTWF0aC5tYXgobi50LCBuLmwpKSxcbiAgICAgICAgdG9wUmlnaHQ6IE1hdGgubWF4KDAsIG8udG9wUmlnaHQgLSBNYXRoLm1heChuLnQsIG4ucikpLFxuICAgICAgICBib3R0b21MZWZ0OiBNYXRoLm1heCgwLCBvLmJvdHRvbUxlZnQgLSBNYXRoLm1heChuLmIsIG4ubCkpLFxuICAgICAgICBib3R0b21SaWdodDogTWF0aC5tYXgoMCwgby5ib3R0b21SaWdodCAtIE1hdGgubWF4KG4uYiwgbi5yKSlcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmaShpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gdCA9PT0gbnVsbCxcbiAgICBvID0gZSA9PT0gbnVsbCxcbiAgICBhID0gaSAmJiAhKG4gJiYgbykgJiYgZW8oaSwgcyk7XG4gIHJldHVybiBhICYmIChuIHx8IF90KHQsIGEubGVmdCwgYS5yaWdodCkpICYmIChvIHx8IF90KGUsIGEudG9wLCBhLmJvdHRvbSkpO1xufVxuZnVuY3Rpb24gWmwoaSkge1xuICByZXR1cm4gaS50b3BMZWZ0IHx8IGkudG9wUmlnaHQgfHwgaS5ib3R0b21MZWZ0IHx8IGkuYm90dG9tUmlnaHQ7XG59XG5mdW5jdGlvbiBRbChpLCB0KSB7XG4gIGkucmVjdCh0LngsIHQueSwgdC53LCB0LmgpO1xufVxuZnVuY3Rpb24gZ2koaSwgdCkge1xuICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBzID0gaS54ICE9PSBlLnggPyAtdCA6IDAsXG4gICAgbiA9IGkueSAhPT0gZS55ID8gLXQgOiAwLFxuICAgIG8gPSAoaS54ICsgaS53ICE9PSBlLnggKyBlLncgPyB0IDogMCkgLSBzLFxuICAgIHIgPSAoaS55ICsgaS5oICE9PSBlLnkgKyBlLmggPyB0IDogMCkgLSBuO1xuICByZXR1cm4ge1xuICAgIHg6IGkueCArIHMsXG4gICAgeTogaS55ICsgbixcbiAgICB3OiBpLncgKyBvLFxuICAgIGg6IGkuaCArIHIsXG4gICAgcmFkaXVzOiBpLnJhZGl1c1xuICB9O1xufVxudmFyIFdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3Q1KSB7XG4gIGZ1bmN0aW9uIFdlKHQpIHtcbiAgICB2YXIgX3RoaXMyMztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2UpO1xuICAgIF90aGlzMjMgPSBfY2FsbFN1cGVyKHRoaXMsIFdlKSwgX3RoaXMyMy5vcHRpb25zID0gdm9pZCAwLCBfdGhpczIzLmhvcml6b250YWwgPSB2b2lkIDAsIF90aGlzMjMuYmFzZSA9IHZvaWQgMCwgX3RoaXMyMy53aWR0aCA9IHZvaWQgMCwgX3RoaXMyMy5oZWlnaHQgPSB2b2lkIDAsIF90aGlzMjMuaW5mbGF0ZUFtb3VudCA9IHZvaWQgMCwgdCAmJiBPYmplY3QuYXNzaWduKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMyMyksIHQpO1xuICAgIHJldHVybiBfdGhpczIzO1xuICB9XG4gIF9pbmhlcml0cyhXZSwgX3N0NSk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoV2UsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuaW5mbGF0ZUFtb3VudCxcbiAgICAgICAgX3RoaXMkb3B0aW9uczEyID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBzID0gX3RoaXMkb3B0aW9uczEyLmJvcmRlckNvbG9yLFxuICAgICAgICBuID0gX3RoaXMkb3B0aW9uczEyLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgX0psID0gSmwodGhpcyksXG4gICAgICAgIG8gPSBfSmwuaW5uZXIsXG4gICAgICAgIHIgPSBfSmwub3V0ZXIsXG4gICAgICAgIGEgPSBabChyLnJhZGl1cykgPyBVZSA6IFFsO1xuICAgICAgdC5zYXZlKCksIChyLncgIT09IG8udyB8fCByLmggIT09IG8uaCkgJiYgKHQuYmVnaW5QYXRoKCksIGEodCwgZ2kociwgZSwgbykpLCB0LmNsaXAoKSwgYSh0LCBnaShvLCAtZSwgcikpLCB0LmZpbGxTdHlsZSA9IHMsIHQuZmlsbChcImV2ZW5vZGRcIikpLCB0LmJlZ2luUGF0aCgpLCBhKHQsIGdpKG8sIGUpKSwgdC5maWxsU3R5bGUgPSBuLCB0LmZpbGwoKSwgdC5yZXN0b3JlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5SYW5nZSh0LCBlLCBzKSB7XG4gICAgICByZXR1cm4gZmkodGhpcywgdCwgZSwgcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluWFJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluWFJhbmdlKHQsIGUpIHtcbiAgICAgIHJldHVybiBmaSh0aGlzLCB0LCBudWxsLCBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5ZUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5ZUmFuZ2UodCwgZSkge1xuICAgICAgcmV0dXJuIGZpKHRoaXMsIG51bGwsIHQsIGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDZW50ZXJQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDZW50ZXJQb2ludCh0KSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0UHJvcHM2ID0gdGhpcy5nZXRQcm9wcyhbXCJ4XCIsIFwieVwiLCBcImJhc2VcIiwgXCJob3Jpem9udGFsXCJdLCB0KSxcbiAgICAgICAgZSA9IF90aGlzJGdldFByb3BzNi54LFxuICAgICAgICBzID0gX3RoaXMkZ2V0UHJvcHM2LnksXG4gICAgICAgIG4gPSBfdGhpcyRnZXRQcm9wczYuYmFzZSxcbiAgICAgICAgbyA9IF90aGlzJGdldFByb3BzNi5ob3Jpem9udGFsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogbyA/IChlICsgbikgLyAyIDogZSxcbiAgICAgICAgeTogbyA/IHMgOiAocyArIG4pIC8gMlxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2UodCkge1xuICAgICAgcmV0dXJuIHQgPT09IFwieFwiID8gdGhpcy53aWR0aCAvIDIgOiB0aGlzLmhlaWdodCAvIDI7XG4gICAgfVxuICB9XSk7XG59KHN0KTtcbncoV2UsIFwiaWRcIiwgXCJiYXJcIiksIHcoV2UsIFwiZGVmYXVsdHNcIiwge1xuICBib3JkZXJTa2lwcGVkOiBcInN0YXJ0XCIsXG4gIGJvcmRlcldpZHRoOiAwLFxuICBib3JkZXJSYWRpdXM6IDAsXG4gIGluZmxhdGVBbW91bnQ6IFwiYXV0b1wiLFxuICBwb2ludFN0eWxlOiB2b2lkIDBcbn0pLCB3KFdlLCBcImRlZmF1bHRSb3V0ZXNcIiwge1xuICBiYWNrZ3JvdW5kQ29sb3I6IFwiYmFja2dyb3VuZENvbG9yXCIsXG4gIGJvcmRlckNvbG9yOiBcImJvcmRlckNvbG9yXCJcbn0pO1xuZnVuY3Rpb24gdGMoaSwgdCwgZSkge1xuICB2YXIgcyA9IGkuc2VnbWVudHMsXG4gICAgbiA9IGkucG9pbnRzLFxuICAgIG8gPSB0LnBvaW50cyxcbiAgICByID0gW107XG4gIHZhciBfaXRlcmF0b3IyOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHMpLFxuICAgIF9zdGVwMjg7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IyOC5zKCk7ICEoX3N0ZXAyOCA9IF9pdGVyYXRvcjI4Lm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBhID0gX3N0ZXAyOC52YWx1ZTtcbiAgICAgIHZhciBsID0gYS5zdGFydCxcbiAgICAgICAgYyA9IGEuZW5kO1xuICAgICAgYyA9IGVpKGwsIGMsIG4pO1xuICAgICAgdmFyIGggPSBDaShlLCBuW2xdLCBuW2NdLCBhLmxvb3ApO1xuICAgICAgaWYgKCF0LnNlZ21lbnRzKSB7XG4gICAgICAgIHIucHVzaCh7XG4gICAgICAgICAgc291cmNlOiBhLFxuICAgICAgICAgIHRhcmdldDogaCxcbiAgICAgICAgICBzdGFydDogbltsXSxcbiAgICAgICAgICBlbmQ6IG5bY11cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGQgPSBIbih0LCBoKTtcbiAgICAgIHZhciBfaXRlcmF0b3IyOSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGQpLFxuICAgICAgICBfc3RlcDI5O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyOS5zKCk7ICEoX3N0ZXAyOSA9IF9pdGVyYXRvcjI5Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgdSA9IF9zdGVwMjkudmFsdWU7XG4gICAgICAgICAgdmFyIGYgPSBDaShlLCBvW3Uuc3RhcnRdLCBvW3UuZW5kXSwgdS5sb29wKSxcbiAgICAgICAgICAgIHAgPSBCbihhLCBuLCBmKTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yMzAgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwKSxcbiAgICAgICAgICAgIF9zdGVwMzA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMzAucygpOyAhKF9zdGVwMzAgPSBfaXRlcmF0b3IzMC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBnID0gX3N0ZXAzMC52YWx1ZTtcbiAgICAgICAgICAgICAgci5wdXNoKHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IGcsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB1LFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBfZGVmaW5lUHJvcGVydHkoe30sIGUsIFVzKGgsIGYsIFwic3RhcnRcIiwgTWF0aC5tYXgpKSxcbiAgICAgICAgICAgICAgICBlbmQ6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgZSwgVXMoaCwgZiwgXCJlbmRcIiwgTWF0aC5taW4pKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjMwLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMzAuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjI5LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjI5LmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjI4LmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IyOC5mKCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBDaShpLCB0LCBlLCBzKSB7XG4gIGlmIChzKSByZXR1cm47XG4gIHZhciBuID0gdFtpXSxcbiAgICBvID0gZVtpXTtcbiAgcmV0dXJuIGkgPT09IFwiYW5nbGVcIiAmJiAobiA9IFoobiksIG8gPSBaKG8pKSwge1xuICAgIHByb3BlcnR5OiBpLFxuICAgIHN0YXJ0OiBuLFxuICAgIGVuZDogb1xuICB9O1xufVxuZnVuY3Rpb24gZWMoaSwgdCkge1xuICB2YXIgX3JlZjggPSBpIHx8IHt9LFxuICAgIF9yZWY4JHggPSBfcmVmOC54LFxuICAgIGUgPSBfcmVmOCR4ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjgkeCxcbiAgICBfcmVmOCR5ID0gX3JlZjgueSxcbiAgICBzID0gX3JlZjgkeSA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWY4JHksXG4gICAgbiA9IHQucG9pbnRzLFxuICAgIG8gPSBbXTtcbiAgcmV0dXJuIHQuc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjkpIHtcbiAgICB2YXIgciA9IF9yZWY5LnN0YXJ0LFxuICAgICAgYSA9IF9yZWY5LmVuZDtcbiAgICBhID0gZWkociwgYSwgbik7XG4gICAgdmFyIGwgPSBuW3JdLFxuICAgICAgYyA9IG5bYV07XG4gICAgcyAhPT0gbnVsbCA/IChvLnB1c2goe1xuICAgICAgeDogbC54LFxuICAgICAgeTogc1xuICAgIH0pLCBvLnB1c2goe1xuICAgICAgeDogYy54LFxuICAgICAgeTogc1xuICAgIH0pKSA6IGUgIT09IG51bGwgJiYgKG8ucHVzaCh7XG4gICAgICB4OiBlLFxuICAgICAgeTogbC55XG4gICAgfSksIG8ucHVzaCh7XG4gICAgICB4OiBlLFxuICAgICAgeTogYy55XG4gICAgfSkpO1xuICB9KSwgbztcbn1cbmZ1bmN0aW9uIGVpKGksIHQsIGUpIHtcbiAgZm9yICg7IHQgPiBpOyB0LS0pIHtcbiAgICB2YXIgcyA9IGVbdF07XG4gICAgaWYgKCFpc05hTihzLngpICYmICFpc05hTihzLnkpKSBicmVhaztcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIFVzKGksIHQsIGUsIHMpIHtcbiAgcmV0dXJuIGkgJiYgdCA/IHMoaVtlXSwgdFtlXSkgOiBpID8gaVtlXSA6IHQgPyB0W2VdIDogMDtcbn1cbmZ1bmN0aW9uIGlvKGksIHQpIHtcbiAgdmFyIGUgPSBbXSxcbiAgICBzID0gITE7XG4gIHJldHVybiBOKGkpID8gKHMgPSAhMCwgZSA9IGkpIDogZSA9IGVjKGksIHQpLCBlLmxlbmd0aCA/IG5ldyB2dCh7XG4gICAgcG9pbnRzOiBlLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHRlbnNpb246IDBcbiAgICB9LFxuICAgIF9sb29wOiBzLFxuICAgIF9mdWxsTG9vcDogc1xuICB9KSA6IG51bGw7XG59XG5mdW5jdGlvbiBYcyhpKSB7XG4gIHJldHVybiBpICYmIGkuZmlsbCAhPT0gITE7XG59XG5mdW5jdGlvbiBpYyhpLCB0LCBlKSB7XG4gIHZhciBuID0gaVt0XS5maWxsO1xuICB2YXIgbyA9IFt0XTtcbiAgdmFyIHI7XG4gIGlmICghZSkgcmV0dXJuIG47XG4gIGZvciAoOyBuICE9PSAhMSAmJiBvLmluZGV4T2YobikgPT09IC0xOykge1xuICAgIGlmICghcShuKSkgcmV0dXJuIG47XG4gICAgaWYgKHIgPSBpW25dLCAhcikgcmV0dXJuICExO1xuICAgIGlmIChyLnZpc2libGUpIHJldHVybiBuO1xuICAgIG8ucHVzaChuKSwgbiA9IHIuZmlsbDtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBzYyhpLCB0LCBlKSB7XG4gIHZhciBzID0gYWMoaSk7XG4gIGlmIChUKHMpKSByZXR1cm4gaXNOYU4ocy52YWx1ZSkgPyAhMSA6IHM7XG4gIHZhciBuID0gcGFyc2VGbG9hdChzKTtcbiAgcmV0dXJuIHEobikgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiA/IG5jKHNbMF0sIHQsIG4sIGUpIDogW1wib3JpZ2luXCIsIFwic3RhcnRcIiwgXCJlbmRcIiwgXCJzdGFja1wiLCBcInNoYXBlXCJdLmluZGV4T2YocykgPj0gMCAmJiBzO1xufVxuZnVuY3Rpb24gbmMoaSwgdCwgZSwgcykge1xuICByZXR1cm4gKGkgPT09IFwiLVwiIHx8IGkgPT09IFwiK1wiKSAmJiAoZSA9IHQgKyBlKSwgZSA9PT0gdCB8fCBlIDwgMCB8fCBlID49IHMgPyAhMSA6IGU7XG59XG5mdW5jdGlvbiBvYyhpLCB0KSB7XG4gIHZhciBlID0gbnVsbDtcbiAgcmV0dXJuIGkgPT09IFwic3RhcnRcIiA/IGUgPSB0LmJvdHRvbSA6IGkgPT09IFwiZW5kXCIgPyBlID0gdC50b3AgOiBUKGkpID8gZSA9IHQuZ2V0UGl4ZWxGb3JWYWx1ZShpLnZhbHVlKSA6IHQuZ2V0QmFzZVBpeGVsICYmIChlID0gdC5nZXRCYXNlUGl4ZWwoKSksIGU7XG59XG5mdW5jdGlvbiByYyhpLCB0LCBlKSB7XG4gIHZhciBzO1xuICByZXR1cm4gaSA9PT0gXCJzdGFydFwiID8gcyA9IGUgOiBpID09PSBcImVuZFwiID8gcyA9IHQub3B0aW9ucy5yZXZlcnNlID8gdC5taW4gOiB0Lm1heCA6IFQoaSkgPyBzID0gaS52YWx1ZSA6IHMgPSB0LmdldEJhc2VWYWx1ZSgpLCBzO1xufVxuZnVuY3Rpb24gYWMoaSkge1xuICB2YXIgdCA9IGkub3B0aW9ucyxcbiAgICBlID0gdC5maWxsO1xuICB2YXIgcyA9IEQoZSAmJiBlLnRhcmdldCwgZSk7XG4gIHJldHVybiBzID09PSB2b2lkIDAgJiYgKHMgPSAhIXQuYmFja2dyb3VuZENvbG9yKSwgcyA9PT0gITEgfHwgcyA9PT0gbnVsbCA/ICExIDogcyA9PT0gITAgPyBcIm9yaWdpblwiIDogcztcbn1cbmZ1bmN0aW9uIGxjKGkpIHtcbiAgdmFyIHQgPSBpLnNjYWxlLFxuICAgIGUgPSBpLmluZGV4LFxuICAgIHMgPSBpLmxpbmUsXG4gICAgbiA9IFtdLFxuICAgIG8gPSBzLnNlZ21lbnRzLFxuICAgIHIgPSBzLnBvaW50cyxcbiAgICBhID0gY2ModCwgZSk7XG4gIGEucHVzaChpbyh7XG4gICAgeDogbnVsbCxcbiAgICB5OiB0LmJvdHRvbVxuICB9LCBzKSk7XG4gIGZvciAodmFyIGwgPSAwOyBsIDwgby5sZW5ndGg7IGwrKykge1xuICAgIHZhciBjID0gb1tsXTtcbiAgICBmb3IgKHZhciBoID0gYy5zdGFydDsgaCA8PSBjLmVuZDsgaCsrKSBoYyhuLCByW2hdLCBhKTtcbiAgfVxuICByZXR1cm4gbmV3IHZ0KHtcbiAgICBwb2ludHM6IG4sXG4gICAgb3B0aW9uczoge31cbiAgfSk7XG59XG5mdW5jdGlvbiBjYyhpLCB0KSB7XG4gIHZhciBlID0gW10sXG4gICAgcyA9IGkuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoXCJsaW5lXCIpO1xuICBmb3IgKHZhciBuID0gMDsgbiA8IHMubGVuZ3RoOyBuKyspIHtcbiAgICB2YXIgbyA9IHNbbl07XG4gICAgaWYgKG8uaW5kZXggPT09IHQpIGJyZWFrO1xuICAgIG8uaGlkZGVuIHx8IGUudW5zaGlmdChvLmRhdGFzZXQpO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gaGMoaSwgdCwgZSkge1xuICB2YXIgcyA9IFtdO1xuICBmb3IgKHZhciBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHtcbiAgICB2YXIgbyA9IGVbbl0sXG4gICAgICBfZGMgPSBkYyhvLCB0LCBcInhcIiksXG4gICAgICByID0gX2RjLmZpcnN0LFxuICAgICAgYSA9IF9kYy5sYXN0LFxuICAgICAgbCA9IF9kYy5wb2ludDtcbiAgICBpZiAoISghbCB8fCByICYmIGEpKSB7XG4gICAgICBpZiAocikgcy51bnNoaWZ0KGwpO2Vsc2UgaWYgKGkucHVzaChsKSwgIWEpIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpLnB1c2guYXBwbHkoaSwgcyk7XG59XG5mdW5jdGlvbiBkYyhpLCB0LCBlKSB7XG4gIHZhciBzID0gaS5pbnRlcnBvbGF0ZSh0LCBlKTtcbiAgaWYgKCFzKSByZXR1cm4ge307XG4gIHZhciBuID0gc1tlXSxcbiAgICBvID0gaS5zZWdtZW50cyxcbiAgICByID0gaS5wb2ludHM7XG4gIHZhciBhID0gITEsXG4gICAgbCA9ICExO1xuICBmb3IgKHZhciBjID0gMDsgYyA8IG8ubGVuZ3RoOyBjKyspIHtcbiAgICB2YXIgaCA9IG9bY10sXG4gICAgICBkID0gcltoLnN0YXJ0XVtlXSxcbiAgICAgIHUgPSByW2guZW5kXVtlXTtcbiAgICBpZiAoX3QobiwgZCwgdSkpIHtcbiAgICAgIGEgPSBuID09PSBkLCBsID0gbiA9PT0gdTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGZpcnN0OiBhLFxuICAgIGxhc3Q6IGwsXG4gICAgcG9pbnQ6IHNcbiAgfTtcbn1cbnZhciBzbyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHNvKHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgc28pO1xuICAgIHRoaXMueCA9IHQueCwgdGhpcy55ID0gdC55LCB0aGlzLnJhZGl1cyA9IHQucmFkaXVzO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3Moc28sIFt7XG4gICAga2V5OiBcInBhdGhTZWdtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhTZWdtZW50KHQsIGUsIHMpIHtcbiAgICAgIHZhciBuID0gdGhpcy54LFxuICAgICAgICBvID0gdGhpcy55LFxuICAgICAgICByID0gdGhpcy5yYWRpdXM7XG4gICAgICByZXR1cm4gZSA9IGUgfHwge1xuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZW5kOiBCXG4gICAgICB9LCB0LmFyYyhuLCBvLCByLCBlLmVuZCwgZS5zdGFydCwgITApLCAhcy5ib3VuZHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludGVycG9sYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVycG9sYXRlKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy54LFxuICAgICAgICBzID0gdGhpcy55LFxuICAgICAgICBuID0gdGhpcy5yYWRpdXMsXG4gICAgICAgIG8gPSB0LmFuZ2xlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogZSArIE1hdGguY29zKG8pICogbixcbiAgICAgICAgeTogcyArIE1hdGguc2luKG8pICogbixcbiAgICAgICAgYW5nbGU6IG9cbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG59KCk7XG5mdW5jdGlvbiB1YyhpKSB7XG4gIHZhciB0ID0gaS5jaGFydCxcbiAgICBlID0gaS5maWxsLFxuICAgIHMgPSBpLmxpbmU7XG4gIGlmIChxKGUpKSByZXR1cm4gZmModCwgZSk7XG4gIGlmIChlID09PSBcInN0YWNrXCIpIHJldHVybiBsYyhpKTtcbiAgaWYgKGUgPT09IFwic2hhcGVcIikgcmV0dXJuICEwO1xuICB2YXIgbiA9IGdjKGkpO1xuICByZXR1cm4gbiBpbnN0YW5jZW9mIHNvID8gbiA6IGlvKG4sIHMpO1xufVxuZnVuY3Rpb24gZmMoaSwgdCkge1xuICB2YXIgZSA9IGkuZ2V0RGF0YXNldE1ldGEodCk7XG4gIHJldHVybiBlICYmIGkuaXNEYXRhc2V0VmlzaWJsZSh0KSA/IGUuZGF0YXNldCA6IG51bGw7XG59XG5mdW5jdGlvbiBnYyhpKSB7XG4gIHJldHVybiAoaS5zY2FsZSB8fCB7fSkuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlID8gbWMoaSkgOiBwYyhpKTtcbn1cbmZ1bmN0aW9uIHBjKGkpIHtcbiAgdmFyIF9pJHNjYWxlID0gaS5zY2FsZSxcbiAgICB0ID0gX2kkc2NhbGUgPT09IHZvaWQgMCA/IHt9IDogX2kkc2NhbGUsXG4gICAgZSA9IGkuZmlsbCxcbiAgICBzID0gb2MoZSwgdCk7XG4gIGlmIChxKHMpKSB7XG4gICAgdmFyIG4gPSB0LmlzSG9yaXpvbnRhbCgpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBuID8gcyA6IG51bGwsXG4gICAgICB5OiBuID8gbnVsbCA6IHNcbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWMoaSkge1xuICB2YXIgdCA9IGkuc2NhbGUsXG4gICAgZSA9IGkuZmlsbCxcbiAgICBzID0gdC5vcHRpb25zLFxuICAgIG4gPSB0LmdldExhYmVscygpLmxlbmd0aCxcbiAgICBvID0gcy5yZXZlcnNlID8gdC5tYXggOiB0Lm1pbixcbiAgICByID0gcmMoZSwgdCwgbyksXG4gICAgYSA9IFtdO1xuICBpZiAocy5ncmlkLmNpcmN1bGFyKSB7XG4gICAgdmFyIGwgPSB0LmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSgwLCBvKTtcbiAgICByZXR1cm4gbmV3IHNvKHtcbiAgICAgIHg6IGwueCxcbiAgICAgIHk6IGwueSxcbiAgICAgIHJhZGl1czogdC5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShyKVxuICAgIH0pO1xuICB9XG4gIGZvciAodmFyIF9sMiA9IDA7IF9sMiA8IG47ICsrX2wyKSBhLnB1c2godC5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoX2wyLCByKSk7XG4gIHJldHVybiBhO1xufVxuZnVuY3Rpb24gcGkoaSwgdCwgZSkge1xuICB2YXIgcyA9IHVjKHQpLFxuICAgIG4gPSB0LmNoYXJ0LFxuICAgIG8gPSB0LmluZGV4LFxuICAgIHIgPSB0LmxpbmUsXG4gICAgYSA9IHQuc2NhbGUsXG4gICAgbCA9IHQuYXhpcyxcbiAgICBjID0gci5vcHRpb25zLFxuICAgIGggPSBjLmZpbGwsXG4gICAgZCA9IGMuYmFja2dyb3VuZENvbG9yLFxuICAgIF9yZWYwID0gaCB8fCB7fSxcbiAgICBfcmVmMCRhYm92ZSA9IF9yZWYwLmFib3ZlLFxuICAgIHUgPSBfcmVmMCRhYm92ZSA9PT0gdm9pZCAwID8gZCA6IF9yZWYwJGFib3ZlLFxuICAgIF9yZWYwJGJlbG93ID0gX3JlZjAuYmVsb3csXG4gICAgZiA9IF9yZWYwJGJlbG93ID09PSB2b2lkIDAgPyBkIDogX3JlZjAkYmVsb3csXG4gICAgcCA9IG4uZ2V0RGF0YXNldE1ldGEobyksXG4gICAgZyA9IFduKG4sIHApO1xuICBzICYmIHIucG9pbnRzLmxlbmd0aCAmJiAoSmUoaSwgZSksIGJjKGksIHtcbiAgICBsaW5lOiByLFxuICAgIHRhcmdldDogcyxcbiAgICBhYm92ZTogdSxcbiAgICBiZWxvdzogZixcbiAgICBhcmVhOiBlLFxuICAgIHNjYWxlOiBhLFxuICAgIGF4aXM6IGwsXG4gICAgY2xpcDogZ1xuICB9KSwgWmUoaSkpO1xufVxuZnVuY3Rpb24gYmMoaSwgdCkge1xuICB2YXIgZSA9IHQubGluZSxcbiAgICBzID0gdC50YXJnZXQsXG4gICAgbiA9IHQuYWJvdmUsXG4gICAgbyA9IHQuYmVsb3csXG4gICAgciA9IHQuYXJlYSxcbiAgICBhID0gdC5zY2FsZSxcbiAgICBsID0gdC5jbGlwLFxuICAgIGMgPSBlLl9sb29wID8gXCJhbmdsZVwiIDogdC5heGlzO1xuICBpLnNhdmUoKTtcbiAgdmFyIGggPSBvO1xuICBvICE9PSBuICYmIChjID09PSBcInhcIiA/IChxcyhpLCBzLCByLnRvcCksIG1pKGksIHtcbiAgICBsaW5lOiBlLFxuICAgIHRhcmdldDogcyxcbiAgICBjb2xvcjogbixcbiAgICBzY2FsZTogYSxcbiAgICBwcm9wZXJ0eTogYyxcbiAgICBjbGlwOiBsXG4gIH0pLCBpLnJlc3RvcmUoKSwgaS5zYXZlKCksIHFzKGksIHMsIHIuYm90dG9tKSkgOiBjID09PSBcInlcIiAmJiAoS3MoaSwgcywgci5sZWZ0KSwgbWkoaSwge1xuICAgIGxpbmU6IGUsXG4gICAgdGFyZ2V0OiBzLFxuICAgIGNvbG9yOiBvLFxuICAgIHNjYWxlOiBhLFxuICAgIHByb3BlcnR5OiBjLFxuICAgIGNsaXA6IGxcbiAgfSksIGkucmVzdG9yZSgpLCBpLnNhdmUoKSwgS3MoaSwgcywgci5yaWdodCksIGggPSBuKSksIG1pKGksIHtcbiAgICBsaW5lOiBlLFxuICAgIHRhcmdldDogcyxcbiAgICBjb2xvcjogaCxcbiAgICBzY2FsZTogYSxcbiAgICBwcm9wZXJ0eTogYyxcbiAgICBjbGlwOiBsXG4gIH0pLCBpLnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIHFzKGksIHQsIGUpIHtcbiAgdmFyIHMgPSB0LnNlZ21lbnRzLFxuICAgIG4gPSB0LnBvaW50cztcbiAgdmFyIG8gPSAhMCxcbiAgICByID0gITE7XG4gIGkuYmVnaW5QYXRoKCk7XG4gIHZhciBfaXRlcmF0b3IzMSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHMpLFxuICAgIF9zdGVwMzE7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IzMS5zKCk7ICEoX3N0ZXAzMSA9IF9pdGVyYXRvcjMxLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBhID0gX3N0ZXAzMS52YWx1ZTtcbiAgICAgIHZhciBsID0gYS5zdGFydCxcbiAgICAgICAgYyA9IGEuZW5kLFxuICAgICAgICBoID0gbltsXSxcbiAgICAgICAgZCA9IG5bZWkobCwgYywgbildO1xuICAgICAgbyA/IChpLm1vdmVUbyhoLngsIGgueSksIG8gPSAhMSkgOiAoaS5saW5lVG8oaC54LCBlKSwgaS5saW5lVG8oaC54LCBoLnkpKSwgciA9ICEhdC5wYXRoU2VnbWVudChpLCBhLCB7XG4gICAgICAgIG1vdmU6IHJcbiAgICAgIH0pLCByID8gaS5jbG9zZVBhdGgoKSA6IGkubGluZVRvKGQueCwgZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IzMS5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMzEuZigpO1xuICB9XG4gIGkubGluZVRvKHQuZmlyc3QoKS54LCBlKSwgaS5jbG9zZVBhdGgoKSwgaS5jbGlwKCk7XG59XG5mdW5jdGlvbiBLcyhpLCB0LCBlKSB7XG4gIHZhciBzID0gdC5zZWdtZW50cyxcbiAgICBuID0gdC5wb2ludHM7XG4gIHZhciBvID0gITAsXG4gICAgciA9ICExO1xuICBpLmJlZ2luUGF0aCgpO1xuICB2YXIgX2l0ZXJhdG9yMzIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzKSxcbiAgICBfc3RlcDMyO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMzIucygpOyAhKF9zdGVwMzIgPSBfaXRlcmF0b3IzMi5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgYSA9IF9zdGVwMzIudmFsdWU7XG4gICAgICB2YXIgbCA9IGEuc3RhcnQsXG4gICAgICAgIGMgPSBhLmVuZCxcbiAgICAgICAgaCA9IG5bbF0sXG4gICAgICAgIGQgPSBuW2VpKGwsIGMsIG4pXTtcbiAgICAgIG8gPyAoaS5tb3ZlVG8oaC54LCBoLnkpLCBvID0gITEpIDogKGkubGluZVRvKGUsIGgueSksIGkubGluZVRvKGgueCwgaC55KSksIHIgPSAhIXQucGF0aFNlZ21lbnQoaSwgYSwge1xuICAgICAgICBtb3ZlOiByXG4gICAgICB9KSwgciA/IGkuY2xvc2VQYXRoKCkgOiBpLmxpbmVUbyhlLCBkLnkpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMzIuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjMyLmYoKTtcbiAgfVxuICBpLmxpbmVUbyhlLCB0LmZpcnN0KCkueSksIGkuY2xvc2VQYXRoKCksIGkuY2xpcCgpO1xufVxuZnVuY3Rpb24gbWkoaSwgdCkge1xuICB2YXIgZSA9IHQubGluZSxcbiAgICBzID0gdC50YXJnZXQsXG4gICAgbiA9IHQucHJvcGVydHksXG4gICAgbyA9IHQuY29sb3IsXG4gICAgciA9IHQuc2NhbGUsXG4gICAgYSA9IHQuY2xpcCxcbiAgICBsID0gdGMoZSwgcywgbik7XG4gIHZhciBfaXRlcmF0b3IzMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGwpLFxuICAgIF9zdGVwMzM7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IzMy5zKCk7ICEoX3N0ZXAzMyA9IF9pdGVyYXRvcjMzLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfc3RlcDMzJHZhbHVlID0gX3N0ZXAzMy52YWx1ZSxcbiAgICAgICAgYyA9IF9zdGVwMzMkdmFsdWUuc291cmNlLFxuICAgICAgICBoID0gX3N0ZXAzMyR2YWx1ZS50YXJnZXQsXG4gICAgICAgIGQgPSBfc3RlcDMzJHZhbHVlLnN0YXJ0LFxuICAgICAgICB1ID0gX3N0ZXAzMyR2YWx1ZS5lbmQ7XG4gICAgICB2YXIgX2Mkc3R5bGUgPSBjLnN0eWxlLFxuICAgICAgICBfYyRzdHlsZTIgPSBfYyRzdHlsZSA9PT0gdm9pZCAwID8ge30gOiBfYyRzdHlsZSxcbiAgICAgICAgX2Mkc3R5bGUyJGJhY2tncm91bmRDID0gX2Mkc3R5bGUyLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgZiA9IF9jJHN0eWxlMiRiYWNrZ3JvdW5kQyA9PT0gdm9pZCAwID8gbyA6IF9jJHN0eWxlMiRiYWNrZ3JvdW5kQyxcbiAgICAgICAgcCA9IHMgIT09ICEwO1xuICAgICAgaS5zYXZlKCksIGkuZmlsbFN0eWxlID0gZiwgX2MoaSwgciwgYSwgcCAmJiBDaShuLCBkLCB1KSksIGkuYmVnaW5QYXRoKCk7XG4gICAgICB2YXIgZyA9ICEhZS5wYXRoU2VnbWVudChpLCBjKTtcbiAgICAgIHZhciBtID0gdm9pZCAwO1xuICAgICAgaWYgKHApIHtcbiAgICAgICAgZyA/IGkuY2xvc2VQYXRoKCkgOiBHcyhpLCBzLCB1LCBuKTtcbiAgICAgICAgdmFyIGIgPSAhIXMucGF0aFNlZ21lbnQoaSwgaCwge1xuICAgICAgICAgIG1vdmU6IGcsXG4gICAgICAgICAgcmV2ZXJzZTogITBcbiAgICAgICAgfSk7XG4gICAgICAgIG0gPSBnICYmIGIsIG0gfHwgR3MoaSwgcywgZCwgbik7XG4gICAgICB9XG4gICAgICBpLmNsb3NlUGF0aCgpLCBpLmZpbGwobSA/IFwiZXZlbm9kZFwiIDogXCJub256ZXJvXCIpLCBpLnJlc3RvcmUoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjMzLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IzMy5mKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSB0LmNoYXJ0LmNoYXJ0QXJlYSxcbiAgICBfcmVmMSA9IHMgfHwge30sXG4gICAgbyA9IF9yZWYxLnByb3BlcnR5LFxuICAgIHIgPSBfcmVmMS5zdGFydCxcbiAgICBhID0gX3JlZjEuZW5kO1xuICBpZiAobyA9PT0gXCJ4XCIgfHwgbyA9PT0gXCJ5XCIpIHtcbiAgICB2YXIgbCwgYywgaCwgZDtcbiAgICBvID09PSBcInhcIiA/IChsID0gciwgYyA9IG4udG9wLCBoID0gYSwgZCA9IG4uYm90dG9tKSA6IChsID0gbi5sZWZ0LCBjID0gciwgaCA9IG4ucmlnaHQsIGQgPSBhKSwgaS5iZWdpblBhdGgoKSwgZSAmJiAobCA9IE1hdGgubWF4KGwsIGUubGVmdCksIGggPSBNYXRoLm1pbihoLCBlLnJpZ2h0KSwgYyA9IE1hdGgubWF4KGMsIGUudG9wKSwgZCA9IE1hdGgubWluKGQsIGUuYm90dG9tKSksIGkucmVjdChsLCBjLCBoIC0gbCwgZCAtIGMpLCBpLmNsaXAoKTtcbiAgfVxufVxuZnVuY3Rpb24gR3MoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IHQuaW50ZXJwb2xhdGUoZSwgcyk7XG4gIG4gJiYgaS5saW5lVG8obi54LCBuLnkpO1xufVxudmFyIHhjID0ge1xuICBpZDogXCJmaWxsZXJcIixcbiAgYWZ0ZXJEYXRhc2V0c1VwZGF0ZTogZnVuY3Rpb24gYWZ0ZXJEYXRhc2V0c1VwZGF0ZShpLCB0LCBlKSB7XG4gICAgdmFyIHMgPSAoaS5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGgsXG4gICAgICBuID0gW107XG4gICAgdmFyIG8sIHIsIGEsIGw7XG4gICAgZm9yIChyID0gMDsgciA8IHM7ICsrcikgbyA9IGkuZ2V0RGF0YXNldE1ldGEociksIGEgPSBvLmRhdGFzZXQsIGwgPSBudWxsLCBhICYmIGEub3B0aW9ucyAmJiBhIGluc3RhbmNlb2YgdnQgJiYgKGwgPSB7XG4gICAgICB2aXNpYmxlOiBpLmlzRGF0YXNldFZpc2libGUociksXG4gICAgICBpbmRleDogcixcbiAgICAgIGZpbGw6IHNjKGEsIHIsIHMpLFxuICAgICAgY2hhcnQ6IGksXG4gICAgICBheGlzOiBvLmNvbnRyb2xsZXIub3B0aW9ucy5pbmRleEF4aXMsXG4gICAgICBzY2FsZTogby52U2NhbGUsXG4gICAgICBsaW5lOiBhXG4gICAgfSksIG8uJGZpbGxlciA9IGwsIG4ucHVzaChsKTtcbiAgICBmb3IgKHIgPSAwOyByIDwgczsgKytyKSBsID0gbltyXSwgISghbCB8fCBsLmZpbGwgPT09ICExKSAmJiAobC5maWxsID0gaWMobiwgciwgZS5wcm9wYWdhdGUpKTtcbiAgfSxcbiAgYmVmb3JlRHJhdzogZnVuY3Rpb24gYmVmb3JlRHJhdyhpLCB0LCBlKSB7XG4gICAgdmFyIHMgPSBlLmRyYXdUaW1lID09PSBcImJlZm9yZURyYXdcIixcbiAgICAgIG4gPSBpLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKSxcbiAgICAgIG8gPSBpLmNoYXJ0QXJlYTtcbiAgICBmb3IgKHZhciByID0gbi5sZW5ndGggLSAxOyByID49IDA7IC0tcikge1xuICAgICAgdmFyIGEgPSBuW3JdLiRmaWxsZXI7XG4gICAgICBhICYmIChhLmxpbmUudXBkYXRlQ29udHJvbFBvaW50cyhvLCBhLmF4aXMpLCBzICYmIGEuZmlsbCAmJiBwaShpLmN0eCwgYSwgbykpO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGF0YXNldHNEcmF3OiBmdW5jdGlvbiBiZWZvcmVEYXRhc2V0c0RyYXcoaSwgdCwgZSkge1xuICAgIGlmIChlLmRyYXdUaW1lICE9PSBcImJlZm9yZURhdGFzZXRzRHJhd1wiKSByZXR1cm47XG4gICAgdmFyIHMgPSBpLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKHZhciBuID0gcy5sZW5ndGggLSAxOyBuID49IDA7IC0tbikge1xuICAgICAgdmFyIG8gPSBzW25dLiRmaWxsZXI7XG4gICAgICBYcyhvKSAmJiBwaShpLmN0eCwgbywgaS5jaGFydEFyZWEpO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGF0YXNldERyYXc6IGZ1bmN0aW9uIGJlZm9yZURhdGFzZXREcmF3KGksIHQsIGUpIHtcbiAgICB2YXIgcyA9IHQubWV0YS4kZmlsbGVyO1xuICAgICFYcyhzKSB8fCBlLmRyYXdUaW1lICE9PSBcImJlZm9yZURhdGFzZXREcmF3XCIgfHwgcGkoaS5jdHgsIHMsIGkuY2hhcnRBcmVhKTtcbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBwcm9wYWdhdGU6ICEwLFxuICAgIGRyYXdUaW1lOiBcImJlZm9yZURhdGFzZXREcmF3XCJcbiAgfVxufTtcbnZhciBKcyA9IGZ1bmN0aW9uIEpzKGksIHQpIHtcbiAgICB2YXIgX2kkYm94SGVpZ2h0ID0gaS5ib3hIZWlnaHQsXG4gICAgICBlID0gX2kkYm94SGVpZ2h0ID09PSB2b2lkIDAgPyB0IDogX2kkYm94SGVpZ2h0LFxuICAgICAgX2kkYm94V2lkdGggPSBpLmJveFdpZHRoLFxuICAgICAgcyA9IF9pJGJveFdpZHRoID09PSB2b2lkIDAgPyB0IDogX2kkYm94V2lkdGg7XG4gICAgcmV0dXJuIGkudXNlUG9pbnRTdHlsZSAmJiAoZSA9IE1hdGgubWluKGUsIHQpLCBzID0gaS5wb2ludFN0eWxlV2lkdGggfHwgTWF0aC5taW4ocywgdCkpLCB7XG4gICAgICBib3hXaWR0aDogcyxcbiAgICAgIGJveEhlaWdodDogZSxcbiAgICAgIGl0ZW1IZWlnaHQ6IE1hdGgubWF4KHQsIGUpXG4gICAgfTtcbiAgfSxcbiAgeWMgPSBmdW5jdGlvbiB5YyhpLCB0KSB7XG4gICAgcmV0dXJuIGkgIT09IG51bGwgJiYgdCAhPT0gbnVsbCAmJiBpLmRhdGFzZXRJbmRleCA9PT0gdC5kYXRhc2V0SW5kZXggJiYgaS5pbmRleCA9PT0gdC5pbmRleDtcbiAgfTtcbnZhciBacyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N0Nikge1xuICBmdW5jdGlvbiBacyh0KSB7XG4gICAgdmFyIF90aGlzMjQ7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFpzKTtcbiAgICBfdGhpczI0ID0gX2NhbGxTdXBlcih0aGlzLCBacyksIF90aGlzMjQuX2FkZGVkID0gITEsIF90aGlzMjQubGVnZW5kSGl0Qm94ZXMgPSBbXSwgX3RoaXMyNC5faG92ZXJlZEl0ZW0gPSBudWxsLCBfdGhpczI0LmRvdWdobnV0TW9kZSA9ICExLCBfdGhpczI0LmNoYXJ0ID0gdC5jaGFydCwgX3RoaXMyNC5vcHRpb25zID0gdC5vcHRpb25zLCBfdGhpczI0LmN0eCA9IHQuY3R4LCBfdGhpczI0LmxlZ2VuZEl0ZW1zID0gdm9pZCAwLCBfdGhpczI0LmNvbHVtblNpemVzID0gdm9pZCAwLCBfdGhpczI0LmxpbmVXaWR0aHMgPSB2b2lkIDAsIF90aGlzMjQubWF4SGVpZ2h0ID0gdm9pZCAwLCBfdGhpczI0Lm1heFdpZHRoID0gdm9pZCAwLCBfdGhpczI0LnRvcCA9IHZvaWQgMCwgX3RoaXMyNC5ib3R0b20gPSB2b2lkIDAsIF90aGlzMjQubGVmdCA9IHZvaWQgMCwgX3RoaXMyNC5yaWdodCA9IHZvaWQgMCwgX3RoaXMyNC5oZWlnaHQgPSB2b2lkIDAsIF90aGlzMjQud2lkdGggPSB2b2lkIDAsIF90aGlzMjQuX21hcmdpbnMgPSB2b2lkIDAsIF90aGlzMjQucG9zaXRpb24gPSB2b2lkIDAsIF90aGlzMjQud2VpZ2h0ID0gdm9pZCAwLCBfdGhpczI0LmZ1bGxTaXplID0gdm9pZCAwO1xuICAgIHJldHVybiBfdGhpczI0O1xuICB9XG4gIF9pbmhlcml0cyhacywgX3N0Nik7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoWnMsIFt7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUodCwgZSwgcykge1xuICAgICAgdGhpcy5tYXhXaWR0aCA9IHQsIHRoaXMubWF4SGVpZ2h0ID0gZSwgdGhpcy5fbWFyZ2lucyA9IHMsIHRoaXMuc2V0RGltZW5zaW9ucygpLCB0aGlzLmJ1aWxkTGFiZWxzKCksIHRoaXMuZml0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldERpbWVuc2lvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGltZW5zaW9ucygpIHtcbiAgICAgIHRoaXMuaXNIb3Jpem9udGFsKCkgPyAodGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGgsIHRoaXMubGVmdCA9IHRoaXMuX21hcmdpbnMubGVmdCwgdGhpcy5yaWdodCA9IHRoaXMud2lkdGgpIDogKHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQsIHRoaXMudG9wID0gdGhpcy5fbWFyZ2lucy50b3AsIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWlsZExhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZExhYmVscygpIHtcbiAgICAgIHZhciBfdGhpczI1ID0gdGhpcztcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLmxhYmVscyB8fCB7fTtcbiAgICAgIHZhciBlID0gSSh0LmdlbmVyYXRlTGFiZWxzLCBbdGhpcy5jaGFydF0sIHRoaXMpIHx8IFtdO1xuICAgICAgdC5maWx0ZXIgJiYgKGUgPSBlLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdC5maWx0ZXIocywgX3RoaXMyNS5jaGFydC5kYXRhKTtcbiAgICAgIH0pKSwgdC5zb3J0ICYmIChlID0gZS5zb3J0KGZ1bmN0aW9uIChzLCBuKSB7XG4gICAgICAgIHJldHVybiB0LnNvcnQocywgbiwgX3RoaXMyNS5jaGFydC5kYXRhKTtcbiAgICAgIH0pKSwgdGhpcy5vcHRpb25zLnJldmVyc2UgJiYgZS5yZXZlcnNlKCksIHRoaXMubGVnZW5kSXRlbXMgPSBlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml0KCkge1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGUgPSB0aGlzLmN0eDtcbiAgICAgIGlmICghdC5kaXNwbGF5KSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzID0gdC5sYWJlbHMsXG4gICAgICAgIG4gPSBYKHMuZm9udCksXG4gICAgICAgIG8gPSBuLnNpemUsXG4gICAgICAgIHIgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKSxcbiAgICAgICAgX0pzID0gSnMocywgbyksXG4gICAgICAgIGEgPSBfSnMuYm94V2lkdGgsXG4gICAgICAgIGwgPSBfSnMuaXRlbUhlaWdodDtcbiAgICAgIHZhciBjLCBoO1xuICAgICAgZS5mb250ID0gbi5zdHJpbmcsIHRoaXMuaXNIb3Jpem9udGFsKCkgPyAoYyA9IHRoaXMubWF4V2lkdGgsIGggPSB0aGlzLl9maXRSb3dzKHIsIG8sIGEsIGwpICsgMTApIDogKGggPSB0aGlzLm1heEhlaWdodCwgYyA9IHRoaXMuX2ZpdENvbHMociwgbiwgYSwgbCkgKyAxMCksIHRoaXMud2lkdGggPSBNYXRoLm1pbihjLCB0Lm1heFdpZHRoIHx8IHRoaXMubWF4V2lkdGgpLCB0aGlzLmhlaWdodCA9IE1hdGgubWluKGgsIHQubWF4SGVpZ2h0IHx8IHRoaXMubWF4SGVpZ2h0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpdFJvd3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpdFJvd3ModCwgZSwgcywgbikge1xuICAgICAgdmFyIG8gPSB0aGlzLmN0eCxcbiAgICAgICAgciA9IHRoaXMubWF4V2lkdGgsXG4gICAgICAgIGEgPSB0aGlzLm9wdGlvbnMubGFiZWxzLnBhZGRpbmcsXG4gICAgICAgIGwgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW10sXG4gICAgICAgIGMgPSB0aGlzLmxpbmVXaWR0aHMgPSBbMF0sXG4gICAgICAgIGggPSBuICsgYTtcbiAgICAgIHZhciBkID0gdDtcbiAgICAgIG8udGV4dEFsaWduID0gXCJsZWZ0XCIsIG8udGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICAgIHZhciB1ID0gLTEsXG4gICAgICAgIGYgPSAtaDtcbiAgICAgIHJldHVybiB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKHAsIGcpIHtcbiAgICAgICAgdmFyIG0gPSBzICsgZSAvIDIgKyBvLm1lYXN1cmVUZXh0KHAudGV4dCkud2lkdGg7XG4gICAgICAgIChnID09PSAwIHx8IGNbYy5sZW5ndGggLSAxXSArIG0gKyAyICogYSA+IHIpICYmIChkICs9IGgsIGNbYy5sZW5ndGggLSAoZyA+IDAgPyAwIDogMSldID0gMCwgZiArPSBoLCB1KyspLCBsW2ddID0ge1xuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgdG9wOiBmLFxuICAgICAgICAgIHJvdzogdSxcbiAgICAgICAgICB3aWR0aDogbSxcbiAgICAgICAgICBoZWlnaHQ6IG5cbiAgICAgICAgfSwgY1tjLmxlbmd0aCAtIDFdICs9IG0gKyBhO1xuICAgICAgfSksIGQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9maXRDb2xzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maXRDb2xzKHQsIGUsIHMsIG4pIHtcbiAgICAgIHZhciBvID0gdGhpcy5jdHgsXG4gICAgICAgIHIgPSB0aGlzLm1heEhlaWdodCxcbiAgICAgICAgYSA9IHRoaXMub3B0aW9ucy5sYWJlbHMucGFkZGluZyxcbiAgICAgICAgbCA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXSxcbiAgICAgICAgYyA9IHRoaXMuY29sdW1uU2l6ZXMgPSBbXSxcbiAgICAgICAgaCA9IHIgLSB0O1xuICAgICAgdmFyIGQgPSBhLFxuICAgICAgICB1ID0gMCxcbiAgICAgICAgZiA9IDAsXG4gICAgICAgIHAgPSAwLFxuICAgICAgICBnID0gMDtcbiAgICAgIHJldHVybiB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKG0sIGIpIHtcbiAgICAgICAgdmFyIF92YyA9IHZjKHMsIGUsIG8sIG0sIG4pLFxuICAgICAgICAgIF8gPSBfdmMuaXRlbVdpZHRoLFxuICAgICAgICAgIHYgPSBfdmMuaXRlbUhlaWdodDtcbiAgICAgICAgYiA+IDAgJiYgZiArIHYgKyAyICogYSA+IGggJiYgKGQgKz0gdSArIGEsIGMucHVzaCh7XG4gICAgICAgICAgd2lkdGg6IHUsXG4gICAgICAgICAgaGVpZ2h0OiBmXG4gICAgICAgIH0pLCBwICs9IHUgKyBhLCBnKyssIHUgPSBmID0gMCksIGxbYl0gPSB7XG4gICAgICAgICAgbGVmdDogcCxcbiAgICAgICAgICB0b3A6IGYsXG4gICAgICAgICAgY29sOiBnLFxuICAgICAgICAgIHdpZHRoOiBfLFxuICAgICAgICAgIGhlaWdodDogdlxuICAgICAgICB9LCB1ID0gTWF0aC5tYXgodSwgXyksIGYgKz0gdiArIGE7XG4gICAgICB9KSwgZCArPSB1LCBjLnB1c2goe1xuICAgICAgICB3aWR0aDogdSxcbiAgICAgICAgaGVpZ2h0OiBmXG4gICAgICB9KSwgZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRqdXN0SGl0Qm94ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRqdXN0SGl0Qm94ZXMoKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNwbGF5KSByZXR1cm47XG4gICAgICB2YXIgdCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpLFxuICAgICAgICBlID0gdGhpcy5sZWdlbmRIaXRCb3hlcyxcbiAgICAgICAgX3RoaXMkb3B0aW9uczEzID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBzID0gX3RoaXMkb3B0aW9uczEzLmFsaWduLFxuICAgICAgICBuID0gX3RoaXMkb3B0aW9uczEzLmxhYmVscy5wYWRkaW5nLFxuICAgICAgICBvID0gX3RoaXMkb3B0aW9uczEzLnJ0bCxcbiAgICAgICAgciA9IFV0KG8sIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICB2YXIgYSA9IDAsXG4gICAgICAgICAgbCA9IFkocywgdGhpcy5sZWZ0ICsgbiwgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1thXSk7XG4gICAgICAgIHZhciBfaXRlcmF0b3IzNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGUpLFxuICAgICAgICAgIF9zdGVwMzQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IzNC5zKCk7ICEoX3N0ZXAzNCA9IF9pdGVyYXRvcjM0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBjID0gX3N0ZXAzNC52YWx1ZTtcbiAgICAgICAgICAgIGEgIT09IGMucm93ICYmIChhID0gYy5yb3csIGwgPSBZKHMsIHRoaXMubGVmdCArIG4sIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbYV0pKSwgYy50b3AgKz0gdGhpcy50b3AgKyB0ICsgbiwgYy5sZWZ0ID0gci5sZWZ0Rm9yTHRyKHIueChsKSwgYy53aWR0aCksIGwgKz0gYy53aWR0aCArIG47XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IzNC5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMzQuZigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2EzID0gMCxcbiAgICAgICAgICBfbDMgPSBZKHMsIHRoaXMudG9wICsgdCArIG4sIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tfYTNdLmhlaWdodCk7XG4gICAgICAgIHZhciBfaXRlcmF0b3IzNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGUpLFxuICAgICAgICAgIF9zdGVwMzU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IzNS5zKCk7ICEoX3N0ZXAzNSA9IF9pdGVyYXRvcjM1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBfYzMgPSBfc3RlcDM1LnZhbHVlO1xuICAgICAgICAgICAgX2MzLmNvbCAhPT0gX2EzICYmIChfYTMgPSBfYzMuY29sLCBfbDMgPSBZKHMsIHRoaXMudG9wICsgdCArIG4sIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tfYTNdLmhlaWdodCkpLCBfYzMudG9wID0gX2wzLCBfYzMubGVmdCArPSB0aGlzLmxlZnQgKyBuLCBfYzMubGVmdCA9IHIubGVmdEZvckx0cihyLngoX2MzLmxlZnQpLCBfYzMud2lkdGgpLCBfbDMgKz0gX2MzLmhlaWdodCArIG47XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IzNS5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMzUuZigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSG9yaXpvbnRhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0hvcml6b250YWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSBcInRvcFwiIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gXCJib3R0b21cIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5jdHg7XG4gICAgICAgIEplKHQsIHRoaXMpLCB0aGlzLl9kcmF3KCksIFplKHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhdygpIHtcbiAgICAgIHZhciBfdGhpczI2ID0gdGhpcztcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBlID0gdGhpcy5jb2x1bW5TaXplcyxcbiAgICAgICAgcyA9IHRoaXMubGluZVdpZHRocyxcbiAgICAgICAgbiA9IHRoaXMuY3R4LFxuICAgICAgICBvID0gdC5hbGlnbixcbiAgICAgICAgciA9IHQubGFiZWxzLFxuICAgICAgICBhID0gVy5jb2xvcixcbiAgICAgICAgbCA9IFV0KHQucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpLFxuICAgICAgICBjID0gWChyLmZvbnQpLFxuICAgICAgICBoID0gci5wYWRkaW5nLFxuICAgICAgICBkID0gYy5zaXplLFxuICAgICAgICB1ID0gZCAvIDI7XG4gICAgICB2YXIgZjtcbiAgICAgIHRoaXMuZHJhd1RpdGxlKCksIG4udGV4dEFsaWduID0gbC50ZXh0QWxpZ24oXCJsZWZ0XCIpLCBuLnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCIsIG4ubGluZVdpZHRoID0gMC41LCBuLmZvbnQgPSBjLnN0cmluZztcbiAgICAgIHZhciBfSnMyID0gSnMociwgZCksXG4gICAgICAgIHAgPSBfSnMyLmJveFdpZHRoLFxuICAgICAgICBnID0gX0pzMi5ib3hIZWlnaHQsXG4gICAgICAgIG0gPSBfSnMyLml0ZW1IZWlnaHQsXG4gICAgICAgIGIgPSBmdW5jdGlvbiBiKE0sIFMsIGspIHtcbiAgICAgICAgICBpZiAoaXNOYU4ocCkgfHwgcCA8PSAwIHx8IGlzTmFOKGcpIHx8IGcgPCAwKSByZXR1cm47XG4gICAgICAgICAgbi5zYXZlKCk7XG4gICAgICAgICAgdmFyIFAgPSBEKGsubGluZVdpZHRoLCAxKTtcbiAgICAgICAgICBpZiAobi5maWxsU3R5bGUgPSBEKGsuZmlsbFN0eWxlLCBhKSwgbi5saW5lQ2FwID0gRChrLmxpbmVDYXAsIFwiYnV0dFwiKSwgbi5saW5lRGFzaE9mZnNldCA9IEQoay5saW5lRGFzaE9mZnNldCwgMCksIG4ubGluZUpvaW4gPSBEKGsubGluZUpvaW4sIFwibWl0ZXJcIiksIG4ubGluZVdpZHRoID0gUCwgbi5zdHJva2VTdHlsZSA9IEQoay5zdHJva2VTdHlsZSwgYSksIG4uc2V0TGluZURhc2goRChrLmxpbmVEYXNoLCBbXSkpLCByLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgICAgICAgIHZhciBDID0ge1xuICAgICAgICAgICAgICAgIHJhZGl1czogZyAqIE1hdGguU1FSVDIgLyAyLFxuICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IGsucG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogay5yb3RhdGlvbixcbiAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogUFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBPID0gbC54UGx1cyhNLCBwIC8gMiksXG4gICAgICAgICAgICAgIEEgPSBTICsgdTtcbiAgICAgICAgICAgIENuKG4sIEMsIE8sIEEsIHIucG9pbnRTdHlsZVdpZHRoICYmIHApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX0MgPSBTICsgTWF0aC5tYXgoKGQgLSBnKSAvIDIsIDApLFxuICAgICAgICAgICAgICBfTyA9IGwubGVmdEZvckx0cihNLCBwKSxcbiAgICAgICAgICAgICAgX0EgPSBZdChrLmJvcmRlclJhZGl1cyk7XG4gICAgICAgICAgICBuLmJlZ2luUGF0aCgpLCBPYmplY3QudmFsdWVzKF9BKS5zb21lKGZ1bmN0aW9uIChqKSB7XG4gICAgICAgICAgICAgIHJldHVybiBqICE9PSAwO1xuICAgICAgICAgICAgfSkgPyBVZShuLCB7XG4gICAgICAgICAgICAgIHg6IF9PLFxuICAgICAgICAgICAgICB5OiBfQyxcbiAgICAgICAgICAgICAgdzogcCxcbiAgICAgICAgICAgICAgaDogZyxcbiAgICAgICAgICAgICAgcmFkaXVzOiBfQVxuICAgICAgICAgICAgfSkgOiBuLnJlY3QoX08sIF9DLCBwLCBnKSwgbi5maWxsKCksIFAgIT09IDAgJiYgbi5zdHJva2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbi5yZXN0b3JlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIF8gPSBmdW5jdGlvbiBfKE0sIFMsIGspIHtcbiAgICAgICAgICBiZShuLCBrLnRleHQsIE0sIFMgKyBtIC8gMiwgYywge1xuICAgICAgICAgICAgc3RyaWtldGhyb3VnaDogay5oaWRkZW4sXG4gICAgICAgICAgICB0ZXh0QWxpZ246IGwudGV4dEFsaWduKGsudGV4dEFsaWduKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB2ID0gdGhpcy5pc0hvcml6b250YWwoKSxcbiAgICAgICAgeSA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgICAgdiA/IGYgPSB7XG4gICAgICAgIHg6IFkobywgdGhpcy5sZWZ0ICsgaCwgdGhpcy5yaWdodCAtIHNbMF0pLFxuICAgICAgICB5OiB0aGlzLnRvcCArIGggKyB5LFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9IDogZiA9IHtcbiAgICAgICAgeDogdGhpcy5sZWZ0ICsgaCxcbiAgICAgICAgeTogWShvLCB0aGlzLnRvcCArIHkgKyBoLCB0aGlzLmJvdHRvbSAtIGVbMF0uaGVpZ2h0KSxcbiAgICAgICAgbGluZTogMFxuICAgICAgfSwgRm4odGhpcy5jdHgsIHQudGV4dERpcmVjdGlvbik7XG4gICAgICB2YXIgeCA9IG0gKyBoO1xuICAgICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChNLCBTKSB7XG4gICAgICAgIG4uc3Ryb2tlU3R5bGUgPSBNLmZvbnRDb2xvciwgbi5maWxsU3R5bGUgPSBNLmZvbnRDb2xvcjtcbiAgICAgICAgdmFyIGsgPSBuLm1lYXN1cmVUZXh0KE0udGV4dCkud2lkdGgsXG4gICAgICAgICAgUCA9IGwudGV4dEFsaWduKE0udGV4dEFsaWduIHx8IChNLnRleHRBbGlnbiA9IHIudGV4dEFsaWduKSksXG4gICAgICAgICAgQyA9IHAgKyB1ICsgaztcbiAgICAgICAgdmFyIE8gPSBmLngsXG4gICAgICAgICAgQSA9IGYueTtcbiAgICAgICAgbC5zZXRXaWR0aChfdGhpczI2LndpZHRoKSwgdiA/IFMgPiAwICYmIE8gKyBDICsgaCA+IF90aGlzMjYucmlnaHQgJiYgKEEgPSBmLnkgKz0geCwgZi5saW5lKyssIE8gPSBmLnggPSBZKG8sIF90aGlzMjYubGVmdCArIGgsIF90aGlzMjYucmlnaHQgLSBzW2YubGluZV0pKSA6IFMgPiAwICYmIEEgKyB4ID4gX3RoaXMyNi5ib3R0b20gJiYgKE8gPSBmLnggPSBPICsgZVtmLmxpbmVdLndpZHRoICsgaCwgZi5saW5lKyssIEEgPSBmLnkgPSBZKG8sIF90aGlzMjYudG9wICsgeSArIGgsIF90aGlzMjYuYm90dG9tIC0gZVtmLmxpbmVdLmhlaWdodCkpO1xuICAgICAgICB2YXIgaiA9IGwueChPKTtcbiAgICAgICAgaWYgKGIoaiwgQSwgTSksIE8gPSBRbyhQLCBPICsgcCArIHUsIHYgPyBPICsgQyA6IF90aGlzMjYucmlnaHQsIHQucnRsKSwgXyhsLngoTyksIEEsIE0pLCB2KSBmLnggKz0gQyArIGg7ZWxzZSBpZiAodHlwZW9mIE0udGV4dCAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdmFyIEogPSBjLmxpbmVIZWlnaHQ7XG4gICAgICAgICAgZi55ICs9IG5vKE0sIEopICsgaDtcbiAgICAgICAgfSBlbHNlIGYueSArPSB4O1xuICAgICAgfSksIEluKHRoaXMuY3R4LCB0LnRleHREaXJlY3Rpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3VGl0bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1RpdGxlKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGUgPSB0LnRpdGxlLFxuICAgICAgICBzID0gWChlLmZvbnQpLFxuICAgICAgICBuID0gZXQoZS5wYWRkaW5nKTtcbiAgICAgIGlmICghZS5kaXNwbGF5KSByZXR1cm47XG4gICAgICB2YXIgbyA9IFV0KHQucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpLFxuICAgICAgICByID0gdGhpcy5jdHgsXG4gICAgICAgIGEgPSBlLnBvc2l0aW9uLFxuICAgICAgICBsID0gcy5zaXplIC8gMixcbiAgICAgICAgYyA9IG4udG9wICsgbDtcbiAgICAgIHZhciBoLFxuICAgICAgICBkID0gdGhpcy5sZWZ0LFxuICAgICAgICB1ID0gdGhpcy53aWR0aDtcbiAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB1ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMubGluZVdpZHRocykpLCBoID0gdGhpcy50b3AgKyBjLCBkID0gWSh0LmFsaWduLCBkLCB0aGlzLnJpZ2h0IC0gdSk7ZWxzZSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5jb2x1bW5TaXplcy5yZWR1Y2UoZnVuY3Rpb24gKGcsIG0pIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoZywgbS5oZWlnaHQpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgaCA9IGMgKyBZKHQuYWxpZ24sIHRoaXMudG9wLCB0aGlzLmJvdHRvbSAtIHAgLSB0LmxhYmVscy5wYWRkaW5nIC0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCkpO1xuICAgICAgfVxuICAgICAgdmFyIGYgPSBZKGEsIGQsIGQgKyB1KTtcbiAgICAgIHIudGV4dEFsaWduID0gby50ZXh0QWxpZ24oemkoYSkpLCByLnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCIsIHIuc3Ryb2tlU3R5bGUgPSBlLmNvbG9yLCByLmZpbGxTdHlsZSA9IGUuY29sb3IsIHIuZm9udCA9IHMuc3RyaW5nLCBiZShyLCBlLnRleHQsIGYsIGgsIHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY29tcHV0ZVRpdGxlSGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21wdXRlVGl0bGVIZWlnaHQoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMub3B0aW9ucy50aXRsZSxcbiAgICAgICAgZSA9IFgodC5mb250KSxcbiAgICAgICAgcyA9IGV0KHQucGFkZGluZyk7XG4gICAgICByZXR1cm4gdC5kaXNwbGF5ID8gZS5saW5lSGVpZ2h0ICsgcy5oZWlnaHQgOiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0TGVnZW5kSXRlbUF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRMZWdlbmRJdGVtQXQodCwgZSkge1xuICAgICAgdmFyIHMsIG4sIG87XG4gICAgICBpZiAoX3QodCwgdGhpcy5sZWZ0LCB0aGlzLnJpZ2h0KSAmJiBfdChlLCB0aGlzLnRvcCwgdGhpcy5ib3R0b20pKSB7XG4gICAgICAgIGZvciAobyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMsIHMgPSAwOyBzIDwgby5sZW5ndGg7ICsrcykgaWYgKG4gPSBvW3NdLCBfdCh0LCBuLmxlZnQsIG4ubGVmdCArIG4ud2lkdGgpICYmIF90KGUsIG4udG9wLCBuLnRvcCArIG4uaGVpZ2h0KSkgcmV0dXJuIHRoaXMubGVnZW5kSXRlbXNbc107XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRXZlbnQodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAoIWtjKHQudHlwZSwgZSkpIHJldHVybjtcbiAgICAgIHZhciBzID0gdGhpcy5fZ2V0TGVnZW5kSXRlbUF0KHQueCwgdC55KTtcbiAgICAgIGlmICh0LnR5cGUgPT09IFwibW91c2Vtb3ZlXCIgfHwgdC50eXBlID09PSBcIm1vdXNlb3V0XCIpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLl9ob3ZlcmVkSXRlbSxcbiAgICAgICAgICBvID0geWMobiwgcyk7XG4gICAgICAgIG4gJiYgIW8gJiYgSShlLm9uTGVhdmUsIFt0LCBuLCB0aGlzXSwgdGhpcyksIHRoaXMuX2hvdmVyZWRJdGVtID0gcywgcyAmJiAhbyAmJiBJKGUub25Ib3ZlciwgW3QsIHMsIHRoaXNdLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBzICYmIEkoZS5vbkNsaWNrLCBbdCwgcywgdGhpc10sIHRoaXMpO1xuICAgIH1cbiAgfV0pO1xufShzdCk7XG5mdW5jdGlvbiB2YyhpLCB0LCBlLCBzLCBuKSB7XG4gIHZhciBvID0gTWMocywgaSwgdCwgZSksXG4gICAgciA9IFNjKG4sIHMsIHQubGluZUhlaWdodCk7XG4gIHJldHVybiB7XG4gICAgaXRlbVdpZHRoOiBvLFxuICAgIGl0ZW1IZWlnaHQ6IHJcbiAgfTtcbn1cbmZ1bmN0aW9uIE1jKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBpLnRleHQ7XG4gIHJldHVybiBuICYmIHR5cGVvZiBuICE9IFwic3RyaW5nXCIgJiYgKG4gPSBuLnJlZHVjZShmdW5jdGlvbiAobywgcikge1xuICAgIHJldHVybiBvLmxlbmd0aCA+IHIubGVuZ3RoID8gbyA6IHI7XG4gIH0pKSwgdCArIGUuc2l6ZSAvIDIgKyBzLm1lYXN1cmVUZXh0KG4pLndpZHRoO1xufVxuZnVuY3Rpb24gU2MoaSwgdCwgZSkge1xuICB2YXIgcyA9IGk7XG4gIHJldHVybiB0eXBlb2YgdC50ZXh0ICE9IFwic3RyaW5nXCIgJiYgKHMgPSBubyh0LCBlKSksIHM7XG59XG5mdW5jdGlvbiBubyhpLCB0KSB7XG4gIHZhciBlID0gaS50ZXh0ID8gaS50ZXh0Lmxlbmd0aCA6IDA7XG4gIHJldHVybiB0ICogZTtcbn1cbmZ1bmN0aW9uIGtjKGksIHQpIHtcbiAgcmV0dXJuICEhKChpID09PSBcIm1vdXNlbW92ZVwiIHx8IGkgPT09IFwibW91c2VvdXRcIikgJiYgKHQub25Ib3ZlciB8fCB0Lm9uTGVhdmUpIHx8IHQub25DbGljayAmJiAoaSA9PT0gXCJjbGlja1wiIHx8IGkgPT09IFwibW91c2V1cFwiKSk7XG59XG52YXIgd2MgPSB7XG4gIGlkOiBcImxlZ2VuZFwiLFxuICBfZWxlbWVudDogWnMsXG4gIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChpLCB0LCBlKSB7XG4gICAgdmFyIHMgPSBpLmxlZ2VuZCA9IG5ldyBacyh7XG4gICAgICBjdHg6IGkuY3R4LFxuICAgICAgb3B0aW9uczogZSxcbiAgICAgIGNoYXJ0OiBpXG4gICAgfSk7XG4gICAgdHQuY29uZmlndXJlKGksIHMsIGUpLCB0dC5hZGRCb3goaSwgcyk7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoaSkge1xuICAgIHR0LnJlbW92ZUJveChpLCBpLmxlZ2VuZCksIGRlbGV0ZSBpLmxlZ2VuZDtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUoaSwgdCwgZSkge1xuICAgIHZhciBzID0gaS5sZWdlbmQ7XG4gICAgdHQuY29uZmlndXJlKGksIHMsIGUpLCBzLm9wdGlvbnMgPSBlO1xuICB9LFxuICBhZnRlclVwZGF0ZTogZnVuY3Rpb24gYWZ0ZXJVcGRhdGUoaSkge1xuICAgIHZhciB0ID0gaS5sZWdlbmQ7XG4gICAgdC5idWlsZExhYmVscygpLCB0LmFkanVzdEhpdEJveGVzKCk7XG4gIH0sXG4gIGFmdGVyRXZlbnQ6IGZ1bmN0aW9uIGFmdGVyRXZlbnQoaSwgdCkge1xuICAgIHQucmVwbGF5IHx8IGkubGVnZW5kLmhhbmRsZUV2ZW50KHQuZXZlbnQpO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGRpc3BsYXk6ICEwLFxuICAgIHBvc2l0aW9uOiBcInRvcFwiLFxuICAgIGFsaWduOiBcImNlbnRlclwiLFxuICAgIGZ1bGxTaXplOiAhMCxcbiAgICByZXZlcnNlOiAhMSxcbiAgICB3ZWlnaHQ6IDFlMyxcbiAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGksIHQsIGUpIHtcbiAgICAgIHZhciBzID0gdC5kYXRhc2V0SW5kZXgsXG4gICAgICAgIG4gPSBlLmNoYXJ0O1xuICAgICAgbi5pc0RhdGFzZXRWaXNpYmxlKHMpID8gKG4uaGlkZShzKSwgdC5oaWRkZW4gPSAhMCkgOiAobi5zaG93KHMpLCB0LmhpZGRlbiA9ICExKTtcbiAgICB9LFxuICAgIG9uSG92ZXI6IG51bGwsXG4gICAgb25MZWF2ZTogbnVsbCxcbiAgICBsYWJlbHM6IHtcbiAgICAgIGNvbG9yOiBmdW5jdGlvbiBjb2xvcihpKSB7XG4gICAgICAgIHJldHVybiBpLmNoYXJ0Lm9wdGlvbnMuY29sb3I7XG4gICAgICB9LFxuICAgICAgYm94V2lkdGg6IDQwLFxuICAgICAgcGFkZGluZzogMTAsXG4gICAgICBnZW5lcmF0ZUxhYmVsczogZnVuY3Rpb24gZ2VuZXJhdGVMYWJlbHMoaSkge1xuICAgICAgICB2YXIgdCA9IGkuZGF0YS5kYXRhc2V0cyxcbiAgICAgICAgICBfaSRsZWdlbmQkb3B0aW9ucyRsYWIgPSBpLmxlZ2VuZC5vcHRpb25zLmxhYmVscyxcbiAgICAgICAgICBlID0gX2kkbGVnZW5kJG9wdGlvbnMkbGFiLnVzZVBvaW50U3R5bGUsXG4gICAgICAgICAgcyA9IF9pJGxlZ2VuZCRvcHRpb25zJGxhYi5wb2ludFN0eWxlLFxuICAgICAgICAgIG4gPSBfaSRsZWdlbmQkb3B0aW9ucyRsYWIudGV4dEFsaWduLFxuICAgICAgICAgIG8gPSBfaSRsZWdlbmQkb3B0aW9ucyRsYWIuY29sb3IsXG4gICAgICAgICAgciA9IF9pJGxlZ2VuZCRvcHRpb25zJGxhYi51c2VCb3JkZXJSYWRpdXMsXG4gICAgICAgICAgYSA9IF9pJGxlZ2VuZCRvcHRpb25zJGxhYi5ib3JkZXJSYWRpdXM7XG4gICAgICAgIHJldHVybiBpLl9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoKS5tYXAoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICB2YXIgYyA9IGwuY29udHJvbGxlci5nZXRTdHlsZShlID8gMCA6IHZvaWQgMCksXG4gICAgICAgICAgICBoID0gZXQoYy5ib3JkZXJXaWR0aCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IHRbbC5pbmRleF0ubGFiZWwsXG4gICAgICAgICAgICBmaWxsU3R5bGU6IGMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZm9udENvbG9yOiBvLFxuICAgICAgICAgICAgaGlkZGVuOiAhbC52aXNpYmxlLFxuICAgICAgICAgICAgbGluZUNhcDogYy5ib3JkZXJDYXBTdHlsZSxcbiAgICAgICAgICAgIGxpbmVEYXNoOiBjLmJvcmRlckRhc2gsXG4gICAgICAgICAgICBsaW5lRGFzaE9mZnNldDogYy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgbGluZUpvaW46IGMuYm9yZGVySm9pblN0eWxlLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAoaC53aWR0aCArIGguaGVpZ2h0KSAvIDQsXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogYy5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIHBvaW50U3R5bGU6IHMgfHwgYy5wb2ludFN0eWxlLFxuICAgICAgICAgICAgcm90YXRpb246IGMucm90YXRpb24sXG4gICAgICAgICAgICB0ZXh0QWxpZ246IG4gfHwgYy50ZXh0QWxpZ24sXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHIgJiYgKGEgfHwgYy5ib3JkZXJSYWRpdXMpLFxuICAgICAgICAgICAgZGF0YXNldEluZGV4OiBsLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0aXRsZToge1xuICAgICAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKGkpIHtcbiAgICAgICAgcmV0dXJuIGkuY2hhcnQub3B0aW9ucy5jb2xvcjtcbiAgICAgIH0sXG4gICAgICBkaXNwbGF5OiAhMSxcbiAgICAgIHBvc2l0aW9uOiBcImNlbnRlclwiLFxuICAgICAgdGV4dDogXCJcIlxuICAgIH1cbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogZnVuY3Rpb24gX3NjcmlwdGFibGUoaSkge1xuICAgICAgcmV0dXJuICFpLnN0YXJ0c1dpdGgoXCJvblwiKTtcbiAgICB9LFxuICAgIGxhYmVsczoge1xuICAgICAgX3NjcmlwdGFibGU6IGZ1bmN0aW9uIF9zY3JpcHRhYmxlKGkpIHtcbiAgICAgICAgcmV0dXJuICFbXCJnZW5lcmF0ZUxhYmVsc1wiLCBcImZpbHRlclwiLCBcInNvcnRcIl0uaW5jbHVkZXMoaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIG9vID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3Q3KSB7XG4gIGZ1bmN0aW9uIG9vKHQpIHtcbiAgICB2YXIgX3RoaXMyNztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgb28pO1xuICAgIF90aGlzMjcgPSBfY2FsbFN1cGVyKHRoaXMsIG9vKSwgX3RoaXMyNy5jaGFydCA9IHQuY2hhcnQsIF90aGlzMjcub3B0aW9ucyA9IHQub3B0aW9ucywgX3RoaXMyNy5jdHggPSB0LmN0eCwgX3RoaXMyNy5fcGFkZGluZyA9IHZvaWQgMCwgX3RoaXMyNy50b3AgPSB2b2lkIDAsIF90aGlzMjcuYm90dG9tID0gdm9pZCAwLCBfdGhpczI3LmxlZnQgPSB2b2lkIDAsIF90aGlzMjcucmlnaHQgPSB2b2lkIDAsIF90aGlzMjcud2lkdGggPSB2b2lkIDAsIF90aGlzMjcuaGVpZ2h0ID0gdm9pZCAwLCBfdGhpczI3LnBvc2l0aW9uID0gdm9pZCAwLCBfdGhpczI3LndlaWdodCA9IHZvaWQgMCwgX3RoaXMyNy5mdWxsU2l6ZSA9IHZvaWQgMDtcbiAgICByZXR1cm4gX3RoaXMyNztcbiAgfVxuICBfaW5oZXJpdHMob28sIF9zdDcpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKG9vLCBbe1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKHQsIGUpIHtcbiAgICAgIHZhciBzID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKHRoaXMubGVmdCA9IDAsIHRoaXMudG9wID0gMCwgIXMuZGlzcGxheSkge1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSB0aGlzLnJpZ2h0ID0gdGhpcy5ib3R0b20gPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5yaWdodCA9IHQsIHRoaXMuaGVpZ2h0ID0gdGhpcy5ib3R0b20gPSBlO1xuICAgICAgdmFyIG4gPSBOKHMudGV4dCkgPyBzLnRleHQubGVuZ3RoIDogMTtcbiAgICAgIHRoaXMuX3BhZGRpbmcgPSBldChzLnBhZGRpbmcpO1xuICAgICAgdmFyIG8gPSBuICogWChzLmZvbnQpLmxpbmVIZWlnaHQgKyB0aGlzLl9wYWRkaW5nLmhlaWdodDtcbiAgICAgIHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLmhlaWdodCA9IG8gOiB0aGlzLndpZHRoID0gbztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNIb3Jpem9udGFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzSG9yaXpvbnRhbCgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgICAgcmV0dXJuIHQgPT09IFwidG9wXCIgfHwgdCA9PT0gXCJib3R0b21cIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdBcmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3QXJncyh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMudG9wLFxuICAgICAgICBzID0gdGhpcy5sZWZ0LFxuICAgICAgICBuID0gdGhpcy5ib3R0b20sXG4gICAgICAgIG8gPSB0aGlzLnJpZ2h0LFxuICAgICAgICByID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBhID0gci5hbGlnbjtcbiAgICAgIHZhciBsID0gMCxcbiAgICAgICAgYyxcbiAgICAgICAgaCxcbiAgICAgICAgZDtcbiAgICAgIHJldHVybiB0aGlzLmlzSG9yaXpvbnRhbCgpID8gKGggPSBZKGEsIHMsIG8pLCBkID0gZSArIHQsIGMgPSBvIC0gcykgOiAoci5wb3NpdGlvbiA9PT0gXCJsZWZ0XCIgPyAoaCA9IHMgKyB0LCBkID0gWShhLCBuLCBlKSwgbCA9IEUgKiAtMC41KSA6IChoID0gbyAtIHQsIGQgPSBZKGEsIGUsIG4pLCBsID0gRSAqIDAuNSksIGMgPSBuIC0gZSksIHtcbiAgICAgICAgdGl0bGVYOiBoLFxuICAgICAgICB0aXRsZVk6IGQsXG4gICAgICAgIG1heFdpZHRoOiBjLFxuICAgICAgICByb3RhdGlvbjogbFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KCkge1xuICAgICAgdmFyIHQgPSB0aGlzLmN0eCxcbiAgICAgICAgZSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmICghZS5kaXNwbGF5KSByZXR1cm47XG4gICAgICB2YXIgcyA9IFgoZS5mb250KSxcbiAgICAgICAgbyA9IHMubGluZUhlaWdodCAvIDIgKyB0aGlzLl9wYWRkaW5nLnRvcCxcbiAgICAgICAgX3RoaXMkX2RyYXdBcmdzID0gdGhpcy5fZHJhd0FyZ3MobyksXG4gICAgICAgIHIgPSBfdGhpcyRfZHJhd0FyZ3MudGl0bGVYLFxuICAgICAgICBhID0gX3RoaXMkX2RyYXdBcmdzLnRpdGxlWSxcbiAgICAgICAgbCA9IF90aGlzJF9kcmF3QXJncy5tYXhXaWR0aCxcbiAgICAgICAgYyA9IF90aGlzJF9kcmF3QXJncy5yb3RhdGlvbjtcbiAgICAgIGJlKHQsIGUudGV4dCwgMCwgMCwgcywge1xuICAgICAgICBjb2xvcjogZS5jb2xvcixcbiAgICAgICAgbWF4V2lkdGg6IGwsXG4gICAgICAgIHJvdGF0aW9uOiBjLFxuICAgICAgICB0ZXh0QWxpZ246IHppKGUuYWxpZ24pLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6IFwibWlkZGxlXCIsXG4gICAgICAgIHRyYW5zbGF0aW9uOiBbciwgYV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xufShzdCk7XG5mdW5jdGlvbiBQYyhpLCB0KSB7XG4gIHZhciBlID0gbmV3IG9vKHtcbiAgICBjdHg6IGkuY3R4LFxuICAgIG9wdGlvbnM6IHQsXG4gICAgY2hhcnQ6IGlcbiAgfSk7XG4gIHR0LmNvbmZpZ3VyZShpLCBlLCB0KSwgdHQuYWRkQm94KGksIGUpLCBpLnRpdGxlQmxvY2sgPSBlO1xufVxudmFyIERjID0ge1xuICBpZDogXCJ0aXRsZVwiLFxuICBfZWxlbWVudDogb28sXG4gIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChpLCB0LCBlKSB7XG4gICAgUGMoaSwgZSk7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoaSkge1xuICAgIHZhciB0ID0gaS50aXRsZUJsb2NrO1xuICAgIHR0LnJlbW92ZUJveChpLCB0KSwgZGVsZXRlIGkudGl0bGVCbG9jaztcbiAgfSxcbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUoaSwgdCwgZSkge1xuICAgIHZhciBzID0gaS50aXRsZUJsb2NrO1xuICAgIHR0LmNvbmZpZ3VyZShpLCBzLCBlKSwgcy5vcHRpb25zID0gZTtcbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogXCJjZW50ZXJcIixcbiAgICBkaXNwbGF5OiAhMSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6IFwiYm9sZFwiXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogITAsXG4gICAgcGFkZGluZzogMTAsXG4gICAgcG9zaXRpb246IFwidG9wXCIsXG4gICAgdGV4dDogXCJcIixcbiAgICB3ZWlnaHQ6IDJlM1xuICB9LFxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6IFwiY29sb3JcIlxuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAhMCxcbiAgICBfaW5kZXhhYmxlOiAhMVxuICB9XG59O1xudmFyIGFlID0ge1xuICBhdmVyYWdlOiBmdW5jdGlvbiBhdmVyYWdlKGkpIHtcbiAgICBpZiAoIWkubGVuZ3RoKSByZXR1cm4gITE7XG4gICAgdmFyIHQsXG4gICAgICBlLFxuICAgICAgcyA9IC8qIEBfX1BVUkVfXyAqL25ldyBTZXQoKSxcbiAgICAgIG4gPSAwLFxuICAgICAgbyA9IDA7XG4gICAgZm9yICh0ID0gMCwgZSA9IGkubGVuZ3RoOyB0IDwgZTsgKyt0KSB7XG4gICAgICB2YXIgYSA9IGlbdF0uZWxlbWVudDtcbiAgICAgIGlmIChhICYmIGEuaGFzVmFsdWUoKSkge1xuICAgICAgICB2YXIgbCA9IGEudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICAgIHMuYWRkKGwueCksIG4gKz0gbC55LCArK287XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvID09PSAwIHx8IHMuc2l6ZSA9PT0gMCA/ICExIDoge1xuICAgICAgeDogX3RvQ29uc3VtYWJsZUFycmF5KHMpLnJlZHVjZShmdW5jdGlvbiAoYSwgbCkge1xuICAgICAgICByZXR1cm4gYSArIGw7XG4gICAgICB9KSAvIHMuc2l6ZSxcbiAgICAgIHk6IG4gLyBvXG4gICAgfTtcbiAgfSxcbiAgbmVhcmVzdDogZnVuY3Rpb24gbmVhcmVzdChpLCB0KSB7XG4gICAgaWYgKCFpLmxlbmd0aCkgcmV0dXJuICExO1xuICAgIHZhciBlID0gdC54LFxuICAgICAgcyA9IHQueSxcbiAgICAgIG4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICBvLFxuICAgICAgcixcbiAgICAgIGE7XG4gICAgZm9yIChvID0gMCwgciA9IGkubGVuZ3RoOyBvIDwgcjsgKytvKSB7XG4gICAgICB2YXIgbCA9IGlbb10uZWxlbWVudDtcbiAgICAgIGlmIChsICYmIGwuaGFzVmFsdWUoKSkge1xuICAgICAgICB2YXIgYyA9IGwuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgICBoID0gdmkodCwgYyk7XG4gICAgICAgIGggPCBuICYmIChuID0gaCwgYSA9IGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYSkge1xuICAgICAgdmFyIF9sNCA9IGEudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICBlID0gX2w0LngsIHMgPSBfbDQueTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGUsXG4gICAgICB5OiBzXG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJ0KGksIHQpIHtcbiAgcmV0dXJuIHQgJiYgKE4odCkgPyBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShpLCB0KSA6IGkucHVzaCh0KSksIGk7XG59XG5mdW5jdGlvbiBmdChpKSB7XG4gIHJldHVybiAodHlwZW9mIGkgPT0gXCJzdHJpbmdcIiB8fCBpIGluc3RhbmNlb2YgU3RyaW5nKSAmJiBpLmluZGV4T2YoXCJcXG5cIikgPiAtMSA/IGkuc3BsaXQoXCJcXG5cIikgOiBpO1xufVxuZnVuY3Rpb24gQ2MoaSwgdCkge1xuICB2YXIgZSA9IHQuZWxlbWVudCxcbiAgICBzID0gdC5kYXRhc2V0SW5kZXgsXG4gICAgbiA9IHQuaW5kZXgsXG4gICAgbyA9IGkuZ2V0RGF0YXNldE1ldGEocykuY29udHJvbGxlcixcbiAgICBfbyRnZXRMYWJlbEFuZFZhbHVlID0gby5nZXRMYWJlbEFuZFZhbHVlKG4pLFxuICAgIHIgPSBfbyRnZXRMYWJlbEFuZFZhbHVlLmxhYmVsLFxuICAgIGEgPSBfbyRnZXRMYWJlbEFuZFZhbHVlLnZhbHVlO1xuICByZXR1cm4ge1xuICAgIGNoYXJ0OiBpLFxuICAgIGxhYmVsOiByLFxuICAgIHBhcnNlZDogby5nZXRQYXJzZWQobiksXG4gICAgcmF3OiBpLmRhdGEuZGF0YXNldHNbc10uZGF0YVtuXSxcbiAgICBmb3JtYXR0ZWRWYWx1ZTogYSxcbiAgICBkYXRhc2V0OiBvLmdldERhdGFzZXQoKSxcbiAgICBkYXRhSW5kZXg6IG4sXG4gICAgZGF0YXNldEluZGV4OiBzLFxuICAgIGVsZW1lbnQ6IGVcbiAgfTtcbn1cbmZ1bmN0aW9uIFFzKGksIHQpIHtcbiAgdmFyIGUgPSBpLmNoYXJ0LmN0eCxcbiAgICBzID0gaS5ib2R5LFxuICAgIG4gPSBpLmZvb3RlcixcbiAgICBvID0gaS50aXRsZSxcbiAgICByID0gdC5ib3hXaWR0aCxcbiAgICBhID0gdC5ib3hIZWlnaHQsXG4gICAgbCA9IFgodC5ib2R5Rm9udCksXG4gICAgYyA9IFgodC50aXRsZUZvbnQpLFxuICAgIGggPSBYKHQuZm9vdGVyRm9udCksXG4gICAgZCA9IG8ubGVuZ3RoLFxuICAgIHUgPSBuLmxlbmd0aCxcbiAgICBmID0gcy5sZW5ndGgsXG4gICAgcCA9IGV0KHQucGFkZGluZyk7XG4gIHZhciBnID0gcC5oZWlnaHQsXG4gICAgbSA9IDAsXG4gICAgYiA9IHMucmVkdWNlKGZ1bmN0aW9uICh5LCB4KSB7XG4gICAgICByZXR1cm4geSArIHguYmVmb3JlLmxlbmd0aCArIHgubGluZXMubGVuZ3RoICsgeC5hZnRlci5sZW5ndGg7XG4gICAgfSwgMCk7XG4gIGlmIChiICs9IGkuYmVmb3JlQm9keS5sZW5ndGggKyBpLmFmdGVyQm9keS5sZW5ndGgsIGQgJiYgKGcgKz0gZCAqIGMubGluZUhlaWdodCArIChkIC0gMSkgKiB0LnRpdGxlU3BhY2luZyArIHQudGl0bGVNYXJnaW5Cb3R0b20pLCBiKSB7XG4gICAgdmFyIHkgPSB0LmRpc3BsYXlDb2xvcnMgPyBNYXRoLm1heChhLCBsLmxpbmVIZWlnaHQpIDogbC5saW5lSGVpZ2h0O1xuICAgIGcgKz0gZiAqIHkgKyAoYiAtIGYpICogbC5saW5lSGVpZ2h0ICsgKGIgLSAxKSAqIHQuYm9keVNwYWNpbmc7XG4gIH1cbiAgdSAmJiAoZyArPSB0LmZvb3Rlck1hcmdpblRvcCArIHUgKiBoLmxpbmVIZWlnaHQgKyAodSAtIDEpICogdC5mb290ZXJTcGFjaW5nKTtcbiAgdmFyIF8gPSAwO1xuICB2YXIgdiA9IGZ1bmN0aW9uIHYoeSkge1xuICAgIG0gPSBNYXRoLm1heChtLCBlLm1lYXN1cmVUZXh0KHkpLndpZHRoICsgXyk7XG4gIH07XG4gIHJldHVybiBlLnNhdmUoKSwgZS5mb250ID0gYy5zdHJpbmcsIEwoaS50aXRsZSwgdiksIGUuZm9udCA9IGwuc3RyaW5nLCBMKGkuYmVmb3JlQm9keS5jb25jYXQoaS5hZnRlckJvZHkpLCB2KSwgXyA9IHQuZGlzcGxheUNvbG9ycyA/IHIgKyAyICsgdC5ib3hQYWRkaW5nIDogMCwgTChzLCBmdW5jdGlvbiAoeSkge1xuICAgIEwoeS5iZWZvcmUsIHYpLCBMKHkubGluZXMsIHYpLCBMKHkuYWZ0ZXIsIHYpO1xuICB9KSwgXyA9IDAsIGUuZm9udCA9IGguc3RyaW5nLCBMKGkuZm9vdGVyLCB2KSwgZS5yZXN0b3JlKCksIG0gKz0gcC53aWR0aCwge1xuICAgIHdpZHRoOiBtLFxuICAgIGhlaWdodDogZ1xuICB9O1xufVxuZnVuY3Rpb24gT2MoaSwgdCkge1xuICB2YXIgZSA9IHQueSxcbiAgICBzID0gdC5oZWlnaHQ7XG4gIHJldHVybiBlIDwgcyAvIDIgPyBcInRvcFwiIDogZSA+IGkuaGVpZ2h0IC0gcyAvIDIgPyBcImJvdHRvbVwiIDogXCJjZW50ZXJcIjtcbn1cbmZ1bmN0aW9uIFRjKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBzLngsXG4gICAgbyA9IHMud2lkdGgsXG4gICAgciA9IGUuY2FyZXRTaXplICsgZS5jYXJldFBhZGRpbmc7XG4gIGlmIChpID09PSBcImxlZnRcIiAmJiBuICsgbyArIHIgPiB0LndpZHRoIHx8IGkgPT09IFwicmlnaHRcIiAmJiBuIC0gbyAtIHIgPCAwKSByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBBYyhpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gZS54LFxuICAgIG8gPSBlLndpZHRoLFxuICAgIHIgPSBpLndpZHRoLFxuICAgIF9pJGNoYXJ0QXJlYSA9IGkuY2hhcnRBcmVhLFxuICAgIGEgPSBfaSRjaGFydEFyZWEubGVmdCxcbiAgICBsID0gX2kkY2hhcnRBcmVhLnJpZ2h0O1xuICB2YXIgYyA9IFwiY2VudGVyXCI7XG4gIHJldHVybiBzID09PSBcImNlbnRlclwiID8gYyA9IG4gPD0gKGEgKyBsKSAvIDIgPyBcImxlZnRcIiA6IFwicmlnaHRcIiA6IG4gPD0gbyAvIDIgPyBjID0gXCJsZWZ0XCIgOiBuID49IHIgLSBvIC8gMiAmJiAoYyA9IFwicmlnaHRcIiksIFRjKGMsIGksIHQsIGUpICYmIChjID0gXCJjZW50ZXJcIiksIGM7XG59XG5mdW5jdGlvbiB0bihpLCB0LCBlKSB7XG4gIHZhciBzID0gZS55QWxpZ24gfHwgdC55QWxpZ24gfHwgT2MoaSwgZSk7XG4gIHJldHVybiB7XG4gICAgeEFsaWduOiBlLnhBbGlnbiB8fCB0LnhBbGlnbiB8fCBBYyhpLCB0LCBlLCBzKSxcbiAgICB5QWxpZ246IHNcbiAgfTtcbn1cbmZ1bmN0aW9uIFJjKGksIHQpIHtcbiAgdmFyIGUgPSBpLngsXG4gICAgcyA9IGkud2lkdGg7XG4gIHJldHVybiB0ID09PSBcInJpZ2h0XCIgPyBlIC09IHMgOiB0ID09PSBcImNlbnRlclwiICYmIChlIC09IHMgLyAyKSwgZTtcbn1cbmZ1bmN0aW9uIExjKGksIHQsIGUpIHtcbiAgdmFyIHMgPSBpLnksXG4gICAgbiA9IGkuaGVpZ2h0O1xuICByZXR1cm4gdCA9PT0gXCJ0b3BcIiA/IHMgKz0gZSA6IHQgPT09IFwiYm90dG9tXCIgPyBzIC09IG4gKyBlIDogcyAtPSBuIC8gMiwgcztcbn1cbmZ1bmN0aW9uIGVuKGksIHQsIGUsIHMpIHtcbiAgdmFyIG4gPSBpLmNhcmV0U2l6ZSxcbiAgICBvID0gaS5jYXJldFBhZGRpbmcsXG4gICAgciA9IGkuY29ybmVyUmFkaXVzLFxuICAgIGEgPSBlLnhBbGlnbixcbiAgICBsID0gZS55QWxpZ24sXG4gICAgYyA9IG4gKyBvLFxuICAgIF9ZdCA9IFl0KHIpLFxuICAgIGggPSBfWXQudG9wTGVmdCxcbiAgICBkID0gX1l0LnRvcFJpZ2h0LFxuICAgIHUgPSBfWXQuYm90dG9tTGVmdCxcbiAgICBmID0gX1l0LmJvdHRvbVJpZ2h0O1xuICB2YXIgcCA9IFJjKHQsIGEpO1xuICB2YXIgZyA9IExjKHQsIGwsIGMpO1xuICByZXR1cm4gbCA9PT0gXCJjZW50ZXJcIiA/IGEgPT09IFwibGVmdFwiID8gcCArPSBjIDogYSA9PT0gXCJyaWdodFwiICYmIChwIC09IGMpIDogYSA9PT0gXCJsZWZ0XCIgPyBwIC09IE1hdGgubWF4KGgsIHUpICsgbiA6IGEgPT09IFwicmlnaHRcIiAmJiAocCArPSBNYXRoLm1heChkLCBmKSArIG4pLCB7XG4gICAgeDogVShwLCAwLCBzLndpZHRoIC0gdC53aWR0aCksXG4gICAgeTogVShnLCAwLCBzLmhlaWdodCAtIHQuaGVpZ2h0KVxuICB9O1xufVxuZnVuY3Rpb24gUmUoaSwgdCwgZSkge1xuICB2YXIgcyA9IGV0KGUucGFkZGluZyk7XG4gIHJldHVybiB0ID09PSBcImNlbnRlclwiID8gaS54ICsgaS53aWR0aCAvIDIgOiB0ID09PSBcInJpZ2h0XCIgPyBpLnggKyBpLndpZHRoIC0gcy5yaWdodCA6IGkueCArIHMubGVmdDtcbn1cbmZ1bmN0aW9uIHNuKGkpIHtcbiAgcmV0dXJuIHJ0KFtdLCBmdChpKSk7XG59XG5mdW5jdGlvbiBFYyhpLCB0LCBlKSB7XG4gIHJldHVybiBCdChpLCB7XG4gICAgdG9vbHRpcDogdCxcbiAgICB0b29sdGlwSXRlbXM6IGUsXG4gICAgdHlwZTogXCJ0b29sdGlwXCJcbiAgfSk7XG59XG5mdW5jdGlvbiBubihpLCB0KSB7XG4gIHZhciBlID0gdCAmJiB0LmRhdGFzZXQgJiYgdC5kYXRhc2V0LnRvb2x0aXAgJiYgdC5kYXRhc2V0LnRvb2x0aXAuY2FsbGJhY2tzO1xuICByZXR1cm4gZSA/IGkub3ZlcnJpZGUoZSkgOiBpO1xufVxudmFyIHJvID0ge1xuICBiZWZvcmVUaXRsZTogZHQsXG4gIHRpdGxlOiBmdW5jdGlvbiB0aXRsZShpKSB7XG4gICAgaWYgKGkubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHQgPSBpWzBdLFxuICAgICAgICBlID0gdC5jaGFydC5kYXRhLmxhYmVscyxcbiAgICAgICAgcyA9IGUgPyBlLmxlbmd0aCA6IDA7XG4gICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09IFwiZGF0YXNldFwiKSByZXR1cm4gdC5kYXRhc2V0LmxhYmVsIHx8IFwiXCI7XG4gICAgICBpZiAodC5sYWJlbCkgcmV0dXJuIHQubGFiZWw7XG4gICAgICBpZiAocyA+IDAgJiYgdC5kYXRhSW5kZXggPCBzKSByZXR1cm4gZVt0LmRhdGFJbmRleF07XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xuICB9LFxuICBhZnRlclRpdGxlOiBkdCxcbiAgYmVmb3JlQm9keTogZHQsXG4gIGJlZm9yZUxhYmVsOiBkdCxcbiAgbGFiZWw6IGZ1bmN0aW9uIGxhYmVsKGkpIHtcbiAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09IFwiZGF0YXNldFwiKSByZXR1cm4gaS5sYWJlbCArIFwiOiBcIiArIGkuZm9ybWF0dGVkVmFsdWUgfHwgaS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICB2YXIgdCA9IGkuZGF0YXNldC5sYWJlbCB8fCBcIlwiO1xuICAgIHQgJiYgKHQgKz0gXCI6IFwiKTtcbiAgICB2YXIgZSA9IGkuZm9ybWF0dGVkVmFsdWU7XG4gICAgcmV0dXJuIFIoZSkgfHwgKHQgKz0gZSksIHQ7XG4gIH0sXG4gIGxhYmVsQ29sb3I6IGZ1bmN0aW9uIGxhYmVsQ29sb3IoaSkge1xuICAgIHZhciBlID0gaS5jaGFydC5nZXREYXRhc2V0TWV0YShpLmRhdGFzZXRJbmRleCkuY29udHJvbGxlci5nZXRTdHlsZShpLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvcmRlckNvbG9yOiBlLmJvcmRlckNvbG9yLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBlLmJhY2tncm91bmRDb2xvcixcbiAgICAgIGJvcmRlcldpZHRoOiBlLmJvcmRlcldpZHRoLFxuICAgICAgYm9yZGVyRGFzaDogZS5ib3JkZXJEYXNoLFxuICAgICAgYm9yZGVyRGFzaE9mZnNldDogZS5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgYm9yZGVyUmFkaXVzOiAwXG4gICAgfTtcbiAgfSxcbiAgbGFiZWxUZXh0Q29sb3I6IGZ1bmN0aW9uIGxhYmVsVGV4dENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYm9keUNvbG9yO1xuICB9LFxuICBsYWJlbFBvaW50U3R5bGU6IGZ1bmN0aW9uIGxhYmVsUG9pbnRTdHlsZShpKSB7XG4gICAgdmFyIGUgPSBpLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkuZGF0YXNldEluZGV4KS5jb250cm9sbGVyLmdldFN0eWxlKGkuZGF0YUluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnRTdHlsZTogZS5wb2ludFN0eWxlLFxuICAgICAgcm90YXRpb246IGUucm90YXRpb25cbiAgICB9O1xuICB9LFxuICBhZnRlckxhYmVsOiBkdCxcbiAgYWZ0ZXJCb2R5OiBkdCxcbiAgYmVmb3JlRm9vdGVyOiBkdCxcbiAgZm9vdGVyOiBkdCxcbiAgYWZ0ZXJGb290ZXI6IGR0XG59O1xuZnVuY3Rpb24gSyhpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gaVt0XS5jYWxsKGUsIHMpO1xuICByZXR1cm4gX3R5cGVvZihuKSA+IFwidVwiID8gcm9bdF0uY2FsbChlLCBzKSA6IG47XG59XG52YXIgT2kgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdDgpIHtcbiAgZnVuY3Rpb24gT2kodCkge1xuICAgIHZhciBfdGhpczI4O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPaSk7XG4gICAgX3RoaXMyOCA9IF9jYWxsU3VwZXIodGhpcywgT2kpLCBfdGhpczI4Lm9wYWNpdHkgPSAwLCBfdGhpczI4Ll9hY3RpdmUgPSBbXSwgX3RoaXMyOC5fZXZlbnRQb3NpdGlvbiA9IHZvaWQgMCwgX3RoaXMyOC5fc2l6ZSA9IHZvaWQgMCwgX3RoaXMyOC5fY2FjaGVkQW5pbWF0aW9ucyA9IHZvaWQgMCwgX3RoaXMyOC5fdG9vbHRpcEl0ZW1zID0gW10sIF90aGlzMjguJGFuaW1hdGlvbnMgPSB2b2lkIDAsIF90aGlzMjguJGNvbnRleHQgPSB2b2lkIDAsIF90aGlzMjguY2hhcnQgPSB0LmNoYXJ0LCBfdGhpczI4Lm9wdGlvbnMgPSB0Lm9wdGlvbnMsIF90aGlzMjguZGF0YVBvaW50cyA9IHZvaWQgMCwgX3RoaXMyOC50aXRsZSA9IHZvaWQgMCwgX3RoaXMyOC5iZWZvcmVCb2R5ID0gdm9pZCAwLCBfdGhpczI4LmJvZHkgPSB2b2lkIDAsIF90aGlzMjguYWZ0ZXJCb2R5ID0gdm9pZCAwLCBfdGhpczI4LmZvb3RlciA9IHZvaWQgMCwgX3RoaXMyOC54QWxpZ24gPSB2b2lkIDAsIF90aGlzMjgueUFsaWduID0gdm9pZCAwLCBfdGhpczI4LnggPSB2b2lkIDAsIF90aGlzMjgueSA9IHZvaWQgMCwgX3RoaXMyOC5oZWlnaHQgPSB2b2lkIDAsIF90aGlzMjgud2lkdGggPSB2b2lkIDAsIF90aGlzMjguY2FyZXRYID0gdm9pZCAwLCBfdGhpczI4LmNhcmV0WSA9IHZvaWQgMCwgX3RoaXMyOC5sYWJlbENvbG9ycyA9IHZvaWQgMCwgX3RoaXMyOC5sYWJlbFBvaW50U3R5bGVzID0gdm9pZCAwLCBfdGhpczI4LmxhYmVsVGV4dENvbG9ycyA9IHZvaWQgMDtcbiAgICByZXR1cm4gX3RoaXMyODtcbiAgfVxuICBfaW5oZXJpdHMoT2ksIF9zdDgpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKE9pLCBbe1xuICAgIGtleTogXCJpbml0aWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemUodCkge1xuICAgICAgdGhpcy5vcHRpb25zID0gdCwgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHZvaWQgMCwgdGhpcy4kY29udGV4dCA9IHZvaWQgMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc29sdmVBbmltYXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNvbHZlQW5pbWF0aW9ucygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY2FjaGVkQW5pbWF0aW9ucztcbiAgICAgIGlmICh0KSByZXR1cm4gdDtcbiAgICAgIHZhciBlID0gdGhpcy5jaGFydCxcbiAgICAgICAgcyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKSxcbiAgICAgICAgbiA9IHMuZW5hYmxlZCAmJiBlLm9wdGlvbnMuYW5pbWF0aW9uICYmIHMuYW5pbWF0aW9ucyxcbiAgICAgICAgbyA9IG5ldyBObih0aGlzLmNoYXJ0LCBuKTtcbiAgICAgIHJldHVybiBuLl9jYWNoZWFibGUgJiYgKHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSBPYmplY3QuZnJlZXplKG8pKSwgbztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSBFYyh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcywgdGhpcy5fdG9vbHRpcEl0ZW1zKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRpdGxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRpdGxlKHQsIGUpIHtcbiAgICAgIHZhciBzID0gZS5jYWxsYmFja3MsXG4gICAgICAgIG4gPSBLKHMsIFwiYmVmb3JlVGl0bGVcIiwgdGhpcywgdCksXG4gICAgICAgIG8gPSBLKHMsIFwidGl0bGVcIiwgdGhpcywgdCksXG4gICAgICAgIHIgPSBLKHMsIFwiYWZ0ZXJUaXRsZVwiLCB0aGlzLCB0KTtcbiAgICAgIHZhciBhID0gW107XG4gICAgICByZXR1cm4gYSA9IHJ0KGEsIGZ0KG4pKSwgYSA9IHJ0KGEsIGZ0KG8pKSwgYSA9IHJ0KGEsIGZ0KHIpKSwgYTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmVmb3JlQm9keVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCZWZvcmVCb2R5KHQsIGUpIHtcbiAgICAgIHJldHVybiBzbihLKGUuY2FsbGJhY2tzLCBcImJlZm9yZUJvZHlcIiwgdGhpcywgdCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb2R5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvZHkodCwgZSkge1xuICAgICAgdmFyIF90aGlzMjkgPSB0aGlzO1xuICAgICAgdmFyIHMgPSBlLmNhbGxiYWNrcyxcbiAgICAgICAgbiA9IFtdO1xuICAgICAgcmV0dXJuIEwodCwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHIgPSB7XG4gICAgICAgICAgICBiZWZvcmU6IFtdLFxuICAgICAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICAgICAgYWZ0ZXI6IFtdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhID0gbm4ocywgbyk7XG4gICAgICAgIHJ0KHIuYmVmb3JlLCBmdChLKGEsIFwiYmVmb3JlTGFiZWxcIiwgX3RoaXMyOSwgbykpKSwgcnQoci5saW5lcywgSyhhLCBcImxhYmVsXCIsIF90aGlzMjksIG8pKSwgcnQoci5hZnRlciwgZnQoSyhhLCBcImFmdGVyTGFiZWxcIiwgX3RoaXMyOSwgbykpKSwgbi5wdXNoKHIpO1xuICAgICAgfSksIG47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEFmdGVyQm9keVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBZnRlckJvZHkodCwgZSkge1xuICAgICAgcmV0dXJuIHNuKEsoZS5jYWxsYmFja3MsIFwiYWZ0ZXJCb2R5XCIsIHRoaXMsIHQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9vdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvb3Rlcih0LCBlKSB7XG4gICAgICB2YXIgcyA9IGUuY2FsbGJhY2tzLFxuICAgICAgICBuID0gSyhzLCBcImJlZm9yZUZvb3RlclwiLCB0aGlzLCB0KSxcbiAgICAgICAgbyA9IEsocywgXCJmb290ZXJcIiwgdGhpcywgdCksXG4gICAgICAgIHIgPSBLKHMsIFwiYWZ0ZXJGb290ZXJcIiwgdGhpcywgdCk7XG4gICAgICB2YXIgYSA9IFtdO1xuICAgICAgcmV0dXJuIGEgPSBydChhLCBmdChuKSksIGEgPSBydChhLCBmdChvKSksIGEgPSBydChhLCBmdChyKSksIGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVJdGVtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlSXRlbXModCkge1xuICAgICAgdmFyIF90aGlzMzAgPSB0aGlzO1xuICAgICAgdmFyIGUgPSB0aGlzLl9hY3RpdmUsXG4gICAgICAgIHMgPSB0aGlzLmNoYXJ0LmRhdGEsXG4gICAgICAgIG4gPSBbXSxcbiAgICAgICAgbyA9IFtdLFxuICAgICAgICByID0gW107XG4gICAgICB2YXIgYSA9IFtdLFxuICAgICAgICBsLFxuICAgICAgICBjO1xuICAgICAgZm9yIChsID0gMCwgYyA9IGUubGVuZ3RoOyBsIDwgYzsgKytsKSBhLnB1c2goQ2ModGhpcy5jaGFydCwgZVtsXSkpO1xuICAgICAgcmV0dXJuIHQuZmlsdGVyICYmIChhID0gYS5maWx0ZXIoZnVuY3Rpb24gKGgsIGQsIHUpIHtcbiAgICAgICAgcmV0dXJuIHQuZmlsdGVyKGgsIGQsIHUsIHMpO1xuICAgICAgfSkpLCB0Lml0ZW1Tb3J0ICYmIChhID0gYS5zb3J0KGZ1bmN0aW9uIChoLCBkKSB7XG4gICAgICAgIHJldHVybiB0Lml0ZW1Tb3J0KGgsIGQsIHMpO1xuICAgICAgfSkpLCBMKGEsIGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHZhciBkID0gbm4odC5jYWxsYmFja3MsIGgpO1xuICAgICAgICBuLnB1c2goSyhkLCBcImxhYmVsQ29sb3JcIiwgX3RoaXMzMCwgaCkpLCBvLnB1c2goSyhkLCBcImxhYmVsUG9pbnRTdHlsZVwiLCBfdGhpczMwLCBoKSksIHIucHVzaChLKGQsIFwibGFiZWxUZXh0Q29sb3JcIiwgX3RoaXMzMCwgaCkpO1xuICAgICAgfSksIHRoaXMubGFiZWxDb2xvcnMgPSBuLCB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSBvLCB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IHIsIHRoaXMuZGF0YVBvaW50cyA9IGEsIGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUodCwgZSkge1xuICAgICAgdmFyIHMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSksXG4gICAgICAgIG4gPSB0aGlzLl9hY3RpdmU7XG4gICAgICB2YXIgbyxcbiAgICAgICAgciA9IFtdO1xuICAgICAgaWYgKCFuLmxlbmd0aCkgdGhpcy5vcGFjaXR5ICE9PSAwICYmIChvID0ge1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9KTtlbHNlIHtcbiAgICAgICAgdmFyIGEgPSBhZVtzLnBvc2l0aW9uXS5jYWxsKHRoaXMsIG4sIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgICByID0gdGhpcy5fY3JlYXRlSXRlbXMocyksIHRoaXMudGl0bGUgPSB0aGlzLmdldFRpdGxlKHIsIHMpLCB0aGlzLmJlZm9yZUJvZHkgPSB0aGlzLmdldEJlZm9yZUJvZHkociwgcyksIHRoaXMuYm9keSA9IHRoaXMuZ2V0Qm9keShyLCBzKSwgdGhpcy5hZnRlckJvZHkgPSB0aGlzLmdldEFmdGVyQm9keShyLCBzKSwgdGhpcy5mb290ZXIgPSB0aGlzLmdldEZvb3RlcihyLCBzKTtcbiAgICAgICAgdmFyIGwgPSB0aGlzLl9zaXplID0gUXModGhpcywgcyksXG4gICAgICAgICAgYyA9IE9iamVjdC5hc3NpZ24oe30sIGEsIGwpLFxuICAgICAgICAgIGggPSB0bih0aGlzLmNoYXJ0LCBzLCBjKSxcbiAgICAgICAgICBkID0gZW4ocywgYywgaCwgdGhpcy5jaGFydCk7XG4gICAgICAgIHRoaXMueEFsaWduID0gaC54QWxpZ24sIHRoaXMueUFsaWduID0gaC55QWxpZ24sIG8gPSB7XG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICB4OiBkLngsXG4gICAgICAgICAgeTogZC55LFxuICAgICAgICAgIHdpZHRoOiBsLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogbC5oZWlnaHQsXG4gICAgICAgICAgY2FyZXRYOiBhLngsXG4gICAgICAgICAgY2FyZXRZOiBhLnlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IHIsIHRoaXMuJGNvbnRleHQgPSB2b2lkIDAsIG8gJiYgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgbyksIHQgJiYgcy5leHRlcm5hbCAmJiBzLmV4dGVybmFsLmNhbGwodGhpcywge1xuICAgICAgICBjaGFydDogdGhpcy5jaGFydCxcbiAgICAgICAgdG9vbHRpcDogdGhpcyxcbiAgICAgICAgcmVwbGF5OiBlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0NhcmV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdDYXJldCh0LCBlLCBzLCBuKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuZ2V0Q2FyZXRQb3NpdGlvbih0LCBzLCBuKTtcbiAgICAgIGUubGluZVRvKG8ueDEsIG8ueTEpLCBlLmxpbmVUbyhvLngyLCBvLnkyKSwgZS5saW5lVG8oby54Mywgby55Myk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENhcmV0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FyZXRQb3NpdGlvbih0LCBlLCBzKSB7XG4gICAgICB2YXIgbiA9IHRoaXMueEFsaWduLFxuICAgICAgICBvID0gdGhpcy55QWxpZ24sXG4gICAgICAgIHIgPSBzLmNhcmV0U2l6ZSxcbiAgICAgICAgYSA9IHMuY29ybmVyUmFkaXVzLFxuICAgICAgICBfWXQyID0gWXQoYSksXG4gICAgICAgIGwgPSBfWXQyLnRvcExlZnQsXG4gICAgICAgIGMgPSBfWXQyLnRvcFJpZ2h0LFxuICAgICAgICBoID0gX1l0Mi5ib3R0b21MZWZ0LFxuICAgICAgICBkID0gX1l0Mi5ib3R0b21SaWdodCxcbiAgICAgICAgdSA9IHQueCxcbiAgICAgICAgZiA9IHQueSxcbiAgICAgICAgcCA9IGUud2lkdGgsXG4gICAgICAgIGcgPSBlLmhlaWdodDtcbiAgICAgIHZhciBtLCBiLCBfLCB2LCB5LCB4O1xuICAgICAgcmV0dXJuIG8gPT09IFwiY2VudGVyXCIgPyAoeSA9IGYgKyBnIC8gMiwgbiA9PT0gXCJsZWZ0XCIgPyAobSA9IHUsIGIgPSBtIC0gciwgdiA9IHkgKyByLCB4ID0geSAtIHIpIDogKG0gPSB1ICsgcCwgYiA9IG0gKyByLCB2ID0geSAtIHIsIHggPSB5ICsgciksIF8gPSBtKSA6IChuID09PSBcImxlZnRcIiA/IGIgPSB1ICsgTWF0aC5tYXgobCwgaCkgKyByIDogbiA9PT0gXCJyaWdodFwiID8gYiA9IHUgKyBwIC0gTWF0aC5tYXgoYywgZCkgLSByIDogYiA9IHRoaXMuY2FyZXRYLCBvID09PSBcInRvcFwiID8gKHYgPSBmLCB5ID0gdiAtIHIsIG0gPSBiIC0gciwgXyA9IGIgKyByKSA6ICh2ID0gZiArIGcsIHkgPSB2ICsgciwgbSA9IGIgKyByLCBfID0gYiAtIHIpLCB4ID0gdiksIHtcbiAgICAgICAgeDE6IG0sXG4gICAgICAgIHgyOiBiLFxuICAgICAgICB4MzogXyxcbiAgICAgICAgeTE6IHYsXG4gICAgICAgIHkyOiB5LFxuICAgICAgICB5MzogeFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1RpdGxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdUaXRsZSh0LCBlLCBzKSB7XG4gICAgICB2YXIgbiA9IHRoaXMudGl0bGUsXG4gICAgICAgIG8gPSBuLmxlbmd0aDtcbiAgICAgIHZhciByLCBhLCBsO1xuICAgICAgaWYgKG8pIHtcbiAgICAgICAgdmFyIGMgPSBVdChzLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICAgICAgZm9yICh0LnggPSBSZSh0aGlzLCBzLnRpdGxlQWxpZ24sIHMpLCBlLnRleHRBbGlnbiA9IGMudGV4dEFsaWduKHMudGl0bGVBbGlnbiksIGUudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIiwgciA9IFgocy50aXRsZUZvbnQpLCBhID0gcy50aXRsZVNwYWNpbmcsIGUuZmlsbFN0eWxlID0gcy50aXRsZUNvbG9yLCBlLmZvbnQgPSByLnN0cmluZywgbCA9IDA7IGwgPCBvOyArK2wpIGUuZmlsbFRleHQobltsXSwgYy54KHQueCksIHQueSArIHIubGluZUhlaWdodCAvIDIpLCB0LnkgKz0gci5saW5lSGVpZ2h0ICsgYSwgbCArIDEgPT09IG8gJiYgKHQueSArPSBzLnRpdGxlTWFyZ2luQm90dG9tIC0gYSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3Q29sb3JCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdDb2xvckJveCh0LCBlLCBzLCBuLCBvKSB7XG4gICAgICB2YXIgciA9IHRoaXMubGFiZWxDb2xvcnNbc10sXG4gICAgICAgIGEgPSB0aGlzLmxhYmVsUG9pbnRTdHlsZXNbc10sXG4gICAgICAgIGwgPSBvLmJveEhlaWdodCxcbiAgICAgICAgYyA9IG8uYm94V2lkdGgsXG4gICAgICAgIGggPSBYKG8uYm9keUZvbnQpLFxuICAgICAgICBkID0gUmUodGhpcywgXCJsZWZ0XCIsIG8pLFxuICAgICAgICB1ID0gbi54KGQpLFxuICAgICAgICBmID0gbCA8IGgubGluZUhlaWdodCA/IChoLmxpbmVIZWlnaHQgLSBsKSAvIDIgOiAwLFxuICAgICAgICBwID0gZS55ICsgZjtcbiAgICAgIGlmIChvLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgICAgdmFyIGcgPSB7XG4gICAgICAgICAgICByYWRpdXM6IE1hdGgubWluKGMsIGwpIC8gMixcbiAgICAgICAgICAgIHBvaW50U3R5bGU6IGEucG9pbnRTdHlsZSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBhLnJvdGF0aW9uLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIG0gPSBuLmxlZnRGb3JMdHIodSwgYykgKyBjIC8gMixcbiAgICAgICAgICBiID0gcCArIGwgLyAyO1xuICAgICAgICB0LnN0cm9rZVN0eWxlID0gby5tdWx0aUtleUJhY2tncm91bmQsIHQuZmlsbFN0eWxlID0gby5tdWx0aUtleUJhY2tncm91bmQsIFNpKHQsIGcsIG0sIGIpLCB0LnN0cm9rZVN0eWxlID0gci5ib3JkZXJDb2xvciwgdC5maWxsU3R5bGUgPSByLmJhY2tncm91bmRDb2xvciwgU2kodCwgZywgbSwgYik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0LmxpbmVXaWR0aCA9IFQoci5ib3JkZXJXaWR0aCkgPyBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0LnZhbHVlcyhyLmJvcmRlcldpZHRoKSkpIDogci5ib3JkZXJXaWR0aCB8fCAxLCB0LnN0cm9rZVN0eWxlID0gci5ib3JkZXJDb2xvciwgdC5zZXRMaW5lRGFzaChyLmJvcmRlckRhc2ggfHwgW10pLCB0LmxpbmVEYXNoT2Zmc2V0ID0gci5ib3JkZXJEYXNoT2Zmc2V0IHx8IDA7XG4gICAgICAgIHZhciBfZzIgPSBuLmxlZnRGb3JMdHIodSwgYyksXG4gICAgICAgICAgX20gPSBuLmxlZnRGb3JMdHIobi54UGx1cyh1LCAxKSwgYyAtIDIpLFxuICAgICAgICAgIF9iMyA9IFl0KHIuYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhfYjMpLnNvbWUoZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICByZXR1cm4gXyAhPT0gMDtcbiAgICAgICAgfSkgPyAodC5iZWdpblBhdGgoKSwgdC5maWxsU3R5bGUgPSBvLm11bHRpS2V5QmFja2dyb3VuZCwgVWUodCwge1xuICAgICAgICAgIHg6IF9nMixcbiAgICAgICAgICB5OiBwLFxuICAgICAgICAgIHc6IGMsXG4gICAgICAgICAgaDogbCxcbiAgICAgICAgICByYWRpdXM6IF9iM1xuICAgICAgICB9KSwgdC5maWxsKCksIHQuc3Ryb2tlKCksIHQuZmlsbFN0eWxlID0gci5iYWNrZ3JvdW5kQ29sb3IsIHQuYmVnaW5QYXRoKCksIFVlKHQsIHtcbiAgICAgICAgICB4OiBfbSxcbiAgICAgICAgICB5OiBwICsgMSxcbiAgICAgICAgICB3OiBjIC0gMixcbiAgICAgICAgICBoOiBsIC0gMixcbiAgICAgICAgICByYWRpdXM6IF9iM1xuICAgICAgICB9KSwgdC5maWxsKCkpIDogKHQuZmlsbFN0eWxlID0gby5tdWx0aUtleUJhY2tncm91bmQsIHQuZmlsbFJlY3QoX2cyLCBwLCBjLCBsKSwgdC5zdHJva2VSZWN0KF9nMiwgcCwgYywgbCksIHQuZmlsbFN0eWxlID0gci5iYWNrZ3JvdW5kQ29sb3IsIHQuZmlsbFJlY3QoX20sIHAgKyAxLCBjIC0gMiwgbCAtIDIpKTtcbiAgICAgIH1cbiAgICAgIHQuZmlsbFN0eWxlID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbc107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdCb2R5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdCb2R5KHQsIGUsIHMpIHtcbiAgICAgIHZhciBuID0gdGhpcy5ib2R5LFxuICAgICAgICBvID0gcy5ib2R5U3BhY2luZyxcbiAgICAgICAgciA9IHMuYm9keUFsaWduLFxuICAgICAgICBhID0gcy5kaXNwbGF5Q29sb3JzLFxuICAgICAgICBsID0gcy5ib3hIZWlnaHQsXG4gICAgICAgIGMgPSBzLmJveFdpZHRoLFxuICAgICAgICBoID0gcy5ib3hQYWRkaW5nLFxuICAgICAgICBkID0gWChzLmJvZHlGb250KTtcbiAgICAgIHZhciB1ID0gZC5saW5lSGVpZ2h0LFxuICAgICAgICBmID0gMDtcbiAgICAgIHZhciBwID0gVXQocy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCksXG4gICAgICAgIGcgPSBmdW5jdGlvbiBnKGspIHtcbiAgICAgICAgICBlLmZpbGxUZXh0KGssIHAueCh0LnggKyBmKSwgdC55ICsgdSAvIDIpLCB0LnkgKz0gdSArIG87XG4gICAgICAgIH0sXG4gICAgICAgIG0gPSBwLnRleHRBbGlnbihyKTtcbiAgICAgIHZhciBiLCBfLCB2LCB5LCB4LCBNLCBTO1xuICAgICAgZm9yIChlLnRleHRBbGlnbiA9IHIsIGUudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIiwgZS5mb250ID0gZC5zdHJpbmcsIHQueCA9IFJlKHRoaXMsIG0sIHMpLCBlLmZpbGxTdHlsZSA9IHMuYm9keUNvbG9yLCBMKHRoaXMuYmVmb3JlQm9keSwgZyksIGYgPSBhICYmIG0gIT09IFwicmlnaHRcIiA/IHIgPT09IFwiY2VudGVyXCIgPyBjIC8gMiArIGggOiBjICsgMiArIGggOiAwLCB5ID0gMCwgTSA9IG4ubGVuZ3RoOyB5IDwgTTsgKyt5KSB7XG4gICAgICAgIGZvciAoYiA9IG5beV0sIF8gPSB0aGlzLmxhYmVsVGV4dENvbG9yc1t5XSwgZS5maWxsU3R5bGUgPSBfLCBMKGIuYmVmb3JlLCBnKSwgdiA9IGIubGluZXMsIGEgJiYgdi5sZW5ndGggJiYgKHRoaXMuX2RyYXdDb2xvckJveChlLCB0LCB5LCBwLCBzKSwgdSA9IE1hdGgubWF4KGQubGluZUhlaWdodCwgbCkpLCB4ID0gMCwgUyA9IHYubGVuZ3RoOyB4IDwgUzsgKyt4KSBnKHZbeF0pLCB1ID0gZC5saW5lSGVpZ2h0O1xuICAgICAgICBMKGIuYWZ0ZXIsIGcpO1xuICAgICAgfVxuICAgICAgZiA9IDAsIHUgPSBkLmxpbmVIZWlnaHQsIEwodGhpcy5hZnRlckJvZHksIGcpLCB0LnkgLT0gbztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0Zvb3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Rm9vdGVyKHQsIGUsIHMpIHtcbiAgICAgIHZhciBuID0gdGhpcy5mb290ZXIsXG4gICAgICAgIG8gPSBuLmxlbmd0aDtcbiAgICAgIHZhciByLCBhO1xuICAgICAgaWYgKG8pIHtcbiAgICAgICAgdmFyIGwgPSBVdChzLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICAgICAgZm9yICh0LnggPSBSZSh0aGlzLCBzLmZvb3RlckFsaWduLCBzKSwgdC55ICs9IHMuZm9vdGVyTWFyZ2luVG9wLCBlLnRleHRBbGlnbiA9IGwudGV4dEFsaWduKHMuZm9vdGVyQWxpZ24pLCBlLnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCIsIHIgPSBYKHMuZm9vdGVyRm9udCksIGUuZmlsbFN0eWxlID0gcy5mb290ZXJDb2xvciwgZS5mb250ID0gci5zdHJpbmcsIGEgPSAwOyBhIDwgbzsgKythKSBlLmZpbGxUZXh0KG5bYV0sIGwueCh0LngpLCB0LnkgKyByLmxpbmVIZWlnaHQgLyAyKSwgdC55ICs9IHIubGluZUhlaWdodCArIHMuZm9vdGVyU3BhY2luZztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0JhY2tncm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0JhY2tncm91bmQodCwgZSwgcywgbikge1xuICAgICAgdmFyIG8gPSB0aGlzLnhBbGlnbixcbiAgICAgICAgciA9IHRoaXMueUFsaWduLFxuICAgICAgICBhID0gdC54LFxuICAgICAgICBsID0gdC55LFxuICAgICAgICBjID0gcy53aWR0aCxcbiAgICAgICAgaCA9IHMuaGVpZ2h0LFxuICAgICAgICBfWXQzID0gWXQobi5jb3JuZXJSYWRpdXMpLFxuICAgICAgICBkID0gX1l0My50b3BMZWZ0LFxuICAgICAgICB1ID0gX1l0My50b3BSaWdodCxcbiAgICAgICAgZiA9IF9ZdDMuYm90dG9tTGVmdCxcbiAgICAgICAgcCA9IF9ZdDMuYm90dG9tUmlnaHQ7XG4gICAgICBlLmZpbGxTdHlsZSA9IG4uYmFja2dyb3VuZENvbG9yLCBlLnN0cm9rZVN0eWxlID0gbi5ib3JkZXJDb2xvciwgZS5saW5lV2lkdGggPSBuLmJvcmRlcldpZHRoLCBlLmJlZ2luUGF0aCgpLCBlLm1vdmVUbyhhICsgZCwgbCksIHIgPT09IFwidG9wXCIgJiYgdGhpcy5kcmF3Q2FyZXQodCwgZSwgcywgbiksIGUubGluZVRvKGEgKyBjIC0gdSwgbCksIGUucXVhZHJhdGljQ3VydmVUbyhhICsgYywgbCwgYSArIGMsIGwgKyB1KSwgciA9PT0gXCJjZW50ZXJcIiAmJiBvID09PSBcInJpZ2h0XCIgJiYgdGhpcy5kcmF3Q2FyZXQodCwgZSwgcywgbiksIGUubGluZVRvKGEgKyBjLCBsICsgaCAtIHApLCBlLnF1YWRyYXRpY0N1cnZlVG8oYSArIGMsIGwgKyBoLCBhICsgYyAtIHAsIGwgKyBoKSwgciA9PT0gXCJib3R0b21cIiAmJiB0aGlzLmRyYXdDYXJldCh0LCBlLCBzLCBuKSwgZS5saW5lVG8oYSArIGYsIGwgKyBoKSwgZS5xdWFkcmF0aWNDdXJ2ZVRvKGEsIGwgKyBoLCBhLCBsICsgaCAtIGYpLCByID09PSBcImNlbnRlclwiICYmIG8gPT09IFwibGVmdFwiICYmIHRoaXMuZHJhd0NhcmV0KHQsIGUsIHMsIG4pLCBlLmxpbmVUbyhhLCBsICsgZCksIGUucXVhZHJhdGljQ3VydmVUbyhhLCBsLCBhICsgZCwgbCksIGUuY2xvc2VQYXRoKCksIGUuZmlsbCgpLCBuLmJvcmRlcldpZHRoID4gMCAmJiBlLnN0cm9rZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlQW5pbWF0aW9uVGFyZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVBbmltYXRpb25UYXJnZXQodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmNoYXJ0LFxuICAgICAgICBzID0gdGhpcy4kYW5pbWF0aW9ucyxcbiAgICAgICAgbiA9IHMgJiYgcy54LFxuICAgICAgICBvID0gcyAmJiBzLnk7XG4gICAgICBpZiAobiB8fCBvKSB7XG4gICAgICAgIHZhciByID0gYWVbdC5wb3NpdGlvbl0uY2FsbCh0aGlzLCB0aGlzLl9hY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgICBpZiAoIXIpIHJldHVybjtcbiAgICAgICAgdmFyIGEgPSB0aGlzLl9zaXplID0gUXModGhpcywgdCksXG4gICAgICAgICAgbCA9IE9iamVjdC5hc3NpZ24oe30sIHIsIHRoaXMuX3NpemUpLFxuICAgICAgICAgIGMgPSB0bihlLCB0LCBsKSxcbiAgICAgICAgICBoID0gZW4odCwgbCwgYywgZSk7XG4gICAgICAgIChuLl90byAhPT0gaC54IHx8IG8uX3RvICE9PSBoLnkpICYmICh0aGlzLnhBbGlnbiA9IGMueEFsaWduLCB0aGlzLnlBbGlnbiA9IGMueUFsaWduLCB0aGlzLndpZHRoID0gYS53aWR0aCwgdGhpcy5oZWlnaHQgPSBhLmhlaWdodCwgdGhpcy5jYXJldFggPSByLngsIHRoaXMuY2FyZXRZID0gci55LCB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBoKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl93aWxsUmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF93aWxsUmVuZGVyKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5vcGFjaXR5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgICB2YXIgcyA9IHRoaXMub3BhY2l0eTtcbiAgICAgIGlmICghcykgcmV0dXJuO1xuICAgICAgdGhpcy5fdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KGUpO1xuICAgICAgdmFyIG4gPSB7XG4gICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICB9LFxuICAgICAgICBvID0ge1xuICAgICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgICB5OiB0aGlzLnlcbiAgICAgICAgfTtcbiAgICAgIHMgPSBNYXRoLmFicyhzKSA8IDFlLTMgPyAwIDogcztcbiAgICAgIHZhciByID0gZXQoZS5wYWRkaW5nKSxcbiAgICAgICAgYSA9IHRoaXMudGl0bGUubGVuZ3RoIHx8IHRoaXMuYmVmb3JlQm9keS5sZW5ndGggfHwgdGhpcy5ib2R5Lmxlbmd0aCB8fCB0aGlzLmFmdGVyQm9keS5sZW5ndGggfHwgdGhpcy5mb290ZXIubGVuZ3RoO1xuICAgICAgZS5lbmFibGVkICYmIGEgJiYgKHQuc2F2ZSgpLCB0Lmdsb2JhbEFscGhhID0gcywgdGhpcy5kcmF3QmFja2dyb3VuZChvLCB0LCBuLCBlKSwgRm4odCwgZS50ZXh0RGlyZWN0aW9uKSwgby55ICs9IHIudG9wLCB0aGlzLmRyYXdUaXRsZShvLCB0LCBlKSwgdGhpcy5kcmF3Qm9keShvLCB0LCBlKSwgdGhpcy5kcmF3Rm9vdGVyKG8sIHQsIGUpLCBJbih0LCBlLnRleHREaXJlY3Rpb24pLCB0LnJlc3RvcmUoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEFjdGl2ZUVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QWN0aXZlRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QWN0aXZlRWxlbWVudHModCwgZSkge1xuICAgICAgdmFyIF90aGlzMzEgPSB0aGlzO1xuICAgICAgdmFyIHMgPSB0aGlzLl9hY3RpdmUsXG4gICAgICAgIG4gPSB0Lm1hcChmdW5jdGlvbiAoX3JlZjEwKSB7XG4gICAgICAgICAgdmFyIGEgPSBfcmVmMTAuZGF0YXNldEluZGV4LFxuICAgICAgICAgICAgbCA9IF9yZWYxMC5pbmRleDtcbiAgICAgICAgICB2YXIgYyA9IF90aGlzMzEuY2hhcnQuZ2V0RGF0YXNldE1ldGEoYSk7XG4gICAgICAgICAgaWYgKCFjKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBhIGRhdGFzZXQgYXQgaW5kZXggXCIgKyBhKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YXNldEluZGV4OiBhLFxuICAgICAgICAgICAgZWxlbWVudDogYy5kYXRhW2xdLFxuICAgICAgICAgICAgaW5kZXg6IGxcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgbyA9ICFqZShzLCBuKSxcbiAgICAgICAgciA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChuLCBlKTtcbiAgICAgIChvIHx8IHIpICYmICh0aGlzLl9hY3RpdmUgPSBuLCB0aGlzLl9ldmVudFBvc2l0aW9uID0gZSwgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gITAsIHRoaXMudXBkYXRlKCEwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KHQsIGUpIHtcbiAgICAgIHZhciBzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAhMDtcbiAgICAgIGlmIChlICYmIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cykgcmV0dXJuICExO1xuICAgICAgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gITE7XG4gICAgICB2YXIgbiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgbyA9IHRoaXMuX2FjdGl2ZSB8fCBbXSxcbiAgICAgICAgciA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKHQsIG8sIGUsIHMpLFxuICAgICAgICBhID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKHIsIHQpLFxuICAgICAgICBsID0gZSB8fCAhamUociwgbykgfHwgYTtcbiAgICAgIHJldHVybiBsICYmICh0aGlzLl9hY3RpdmUgPSByLCAobi5lbmFibGVkIHx8IG4uZXh0ZXJuYWwpICYmICh0aGlzLl9ldmVudFBvc2l0aW9uID0ge1xuICAgICAgICB4OiB0LngsXG4gICAgICAgIHk6IHQueVxuICAgICAgfSwgdGhpcy51cGRhdGUoITAsIGUpKSksIGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRBY3RpdmVFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QWN0aXZlRWxlbWVudHModCwgZSwgcywgbikge1xuICAgICAgdmFyIF90aGlzMzIgPSB0aGlzO1xuICAgICAgdmFyIG8gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAodC50eXBlID09PSBcIm1vdXNlb3V0XCIpIHJldHVybiBbXTtcbiAgICAgIGlmICghbikgcmV0dXJuIGUuZmlsdGVyKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMyLmNoYXJ0LmRhdGEuZGF0YXNldHNbYS5kYXRhc2V0SW5kZXhdICYmIF90aGlzMzIuY2hhcnQuZ2V0RGF0YXNldE1ldGEoYS5kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIuZ2V0UGFyc2VkKGEuaW5kZXgpICE9PSB2b2lkIDA7XG4gICAgICB9KTtcbiAgICAgIHZhciByID0gdGhpcy5jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKHQsIG8ubW9kZSwgbywgcyk7XG4gICAgICByZXR1cm4gby5yZXZlcnNlICYmIHIucmV2ZXJzZSgpLCByO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcG9zaXRpb25DaGFuZ2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb3NpdGlvbkNoYW5nZWQodCwgZSkge1xuICAgICAgdmFyIHMgPSB0aGlzLmNhcmV0WCxcbiAgICAgICAgbiA9IHRoaXMuY2FyZXRZLFxuICAgICAgICBvID0gdGhpcy5vcHRpb25zLFxuICAgICAgICByID0gYWVbby5wb3NpdGlvbl0uY2FsbCh0aGlzLCB0LCBlKTtcbiAgICAgIHJldHVybiByICE9PSAhMSAmJiAocyAhPT0gci54IHx8IG4gIT09IHIueSk7XG4gICAgfVxuICB9XSk7XG59KHN0KTtcbncoT2ksIFwicG9zaXRpb25lcnNcIiwgYWUpO1xudmFyIEZjID0ge1xuICBpZDogXCJ0b29sdGlwXCIsXG4gIF9lbGVtZW50OiBPaSxcbiAgcG9zaXRpb25lcnM6IGFlLFxuICBhZnRlckluaXQ6IGZ1bmN0aW9uIGFmdGVySW5pdChpLCB0LCBlKSB7XG4gICAgZSAmJiAoaS50b29sdGlwID0gbmV3IE9pKHtcbiAgICAgIGNoYXJ0OiBpLFxuICAgICAgb3B0aW9uczogZVxuICAgIH0pKTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUoaSwgdCwgZSkge1xuICAgIGkudG9vbHRpcCAmJiBpLnRvb2x0aXAuaW5pdGlhbGl6ZShlKTtcbiAgfSxcbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KGksIHQsIGUpIHtcbiAgICBpLnRvb2x0aXAgJiYgaS50b29sdGlwLmluaXRpYWxpemUoZSk7XG4gIH0sXG4gIGFmdGVyRHJhdzogZnVuY3Rpb24gYWZ0ZXJEcmF3KGkpIHtcbiAgICB2YXIgdCA9IGkudG9vbHRpcDtcbiAgICBpZiAodCAmJiB0Ll93aWxsUmVuZGVyKCkpIHtcbiAgICAgIHZhciBlID0ge1xuICAgICAgICB0b29sdGlwOiB0XG4gICAgICB9O1xuICAgICAgaWYgKGkubm90aWZ5UGx1Z2lucyhcImJlZm9yZVRvb2x0aXBEcmF3XCIsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZSksIHt9LCB7XG4gICAgICAgIGNhbmNlbGFibGU6ICEwXG4gICAgICB9KSkgPT09ICExKSByZXR1cm47XG4gICAgICB0LmRyYXcoaS5jdHgpLCBpLm5vdGlmeVBsdWdpbnMoXCJhZnRlclRvb2x0aXBEcmF3XCIsIGUpO1xuICAgIH1cbiAgfSxcbiAgYWZ0ZXJFdmVudDogZnVuY3Rpb24gYWZ0ZXJFdmVudChpLCB0KSB7XG4gICAgaWYgKGkudG9vbHRpcCkge1xuICAgICAgdmFyIGUgPSB0LnJlcGxheTtcbiAgICAgIGkudG9vbHRpcC5oYW5kbGVFdmVudCh0LmV2ZW50LCBlLCB0LmluQ2hhcnRBcmVhKSAmJiAodC5jaGFuZ2VkID0gITApO1xuICAgIH1cbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBlbmFibGVkOiAhMCxcbiAgICBleHRlcm5hbDogbnVsbCxcbiAgICBwb3NpdGlvbjogXCJhdmVyYWdlXCIsXG4gICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoMCwwLDAsMC44KVwiLFxuICAgIHRpdGxlQ29sb3I6IFwiI2ZmZlwiLFxuICAgIHRpdGxlRm9udDoge1xuICAgICAgd2VpZ2h0OiBcImJvbGRcIlxuICAgIH0sXG4gICAgdGl0bGVTcGFjaW5nOiAyLFxuICAgIHRpdGxlTWFyZ2luQm90dG9tOiA2LFxuICAgIHRpdGxlQWxpZ246IFwibGVmdFwiLFxuICAgIGJvZHlDb2xvcjogXCIjZmZmXCIsXG4gICAgYm9keVNwYWNpbmc6IDIsXG4gICAgYm9keUZvbnQ6IHt9LFxuICAgIGJvZHlBbGlnbjogXCJsZWZ0XCIsXG4gICAgZm9vdGVyQ29sb3I6IFwiI2ZmZlwiLFxuICAgIGZvb3RlclNwYWNpbmc6IDIsXG4gICAgZm9vdGVyTWFyZ2luVG9wOiA2LFxuICAgIGZvb3RlckZvbnQ6IHtcbiAgICAgIHdlaWdodDogXCJib2xkXCJcbiAgICB9LFxuICAgIGZvb3RlckFsaWduOiBcImxlZnRcIixcbiAgICBwYWRkaW5nOiA2LFxuICAgIGNhcmV0UGFkZGluZzogMixcbiAgICBjYXJldFNpemU6IDUsXG4gICAgY29ybmVyUmFkaXVzOiA2LFxuICAgIGJveEhlaWdodDogZnVuY3Rpb24gYm94SGVpZ2h0KGksIHQpIHtcbiAgICAgIHJldHVybiB0LmJvZHlGb250LnNpemU7XG4gICAgfSxcbiAgICBib3hXaWR0aDogZnVuY3Rpb24gYm94V2lkdGgoaSwgdCkge1xuICAgICAgcmV0dXJuIHQuYm9keUZvbnQuc2l6ZTtcbiAgICB9LFxuICAgIG11bHRpS2V5QmFja2dyb3VuZDogXCIjZmZmXCIsXG4gICAgZGlzcGxheUNvbG9yczogITAsXG4gICAgYm94UGFkZGluZzogMCxcbiAgICBib3JkZXJDb2xvcjogXCJyZ2JhKDAsMCwwLDApXCIsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwLFxuICAgICAgZWFzaW5nOiBcImVhc2VPdXRRdWFydFwiXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgIHByb3BlcnRpZXM6IFtcInhcIiwgXCJ5XCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJjYXJldFhcIiwgXCJjYXJldFlcIl1cbiAgICAgIH0sXG4gICAgICBvcGFjaXR5OiB7XG4gICAgICAgIGVhc2luZzogXCJsaW5lYXJcIixcbiAgICAgICAgZHVyYXRpb246IDIwMFxuICAgICAgfVxuICAgIH0sXG4gICAgY2FsbGJhY2tzOiByb1xuICB9LFxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgYm9keUZvbnQ6IFwiZm9udFwiLFxuICAgIGZvb3RlckZvbnQ6IFwiZm9udFwiLFxuICAgIHRpdGxlRm9udDogXCJmb250XCJcbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogZnVuY3Rpb24gX3NjcmlwdGFibGUoaSkge1xuICAgICAgcmV0dXJuIGkgIT09IFwiZmlsdGVyXCIgJiYgaSAhPT0gXCJpdGVtU29ydFwiICYmIGkgIT09IFwiZXh0ZXJuYWxcIjtcbiAgICB9LFxuICAgIF9pbmRleGFibGU6ICExLFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgX3NjcmlwdGFibGU6ICExLFxuICAgICAgX2luZGV4YWJsZTogITFcbiAgICB9LFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgX2ZhbGxiYWNrOiAhMVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgX2ZhbGxiYWNrOiBcImFuaW1hdGlvblwiXG4gICAgfVxuICB9LFxuICBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzOiBbXCJpbnRlcmFjdGlvblwiXVxufTtcbnZhciBJYyA9IGZ1bmN0aW9uIEljKGksIHQsIGUsIHMpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyAoZSA9IGkucHVzaCh0KSAtIDEsIHMudW5zaGlmdCh7XG4gICAgaW5kZXg6IGUsXG4gICAgbGFiZWw6IHRcbiAgfSkpIDogaXNOYU4odCkgJiYgKGUgPSBudWxsKSwgZTtcbn07XG5mdW5jdGlvbiB6YyhpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gaS5pbmRleE9mKHQpO1xuICBpZiAobiA9PT0gLTEpIHJldHVybiBJYyhpLCB0LCBlLCBzKTtcbiAgdmFyIG8gPSBpLmxhc3RJbmRleE9mKHQpO1xuICByZXR1cm4gbiAhPT0gbyA/IGUgOiBuO1xufVxudmFyIEJjID0gZnVuY3Rpb24gQmMoaSwgdCkge1xuICByZXR1cm4gaSA9PT0gbnVsbCA/IG51bGwgOiBVKE1hdGgucm91bmQoaSksIDAsIHQpO1xufTtcbmZ1bmN0aW9uIG9uKGkpIHtcbiAgdmFyIHQgPSB0aGlzLmdldExhYmVscygpO1xuICByZXR1cm4gaSA+PSAwICYmIGkgPCB0Lmxlbmd0aCA/IHRbaV0gOiBpO1xufVxudmFyIFRpID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfR3QpIHtcbiAgZnVuY3Rpb24gVGkodCkge1xuICAgIHZhciBfdGhpczMzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaSk7XG4gICAgX3RoaXMzMyA9IF9jYWxsU3VwZXIodGhpcywgVGksIFt0XSksIF90aGlzMzMuX3N0YXJ0VmFsdWUgPSB2b2lkIDAsIF90aGlzMzMuX3ZhbHVlUmFuZ2UgPSAwLCBfdGhpczMzLl9hZGRlZExhYmVscyA9IFtdO1xuICAgIHJldHVybiBfdGhpczMzO1xuICB9XG4gIF9pbmhlcml0cyhUaSwgX0d0KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhUaSwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fYWRkZWRMYWJlbHM7XG4gICAgICBpZiAoZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yMzYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihlKSxcbiAgICAgICAgICBfc3RlcDM2O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMzYucygpOyAhKF9zdGVwMzYgPSBfaXRlcmF0b3IzNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgX3N0ZXAzNiR2YWx1ZSA9IF9zdGVwMzYudmFsdWUsXG4gICAgICAgICAgICAgIG4gPSBfc3RlcDM2JHZhbHVlLmluZGV4LFxuICAgICAgICAgICAgICBvID0gX3N0ZXAzNiR2YWx1ZS5sYWJlbDtcbiAgICAgICAgICAgIHNbbl0gPT09IG8gJiYgcy5zcGxpY2UobiwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IzNi5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMzYuZigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gICAgICB9XG4gICAgICBfc3VwZXJQcm9wR2V0KFRpLCBcImluaXRcIiwgdGhpcywgMykoW3RdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UodCwgZSkge1xuICAgICAgaWYgKFIodCkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgICAgcmV0dXJuIGUgPSBpc0Zpbml0ZShlKSAmJiBzW2VdID09PSB0ID8gZSA6IHpjKHMsIHQsIEQoZSwgdCksIHRoaXMuX2FkZGVkTGFiZWxzKSwgQmMoZSwgcy5sZW5ndGggLSAxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGV0ZXJtaW5lRGF0YUxpbWl0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgICAgdmFyIF90aGlzJGdldFVzZXJCb3VuZHMyID0gdGhpcy5nZXRVc2VyQm91bmRzKCksXG4gICAgICAgIHQgPSBfdGhpcyRnZXRVc2VyQm91bmRzMi5taW5EZWZpbmVkLFxuICAgICAgICBlID0gX3RoaXMkZ2V0VXNlckJvdW5kczIubWF4RGVmaW5lZDtcbiAgICAgIHZhciBfdGhpcyRnZXRNaW5NYXggPSB0aGlzLmdldE1pbk1heCghMCksXG4gICAgICAgIHMgPSBfdGhpcyRnZXRNaW5NYXgubWluLFxuICAgICAgICBuID0gX3RoaXMkZ2V0TWluTWF4Lm1heDtcbiAgICAgIHRoaXMub3B0aW9ucy5ib3VuZHMgPT09IFwidGlja3NcIiAmJiAodCB8fCAocyA9IDApLCBlIHx8IChuID0gdGhpcy5nZXRMYWJlbHMoKS5sZW5ndGggLSAxKSksIHRoaXMubWluID0gcywgdGhpcy5tYXggPSBuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWlsZFRpY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkVGlja3MoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMubWluLFxuICAgICAgICBlID0gdGhpcy5tYXgsXG4gICAgICAgIHMgPSB0aGlzLm9wdGlvbnMub2Zmc2V0LFxuICAgICAgICBuID0gW107XG4gICAgICB2YXIgbyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgICBvID0gdCA9PT0gMCAmJiBlID09PSBvLmxlbmd0aCAtIDEgPyBvIDogby5zbGljZSh0LCBlICsgMSksIHRoaXMuX3ZhbHVlUmFuZ2UgPSBNYXRoLm1heChvLmxlbmd0aCAtIChzID8gMCA6IDEpLCAxKSwgdGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMubWluIC0gKHMgPyAwLjUgOiAwKTtcbiAgICAgIGZvciAodmFyIHIgPSB0OyByIDw9IGU7IHIrKykgbi5wdXNoKHtcbiAgICAgICAgdmFsdWU6IHJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsRm9yVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxGb3JWYWx1ZSh0KSB7XG4gICAgICByZXR1cm4gb24uY2FsbCh0aGlzLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29uZmlndXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmZpZ3VyZSgpIHtcbiAgICAgIF9zdXBlclByb3BHZXQoVGksIFwiY29uZmlndXJlXCIsIHRoaXMsIDMpKFtdKSwgdGhpcy5pc0hvcml6b250YWwoKSB8fCAodGhpcy5fcmV2ZXJzZVBpeGVscyA9ICF0aGlzLl9yZXZlcnNlUGl4ZWxzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGl4ZWxGb3JWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQaXhlbEZvclZhbHVlKHQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdCAhPSBcIm51bWJlclwiICYmICh0ID0gdGhpcy5wYXJzZSh0KSksIHQgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodCAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBpeGVsRm9yVGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQaXhlbEZvclRpY2sodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLnRpY2tzO1xuICAgICAgcmV0dXJuIHQgPCAwIHx8IHQgPiBlLmxlbmd0aCAtIDEgPyBudWxsIDogdGhpcy5nZXRQaXhlbEZvclZhbHVlKGVbdF0udmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWYWx1ZUZvclBpeGVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlRm9yUGl4ZWwodCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHQpICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJhc2VQaXhlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib3R0b207XG4gICAgfVxuICB9XSk7XG59KEd0KTtcbncoVGksIFwiaWRcIiwgXCJjYXRlZ29yeVwiKSwgdyhUaSwgXCJkZWZhdWx0c1wiLCB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IG9uXG4gIH1cbn0pO1xuZnVuY3Rpb24gSGMoaSwgdCkge1xuICB2YXIgZSA9IFtdLFxuICAgIG4gPSBpLmJvdW5kcyxcbiAgICBvID0gaS5zdGVwLFxuICAgIHIgPSBpLm1pbixcbiAgICBhID0gaS5tYXgsXG4gICAgbCA9IGkucHJlY2lzaW9uLFxuICAgIGMgPSBpLmNvdW50LFxuICAgIGggPSBpLm1heFRpY2tzLFxuICAgIGQgPSBpLm1heERpZ2l0cyxcbiAgICB1ID0gaS5pbmNsdWRlQm91bmRzLFxuICAgIGYgPSBvIHx8IDEsXG4gICAgcCA9IGggLSAxLFxuICAgIGcgPSB0Lm1pbixcbiAgICBtID0gdC5tYXgsXG4gICAgYiA9ICFSKHIpLFxuICAgIF8gPSAhUihhKSxcbiAgICB2ID0gIVIoYyksXG4gICAgeSA9IChtIC0gZykgLyAoZCArIDEpO1xuICB2YXIgeCA9IGVzKChtIC0gZykgLyBwIC8gZikgKiBmLFxuICAgIE0sXG4gICAgUyxcbiAgICBrLFxuICAgIFA7XG4gIGlmICh4IDwgMWUtMTQgJiYgIWIgJiYgIV8pIHJldHVybiBbe1xuICAgIHZhbHVlOiBnXG4gIH0sIHtcbiAgICB2YWx1ZTogbVxuICB9XTtcbiAgUCA9IE1hdGguY2VpbChtIC8geCkgLSBNYXRoLmZsb29yKGcgLyB4KSwgUCA+IHAgJiYgKHggPSBlcyhQICogeCAvIHAgLyBmKSAqIGYpLCBSKGwpIHx8IChNID0gTWF0aC5wb3coMTAsIGwpLCB4ID0gTWF0aC5jZWlsKHggKiBNKSAvIE0pLCBuID09PSBcInRpY2tzXCIgPyAoUyA9IE1hdGguZmxvb3IoZyAvIHgpICogeCwgayA9IE1hdGguY2VpbChtIC8geCkgKiB4KSA6IChTID0gZywgayA9IG0pLCBiICYmIF8gJiYgbyAmJiAkbygoYSAtIHIpIC8gbywgeCAvIDFlMykgPyAoUCA9IE1hdGgucm91bmQoTWF0aC5taW4oKGEgLSByKSAvIHgsIGgpKSwgeCA9IChhIC0gcikgLyBQLCBTID0gciwgayA9IGEpIDogdiA/IChTID0gYiA/IHIgOiBTLCBrID0gXyA/IGEgOiBrLCBQID0gYyAtIDEsIHggPSAoayAtIFMpIC8gUCkgOiAoUCA9IChrIC0gUykgLyB4LCBjZShQLCBNYXRoLnJvdW5kKFApLCB4IC8gMWUzKSA/IFAgPSBNYXRoLnJvdW5kKFApIDogUCA9IE1hdGguY2VpbChQKSk7XG4gIHZhciBDID0gTWF0aC5tYXgoaXMoeCksIGlzKFMpKTtcbiAgTSA9IE1hdGgucG93KDEwLCBSKGwpID8gQyA6IGwpLCBTID0gTWF0aC5yb3VuZChTICogTSkgLyBNLCBrID0gTWF0aC5yb3VuZChrICogTSkgLyBNO1xuICB2YXIgTyA9IDA7XG4gIGZvciAoYiAmJiAodSAmJiBTICE9PSByID8gKGUucHVzaCh7XG4gICAgdmFsdWU6IHJcbiAgfSksIFMgPCByICYmIE8rKywgY2UoTWF0aC5yb3VuZCgoUyArIE8gKiB4KSAqIE0pIC8gTSwgciwgcm4ociwgeSwgaSkpICYmIE8rKykgOiBTIDwgciAmJiBPKyspOyBPIDwgUDsgKytPKSB7XG4gICAgdmFyIEEgPSBNYXRoLnJvdW5kKChTICsgTyAqIHgpICogTSkgLyBNO1xuICAgIGlmIChfICYmIEEgPiBhKSBicmVhaztcbiAgICBlLnB1c2goe1xuICAgICAgdmFsdWU6IEFcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gXyAmJiB1ICYmIGsgIT09IGEgPyBlLmxlbmd0aCAmJiBjZShlW2UubGVuZ3RoIC0gMV0udmFsdWUsIGEsIHJuKGEsIHksIGkpKSA/IGVbZS5sZW5ndGggLSAxXS52YWx1ZSA9IGEgOiBlLnB1c2goe1xuICAgIHZhbHVlOiBhXG4gIH0pIDogKCFfIHx8IGsgPT09IGEpICYmIGUucHVzaCh7XG4gICAgdmFsdWU6IGtcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBybihpLCB0LCBfcmVmMTEpIHtcbiAgdmFyIGUgPSBfcmVmMTEuaG9yaXpvbnRhbCxcbiAgICBzID0gX3JlZjExLm1pblJvdGF0aW9uO1xuICB2YXIgbiA9IGJ0KHMpLFxuICAgIG8gPSAoZSA/IE1hdGguc2luKG4pIDogTWF0aC5jb3MobikpIHx8IDFlLTMsXG4gICAgciA9IDAuNzUgKiB0ICogKFwiXCIgKyBpKS5sZW5ndGg7XG4gIHJldHVybiBNYXRoLm1pbih0IC8gbywgcik7XG59XG52YXIgV2MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9HdDIpIHtcbiAgZnVuY3Rpb24gV2ModCkge1xuICAgIHZhciBfdGhpczM0O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXYyk7XG4gICAgX3RoaXMzNCA9IF9jYWxsU3VwZXIodGhpcywgV2MsIFt0XSksIF90aGlzMzQuc3RhcnQgPSB2b2lkIDAsIF90aGlzMzQuZW5kID0gdm9pZCAwLCBfdGhpczM0Ll9zdGFydFZhbHVlID0gdm9pZCAwLCBfdGhpczM0Ll9lbmRWYWx1ZSA9IHZvaWQgMCwgX3RoaXMzNC5fdmFsdWVSYW5nZSA9IDA7XG4gICAgcmV0dXJuIF90aGlzMzQ7XG4gIH1cbiAgX2luaGVyaXRzKFdjLCBfR3QyKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhXYywgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UodCwgZSkge1xuICAgICAgcmV0dXJuIFIodCkgfHwgKHR5cGVvZiB0ID09IFwibnVtYmVyXCIgfHwgdCBpbnN0YW5jZW9mIE51bWJlcikgJiYgIWlzRmluaXRlKCt0KSA/IG51bGwgOiArdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlVGlja1JhbmdlT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMuYmVnaW5BdFplcm8sXG4gICAgICAgIF90aGlzJGdldFVzZXJCb3VuZHMzID0gdGhpcy5nZXRVc2VyQm91bmRzKCksXG4gICAgICAgIGUgPSBfdGhpcyRnZXRVc2VyQm91bmRzMy5taW5EZWZpbmVkLFxuICAgICAgICBzID0gX3RoaXMkZ2V0VXNlckJvdW5kczMubWF4RGVmaW5lZDtcbiAgICAgIHZhciBuID0gdGhpcy5taW4sXG4gICAgICAgIG8gPSB0aGlzLm1heDtcbiAgICAgIHZhciByID0gZnVuY3Rpb24gcihsKSB7XG4gICAgICAgICAgcmV0dXJuIG4gPSBlID8gbiA6IGw7XG4gICAgICAgIH0sXG4gICAgICAgIGEgPSBmdW5jdGlvbiBhKGwpIHtcbiAgICAgICAgICByZXR1cm4gbyA9IHMgPyBvIDogbDtcbiAgICAgICAgfTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIHZhciBsID0gbHQobiksXG4gICAgICAgICAgYyA9IGx0KG8pO1xuICAgICAgICBsIDwgMCAmJiBjIDwgMCA/IGEoMCkgOiBsID4gMCAmJiBjID4gMCAmJiByKDApO1xuICAgICAgfVxuICAgICAgaWYgKG4gPT09IG8pIHtcbiAgICAgICAgdmFyIF9sNSA9IG8gPT09IDAgPyAxIDogTWF0aC5hYnMobyAqIDAuMDUpO1xuICAgICAgICBhKG8gKyBfbDUpLCB0IHx8IHIobiAtIF9sNSk7XG4gICAgICB9XG4gICAgICB0aGlzLm1pbiA9IG4sIHRoaXMubWF4ID0gbztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGlja0xpbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRpY2tMaW1pdCgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgICAgdmFyIGUgPSB0Lm1heFRpY2tzTGltaXQsXG4gICAgICAgIHMgPSB0LnN0ZXBTaXplLFxuICAgICAgICBuO1xuICAgICAgcmV0dXJuIHMgPyAobiA9IE1hdGguY2VpbCh0aGlzLm1heCAvIHMpIC0gTWF0aC5mbG9vcih0aGlzLm1pbiAvIHMpICsgMSwgbiA+IDFlMyAmJiAoY29uc29sZS53YXJuKFwic2NhbGVzLlwiLmNvbmNhdCh0aGlzLmlkLCBcIi50aWNrcy5zdGVwU2l6ZTogXCIpLmNvbmNhdChzLCBcIiB3b3VsZCByZXN1bHQgZ2VuZXJhdGluZyB1cCB0byBcIikuY29uY2F0KG4sIFwiIHRpY2tzLiBMaW1pdGluZyB0byAxMDAwLlwiKSksIG4gPSAxZTMpKSA6IChuID0gdGhpcy5jb21wdXRlVGlja0xpbWl0KCksIGUgPSBlIHx8IDExKSwgZSAmJiAobiA9IE1hdGgubWluKGUsIG4pKSwgbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcHV0ZVRpY2tMaW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRUaWNrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZFRpY2tzKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGUgPSB0LnRpY2tzO1xuICAgICAgdmFyIHMgPSB0aGlzLmdldFRpY2tMaW1pdCgpO1xuICAgICAgcyA9IE1hdGgubWF4KDIsIHMpO1xuICAgICAgdmFyIG4gPSB7XG4gICAgICAgICAgbWF4VGlja3M6IHMsXG4gICAgICAgICAgYm91bmRzOiB0LmJvdW5kcyxcbiAgICAgICAgICBtaW46IHQubWluLFxuICAgICAgICAgIG1heDogdC5tYXgsXG4gICAgICAgICAgcHJlY2lzaW9uOiBlLnByZWNpc2lvbixcbiAgICAgICAgICBzdGVwOiBlLnN0ZXBTaXplLFxuICAgICAgICAgIGNvdW50OiBlLmNvdW50LFxuICAgICAgICAgIG1heERpZ2l0czogdGhpcy5fbWF4RGlnaXRzKCksXG4gICAgICAgICAgaG9yaXpvbnRhbDogdGhpcy5pc0hvcml6b250YWwoKSxcbiAgICAgICAgICBtaW5Sb3RhdGlvbjogZS5taW5Sb3RhdGlvbiB8fCAwLFxuICAgICAgICAgIGluY2x1ZGVCb3VuZHM6IGUuaW5jbHVkZUJvdW5kcyAhPT0gITFcbiAgICAgICAgfSxcbiAgICAgICAgbyA9IHRoaXMuX3JhbmdlIHx8IHRoaXMsXG4gICAgICAgIHIgPSBIYyhuLCBvKTtcbiAgICAgIHJldHVybiB0LmJvdW5kcyA9PT0gXCJ0aWNrc1wiICYmIFlvKHIsIHRoaXMsIFwidmFsdWVcIiksIHQucmV2ZXJzZSA/IChyLnJldmVyc2UoKSwgdGhpcy5zdGFydCA9IHRoaXMubWF4LCB0aGlzLmVuZCA9IHRoaXMubWluKSA6ICh0aGlzLnN0YXJ0ID0gdGhpcy5taW4sIHRoaXMuZW5kID0gdGhpcy5tYXgpLCByO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25maWd1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uZmlndXJlKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLnRpY2tzO1xuICAgICAgdmFyIGUgPSB0aGlzLm1pbixcbiAgICAgICAgcyA9IHRoaXMubWF4O1xuICAgICAgaWYgKF9zdXBlclByb3BHZXQoV2MsIFwiY29uZmlndXJlXCIsIHRoaXMsIDMpKFtdKSwgdGhpcy5vcHRpb25zLm9mZnNldCAmJiB0Lmxlbmd0aCkge1xuICAgICAgICB2YXIgbiA9IChzIC0gZSkgLyBNYXRoLm1heCh0Lmxlbmd0aCAtIDEsIDEpIC8gMjtcbiAgICAgICAgZSAtPSBuLCBzICs9IG47XG4gICAgICB9XG4gICAgICB0aGlzLl9zdGFydFZhbHVlID0gZSwgdGhpcy5fZW5kVmFsdWUgPSBzLCB0aGlzLl92YWx1ZVJhbmdlID0gcyAtIGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsRm9yVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxGb3JWYWx1ZSh0KSB7XG4gICAgICByZXR1cm4gSGkodCwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gICAgfVxuICB9XSk7XG59KEd0KTtcbnZhciBBaSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1djKSB7XG4gIGZ1bmN0aW9uIEFpKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBaSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgQWksIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2luaGVyaXRzKEFpLCBfV2MpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEFpLCBbe1xuICAgIGtleTogXCJkZXRlcm1pbmVEYXRhTGltaXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0TWluTWF4MiA9IHRoaXMuZ2V0TWluTWF4KCEwKSxcbiAgICAgICAgdCA9IF90aGlzJGdldE1pbk1heDIubWluLFxuICAgICAgICBlID0gX3RoaXMkZ2V0TWluTWF4Mi5tYXg7XG4gICAgICB0aGlzLm1pbiA9IHEodCkgPyB0IDogMCwgdGhpcy5tYXggPSBxKGUpID8gZSA6IDEsIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wdXRlVGlja0xpbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuaXNIb3Jpem9udGFsKCksXG4gICAgICAgIGUgPSB0ID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0LFxuICAgICAgICBzID0gYnQodGhpcy5vcHRpb25zLnRpY2tzLm1pblJvdGF0aW9uKSxcbiAgICAgICAgbiA9ICh0ID8gTWF0aC5zaW4ocykgOiBNYXRoLmNvcyhzKSkgfHwgMWUtMyxcbiAgICAgICAgbyA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCk7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKGUgLyBNYXRoLm1pbig0MCwgby5saW5lSGVpZ2h0IC8gbikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQaXhlbEZvclZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBpeGVsRm9yVmFsdWUodCkge1xuICAgICAgcmV0dXJuIHQgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodCAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFZhbHVlRm9yUGl4ZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWVGb3JQaXhlbCh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHQpICogdGhpcy5fdmFsdWVSYW5nZTtcbiAgICB9XG4gIH1dKTtcbn0oV2MpO1xudyhBaSwgXCJpZFwiLCBcImxpbmVhclwiKSwgdyhBaSwgXCJkZWZhdWx0c1wiLCB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IERuLmZvcm1hdHRlcnMubnVtZXJpY1xuICB9XG59KTtcbnZhciBpaSA9IHtcbiAgICBtaWxsaXNlY29uZDoge1xuICAgICAgY29tbW9uOiAhMCxcbiAgICAgIHNpemU6IDEsXG4gICAgICBzdGVwczogMWUzXG4gICAgfSxcbiAgICBzZWNvbmQ6IHtcbiAgICAgIGNvbW1vbjogITAsXG4gICAgICBzaXplOiAxZTMsXG4gICAgICBzdGVwczogNjBcbiAgICB9LFxuICAgIG1pbnV0ZToge1xuICAgICAgY29tbW9uOiAhMCxcbiAgICAgIHNpemU6IDZlNCxcbiAgICAgIHN0ZXBzOiA2MFxuICAgIH0sXG4gICAgaG91cjoge1xuICAgICAgY29tbW9uOiAhMCxcbiAgICAgIHNpemU6IDM2ZTUsXG4gICAgICBzdGVwczogMjRcbiAgICB9LFxuICAgIGRheToge1xuICAgICAgY29tbW9uOiAhMCxcbiAgICAgIHNpemU6IDg2NGU1LFxuICAgICAgc3RlcHM6IDMwXG4gICAgfSxcbiAgICB3ZWVrOiB7XG4gICAgICBjb21tb246ICExLFxuICAgICAgc2l6ZTogNjA0OGU1LFxuICAgICAgc3RlcHM6IDRcbiAgICB9LFxuICAgIG1vbnRoOiB7XG4gICAgICBjb21tb246ICEwLFxuICAgICAgc2l6ZTogMjYyOGU2LFxuICAgICAgc3RlcHM6IDEyXG4gICAgfSxcbiAgICBxdWFydGVyOiB7XG4gICAgICBjb21tb246ICExLFxuICAgICAgc2l6ZTogNzg4NGU2LFxuICAgICAgc3RlcHM6IDRcbiAgICB9LFxuICAgIHllYXI6IHtcbiAgICAgIGNvbW1vbjogITAsXG4gICAgICBzaXplOiAzMTU0ZTdcbiAgICB9XG4gIH0sXG4gIEcgPSAvKiBAX19QVVJFX18gKi9PYmplY3Qua2V5cyhpaSk7XG5mdW5jdGlvbiBhbihpLCB0KSB7XG4gIHJldHVybiBpIC0gdDtcbn1cbmZ1bmN0aW9uIGxuKGksIHQpIHtcbiAgaWYgKFIodCkpIHJldHVybiBudWxsO1xuICB2YXIgZSA9IGkuX2FkYXB0ZXIsXG4gICAgX2kkX3BhcnNlT3B0cyA9IGkuX3BhcnNlT3B0cyxcbiAgICBzID0gX2kkX3BhcnNlT3B0cy5wYXJzZXIsXG4gICAgbiA9IF9pJF9wYXJzZU9wdHMucm91bmQsXG4gICAgbyA9IF9pJF9wYXJzZU9wdHMuaXNvV2Vla2RheTtcbiAgdmFyIHIgPSB0O1xuICByZXR1cm4gdHlwZW9mIHMgPT0gXCJmdW5jdGlvblwiICYmIChyID0gcyhyKSksIHEocikgfHwgKHIgPSB0eXBlb2YgcyA9PSBcInN0cmluZ1wiID8gZS5wYXJzZShyLCBzKSA6IGUucGFyc2UocikpLCByID09PSBudWxsID8gbnVsbCA6IChuICYmIChyID0gbiA9PT0gXCJ3ZWVrXCIgJiYgKFh0KG8pIHx8IG8gPT09ICEwKSA/IGUuc3RhcnRPZihyLCBcImlzb1dlZWtcIiwgbykgOiBlLnN0YXJ0T2YociwgbikpLCArcik7XG59XG5mdW5jdGlvbiBjbihpLCB0LCBlLCBzKSB7XG4gIHZhciBuID0gRy5sZW5ndGg7XG4gIGZvciAodmFyIG8gPSBHLmluZGV4T2YoaSk7IG8gPCBuIC0gMTsgKytvKSB7XG4gICAgdmFyIHIgPSBpaVtHW29dXSxcbiAgICAgIGEgPSByLnN0ZXBzID8gci5zdGVwcyA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIGlmIChyLmNvbW1vbiAmJiBNYXRoLmNlaWwoKGUgLSB0KSAvIChhICogci5zaXplKSkgPD0gcykgcmV0dXJuIEdbb107XG4gIH1cbiAgcmV0dXJuIEdbbiAtIDFdO1xufVxuZnVuY3Rpb24gTmMoaSwgdCwgZSwgcywgbikge1xuICBmb3IgKHZhciBvID0gRy5sZW5ndGggLSAxOyBvID49IEcuaW5kZXhPZihlKTsgby0tKSB7XG4gICAgdmFyIHIgPSBHW29dO1xuICAgIGlmIChpaVtyXS5jb21tb24gJiYgaS5fYWRhcHRlci5kaWZmKG4sIHMsIHIpID49IHQgLSAxKSByZXR1cm4gcjtcbiAgfVxuICByZXR1cm4gR1tlID8gRy5pbmRleE9mKGUpIDogMF07XG59XG5mdW5jdGlvbiBWYyhpKSB7XG4gIGZvciAodmFyIHQgPSBHLmluZGV4T2YoaSkgKyAxLCBlID0gRy5sZW5ndGg7IHQgPCBlOyArK3QpIGlmIChpaVtHW3RdXS5jb21tb24pIHJldHVybiBHW3RdO1xufVxuZnVuY3Rpb24gaG4oaSwgdCwgZSkge1xuICBpZiAoIWUpIGlbdF0gPSAhMDtlbHNlIGlmIChlLmxlbmd0aCkge1xuICAgIHZhciBfSWkgPSBJaShlLCB0KSxcbiAgICAgIHMgPSBfSWkubG8sXG4gICAgICBuID0gX0lpLmhpLFxuICAgICAgbyA9IGVbc10gPj0gdCA/IGVbc10gOiBlW25dO1xuICAgIGlbb10gPSAhMDtcbiAgfVxufVxuZnVuY3Rpb24gamMoaSwgdCwgZSwgcykge1xuICB2YXIgbiA9IGkuX2FkYXB0ZXIsXG4gICAgbyA9ICtuLnN0YXJ0T2YodFswXS52YWx1ZSwgcyksXG4gICAgciA9IHRbdC5sZW5ndGggLSAxXS52YWx1ZTtcbiAgdmFyIGEsIGw7XG4gIGZvciAoYSA9IG87IGEgPD0gcjsgYSA9ICtuLmFkZChhLCAxLCBzKSkgbCA9IGVbYV0sIGwgPj0gMCAmJiAodFtsXS5tYWpvciA9ICEwKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBkbihpLCB0LCBlKSB7XG4gIHZhciBzID0gW10sXG4gICAgbiA9IHt9LFxuICAgIG8gPSB0Lmxlbmd0aDtcbiAgdmFyIHIsIGE7XG4gIGZvciAociA9IDA7IHIgPCBvOyArK3IpIGEgPSB0W3JdLCBuW2FdID0gciwgcy5wdXNoKHtcbiAgICB2YWx1ZTogYSxcbiAgICBtYWpvcjogITFcbiAgfSk7XG4gIHJldHVybiBvID09PSAwIHx8ICFlID8gcyA6IGpjKGksIHMsIG4sIGUpO1xufVxudmFyIEdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfR3QzKSB7XG4gIGZ1bmN0aW9uIEdlKHQpIHtcbiAgICB2YXIgX3RoaXMzNTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR2UpO1xuICAgIF90aGlzMzUgPSBfY2FsbFN1cGVyKHRoaXMsIEdlLCBbdF0pLCBfdGhpczM1Ll9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9LCBfdGhpczM1Ll91bml0ID0gXCJkYXlcIiwgX3RoaXMzNS5fbWFqb3JVbml0ID0gdm9pZCAwLCBfdGhpczM1Ll9vZmZzZXRzID0ge30sIF90aGlzMzUuX25vcm1hbGl6ZWQgPSAhMSwgX3RoaXMzNS5fcGFyc2VPcHRzID0gdm9pZCAwO1xuICAgIHJldHVybiBfdGhpczM1O1xuICB9XG4gIF9pbmhlcml0cyhHZSwgX0d0Myk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoR2UsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCh0KSB7XG4gICAgICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgcyA9IHQudGltZSB8fCAodC50aW1lID0ge30pLFxuICAgICAgICBuID0gdGhpcy5fYWRhcHRlciA9IG5ldyB3YS5fZGF0ZSh0LmFkYXB0ZXJzLmRhdGUpO1xuICAgICAgbi5pbml0KGUpLCBsZShzLmRpc3BsYXlGb3JtYXRzLCBuLmZvcm1hdHMoKSksIHRoaXMuX3BhcnNlT3B0cyA9IHtcbiAgICAgICAgcGFyc2VyOiBzLnBhcnNlcixcbiAgICAgICAgcm91bmQ6IHMucm91bmQsXG4gICAgICAgIGlzb1dlZWtkYXk6IHMuaXNvV2Vla2RheVxuICAgICAgfSwgX3N1cGVyUHJvcEdldChHZSwgXCJpbml0XCIsIHRoaXMsIDMpKFt0XSksIHRoaXMuX25vcm1hbGl6ZWQgPSBlLm5vcm1hbGl6ZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKHQsIGUpIHtcbiAgICAgIHJldHVybiB0ID09PSB2b2lkIDAgPyBudWxsIDogbG4odGhpcywgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJlZm9yZUxheW91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmVMYXlvdXQoKSB7XG4gICAgICBfc3VwZXJQcm9wR2V0KEdlLCBcImJlZm9yZUxheW91dFwiLCB0aGlzLCAzKShbXSksIHRoaXMuX2NhY2hlID0ge1xuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgbGFiZWxzOiBbXSxcbiAgICAgICAgYWxsOiBbXVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGV0ZXJtaW5lRGF0YUxpbWl0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGUgPSB0aGlzLl9hZGFwdGVyLFxuICAgICAgICBzID0gdC50aW1lLnVuaXQgfHwgXCJkYXlcIjtcbiAgICAgIHZhciBfdGhpcyRnZXRVc2VyQm91bmRzNCA9IHRoaXMuZ2V0VXNlckJvdW5kcygpLFxuICAgICAgICBuID0gX3RoaXMkZ2V0VXNlckJvdW5kczQubWluLFxuICAgICAgICBvID0gX3RoaXMkZ2V0VXNlckJvdW5kczQubWF4LFxuICAgICAgICByID0gX3RoaXMkZ2V0VXNlckJvdW5kczQubWluRGVmaW5lZCxcbiAgICAgICAgYSA9IF90aGlzJGdldFVzZXJCb3VuZHM0Lm1heERlZmluZWQ7XG4gICAgICBmdW5jdGlvbiBsKGMpIHtcbiAgICAgICAgIXIgJiYgIWlzTmFOKGMubWluKSAmJiAobiA9IE1hdGgubWluKG4sIGMubWluKSksICFhICYmICFpc05hTihjLm1heCkgJiYgKG8gPSBNYXRoLm1heChvLCBjLm1heCkpO1xuICAgICAgfVxuICAgICAgKCFyIHx8ICFhKSAmJiAobCh0aGlzLl9nZXRMYWJlbEJvdW5kcygpKSwgKHQuYm91bmRzICE9PSBcInRpY2tzXCIgfHwgdC50aWNrcy5zb3VyY2UgIT09IFwibGFiZWxzXCIpICYmIGwodGhpcy5nZXRNaW5NYXgoITEpKSksIG4gPSBxKG4pICYmICFpc05hTihuKSA/IG4gOiArZS5zdGFydE9mKERhdGUubm93KCksIHMpLCBvID0gcShvKSAmJiAhaXNOYU4obykgPyBvIDogK2UuZW5kT2YoRGF0ZS5ub3coKSwgcykgKyAxLCB0aGlzLm1pbiA9IE1hdGgubWluKG4sIG8gLSAxKSwgdGhpcy5tYXggPSBNYXRoLm1heChuICsgMSwgbyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRMYWJlbEJvdW5kc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TGFiZWxCb3VuZHMoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgICB2YXIgZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgcyA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgIHJldHVybiB0Lmxlbmd0aCAmJiAoZSA9IHRbMF0sIHMgPSB0W3QubGVuZ3RoIC0gMV0pLCB7XG4gICAgICAgIG1pbjogZSxcbiAgICAgICAgbWF4OiBzXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWlsZFRpY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkVGlja3MoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZSA9IHQudGltZSxcbiAgICAgICAgcyA9IHQudGlja3MsXG4gICAgICAgIG4gPSBzLnNvdXJjZSA9PT0gXCJsYWJlbHNcIiA/IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCkgOiB0aGlzLl9nZW5lcmF0ZSgpO1xuICAgICAgdC5ib3VuZHMgPT09IFwidGlja3NcIiAmJiBuLmxlbmd0aCAmJiAodGhpcy5taW4gPSB0aGlzLl91c2VyTWluIHx8IG5bMF0sIHRoaXMubWF4ID0gdGhpcy5fdXNlck1heCB8fCBuW24ubGVuZ3RoIC0gMV0pO1xuICAgICAgdmFyIG8gPSB0aGlzLm1pbixcbiAgICAgICAgciA9IHRoaXMubWF4LFxuICAgICAgICBhID0gR28obiwgbywgcik7XG4gICAgICByZXR1cm4gdGhpcy5fdW5pdCA9IGUudW5pdCB8fCAocy5hdXRvU2tpcCA/IGNuKGUubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG8pKSA6IE5jKHRoaXMsIGEubGVuZ3RoLCBlLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCkpLCB0aGlzLl9tYWpvclVuaXQgPSAhcy5tYWpvci5lbmFibGVkIHx8IHRoaXMuX3VuaXQgPT09IFwieWVhclwiID8gdm9pZCAwIDogVmModGhpcy5fdW5pdCksIHRoaXMuaW5pdE9mZnNldHMobiksIHQucmV2ZXJzZSAmJiBhLnJldmVyc2UoKSwgZG4odGhpcywgYSwgdGhpcy5fbWFqb3JVbml0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWZ0ZXJBdXRvU2tpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZnRlckF1dG9Ta2lwKCkge1xuICAgICAgdGhpcy5vcHRpb25zLm9mZnNldEFmdGVyQXV0b3NraXAgJiYgdGhpcy5pbml0T2Zmc2V0cyh0aGlzLnRpY2tzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gK3QudmFsdWU7XG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRPZmZzZXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRPZmZzZXRzKCkge1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgICAgdmFyIGUgPSAwLFxuICAgICAgICBzID0gMCxcbiAgICAgICAgbixcbiAgICAgICAgbztcbiAgICAgIHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdC5sZW5ndGggJiYgKG4gPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0WzBdKSwgdC5sZW5ndGggPT09IDEgPyBlID0gMSAtIG4gOiBlID0gKHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRbMV0pIC0gbikgLyAyLCBvID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodFt0Lmxlbmd0aCAtIDFdKSwgdC5sZW5ndGggPT09IDEgPyBzID0gbyA6IHMgPSAobyAtIHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRbdC5sZW5ndGggLSAyXSkpIC8gMik7XG4gICAgICB2YXIgciA9IHQubGVuZ3RoIDwgMyA/IDAuNSA6IDAuMjU7XG4gICAgICBlID0gVShlLCAwLCByKSwgcyA9IFUocywgMCwgciksIHRoaXMuX29mZnNldHMgPSB7XG4gICAgICAgIHN0YXJ0OiBlLFxuICAgICAgICBlbmQ6IHMsXG4gICAgICAgIGZhY3RvcjogMSAvIChlICsgMSArIHMpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2VuZXJhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9hZGFwdGVyLFxuICAgICAgICBlID0gdGhpcy5taW4sXG4gICAgICAgIHMgPSB0aGlzLm1heCxcbiAgICAgICAgbiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgbyA9IG4udGltZSxcbiAgICAgICAgciA9IG8udW5pdCB8fCBjbihvLm1pblVuaXQsIGUsIHMsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkoZSkpLFxuICAgICAgICBhID0gRChuLnRpY2tzLnN0ZXBTaXplLCAxKSxcbiAgICAgICAgbCA9IHIgPT09IFwid2Vla1wiID8gby5pc29XZWVrZGF5IDogITEsXG4gICAgICAgIGMgPSBYdChsKSB8fCBsID09PSAhMCxcbiAgICAgICAgaCA9IHt9O1xuICAgICAgdmFyIGQgPSBlLFxuICAgICAgICB1LFxuICAgICAgICBmO1xuICAgICAgaWYgKGMgJiYgKGQgPSArdC5zdGFydE9mKGQsIFwiaXNvV2Vla1wiLCBsKSksIGQgPSArdC5zdGFydE9mKGQsIGMgPyBcImRheVwiIDogciksIHQuZGlmZihzLCBlLCByKSA+IDFlNSAqIGEpIHRocm93IG5ldyBFcnJvcihlICsgXCIgYW5kIFwiICsgcyArIFwiIGFyZSB0b28gZmFyIGFwYXJ0IHdpdGggc3RlcFNpemUgb2YgXCIgKyBhICsgXCIgXCIgKyByKTtcbiAgICAgIHZhciBwID0gbi50aWNrcy5zb3VyY2UgPT09IFwiZGF0YVwiICYmIHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICAgIGZvciAodSA9IGQsIGYgPSAwOyB1IDwgczsgdSA9ICt0LmFkZCh1LCBhLCByKSwgZisrKSBobihoLCB1LCBwKTtcbiAgICAgIHJldHVybiAodSA9PT0gcyB8fCBuLmJvdW5kcyA9PT0gXCJ0aWNrc1wiIHx8IGYgPT09IDEpICYmIGhuKGgsIHUsIHApLCBPYmplY3Qua2V5cyhoKS5zb3J0KGFuKS5tYXAoZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgcmV0dXJuICtnO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsRm9yVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxGb3JWYWx1ZSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2FkYXB0ZXIsXG4gICAgICAgIHMgPSB0aGlzLm9wdGlvbnMudGltZTtcbiAgICAgIHJldHVybiBzLnRvb2x0aXBGb3JtYXQgPyBlLmZvcm1hdCh0LCBzLnRvb2x0aXBGb3JtYXQpIDogZS5mb3JtYXQodCwgcy5kaXNwbGF5Rm9ybWF0cy5kYXRldGltZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQodCwgZSkge1xuICAgICAgdmFyIG4gPSB0aGlzLm9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cyxcbiAgICAgICAgbyA9IHRoaXMuX3VuaXQsXG4gICAgICAgIHIgPSBlIHx8IG5bb107XG4gICAgICByZXR1cm4gdGhpcy5fYWRhcHRlci5mb3JtYXQodCwgcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl90aWNrRm9ybWF0RnVuY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RpY2tGb3JtYXRGdW5jdGlvbih0LCBlLCBzLCBuKSB7XG4gICAgICB2YXIgbyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgciA9IG8udGlja3MuY2FsbGJhY2s7XG4gICAgICBpZiAocikgcmV0dXJuIEkociwgW3QsIGUsIHNdLCB0aGlzKTtcbiAgICAgIHZhciBhID0gby50aW1lLmRpc3BsYXlGb3JtYXRzLFxuICAgICAgICBsID0gdGhpcy5fdW5pdCxcbiAgICAgICAgYyA9IHRoaXMuX21ham9yVW5pdCxcbiAgICAgICAgaCA9IGwgJiYgYVtsXSxcbiAgICAgICAgZCA9IGMgJiYgYVtjXSxcbiAgICAgICAgdSA9IHNbZV0sXG4gICAgICAgIGYgPSBjICYmIGQgJiYgdSAmJiB1Lm1ham9yO1xuICAgICAgcmV0dXJuIHRoaXMuX2FkYXB0ZXIuZm9ybWF0KHQsIG4gfHwgKGYgPyBkIDogaCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZVRpY2tMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVUaWNrTGFiZWxzKHQpIHtcbiAgICAgIHZhciBlLCBzLCBuO1xuICAgICAgZm9yIChlID0gMCwgcyA9IHQubGVuZ3RoOyBlIDwgczsgKytlKSBuID0gdFtlXSwgbi5sYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbihuLnZhbHVlLCBlLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGVjaW1hbEZvclZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlY2ltYWxGb3JWYWx1ZSh0KSB7XG4gICAgICByZXR1cm4gdCA9PT0gbnVsbCA/IE5hTiA6ICh0IC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQaXhlbEZvclZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBpeGVsRm9yVmFsdWUodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9vZmZzZXRzLFxuICAgICAgICBzID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodCk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKGUuc3RhcnQgKyBzKSAqIGUuZmFjdG9yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmFsdWVGb3JQaXhlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZUZvclBpeGVsKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fb2Zmc2V0cyxcbiAgICAgICAgcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHQpIC8gZS5mYWN0b3IgLSBlLmVuZDtcbiAgICAgIHJldHVybiB0aGlzLm1pbiArIHMgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRMYWJlbFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldExhYmVsU2l6ZSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMub3B0aW9ucy50aWNrcyxcbiAgICAgICAgcyA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KHQpLndpZHRoLFxuICAgICAgICBuID0gYnQodGhpcy5pc0hvcml6b250YWwoKSA/IGUubWF4Um90YXRpb24gOiBlLm1pblJvdGF0aW9uKSxcbiAgICAgICAgbyA9IE1hdGguY29zKG4pLFxuICAgICAgICByID0gTWF0aC5zaW4obiksXG4gICAgICAgIGEgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLnNpemU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3OiBzICogbyArIGEgKiByLFxuICAgICAgICBoOiBzICogciArIGEgKiBvXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0TGFiZWxDYXBhY2l0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TGFiZWxDYXBhY2l0eSh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMub3B0aW9ucy50aW1lLFxuICAgICAgICBzID0gZS5kaXNwbGF5Rm9ybWF0cyxcbiAgICAgICAgbiA9IHNbZS51bml0XSB8fCBzLm1pbGxpc2Vjb25kLFxuICAgICAgICBvID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKHQsIDAsIGRuKHRoaXMsIFt0XSwgdGhpcy5fbWFqb3JVbml0KSwgbiksXG4gICAgICAgIHIgPSB0aGlzLl9nZXRMYWJlbFNpemUobyksXG4gICAgICAgIGEgPSBNYXRoLmZsb29yKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIC8gci53IDogdGhpcy5oZWlnaHQgLyByLmgpIC0gMTtcbiAgICAgIHJldHVybiBhID4gMCA/IGEgOiAxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREYXRhVGltZXN0YW1wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREYXRhVGltZXN0YW1wcygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY2FjaGUuZGF0YSB8fCBbXSxcbiAgICAgICAgZSxcbiAgICAgICAgcztcbiAgICAgIGlmICh0Lmxlbmd0aCkgcmV0dXJuIHQ7XG4gICAgICB2YXIgbiA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICAgIGlmICh0aGlzLl9ub3JtYWxpemVkICYmIG4ubGVuZ3RoKSByZXR1cm4gdGhpcy5fY2FjaGUuZGF0YSA9IG5bMF0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcyk7XG4gICAgICBmb3IgKGUgPSAwLCBzID0gbi5sZW5ndGg7IGUgPCBzOyArK2UpIHQgPSB0LmNvbmNhdChuW2VdLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpKTtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5kYXRhID0gdGhpcy5ub3JtYWxpemUodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsVGltZXN0YW1wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbFRpbWVzdGFtcHMoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2NhY2hlLmxhYmVscyB8fCBbXTtcbiAgICAgIHZhciBlLCBzO1xuICAgICAgaWYgKHQubGVuZ3RoKSByZXR1cm4gdDtcbiAgICAgIHZhciBuID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICAgIGZvciAoZSA9IDAsIHMgPSBuLmxlbmd0aDsgZSA8IHM7ICsrZSkgdC5wdXNoKGxuKHRoaXMsIG5bZV0pKTtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5sYWJlbHMgPSB0aGlzLl9ub3JtYWxpemVkID8gdCA6IHRoaXMubm9ybWFsaXplKHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub3JtYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplKHQpIHtcbiAgICAgIHJldHVybiBNbih0LnNvcnQoYW4pKTtcbiAgICB9XG4gIH1dKTtcbn0oR3QpO1xudyhHZSwgXCJpZFwiLCBcInRpbWVcIiksIHcoR2UsIFwiZGVmYXVsdHNcIiwge1xuICBib3VuZHM6IFwiZGF0YVwiLFxuICBhZGFwdGVyczoge30sXG4gIHRpbWU6IHtcbiAgICBwYXJzZXI6ICExLFxuICAgIHVuaXQ6ICExLFxuICAgIHJvdW5kOiAhMSxcbiAgICBpc29XZWVrZGF5OiAhMSxcbiAgICBtaW5Vbml0OiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgZGlzcGxheUZvcm1hdHM6IHt9XG4gIH0sXG4gIHRpY2tzOiB7XG4gICAgc291cmNlOiBcImF1dG9cIixcbiAgICBjYWxsYmFjazogITEsXG4gICAgbWFqb3I6IHtcbiAgICAgIGVuYWJsZWQ6ICExXG4gICAgfVxuICB9XG59KTtcbmZ1bmN0aW9uIExlKGksIHQsIGUpIHtcbiAgdmFyIF9FdCwgX2kkcywgX2kkbiwgX0V0MiwgX2kkczIsIF9pJG4yO1xuICB2YXIgcyA9IDAsXG4gICAgbiA9IGkubGVuZ3RoIC0gMSxcbiAgICBvLFxuICAgIHIsXG4gICAgYSxcbiAgICBsO1xuICBlID8gKHQgPj0gaVtzXS5wb3MgJiYgdCA8PSBpW25dLnBvcyAmJiAoX0V0ID0gRXQoaSwgXCJwb3NcIiwgdCksIHMgPSBfRXQubG8sIG4gPSBfRXQuaGksIF9FdCksIF9pJHMgPSBpW3NdLCBvID0gX2kkcy5wb3MsIGEgPSBfaSRzLnRpbWUsIF9pJG4gPSBpW25dLCByID0gX2kkbi5wb3MsIGwgPSBfaSRuLnRpbWUpIDogKHQgPj0gaVtzXS50aW1lICYmIHQgPD0gaVtuXS50aW1lICYmIChfRXQyID0gRXQoaSwgXCJ0aW1lXCIsIHQpLCBzID0gX0V0Mi5sbywgbiA9IF9FdDIuaGksIF9FdDIpLCBfaSRzMiA9IGlbc10sIG8gPSBfaSRzMi50aW1lLCBhID0gX2kkczIucG9zLCBfaSRuMiA9IGlbbl0sIHIgPSBfaSRuMi50aW1lLCBsID0gX2kkbjIucG9zKTtcbiAgdmFyIGMgPSByIC0gbztcbiAgcmV0dXJuIGMgPyBhICsgKGwgLSBhKSAqICh0IC0gbykgLyBjIDogYTtcbn1cbnZhciB1biA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0dlKSB7XG4gIGZ1bmN0aW9uIHVuKHQpIHtcbiAgICB2YXIgX3RoaXMzNjtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgdW4pO1xuICAgIF90aGlzMzYgPSBfY2FsbFN1cGVyKHRoaXMsIHVuLCBbdF0pLCBfdGhpczM2Ll90YWJsZSA9IFtdLCBfdGhpczM2Ll9taW5Qb3MgPSB2b2lkIDAsIF90aGlzMzYuX3RhYmxlUmFuZ2UgPSB2b2lkIDA7XG4gICAgcmV0dXJuIF90aGlzMzY7XG4gIH1cbiAgX2luaGVyaXRzKHVuLCBfR2UpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKHVuLCBbe1xuICAgIGtleTogXCJpbml0T2Zmc2V0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0T2Zmc2V0cygpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCksXG4gICAgICAgIGUgPSB0aGlzLl90YWJsZSA9IHRoaXMuYnVpbGRMb29rdXBUYWJsZSh0KTtcbiAgICAgIHRoaXMuX21pblBvcyA9IExlKGUsIHRoaXMubWluKSwgdGhpcy5fdGFibGVSYW5nZSA9IExlKGUsIHRoaXMubWF4KSAtIHRoaXMuX21pblBvcywgX3N1cGVyUHJvcEdldCh1biwgXCJpbml0T2Zmc2V0c1wiLCB0aGlzLCAzKShbdF0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWlsZExvb2t1cFRhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkTG9va3VwVGFibGUodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLm1pbixcbiAgICAgICAgcyA9IHRoaXMubWF4LFxuICAgICAgICBuID0gW10sXG4gICAgICAgIG8gPSBbXTtcbiAgICAgIHZhciByLCBhLCBsLCBjLCBoO1xuICAgICAgZm9yIChyID0gMCwgYSA9IHQubGVuZ3RoOyByIDwgYTsgKytyKSBjID0gdFtyXSwgYyA+PSBlICYmIGMgPD0gcyAmJiBuLnB1c2goYyk7XG4gICAgICBpZiAobi5sZW5ndGggPCAyKSByZXR1cm4gW3tcbiAgICAgICAgdGltZTogZSxcbiAgICAgICAgcG9zOiAwXG4gICAgICB9LCB7XG4gICAgICAgIHRpbWU6IHMsXG4gICAgICAgIHBvczogMVxuICAgICAgfV07XG4gICAgICBmb3IgKHIgPSAwLCBhID0gbi5sZW5ndGg7IHIgPCBhOyArK3IpIGggPSBuW3IgKyAxXSwgbCA9IG5bciAtIDFdLCBjID0gbltyXSwgTWF0aC5yb3VuZCgoaCArIGwpIC8gMikgIT09IGMgJiYgby5wdXNoKHtcbiAgICAgICAgdGltZTogYyxcbiAgICAgICAgcG9zOiByIC8gKGEgLSAxKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dlbmVyYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZW5lcmF0ZSgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5taW4sXG4gICAgICAgIGUgPSB0aGlzLm1heDtcbiAgICAgIHZhciBzID0gX3N1cGVyUHJvcEdldCh1biwgXCJnZXREYXRhVGltZXN0YW1wc1wiLCB0aGlzLCAzKShbXSk7XG4gICAgICByZXR1cm4gKCFzLmluY2x1ZGVzKHQpIHx8ICFzLmxlbmd0aCkgJiYgcy5zcGxpY2UoMCwgMCwgdCksICghcy5pbmNsdWRlcyhlKSB8fCBzLmxlbmd0aCA9PT0gMSkgJiYgcy5wdXNoKGUpLCBzLnNvcnQoZnVuY3Rpb24gKG4sIG8pIHtcbiAgICAgICAgcmV0dXJuIG4gLSBvO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRUaW1lc3RhbXBzRm9yVGFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY2FjaGUuYWxsIHx8IFtdO1xuICAgICAgaWYgKHQubGVuZ3RoKSByZXR1cm4gdDtcbiAgICAgIHZhciBlID0gdGhpcy5nZXREYXRhVGltZXN0YW1wcygpLFxuICAgICAgICBzID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICAgIHJldHVybiBlLmxlbmd0aCAmJiBzLmxlbmd0aCA/IHQgPSB0aGlzLm5vcm1hbGl6ZShlLmNvbmNhdChzKSkgOiB0ID0gZS5sZW5ndGggPyBlIDogcywgdCA9IHRoaXMuX2NhY2hlLmFsbCA9IHQsIHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERlY2ltYWxGb3JWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWNpbWFsRm9yVmFsdWUodCkge1xuICAgICAgcmV0dXJuIChMZSh0aGlzLl90YWJsZSwgdCkgLSB0aGlzLl9taW5Qb3MpIC8gdGhpcy5fdGFibGVSYW5nZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmFsdWVGb3JQaXhlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZUZvclBpeGVsKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fb2Zmc2V0cyxcbiAgICAgICAgcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHQpIC8gZS5mYWN0b3IgLSBlLmVuZDtcbiAgICAgIHJldHVybiBMZSh0aGlzLl90YWJsZSwgcyAqIHRoaXMuX3RhYmxlUmFuZ2UgKyB0aGlzLl9taW5Qb3MsICEwKTtcbiAgICB9XG4gIH1dKTtcbn0oR2UpO1xudyh1biwgXCJpZFwiLCBcInRpbWVzZXJpZXNcIiksIHcodW4sIFwiZGVmYXVsdHNcIiwgR2UuZGVmYXVsdHMpO1xubXQucmVnaXN0ZXIoVGksIEFpLCBFZSwgV2UsIEZlLCB2dCwgSGUsIGtpLCBqdCwgcmUsIEllLCB4Yywgd2MsIERjLCBGYyk7XG52YXIgZm4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBmbih0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIGZuKTtcbiAgICB0aGlzLmNoYXJ0ID0gbnVsbCwgdGhpcy5jYW52YXMgPSB0O1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoZm4sIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIodCkge1xuICAgICAgdmFyIF9yZWYxMiwgX3JlZjEzO1xuICAgICAgdmFyIHIsIGE7XG4gICAgICB0aGlzLmNoYXJ0ICYmICh0aGlzLmNoYXJ0LmRlc3Ryb3koKSwgdGhpcy5jaGFydCA9IG51bGwpO1xuICAgICAgdmFyIGUgPSB0LmNoYXJ0U3BlYyxcbiAgICAgICAgcyA9IHQuZGF0YSxcbiAgICAgICAgbiA9IHRoaXMubWFwQ2hhcnRUeXBlKGUudHlwZSksXG4gICAgICAgIG8gPSB7XG4gICAgICAgICAgdHlwZTogbixcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBsYWJlbHM6IHMubGFiZWxzLFxuICAgICAgICAgICAgZGF0YXNldHM6IHMuZGF0YXNldHMubWFwKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGwpLCB7fSwge1xuICAgICAgICAgICAgICAgIGZpbGw6IGUudHlwZSA9PT0gXCJhcmVhXCIsXG4gICAgICAgICAgICAgICAgdGVuc2lvbjogZS50eXBlID09PSBcImxpbmVcIiB8fCBlLnR5cGUgPT09IFwiYXJlYVwiID8gMC4zIDogMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgICAgICAgIG1haW50YWluQXNwZWN0UmF0aW86ICExLFxuICAgICAgICAgICAgcGx1Z2luczoge1xuICAgICAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICEhZS50aXRsZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBlLnRpdGxlLFxuICAgICAgICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgICAgICAgIHNpemU6IDE2LFxuICAgICAgICAgICAgICAgICAgd2VpZ2h0OiBcImJvbGRcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogKF9yZWYxMiA9IChyID0gZS5sZWdlbmQpID09IG51bGwgPyB2b2lkIDAgOiByLmRpc3BsYXkpICE9PSBudWxsICYmIF9yZWYxMiAhPT0gdm9pZCAwID8gX3JlZjEyIDogITAsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IChfcmVmMTMgPSAoYSA9IGUubGVnZW5kKSA9PSBudWxsID8gdm9pZCAwIDogYS5wb3NpdGlvbikgIT09IG51bGwgJiYgX3JlZjEzICE9PSB2b2lkIDAgPyBfcmVmMTMgOiBcInRvcFwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiAhMFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NhbGVzOiB0aGlzLmJ1aWxkU2NhbGVzKGUsIG4pXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgdGhpcy5jaGFydCA9IG5ldyBtdCh0aGlzLmNhbnZhcywgbyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcENoYXJ0VHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXBDaGFydFR5cGUodCkge1xuICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgXCJhcmVhXCI6XG4gICAgICAgICAgcmV0dXJuIFwibGluZVwiO1xuICAgICAgICBjYXNlIFwiYmFyXCI6XG4gICAgICAgIGNhc2UgXCJsaW5lXCI6XG4gICAgICAgIGNhc2UgXCJwaWVcIjpcbiAgICAgICAgY2FzZSBcImRvdWdobnV0XCI6XG4gICAgICAgIGNhc2UgXCJzY2F0dGVyXCI6XG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFwiYmFyXCI7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkU2NhbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkU2NhbGVzKHQsIGUpIHtcbiAgICAgIHZhciBzLCBuLCBvLCByO1xuICAgICAgaWYgKCEoZSA9PT0gXCJwaWVcIiB8fCBlID09PSBcImRvdWdobnV0XCIpKSByZXR1cm4ge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgZGlzcGxheTogITAsXG4gICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICEhKChzID0gdC54QXhpcykgIT0gbnVsbCAmJiBzLmxhYmVsKSxcbiAgICAgICAgICAgIHRleHQ6IChuID0gdC54QXhpcykgPT0gbnVsbCA/IHZvaWQgMCA6IG4ubGFiZWxcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHk6IHtcbiAgICAgICAgICBkaXNwbGF5OiAhMCxcbiAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgZGlzcGxheTogISEoKG8gPSB0LnlBeGlzKSAhPSBudWxsICYmIG8ubGFiZWwpLFxuICAgICAgICAgICAgdGV4dDogKHIgPSB0LnlBeGlzKSA9PSBudWxsID8gdm9pZCAwIDogci5sYWJlbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYmVnaW5BdFplcm86ICEwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuY2hhcnQgJiYgKHRoaXMuY2hhcnQuZGVzdHJveSgpLCB0aGlzLmNoYXJ0ID0gbnVsbCk7XG4gICAgfVxuICB9XSk7XG59KCk7XG52YXIgJGMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiAkYyh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsICRjKTtcbiAgICB0aGlzLl9jaGFydFJlbmRlcmVycyA9IFtdLCB0aGlzLl9jb250YWluZXIgPSB0O1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoJGMsIFt7XG4gICAga2V5OiBcInJlbmRlckVtcHR5U3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyRW1wdHlTdGF0ZSgpIHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImVtcHR5LXN0YXRlXFxcIj5cXG4gICAgICAgIDxzcGFuPlNldCBhIHByb21wdCB0byBnZW5lcmF0ZSBhIGNoYXJ0PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd0xvYWRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd0xvYWRpbmcoKSB7XG4gICAgICB0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJsb2FkaW5nLW92ZXJsYXlcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwic3Bpbm5lclxcXCI+PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsb2FkaW5nLXRleHRcXFwiPkdlbmVyYXRpbmcgY2hhcnQuLi48L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjaGFydC13cmFwcGVyXFxcIj5cXG4gICAgICAgIDxjYW52YXM+PC9jYW52YXM+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaG93RXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd0Vycm9yKHQsIGUpIHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImVycm9yLWNvbnRhaW5lclxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJlcnJvci1pY29uXFxcIj4hPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJlcnJvci1tZXNzYWdlXFxcIj5cIi5jb25jYXQodGhpcy5fZXNjYXBlSHRtbCh0KSwgXCI8L2Rpdj5cXG4gICAgICAgIDxidXR0b24gY2xhc3M9XFxcInJldHJ5LWJ1dHRvblxcXCI+UmV0cnk8L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCIpO1xuICAgICAgdmFyIHMgPSB0aGlzLl9jb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5yZXRyeS1idXR0b25cIik7XG4gICAgICBzID09IG51bGwgfHwgcy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckNoYXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNoYXJ0KHQpIHtcbiAgICAgIHZhciBfdGhpczM3ID0gdGhpcztcbiAgICAgIHRoaXMuX2Rlc3Ryb3lSZW5kZXJlcnMoKTtcbiAgICAgIHZhciBlID0gQXJyYXkuaXNBcnJheSh0KSA/IHQgOiBbdF07XG4gICAgICBpZiAoZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cImNoYXJ0cy1ncmlkXCI+PC9kaXY+JztcbiAgICAgICAgdmFyIG4gPSB0aGlzLl9jb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5jaGFydHMtZ3JpZFwiKTtcbiAgICAgICAgZS5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgdmFyIHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgIHIuY2xhc3NOYW1lID0gXCJjaGFydC13cmFwcGVyXCIsIHIuaW5uZXJIVE1MID0gXCI8Y2FudmFzPjwvY2FudmFzPlwiLCBuLmFwcGVuZENoaWxkKHIpO1xuICAgICAgICAgIHZhciBhID0gci5xdWVyeVNlbGVjdG9yKFwiY2FudmFzXCIpLFxuICAgICAgICAgICAgbCA9IG5ldyBmbihhKTtcbiAgICAgICAgICBsLnJlbmRlcihvKSwgX3RoaXMzNy5fY2hhcnRSZW5kZXJlcnMucHVzaChsKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gXCJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNoYXJ0LXdyYXBwZXJcXFwiPlxcbiAgICAgICAgICA8Y2FudmFzPjwvY2FudmFzPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgXCI7XG4gICAgICAgIHZhciBfbjQgPSB0aGlzLl9jb250YWluZXIucXVlcnlTZWxlY3RvcihcImNhbnZhc1wiKTtcbiAgICAgICAgaWYgKCFfbjQpIHJldHVybjtcbiAgICAgICAgdmFyIG8gPSBuZXcgZm4oX240KTtcbiAgICAgICAgby5yZW5kZXIoZVswXSksIHRoaXMuX2NoYXJ0UmVuZGVyZXJzLnB1c2gobyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3lSZW5kZXJlcnMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lSZW5kZXJlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3lSZW5kZXJlcnMoKSB7XG4gICAgICB0aGlzLl9jaGFydFJlbmRlcmVycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmRlc3Ryb3koKTtcbiAgICAgIH0pLCB0aGlzLl9jaGFydFJlbmRlcmVycyA9IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZXNjYXBlSHRtbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXNjYXBlSHRtbCh0KSB7XG4gICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICByZXR1cm4gZS50ZXh0Q29udGVudCA9IHQsIGUuaW5uZXJIVE1MO1xuICAgIH1cbiAgfV0pO1xufSgpO1xudmFyIFljID0gXCJcXG4gIDpob3N0IHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90bywgT3h5Z2VuLCBVYnVudHUsIHNhbnMtc2VyaWY7XFxuICB9XFxuXFxuICAucHJvbXB0LWNoYXJ0LWNvbnRhaW5lciB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgbWluLWhlaWdodDogMzAwcHg7XFxuICB9XFxuXFxuICAuY2hhcnQtd3JhcHBlciB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIG1pbi1oZWlnaHQ6IDMwMHB4O1xcbiAgfVxcblxcbiAgLmNoYXJ0cy1ncmlkIHtcXG4gICAgZGlzcGxheTogZ3JpZDtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoYXV0by1maXQsIG1pbm1heCg0MDBweCwgMWZyKSk7XFxuICAgIGdhcDogMjBweDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gIH1cXG5cXG4gIC5jaGFydHMtZ3JpZCAuY2hhcnQtd3JhcHBlciB7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNlNWU3ZWI7XFxuICAgIGJvcmRlci1yYWRpdXM6IDhweDtcXG4gICAgcGFkZGluZzogMTZweDtcXG4gICAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIH1cXG5cXG4gIC5sb2FkaW5nLW92ZXJsYXkge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45KTtcXG4gICAgei1pbmRleDogMTA7XFxuICB9XFxuXFxuICAuc3Bpbm5lciB7XFxuICAgIHdpZHRoOiA0MHB4O1xcbiAgICBoZWlnaHQ6IDQwcHg7XFxuICAgIGJvcmRlcjogM3B4IHNvbGlkICNlNWU3ZWI7XFxuICAgIGJvcmRlci10b3AtY29sb3I6ICMzYjgyZjY7XFxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gICAgYW5pbWF0aW9uOiBzcGluIDFzIGxpbmVhciBpbmZpbml0ZTtcXG4gIH1cXG5cXG4gIEBrZXlmcmFtZXMgc3BpbiB7XFxuICAgIHRvIHtcXG4gICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICB9XFxuICB9XFxuXFxuICAubG9hZGluZy10ZXh0IHtcXG4gICAgbWFyZ2luLXRvcDogMTJweDtcXG4gICAgY29sb3I6ICM2YjcyODA7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gIH1cXG5cXG4gIC5lcnJvci1jb250YWluZXIge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBtaW4taGVpZ2h0OiAyMDBweDtcXG4gICAgcGFkZGluZzogMjBweDtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICBjb2xvcjogI2RjMjYyNjtcXG4gIH1cXG5cXG4gIC5lcnJvci1pY29uIHtcXG4gICAgZm9udC1zaXplOiA0OHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAxNnB4O1xcbiAgfVxcblxcbiAgLmVycm9yLW1lc3NhZ2Uge1xcbiAgICBmb250LXNpemU6IDE0cHg7XFxuICAgIG1heC13aWR0aDogNDAwcHg7XFxuICB9XFxuXFxuICAucmV0cnktYnV0dG9uIHtcXG4gICAgbWFyZ2luLXRvcDogMTZweDtcXG4gICAgcGFkZGluZzogOHB4IDE2cHg7XFxuICAgIGJhY2tncm91bmQ6ICMzYjgyZjY7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBib3JkZXItcmFkaXVzOiA2cHg7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDAuMnM7XFxuICB9XFxuXFxuICAucmV0cnktYnV0dG9uOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZDogIzI1NjNlYjtcXG4gIH1cXG5cXG4gIC5lbXB0eS1zdGF0ZSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIG1pbi1oZWlnaHQ6IDIwMHB4O1xcbiAgICBjb2xvcjogIzljYTNhZjtcXG4gICAgZm9udC1zaXplOiAxNHB4O1xcbiAgfVxcblwiO1xudmFyIFVjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICBodCA9IGZ1bmN0aW9uIGh0KGksIHQsIGUsIHMpIHtcbiAgICBmb3IgKHZhciBuID0gdm9pZCAwLCBvID0gaS5sZW5ndGggLSAxLCByOyBvID49IDA7IG8tLSkgKHIgPSBpW29dKSAmJiAobiA9IHIodCwgZSwgbikgfHwgbik7XG4gICAgcmV0dXJuIG4gJiYgVWModCwgZSwgbiksIG47XG4gIH07XG52YXIgbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9pNSkge1xuICBmdW5jdGlvbiBudCgpIHtcbiAgICB2YXIgX3RoaXMzODtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgbnQpO1xuICAgIF90aGlzMzggPSBfY2FsbFN1cGVyKHRoaXMsIG50KSwgX3RoaXMzOC5faGFzQmVlblJlbmRlcmVkID0gITEsIF90aGlzMzguX2Fib3J0Q29udHJvbGxlciA9IG51bGwsIF90aGlzMzguX3NoYWRvdyA9IF90aGlzMzguYXR0YWNoU2hhZG93KHtcbiAgICAgIG1vZGU6IFwib3BlblwiXG4gICAgfSk7XG4gICAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHQuY2xhc3NOYW1lID0gXCJwcm9tcHQtY2hhcnQtY29udGFpbmVyXCIsIF90aGlzMzguX3NoYWRvdy5pbm5lckhUTUwgPSBcIjxzdHlsZT5cIi5jb25jYXQoWWMsIFwiPC9zdHlsZT5cIiksIF90aGlzMzguX3NoYWRvdy5hcHBlbmRDaGlsZCh0KSwgX3RoaXMzOC5fc3RhdGVSZW5kZXJlciA9IG5ldyAkYyh0KSwgX3RoaXMzOC5fZGVtb0RhdGFHZW5lcmF0b3IgPSBuZXcgY28oKSwgX3RoaXMzOC5fc3RhdGVSZW5kZXJlci5yZW5kZXJFbXB0eVN0YXRlKCksIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMzOC5faGFzQmVlblJlbmRlcmVkIHx8IF90aGlzMzgub25SZW5kZXIoKTtcbiAgICB9LCAyMCk7XG4gICAgcmV0dXJuIF90aGlzMzg7XG4gIH1cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIF9pbmhlcml0cyhudCwgX2k1KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhudCwgW3tcbiAgICBrZXk6IFwib25SZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25SZW5kZXIoKSB7XG4gICAgICBOZS5hdHRlbXB0QXBwZW5kU3R5bGVTaGVldFRvSGVhZCh0aGlzLnN0eWxlKSwgYmkuYXBwbHlEZWZhdWx0U3R5bGVUb0NvbXBvbmVudCh0aGlzLnN0eWxlLCB0aGlzLmNvbnRhaW5lclN0eWxlKSwgdGhpcy5faGFzQmVlblJlbmRlcmVkID0gITA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbm5lY3RlZENhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgdmFyIHQ7XG4gICAgICB0aGlzLmRhdGEgPyB0aGlzLl9yZW5kZXJEYXRhKCkgOiB0aGlzLmF1dG9GZXRjaCAmJiB0aGlzLnByb21wdCAmJiAoKHQgPSB0aGlzLmNvbm5lY3QpICE9IG51bGwgJiYgdC51cmwgfHwgdGhpcy5kZW1vKSAmJiB0aGlzLmZldGNoQ2hhcnQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzY29ubmVjdGVkQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgfVxuICAgIC8vIG92ZXJyaWRlIG9uUHJvcGVydHlDaGFuZ2UocHJvcGVydHk6IHN0cmluZywgX3ZhbHVlOiB1bmtub3duKTogdm9pZCB7XG4gICAgLy8gICBpZiAocHJvcGVydHkgPT09ICdkYXRhJyAmJiB0aGlzLmRhdGEpIHtcbiAgICAvLyAgICAgdGhpcy5fcmVuZGVyRGF0YSgpO1xuICAgIC8vICAgfSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJ3Byb21wdCcgJiYgdGhpcy5hdXRvRmV0Y2ggJiYgdGhpcy5wcm9tcHQgJiYgKHRoaXMuY29ubmVjdD8udXJsIHx8IHRoaXMuZGVtbykpIHtcbiAgICAvLyAgICAgdGhpcy5mZXRjaENoYXJ0KCk7XG4gICAgLy8gICB9XG4gICAgLy8gfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZW5kZXJEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJEYXRhKCkge1xuICAgICAgdmFyIHQ7XG4gICAgICB0aGlzLmRhdGEgJiYgKHRoaXMuX3N0YXRlUmVuZGVyZXIucmVuZGVyQ2hhcnQodGhpcy5kYXRhKSwgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImNoYXJ0LWxvYWRlZFwiLCB7XG4gICAgICAgIGRldGFpbDogdGhpcy5kYXRhLFxuICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgY29tcG9zZWQ6ICEwXG4gICAgICB9KSksICh0ID0gdGhpcy5vbkNoYXJ0TG9hZGVkKSA9PSBudWxsIHx8IHQuY2FsbCh0aGlzLCB0aGlzLmRhdGEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYW5kIHJlbmRlciBhIGNoYXJ0IGJhc2VkIG9uIHRoZSBjdXJyZW50IHByb21wdFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZldGNoQ2hhcnRcIixcbiAgICB2YWx1ZTogKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZmV0Y2hDaGFydCA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IoKS5tKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBfdGhpczM5ID0gdGhpcztcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IoKS53KGZ1bmN0aW9uIChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Lm4pIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaWYgKHRoaXMucHJvbXB0KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubiA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fc3RhdGVSZW5kZXJlci5zaG93RXJyb3IoXCJNaXNzaW5nIHByb21wdFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMzkuZmV0Y2hDaGFydCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmEoMik7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGlmICghKCF0aGlzLmRlbW8gJiYgISgodCA9IHRoaXMuY29ubmVjdCkgIT0gbnVsbCAmJiB0LnVybCkpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubiA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fc3RhdGVSZW5kZXJlci5zaG93RXJyb3IoXCJNaXNzaW5nIGNvbm5lY3QudXJsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzOS5mZXRjaENoYXJ0KCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYSgyKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLmRlbW8pIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dC5uID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoRGVtb0NoYXJ0KCk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hKDIpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBfY29udGV4dC5uID0gNTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoUmVtb3RlQ2hhcnQoKTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmEoMik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGZldGNoQ2hhcnQoKSB7XG4gICAgICAgIHJldHVybiBfZmV0Y2hDaGFydC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZldGNoQ2hhcnQ7XG4gICAgfSgpKVxuICB9LCB7XG4gICAga2V5OiBcIl9mZXRjaERlbW9DaGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2ZldGNoRGVtb0NoYXJ0MiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IoKS5tKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICB2YXIgZSwgdDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcigpLncoZnVuY3Rpb24gKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Mi5uKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMuX3N0YXRlUmVuZGVyZXIuc2hvd0xvYWRpbmcoKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm4gPSAxO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChzLCA1MDApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgdCA9IHRoaXMuX2RlbW9EYXRhR2VuZXJhdG9yLmdlbmVyYXRlKHRoaXMucHJvbXB0KTtcbiAgICAgICAgICAgICAgdGhpcy5fc3RhdGVSZW5kZXJlci5yZW5kZXJDaGFydCh0KSwgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImNoYXJ0LWxvYWRlZFwiLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiB0LFxuICAgICAgICAgICAgICAgIGJ1YmJsZXM6ICEwLFxuICAgICAgICAgICAgICAgIGNvbXBvc2VkOiAhMFxuICAgICAgICAgICAgICB9KSksIChlID0gdGhpcy5vbkNoYXJ0TG9hZGVkKSA9PSBudWxsIHx8IGUuY2FsbCh0aGlzLCB0KTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hKDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gX2ZldGNoRGVtb0NoYXJ0KCkge1xuICAgICAgICByZXR1cm4gX2ZldGNoRGVtb0NoYXJ0Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9mZXRjaERlbW9DaGFydDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfZmV0Y2hSZW1vdGVDaGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2ZldGNoUmVtb3RlQ2hhcnQyID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvcigpLm0oZnVuY3Rpb24gX2NhbGxlZTMoKSB7XG4gICAgICAgIHZhciBfdGhpczQwID0gdGhpcztcbiAgICAgICAgdmFyIHQsIGUsIHMsIF90aGlzJGNvbm5lY3QkbWV0aG9kLCBuLCBvLCBsLCByLCBhLCBfbzQsIF90NCwgX3Q1LCBfdDY7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IoKS53KGZ1bmN0aW9uIChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDMucCA9IF9jb250ZXh0My5uKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICh0ID0gdGhpcy5fYWJvcnRDb250cm9sbGVyKSA9PSBudWxsIHx8IHQuYWJvcnQoKSwgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpLCB0aGlzLl9zdGF0ZVJlbmRlcmVyLnNob3dMb2FkaW5nKCk7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5wID0gMTtcbiAgICAgICAgICAgICAgbiA9IHtcbiAgICAgICAgICAgICAgICBlbmRwb2ludDogdGhpcy5jb25uZWN0LnVybCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IChfdGhpcyRjb25uZWN0JG1ldGhvZCA9IHRoaXMuY29ubmVjdC5tZXRob2QpICE9PSBudWxsICYmIF90aGlzJGNvbm5lY3QkbWV0aG9kICE9PSB2b2lkIDAgPyBfdGhpcyRjb25uZWN0JG1ldGhvZCA6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICAgICAgICB9LCB0aGlzLmNvbm5lY3QuaGVhZGVycyksXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgcHJvbXB0OiB0aGlzLnByb21wdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgX3Q0ID0gdGhpcy5yZXF1ZXN0SW50ZXJjZXB0b3I7XG4gICAgICAgICAgICAgIGlmICghX3Q0KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm4gPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEludGVyY2VwdG9yKG4pO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBuID0gX2NvbnRleHQzLnY7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIGZldGNoKG4uZW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG4ubWV0aG9kLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IG4uaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShuLmJvZHkpLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogdGhpcy5fYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgbyA9IF9jb250ZXh0My52O1xuICAgICAgICAgICAgICBpZiAoby5vaykge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uID0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dDMubiA9IDU7XG4gICAgICAgICAgICAgIHJldHVybiBvLmpzb24oKVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgZXJyb3I6IFwiUmVxdWVzdCBmYWlsZWRcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBsID0gX2NvbnRleHQzLnY7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihsLmVycm9yIHx8IFwiSFRUUCBcIi5jb25jYXQoby5zdGF0dXMpKTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm4gPSA3O1xuICAgICAgICAgICAgICByZXR1cm4gby5qc29uKCk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHIgPSBfY29udGV4dDMudjtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlc3BvbnNlSW50ZXJjZXB0b3IpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubiA9IDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NvbnRleHQzLm4gPSA4O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZUludGVyY2VwdG9yKHIpO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBfdDUgPSBfY29udGV4dDMudjtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm4gPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIF90NSA9IHI7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBhID0gX3Q1O1xuICAgICAgICAgICAgICB0aGlzLl9zdGF0ZVJlbmRlcmVyLnJlbmRlckNoYXJ0KGEpLCB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiY2hhcnQtbG9hZGVkXCIsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IGEsXG4gICAgICAgICAgICAgICAgYnViYmxlczogITAsXG4gICAgICAgICAgICAgICAgY29tcG9zZWQ6ICEwXG4gICAgICAgICAgICAgIH0pKSwgKGUgPSB0aGlzLm9uQ2hhcnRMb2FkZWQpID09IG51bGwgfHwgZS5jYWxsKHRoaXMsIGEpO1xuICAgICAgICAgICAgICBfY29udGV4dDMubiA9IDEzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIF9jb250ZXh0My5wID0gMTE7XG4gICAgICAgICAgICAgIF90NiA9IF9jb250ZXh0My52O1xuICAgICAgICAgICAgICBpZiAoIShfdDYgaW5zdGFuY2VvZiBFcnJvciAmJiBfdDYubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm4gPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmEoMik7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBfbzQgPSBfdDYgaW5zdGFuY2VvZiBFcnJvciA/IF90Ni5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCI7XG4gICAgICAgICAgICAgIHRoaXMuX3N0YXRlUmVuZGVyZXIuc2hvd0Vycm9yKF9vNCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczQwLmZldGNoQ2hhcnQoKTtcbiAgICAgICAgICAgICAgfSksIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJjaGFydC1lcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICBlcnJvcjogX280XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICAgICAgICBjb21wb3NlZDogITBcbiAgICAgICAgICAgICAgfSkpLCAocyA9IHRoaXMub25DaGFydEVycm9yKSA9PSBudWxsIHx8IHMuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYSgyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzLCBbWzEsIDExXV0pO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gX2ZldGNoUmVtb3RlQ2hhcnQoKSB7XG4gICAgICAgIHJldHVybiBfZmV0Y2hSZW1vdGVDaGFydDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfZmV0Y2hSZW1vdGVDaGFydDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfY2xlYW51cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW51cCgpIHtcbiAgICAgIHZhciB0O1xuICAgICAgKHQgPSB0aGlzLl9hYm9ydENvbnRyb2xsZXIpID09IG51bGwgfHwgdC5hYm9ydCgpLCB0aGlzLl9zdGF0ZVJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1dKTtcbn0oX2kpO1xuaHQoW2N0KFwib2JqZWN0XCIpXSwgbnQucHJvdG90eXBlLCBcImNvbm5lY3RcIik7XG5odChbY3QoXCJzdHJpbmdcIildLCBudC5wcm90b3R5cGUsIFwicHJvbXB0XCIpO1xuaHQoW2N0KFwiYm9vbGVhblwiKV0sIG50LnByb3RvdHlwZSwgXCJhdXRvRmV0Y2hcIik7XG5odChbY3QoXCJvYmplY3RcIildLCBudC5wcm90b3R5cGUsIFwiY29udGFpbmVyU3R5bGVcIik7XG5odChbY3QoXCJmdW5jdGlvblwiKV0sIG50LnByb3RvdHlwZSwgXCJvbkNoYXJ0TG9hZGVkXCIpO1xuaHQoW2N0KFwiZnVuY3Rpb25cIildLCBudC5wcm90b3R5cGUsIFwib25DaGFydEVycm9yXCIpO1xuaHQoW2N0KFwiZnVuY3Rpb25cIildLCBudC5wcm90b3R5cGUsIFwicmVxdWVzdEludGVyY2VwdG9yXCIpO1xuaHQoW2N0KFwiZnVuY3Rpb25cIildLCBudC5wcm90b3R5cGUsIFwicmVzcG9uc2VJbnRlcmNlcHRvclwiKTtcbmh0KFtjdChcImJvb2xlYW5cIildLCBudC5wcm90b3R5cGUsIFwiZGVtb1wiKTtcbmh0KFtjdChcIm9iamVjdFwiKV0sIG50LnByb3RvdHlwZSwgXCJkYXRhXCIpO1xuY3VzdG9tRWxlbWVudHMuZ2V0KFwicHJvbXB0LWNoYXJ0XCIpIHx8IGN1c3RvbUVsZW1lbnRzLmRlZmluZShcInByb21wdC1jaGFydFwiLCBudCk7XG5leHBvcnQgeyBmbiBhcyBDaGFydFJlbmRlcmVyLCBudCBhcyBQcm9tcHRDaGFydCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prompt-chart/dist/promptChart.js\n"));

/***/ })

}]);